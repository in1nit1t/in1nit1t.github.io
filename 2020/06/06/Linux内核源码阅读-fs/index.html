<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Linux内核源码阅读-fs | in1t's blog</title><meta name="keywords" content="操作系统,Linux0.11"><meta name="author" content="in1t"><meta name="copyright" content="in1t"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本文主要介绍了 Minix 1.0 文件系统对于高速缓冲区的管理和使用方式，并通过实例——读取文件的完整过程来讲述文件内容从硬盘-&gt;高速缓冲-&gt;程序栈上缓冲区的生命历程">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux内核源码阅读-fs">
<meta property="og:url" content="http://in1nit1t.github.io/2020/06/06/Linux%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-fs/index.html">
<meta property="og:site_name" content="in1t&#39;s blog">
<meta property="og:description" content="本文主要介绍了 Minix 1.0 文件系统对于高速缓冲区的管理和使用方式，并通过实例——读取文件的完整过程来讲述文件内容从硬盘-&gt;高速缓冲-&gt;程序栈上缓冲区的生命历程">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://in1nit1t.github.io/img/cover/linux_fs.jpg">
<meta property="article:published_time" content="2020-06-06T12:25:11.000Z">
<meta property="article:modified_time" content="2021-07-07T08:24:31.428Z">
<meta property="article:author" content="in1t">
<meta property="article:tag" content="操作系统">
<meta property="article:tag" content="Linux0.11">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://in1nit1t.github.io/img/cover/linux_fs.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://in1nit1t.github.io/2020/06/06/Linux%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-fs/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux内核源码阅读-fs',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-07-07 16:24:31'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="wizard-scene"><div class="wizard-objects"><div class="wizard-square"></div><div class="wizard-circle"></div><div class="wizard-triangle"></div></div><div class="wizard"><div class="wizard-body"></div><div class="wizard-right-arm"><div class="wizard-right-hand"></div></div><div class="wizard-left-arm"><div class="wizard-left-hand"></div></div><div class="wizard-head"><div class="wizard-beard"></div><div class="wizard-face"><div class="wizard-adds"></div></div><div class="wizard-hat"><div class="wizard-hat-of-the-hat"></div><div class="wizard-four-point-star --first"></div><div class="wizard-four-point-star --second"></div><div class="wizard-four-point-star --third"></div></div></div></div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">42</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/bangumis/"><i class="fa-fw fas fa-play-circle"></i><span> 番剧</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/cover/linux_fs.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">in1t's blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/bangumis/"><i class="fa-fw fas fa-play-circle"></i><span> 番剧</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Linux内核源码阅读-fs</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-06-06T12:25:11.000Z" title="发表于 2020-06-06 20:25:11">2020-06-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-07-07T08:24:31.428Z" title="更新于 2021-07-07 16:24:31">2021-07-07</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>23分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="高速缓冲区的管理方式"><a href="#高速缓冲区的管理方式" class="headerlink" title="高速缓冲区的管理方式"></a>高速缓冲区的管理方式</h2><p>整个高速缓冲区被划分为 1024 字节一块的缓冲块，正好与块设备上的磁盘逻辑块大小相同。在高速缓冲区初始化时，初始化程序分别从缓冲区的<strong>两端</strong>开始，分别同时设置<strong>缓冲头</strong>和划分出对应的<strong>缓冲块</strong>，如图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="../img/g1.png" alt="缓冲区概况"></p>
<p><strong>缓冲头</strong>是定义在 include/linux/fs.h 中的一个结构体，用于描述对应缓冲块的各种属性，并用于将所用缓冲头连成链表。<strong>缓冲块的划分</strong>一直持续到缓冲区中没有足够的内存再划分出缓冲块为止</p>
<p>缓冲头的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/fs.h Line 68</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span> * b_data;			<span class="comment">// 指向对应缓冲块起始地址</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> b_blocknr;	<span class="comment">// 缓冲块的块号</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> b_dev;		<span class="comment">// 数据源的设备号</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> b_uptodate;	<span class="comment">// 更新标志，表示数据是否已经更新</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> b_dirt;		<span class="comment">// 修改标志，为 0 表示未被修改，为 1 表示已被修改过</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> b_count;		<span class="comment">// 使用该块的用户数</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> b_lock;		<span class="comment">// 缓冲块是否被锁定，1 表示被上锁</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * <span class="title">b_wait</span>;</span>	<span class="comment">// 指向等待该缓冲块解锁的任务</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">b_prev</span>;</span>	<span class="comment">// hash 队列的前一块</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">b_next</span>;</span>	<span class="comment">// hash 队列的下一块</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">b_prev_free</span>;</span>	<span class="comment">// 空闲表的前一块</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">b_next_free</span>;</span>	<span class="comment">// 空闲表的下一块</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>b_blocknr</strong> 与 <strong>b_dev</strong> 唯一确定了缓冲块中的数据对应的块设备和数据块</p>
<p><strong>b_count</strong> 字段表示引用该块的进程数，当其不为 0 时，缓冲管理程序就不能释放该块。程序申请读/写硬盘上的一个块时，会先在高速缓冲中申请一个块，若在 hash 表中能得到指定的块，则该块的 b_count 增加 1，否则表示缓冲块是重新申请得到的，该块的 b_count 置为 1。当程序释放一个块时，该块的 b_count 减 1</p>
<p><strong>b_lock</strong> 为锁定标志，当其为 1 时，表示驱动程序正在对该缓冲块内容进行修改。更新缓冲块中的数据时，进程会主动睡眠，此时其他进程就有访问同样缓冲块的机会，因此在睡眠前该缓冲块对应缓冲头的 b_lock 字段被置 1</p>
<p><strong>b_dirt</strong> 为修改标志，表示缓冲块中的内容是否与块设备上对应数据块的内容不同。b_uptodate 为数据更新标志，用于说明缓冲块中的数据是否有效。</p>
<ul>
<li>初始化或释放块时，这两个标志均置为 0，表示该缓冲块中的数据无效</li>
<li>当数据被写入缓冲块但还没有被写入块设备中时，b_dirt = 1，b_uptodate = 0</li>
<li>当数据被写入块设备或刚从块设备中读入缓冲块时，b_dirt = 0，b_uptodate = 1</li>
<li>在新申请一个缓冲块时，这两个标志均为 1</li>
</ul>
<p><strong>b_prev_free</strong> 与 <strong>b_next_free</strong> 字段用于构建空闲缓冲块对应缓冲头的双向链表，如图：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="../img/g2.png" alt="空闲缓冲头构成双向链表"></p>
<p><strong>b_prev</strong> 与 <strong>b_next</strong> 字段用于构建 hash 表。buffer.c 中使用具有 307 个缓冲头指针项的 hash 数组表结构，从而达到快速而有效地在缓冲区中寻找请求的数据块是否已经被读入到缓冲区中的目的。这两个字段就是用于 hash 表中国<strong>散列在同一项</strong>上多个缓冲块之间的双向链接，如图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="../img/g3.png" alt="缓冲头的hash表"></p>
<p>图中的双箭头实线表示散列在同一 hash 表项中缓冲头结构体之间的双向链接指针。虚线表示缓冲区中所有缓冲块组成的一个双向循环链表（即所谓的空闲链表），实际上这个双向链表是最近最少使用链表（LRU）</p>
<br>

<h2 id="读取文件的完整过程"><a href="#读取文件的完整过程" class="headerlink" title="读取文件的完整过程"></a>读取文件的完整过程</h2><p>前面也铺垫的差不多了，接下来，通过一个文件从打开（open）、读取（read）到关闭（close）的过程来整体把握文件系统，其中涉及的一些较为底层的函数现在只需知道功能即可</p>
<p>首先修改一下 main.c 的 init 函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd;</span><br><span class="line">	<span class="keyword">char</span> msg[<span class="number">80</span>];</span><br><span class="line"></span><br><span class="line">	setup((<span class="keyword">void</span> *) &amp;drive_info);</span><br><span class="line">	(<span class="keyword">void</span>) open(<span class="string">&quot;/dev/tty0&quot;</span>,O_RDWR,<span class="number">0</span>);</span><br><span class="line">	(<span class="keyword">void</span>) dup(<span class="number">0</span>);</span><br><span class="line">	(<span class="keyword">void</span>) dup(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	fd = open(<span class="string">&quot;/usr/root/hello.c&quot;</span>, O_RDONLY, <span class="number">0</span>);</span><br><span class="line">	msg[read(fd, msg, <span class="number">79</span>)] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, msg);</span><br><span class="line">	close(fd);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码实现打开 hello.c 并获取其句柄、读取并输出其内容及关闭文件，运行结果：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="../img/d1.png" alt="hello.c内容"></p>
<h3 id="open"><a href="#open" class="headerlink" title="open"></a>open</h3><p>open 实际上是一个系统调用，在 system_call 中调用 sys_open，参数 filename 为要打开的文件名字符串指针；flag 为打开文件的标志（只读、只写、可读可写等）；mode 只有在创建文件时才会被用于指定文件的许可属性（如 0664）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/open.c Line 138</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * filename,<span class="keyword">int</span> flag,<span class="keyword">int</span> mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">inode</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">f</span>;</span></span><br><span class="line">	<span class="keyword">int</span> i,fd;</span><br><span class="line"></span><br><span class="line">	mode &amp;= <span class="number">0777</span> &amp; ~current-&gt;umask;		<span class="comment">// umask 的作用在这里体现(参考 umask 指令)</span></span><br><span class="line">	<span class="keyword">for</span>(fd=<span class="number">0</span> ; fd&lt;NR_OPEN ; fd++)		<span class="comment">// 遍历进程打开文件数组 flip</span></span><br><span class="line">		<span class="keyword">if</span> (!current-&gt;filp[fd])		<span class="comment">// 寻找一个空闲项</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">if</span> (fd&gt;=NR_OPEN)			<span class="comment">// 没有空闲项则返回出错码</span></span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="comment">// 设置进程执行时关闭文件句柄位图，将找出的空闲项对应的比特位复位</span></span><br><span class="line">	current-&gt;close_on_exec &amp;= ~(<span class="number">1</span>&lt;&lt;fd);</span><br><span class="line">	f=<span class="number">0</span>+file_table;				<span class="comment">// f 指向文件表数组起始</span></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;NR_FILE ; i++,f++)		<span class="comment">// 遍历文件表，寻找空闲项</span></span><br><span class="line">		<span class="keyword">if</span> (!f-&gt;f_count) <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">if</span> (i&gt;=NR_FILE)				<span class="comment">// 文件表数组没有空闲项，返回出错码</span></span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	(current-&gt;filp[fd]=f)-&gt;f_count++;	<span class="comment">// 该项的文件引用计数加 1</span></span><br><span class="line">	<span class="comment">// 获得 filename 对应文件的 i 节点指针，如果出错，释放刚找到的空闲项</span></span><br><span class="line">	<span class="keyword">if</span> ((i=open_namei(filename,flag,mode,&amp;inode))&lt;<span class="number">0</span>) &#123;</span><br><span class="line">		current-&gt;filp[fd]=<span class="literal">NULL</span>;</span><br><span class="line">		f-&gt;f_count=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> i;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>sys_open 函数还没有结束，但这里有必要打断一下，来说说 task_struct 中的 filp 字段与文件表数组 file_table 的关系，及 close_on_exec 字段的含义；之后深入 open_namei 函数去查看其实现细节</p>
<ol>
<li><p>flip 与 file_table</p>
<p>os 维护着一张元素个数为 64（NR_FILE）的打开文件表，名为 file_table，该数组的元素类型为 <strong>file 结构体</strong>，记录着所有已被打开的文件的信息；每个进程的 task_struct 结构体中都有一个元素个数为 20（NR_OPEN）的 file 结构体<strong>指针数组</strong>，如果其中的某一项非空（NULL），其必定指向 file_table 数组中的一个 file 结构体，表示该进程捏着这个文件的句柄，可以对其进行合法的操作</p>
<p>那么现在就好解释为什么标准输入的句柄是 0，标准输出的句柄是 1 了。还记得 init 函数中的操作吗：<code>(void) open(&quot;/dev/tty0&quot;,O_RDWR,0);</code> 该函数以可读可写模式打开终端设备，此时 1 号进程的 filp 数组为空，故 filp[0] 为 sys_open 中找到的空闲项。在 open 系统调用成功返回后，file_table 中就会有一项 tty0 的 file 结构体，而 1 号进程的 filp[0] 就指向该结构体。之后 init 调用 <code>(void) dup(0);</code> 复制文件句柄，即使得 filp[1] 也同样指向 tty0 的 file结构体。以此类推，标准错误的句柄在第二次 dup 后应该为 2。你会发现，所谓的<strong>文件句柄</strong>，其实是进程 task_struct 结构体中 <strong>filp 数组的下标</strong></p>
</li>
<li><p>close_on_exec</p>
<p>task_struct 中该字段用于确定在调用 execve 时需要关闭的文件句柄，类型为 <code>unsigned long</code> ，每一个比特位对应一个打开着的文件描述符。当进程创建出子进程后，往往会调用 execve 加载新的程序，此时若文件句柄在 close_on_exec 中对应的比特位为 1，则执行 do_execve 时，该文件将被关闭。在打开一个文件时，默认情况下文件句柄在子进程中也处于打开状态</p>
</li>
</ol>
<p>下面来研究 open_namei 是如何通过 pathname 来找到文件对应 i 节点的，粗略的过程及目录项结构体的定义在 <a href="https://in1nit1t.github.io/2020/05/04/Minix-1-0-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">Minix 1.0 文件系统</a> 一文中有所提及，此时 pathname 为 “/usr/root/hello.c”</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/namei.c Line 337</span></span><br><span class="line"><span class="comment">// 最后一个参数用于保存文件路径 pathname 对应 i 节点的指针(保存函数返回值)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open_namei</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * pathname, <span class="keyword">int</span> flag, <span class="keyword">int</span> mode,</span></span></span><br><span class="line"><span class="params"><span class="function">	struct m_inode ** res_inode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> * basename;</span><br><span class="line">	<span class="keyword">int</span> inr,dev,namelen;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">dir</span>, *<span class="title">inode</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dir_entry</span> * <span class="title">de</span>;</span></span><br><span class="line">	<span class="comment">// 如果文件访问模式是只读，但文件截零标志 O_TRUNC 置位，则添加只写 O_WRONLY 标志</span></span><br><span class="line">	<span class="keyword">if</span> ((flag &amp; O_TRUNC) &amp;&amp; !(flag &amp; O_ACCMODE))</span><br><span class="line">		flag |= O_WRONLY;</span><br><span class="line">	<span class="comment">// 下面两句作用是产生一个 mode，当指定文件不存在需要创建时，将其作为新文件的属性</span></span><br><span class="line">	mode &amp;= <span class="number">0777</span> &amp; ~current-&gt;umask;</span><br><span class="line">	mode |= I_REGULAR;		<span class="comment">// I_REGULAR 表示常规文件</span></span><br><span class="line">	<span class="comment">// dir_namei 返回值为目录 &quot;/usr/root&quot; 对应的 i 节点指针，</span></span><br><span class="line">	<span class="comment">// namelen 为 &quot;hello.c&quot; 长度，basename 指向字符串 &quot;hello.c&quot;</span></span><br><span class="line">	<span class="comment">// 相当于将 pathname 进行切割，分成父级及以上目录 &quot;/usr/root&quot; 与 basename &quot;hello.c&quot;</span></span><br><span class="line">	<span class="keyword">if</span> (!(dir = dir_namei(pathname,&amp;namelen,&amp;basename)))</span><br><span class="line">		<span class="keyword">return</span> -ENOENT;</span><br><span class="line">	<span class="keyword">if</span> (!namelen) &#123;		<span class="comment">// 如果 basename 的长度为 0，表示操作的是目录</span></span><br><span class="line">		<span class="keyword">if</span> (!(flag &amp; (O_ACCMODE|O_CREAT|O_TRUNC))) &#123;	<span class="comment">// 如果操作不是读写、创建、截零</span></span><br><span class="line">			*res_inode=dir;				<span class="comment">// 直接返回目录对应的 i 节点指针</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		iput(dir);	<span class="comment">// 到这里表示操作非法，放回 i 节点</span></span><br><span class="line">		<span class="keyword">return</span> -EISDIR;	<span class="comment">// 返回出错码</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// find_entry 在 &quot;/usr/root&quot; 目录下查找 &quot;hello.c&quot; 对应的目录项，存放在 de 中，</span></span><br><span class="line">	<span class="comment">// 并返回该目录项所在的高速缓冲块对应的缓冲头指针</span></span><br><span class="line">	bh = find_entry(&amp;dir,basename,namelen,&amp;de);</span><br><span class="line">	<span class="comment">// 如果缓冲头为 NULL，表示没有找到对应文件名的目录项，即只能是创建文件的操作</span></span><br><span class="line">	<span class="comment">// 因为 &quot;/usr/root/hello.c&quot; 在硬盘上是存在的，所以不会进下面这个 if</span></span><br><span class="line">	<span class="keyword">if</span> (!bh) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!(flag &amp; O_CREAT)) &#123;	<span class="comment">// 如果没有 O_CREAT 标志</span></span><br><span class="line">			iput(dir);		<span class="comment">// 放回 i 节点，并返回出错码</span></span><br><span class="line">			<span class="keyword">return</span> -ENOENT;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!permission(dir,MAY_WRITE)) &#123;	<span class="comment">// 如果用户在该目录没有写权利</span></span><br><span class="line">			iput(dir);			<span class="comment">// 放回 i 节点，并返回出错码</span></span><br><span class="line">			<span class="keyword">return</span> -EACCES;</span><br><span class="line">		&#125;</span><br><span class="line">		inode = new_inode(dir-&gt;i_dev);	<span class="comment">// 申请一个新 i 节点</span></span><br><span class="line">		<span class="keyword">if</span> (!inode) &#123;			<span class="comment">// 如果失败，放回 i 节点，并返回出错码</span></span><br><span class="line">			iput(dir);</span><br><span class="line">			<span class="keyword">return</span> -ENOSPC;</span><br><span class="line">		&#125;</span><br><span class="line">		inode-&gt;i_uid = current-&gt;euid;	<span class="comment">// 设置用户 id、访问模式，置已修改标志</span></span><br><span class="line">		inode-&gt;i_mode = mode;</span><br><span class="line">		inode-&gt;i_dirt = <span class="number">1</span>;</span><br><span class="line">		bh = add_entry(dir,basename,namelen,&amp;de);	<span class="comment">// 在 &quot;/usr/root&quot; 目录下新建一个目录项</span></span><br><span class="line">		<span class="keyword">if</span> (!bh) &#123;			<span class="comment">// 如果失败</span></span><br><span class="line">			inode-&gt;i_nlinks--;	<span class="comment">// 新节点硬连接数减 1</span></span><br><span class="line">			iput(inode);		<span class="comment">// 放回该 i 节点与目录 i 节点，返回出错码</span></span><br><span class="line">			iput(dir);</span><br><span class="line">			<span class="keyword">return</span> -ENOSPC;</span><br><span class="line">		&#125;</span><br><span class="line">		de-&gt;inode = inode-&gt;i_num;	<span class="comment">// 目录项 i 节点号置为新申请到的 i 节点号</span></span><br><span class="line">		bh-&gt;b_dirt = <span class="number">1</span>;			<span class="comment">// 置已修改标志</span></span><br><span class="line">		brelse(bh);			<span class="comment">// 释放该高速缓冲块</span></span><br><span class="line">		iput(dir);			<span class="comment">// 放回目录的 i 节点</span></span><br><span class="line">		*res_inode = inode;		<span class="comment">// 返回新文件的 i 节点指针</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	inr = de-&gt;inode;		<span class="comment">// 获得 &quot;hello.c&quot; 对应 i 节点号</span></span><br><span class="line">	dev = dir-&gt;i_dev;		<span class="comment">// 获得其所在设备号</span></span><br><span class="line">	brelse(bh);			<span class="comment">// 释放该高速缓冲块</span></span><br><span class="line">	iput(dir);			<span class="comment">// 放回目录的 i 节点</span></span><br><span class="line">	<span class="keyword">if</span> (flag &amp; O_EXCL)		<span class="comment">// 如果独占操作标志 O_EXCL 置位，返回出错码</span></span><br><span class="line">		<span class="keyword">return</span> -EEXIST;</span><br><span class="line">	<span class="keyword">if</span> (!(inode=iget(dev,inr)))	<span class="comment">// 根据 i 节点号获得 &quot;hello.c&quot; 对应 i 节点指针</span></span><br><span class="line">		<span class="keyword">return</span> -EACCES;		<span class="comment">// 出错返回出错码</span></span><br><span class="line">	<span class="comment">// 如果取得的 i 节点是一个目录的 i 节点，且访问模式是只读或读写，或者没有访问权限</span></span><br><span class="line">	<span class="keyword">if</span> ((S_ISDIR(inode-&gt;i_mode) &amp;&amp; (flag &amp; O_ACCMODE)) ||</span><br><span class="line">	    !permission(inode,ACC_MODE(flag))) &#123;</span><br><span class="line">		iput(inode);		<span class="comment">// 放回 i 节点，返回出错码</span></span><br><span class="line">		<span class="keyword">return</span> -EPERM;</span><br><span class="line">	&#125;</span><br><span class="line">	inode-&gt;i_atime = CURRENT_TIME;	<span class="comment">// 更新该 i 节点访问时间字段为当前时间</span></span><br><span class="line">	<span class="keyword">if</span> (flag &amp; O_TRUNC)		<span class="comment">// 如果有截零标志，则将文件长度截为 0</span></span><br><span class="line">		truncate(inode);</span><br><span class="line">	*res_inode = inode;		<span class="comment">// 返回 &quot;/usr/root/hello.c&quot; 对应 i 节点指针</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么根据 “/usr/root/hello.c” 是怎样找到 “/usr/root” 的 i 节点指针的呢？其步骤类似 open_namei 中已知 “/usr/root” 的 i 节点指针（调用完 dir_namei 函数），获取 “hello.c” 的 i 节点指针。现已知根目录 “/“ i 节点指针，通过调用 find_entry，找到 “usr” 对应的目录项，从而得知其 i 节点号，再调用 iget 即可获取 “/usr” 的 i 节点指针；第二次调用 find_entry 在 “/usr” 目录下找到 “root” 对应的目录项，从而得知 “/usr/root” 的 i 节点号，调用 iget 获取 “/usr/root” 的 i 节点指针。理所当然地，能想到应该使用一个 whlie 循环来完成上述操作，下面是 dir_namei 函数的代码，其调用 get_dir 函数，在 get_dir 中通过 while 循环来获取 “/usr/root” 的 i 节点指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/namei.c Line 278</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct m_inode * <span class="title">dir_namei</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * pathname,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">int</span> * namelen, <span class="keyword">const</span> <span class="keyword">char</span> ** name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> c;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> * basename;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">dir</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(dir = get_dir(pathname)))		<span class="comment">// 获取 &quot;/usr/root&quot; 的 i 节点指针</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;			<span class="comment">// 失败返回 NULL</span></span><br><span class="line">	basename = pathname;</span><br><span class="line">	<span class="keyword">while</span> (c=get_fs_byte(pathname++))	<span class="comment">// 使得 basename 指向 &quot;hello.c&quot;</span></span><br><span class="line">		<span class="keyword">if</span> (c==<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">			basename=pathname;</span><br><span class="line">	*namelen = pathname-basename<span class="number">-1</span>;		<span class="comment">// 计算 basename 的长度</span></span><br><span class="line">	*name = basename;			<span class="comment">// 返回 basename 指针及 &quot;/usr/root&quot; 的 i 节点指针</span></span><br><span class="line">	<span class="keyword">return</span> dir;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Line 228</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct m_inode * <span class="title">get_dir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * pathname)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> c;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> * thisname;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">inode</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line">	<span class="keyword">int</span> namelen,inr,idev;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dir_entry</span> * <span class="title">de</span>;</span></span><br><span class="line">	<span class="comment">// 当前进程的根与当前工作路径的 i 节点需存在且有效</span></span><br><span class="line">	<span class="keyword">if</span> (!current-&gt;root || !current-&gt;root-&gt;i_count)</span><br><span class="line">		panic(<span class="string">&quot;No root inode&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (!current-&gt;pwd || !current-&gt;pwd-&gt;i_count)</span><br><span class="line">		panic(<span class="string">&quot;No cwd inode&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> ((c=get_fs_byte(pathname))==<span class="string">&#x27;/&#x27;</span>) &#123;	<span class="comment">// 如果是绝对路径 </span></span><br><span class="line">		inode = current-&gt;root;		<span class="comment">// 起始 inode 设置为根目录(或伪根)对应 i 节点指针</span></span><br><span class="line">		pathname++;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (c)				<span class="comment">// 否则是相对路径</span></span><br><span class="line">		inode = current-&gt;pwd;		<span class="comment">// 起始 inode 设置为当前工作路径对应 i 节点指针</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	inode-&gt;i_count++;			<span class="comment">// 引用计数加 1</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;				<span class="comment">// 开始逐层解析目录路径</span></span><br><span class="line">		thisname = pathname;		<span class="comment">// thisname 指向正在处理的目录名</span></span><br><span class="line">		<span class="comment">// 如果不是目录或没有进入该目录的权限</span></span><br><span class="line">		<span class="keyword">if</span> (!S_ISDIR(inode-&gt;i_mode) || !permission(inode,MAY_EXEC)) &#123;</span><br><span class="line">			iput(inode);		<span class="comment">// 放回 i 节点</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 搜索到下一个 &#x27;/&#x27;，如第一次循环时，namelen = 3（usr），pathname 指向 &quot;root/hello.c&quot;</span></span><br><span class="line">		<span class="keyword">for</span>(namelen=<span class="number">0</span>;(c=get_fs_byte(pathname++))&amp;&amp;(c!=<span class="string">&#x27;/&#x27;</span>);namelen++)</span><br><span class="line">			<span class="comment">/* nothing */</span> ;</span><br><span class="line">		<span class="keyword">if</span> (!c)				<span class="comment">// 如果已经搜索到路径名末尾</span></span><br><span class="line">			<span class="keyword">return</span> inode;		<span class="comment">// 返回 i 节点指针</span></span><br><span class="line">		<span class="comment">// 在 inode 对应的目录下查找长度为 namelen 的 thisname 对应的目录项</span></span><br><span class="line">		<span class="keyword">if</span> (!(bh = find_entry(&amp;inode,thisname,namelen,&amp;de))) &#123;	</span><br><span class="line">			iput(inode);		<span class="comment">// 失败放回 i 节点</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		inr = de-&gt;inode;		<span class="comment">// 获得 thisname 对应的 i 节点号</span></span><br><span class="line">		idev = inode-&gt;i_dev;		<span class="comment">// 获得设备号</span></span><br><span class="line">		brelse(bh);			<span class="comment">// 释放含有该目录项的高速缓冲块</span></span><br><span class="line">		iput(inode);			<span class="comment">// 放回 i 节点</span></span><br><span class="line">		<span class="keyword">if</span> (!(inode = iget(idev,inr)))	<span class="comment">// 获得设备号为 idev、i 节点号为 inr 的 i 节点指针</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，不再深入，回到 sys_open 函数。之前调用 open_namei 时，返回的 i 节点指针存储在 inode 中，现在要根据 i_mode 字段判断该文件的类型，对于不同类型的文件，需要做一些处理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/open.c Line 163</span></span><br><span class="line">	<span class="keyword">if</span> (S_ISCHR(inode-&gt;i_mode))		<span class="comment">// 如果打开的是字符设备，无关，不作记录</span></span><br><span class="line">		<span class="keyword">if</span> (MAJOR(inode-&gt;i_zone[<span class="number">0</span>])==<span class="number">4</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (current-&gt;leader &amp;&amp; current-&gt;tty&lt;<span class="number">0</span>) &#123;</span><br><span class="line">				current-&gt;tty = MINOR(inode-&gt;i_zone[<span class="number">0</span>]);</span><br><span class="line">				tty_table[current-&gt;tty].pgrp = current-&gt;pgrp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (MAJOR(inode-&gt;i_zone[<span class="number">0</span>])==<span class="number">5</span>)</span><br><span class="line">			<span class="keyword">if</span> (current-&gt;tty&lt;<span class="number">0</span>) &#123;</span><br><span class="line">				iput(inode);</span><br><span class="line">				current-&gt;filp[fd]=<span class="literal">NULL</span>;</span><br><span class="line">				f-&gt;f_count=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">return</span> -EPERM;</span><br><span class="line">			&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (S_ISBLK(inode-&gt;i_mode))		<span class="comment">// 如果打开的是块设备</span></span><br><span class="line">		check_disk_change(inode-&gt;i_zone[<span class="number">0</span>]);	<span class="comment">//检查盘片是否被更换</span></span><br><span class="line">	f-&gt;f_mode = inode-&gt;i_mode;		<span class="comment">// 设置 file_table 中 file 结构体的一些属性</span></span><br><span class="line">	f-&gt;f_flags = flag;</span><br><span class="line">	f-&gt;f_count = <span class="number">1</span>;</span><br><span class="line">	f-&gt;f_inode = inode;</span><br><span class="line">	f-&gt;f_pos = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> (fd);				<span class="comment">// 返回文件句柄</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时返回的 fd 应该为 3</p>
<br>

<h3 id="read"><a href="#read" class="headerlink" title="read"></a>read</h3><p>read 也是一个系统调用，处理函数为 sys_read，现在要从已打开的 “/usr/root/hello.c” 中读取 79 个字符</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/read_write.c Line 55</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_read</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> fd,<span class="keyword">char</span> * buf,<span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">file</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">m_inode</span> * <span class="title">inode</span>;</span></span><br><span class="line">	<span class="comment">// 判断参数文件句柄与要读的字符数的合法性</span></span><br><span class="line">	<span class="keyword">if</span> (fd&gt;=NR_OPEN || count&lt;<span class="number">0</span> || !(file=current-&gt;filp[fd]))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (!count)			<span class="comment">// count 为 0，表示一个字符都不读，返回</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	verify_area(buf,count);		<span class="comment">// 验证存放数据的地址是否存在内存越界等问题</span></span><br><span class="line">	inode = file-&gt;f_inode;		<span class="comment">// 获得文件 i 节点指针</span></span><br><span class="line">	<span class="keyword">if</span> (inode-&gt;i_pipe)		<span class="comment">// 如果是管道文件，进行管道读操作</span></span><br><span class="line">		<span class="keyword">return</span> (file-&gt;f_mode&amp;<span class="number">1</span>)?read_pipe(inode,buf,count):-EIO;</span><br><span class="line">	<span class="keyword">if</span> (S_ISCHR(inode-&gt;i_mode))	<span class="comment">// 如果是字符型文件，进行字符设备读操作</span></span><br><span class="line">		<span class="keyword">return</span> rw_char(READ,inode-&gt;i_zone[<span class="number">0</span>],buf,count,&amp;file-&gt;f_pos);</span><br><span class="line">	<span class="keyword">if</span> (S_ISBLK(inode-&gt;i_mode))	<span class="comment">// 如果是块设备文件，进行块设备读操作</span></span><br><span class="line">		<span class="keyword">return</span> block_read(inode-&gt;i_zone[<span class="number">0</span>],&amp;file-&gt;f_pos,buf,count);</span><br><span class="line">	<span class="keyword">if</span> (S_ISDIR(inode-&gt;i_mode) || S_ISREG(inode-&gt;i_mode)) &#123;	<span class="comment">// 是目录或普通文件</span></span><br><span class="line">		<span class="keyword">if</span> (count+file-&gt;f_pos &gt; inode-&gt;i_size)		<span class="comment">// 如果读写指针加上欲读字符数超出文件末尾</span></span><br><span class="line">			count = inode-&gt;i_size - file-&gt;f_pos;	<span class="comment">// 重新计算 count</span></span><br><span class="line">		<span class="keyword">if</span> (count&lt;=<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> file_read(inode,file,buf,count);		<span class="comment">// 进行文件读操作</span></span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;(Read)inode-&gt;i_mode=%06o\n\r&quot;</span>,inode-&gt;i_mode);</span><br><span class="line">	<span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为 “/usr/root/hello.c” 是一个<strong>普通文件</strong>，所以应该调用 <strong>file_read</strong> 函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/file_dev.c Line 17</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_read</span><span class="params">(struct m_inode * inode, struct file * filp, <span class="keyword">char</span> * buf, <span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> left,chars,nr;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((left=count)&lt;=<span class="number">0</span>)	<span class="comment">// 判断参数有效性</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (left) &#123;		<span class="comment">// 如果还需要读取的字符数不为 0</span></span><br><span class="line">		<span class="comment">// bmap 获取文件当前读写位置的数据块在设备上对应的逻辑块号</span></span><br><span class="line">		<span class="keyword">if</span> (nr = bmap(inode,(filp-&gt;f_pos)/BLOCK_SIZE)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!(bh=bread(inode-&gt;i_dev,nr)))	<span class="comment">// 从设备上读取该逻辑块</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span>		<span class="comment">// bmap 失败，bh 置为空</span></span><br><span class="line">			bh = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>file_read 还没有结束，先来看看 bread 函数的实现细节，该函数的作用是从指定设备号的设备中读取指定块号的数据到高速缓冲块中，返回值是缓冲块对应的缓冲头</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/buffer.c Line 270</span></span><br><span class="line"><span class="comment">// dev 是设备号，block 是逻辑块号</span></span><br><span class="line"><span class="function">struct buffer_head * <span class="title">bread</span><span class="params">(<span class="keyword">int</span> dev,<span class="keyword">int</span> block)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">bh</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(bh=getblk(dev,block)))	<span class="comment">// 根据 dev 与 block 在高速缓冲区中申请一块缓冲块</span></span><br><span class="line">		panic(<span class="string">&quot;bread: getblk returned NULL\n&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (bh-&gt;b_uptodate)		<span class="comment">// 如果缓冲块中的数据时有效的，则可以直接使用</span></span><br><span class="line">		<span class="keyword">return</span> bh;</span><br><span class="line">	ll_rw_block(READ,bh);		<span class="comment">// 调用底层块设备读写函数 ll_rw_block</span></span><br><span class="line">	wait_on_buffer(bh);		<span class="comment">// 当前进程睡眠，等待缓冲块解锁</span></span><br><span class="line">	<span class="keyword">if</span> (bh-&gt;b_uptodate)		<span class="comment">// 醒来后如果缓冲区已被更新，则返回</span></span><br><span class="line">		<span class="keyword">return</span> bh;</span><br><span class="line">	brelse(bh);			<span class="comment">// 否则表示读操作失败，释放该缓冲区</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/blk_dev/ll_rw_blk.c Line 145</span></span><br><span class="line"><span class="comment">// 参数 rw 是操作类型（如读/写），bh 对应的缓冲块用于存储从块设备中读出的数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ll_rw_block</span><span class="params">(<span class="keyword">int</span> rw, struct buffer_head * bh)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> major;</span><br><span class="line">	<span class="comment">// 如果主设备号不存在，或者处理请求的函数不存在，停机</span></span><br><span class="line">	<span class="keyword">if</span> ((major=MAJOR(bh-&gt;b_dev)) &gt;= NR_BLK_DEV ||</span><br><span class="line">	!(blk_dev[major].request_fn)) &#123;</span><br><span class="line">		printk(<span class="string">&quot;Trying to read nonexistent block-device\n\r&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	make_request(major,rw,bh);	<span class="comment">// 否则创建请求项，并加入请求队列</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Line 88</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">make_request</span><span class="params">(<span class="keyword">int</span> major,<span class="keyword">int</span> rw, struct buffer_head * bh)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">request</span> * <span class="title">req</span>;</span></span><br><span class="line">	<span class="keyword">int</span> rw_ahead;</span><br><span class="line">	<span class="comment">// 预读取与预写功能并非必要，若缓冲区已上锁，就不用管它，否则它只是一个一般的读/写操作</span></span><br><span class="line">	<span class="keyword">if</span> (rw_ahead = (rw == READA || rw == WRITEA)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (bh-&gt;b_lock)</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span> (rw == READA)</span><br><span class="line">			rw = READ;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			rw = WRITE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 不支持其他操作</span></span><br><span class="line">	<span class="keyword">if</span> (rw!=READ &amp;&amp; rw!=WRITE)</span><br><span class="line">		panic(<span class="string">&quot;Bad block dev command, must be R/W/RA/WA&quot;</span>);</span><br><span class="line">	lock_buffer(bh);	<span class="comment">// 缓冲头上锁</span></span><br><span class="line">	<span class="comment">// 如果是写操作且已修改标志未置位，说明该块没有被修改，与块设备中相同，不必写回</span></span><br><span class="line">	<span class="comment">// 如果是读操作且更新（有效）标志置位，说明该块已经被读入高速缓冲，不必再读取</span></span><br><span class="line">	<span class="keyword">if</span> ((rw == WRITE &amp;&amp; !bh-&gt;b_dirt) || (rw == READ &amp;&amp; bh-&gt;b_uptodate)) &#123;</span><br><span class="line">		unlock_buffer(bh);		<span class="comment">// 解锁缓冲头并返回</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">repeat:				<span class="comment">// 给读请求保留一些空间，防止数组被写请求占满，无法读数据</span></span><br><span class="line">	<span class="keyword">if</span> (rw == READ)		<span class="comment">// 如果是读请求，就从 request 数组末开始往前搜索空闲项</span></span><br><span class="line">		req = request+NR_REQUEST;</span><br><span class="line">	<span class="keyword">else</span>			<span class="comment">// 如果是写请求，就从 request 数组 2/3 处开始往前搜索空闲项</span></span><br><span class="line">		req = request+((NR_REQUEST*<span class="number">2</span>)/<span class="number">3</span>);</span><br><span class="line">	<span class="keyword">while</span> (--req &gt;= request)	<span class="comment">// 搜索空闲项，req-&gt;dev 为 -1 表示该项空闲</span></span><br><span class="line">		<span class="keyword">if</span> (req-&gt;dev&lt;<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">if</span> (req &lt; request) &#123;		<span class="comment">// 如果已经搜索到 request 数组头</span></span><br><span class="line">		<span class="keyword">if</span> (rw_ahead) &#123;			<span class="comment">// 如果是预读/写请求，则释放缓冲头并退出</span></span><br><span class="line">			unlock_buffer(bh);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		sleep_on(&amp;wait_for_request);	<span class="comment">// 否则就睡眠，过会儿再搜索请求队列</span></span><br><span class="line">		<span class="keyword">goto</span> repeat;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 设置请求项各字段</span></span><br><span class="line">	req-&gt;dev = bh-&gt;b_dev;			<span class="comment">// 设备号</span></span><br><span class="line">	req-&gt;cmd = rw;				<span class="comment">// 操作类型</span></span><br><span class="line">	req-&gt;errors=<span class="number">0</span>;				<span class="comment">// 出错次数</span></span><br><span class="line">	req-&gt;sector = bh-&gt;b_blocknr&lt;&lt;<span class="number">1</span>;		<span class="comment">// 起始扇区</span></span><br><span class="line">	req-&gt;nr_sectors = <span class="number">2</span>;			<span class="comment">// 要操作的扇区数（两个扇区为一个块）</span></span><br><span class="line">	req-&gt;buffer = bh-&gt;b_data;		<span class="comment">// 高速缓冲块起始地址指针</span></span><br><span class="line">	req-&gt;waiting = <span class="literal">NULL</span>;			<span class="comment">// 等待该请求完成的进程</span></span><br><span class="line">	req-&gt;bh = bh;				<span class="comment">// 缓冲头</span></span><br><span class="line">	req-&gt;next = <span class="literal">NULL</span>;			<span class="comment">// 下个请求项置空</span></span><br><span class="line">	add_request(major+blk_dev,req);		<span class="comment">// 将请求项添加到 blk_dev[3](硬盘) 的请求队列中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Line 64</span></span><br><span class="line"><span class="comment">// 该函数将设置好的请求项 req 加入指定设备的请求处理队列</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add_request</span><span class="params">(struct blk_dev_struct * dev, struct request * req)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">request</span> * <span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line">	req-&gt;next = <span class="literal">NULL</span>;		<span class="comment">// next 字段先置空</span></span><br><span class="line">	cli();				<span class="comment">// 关中断</span></span><br><span class="line">	<span class="keyword">if</span> (req-&gt;bh)			<span class="comment">// 设置缓冲头的已修改标志为 0</span></span><br><span class="line">		req-&gt;bh-&gt;b_dirt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!(tmp = dev-&gt;current_request)) &#123;	<span class="comment">// 如果请求队列中没有请求项</span></span><br><span class="line">		dev-&gt;current_request = req;	<span class="comment">// 则将该请求项设置为当前处理请求项</span></span><br><span class="line">		sti();				<span class="comment">// 开中断</span></span><br><span class="line">		(dev-&gt;request_fn)();		<span class="comment">// 调用请求处理函数</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 来到这里表示设备的请求队列中存在其他请求，通过单向电梯算法将新请求插入请求队列中</span></span><br><span class="line">	<span class="keyword">for</span> ( ; tmp-&gt;next ; tmp=tmp-&gt;next)</span><br><span class="line">		<span class="keyword">if</span> ((IN_ORDER(tmp,req) ||</span><br><span class="line">		    !IN_ORDER(tmp,tmp-&gt;next)) &amp;&amp;</span><br><span class="line">		    IN_ORDER(req,tmp-&gt;next))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	req-&gt;next=tmp-&gt;next;</span><br><span class="line">	tmp-&gt;next=req;</span><br><span class="line">	sti();		<span class="comment">// 开中断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>硬盘对应的请求处理函数 dev-&gt;request_fn 为 do_hd_request，在上一篇文章 <a href="https://in1nit1t.github.io/2020/06/04/Linux%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%9D%97%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/">块设备驱动</a> 中已经给出注释。add_request 函数将请求添加到队列中后，会返回到 bread 中，执行 <code>wait_on_buffer</code>，等待读请求完成，再返回到 file_read 函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/file_dev.c Line 30</span></span><br><span class="line">		nr = filp-&gt;f_pos % BLOCK_SIZE;		<span class="comment">// 计算文件当前读写指针在数据块中的偏移 nr</span></span><br><span class="line">		chars = MIN( BLOCK_SIZE-nr , left );	<span class="comment">// 获得二者之间较小的值</span></span><br><span class="line">		filp-&gt;f_pos += chars;			<span class="comment">// 设置文件当前读写指针</span></span><br><span class="line">		left -= chars;				<span class="comment">// 剩余未读字符数减去将拷贝字符数</span></span><br><span class="line">		<span class="keyword">if</span> (bh) &#123;</span><br><span class="line">			<span class="keyword">char</span> * p = nr + bh-&gt;b_data;</span><br><span class="line">			<span class="keyword">while</span> (chars--&gt;<span class="number">0</span>)		<span class="comment">// buf 为 read 第二个参数</span></span><br><span class="line">				put_fs_byte(*(p++),buf++);	<span class="comment">// 将高速缓冲块中的数据拷贝到目标地址处</span></span><br><span class="line">			brelse(bh);			<span class="comment">// 释放缓冲头</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;				<span class="comment">// 如果上面 bread 失败，bh 为 NULL，则将 buf 填 0</span></span><br><span class="line">			<span class="keyword">while</span> (chars--&gt;<span class="number">0</span>)</span><br><span class="line">				put_fs_byte(<span class="number">0</span>,buf++);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	inode-&gt;i_atime = CURRENT_TIME;			<span class="comment">// 设置 i 节点访问时间为当前时间</span></span><br><span class="line">	<span class="keyword">return</span> (count-left)?(count-left):-ERROR;	<span class="comment">// 返回读到 buf 的字符数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，”/usr/root/hello.c” 文件的内容已经被读入 msg 中，最后是文件的关闭</p>
<br>

<h3 id="close"><a href="#close" class="headerlink" title="close"></a>close</h3><p>close 系统调用就比较简单了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/open.c Line 192</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_close</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">filp</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fd &gt;= NR_OPEN)		<span class="comment">// 判断参数的合法性</span></span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	current-&gt;close_on_exec &amp;= ~(<span class="number">1</span>&lt;&lt;fd);	<span class="comment">// 复位执行时关闭位图中对应的位</span></span><br><span class="line">	<span class="keyword">if</span> (!(filp = current-&gt;filp[fd]))	<span class="comment">// 如果该文件句柄不存在，返回错误码</span></span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	current-&gt;filp[fd] = <span class="literal">NULL</span>;		<span class="comment">// 将 filp 数组该项置空</span></span><br><span class="line">	<span class="keyword">if</span> (filp-&gt;f_count == <span class="number">0</span>)			<span class="comment">// 如果句柄引用计数已经为 0，说明内核出现错误，停机</span></span><br><span class="line">		panic(<span class="string">&quot;Close: file count is 0&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (--filp-&gt;f_count)		<span class="comment">// 否则将引用计数减一</span></span><br><span class="line">		<span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">	iput(filp-&gt;f_inode);		<span class="comment">// 放回该 i 节点</span></span><br><span class="line">	<span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p>呼~ 这个系列到此结束啦✿✿ヽ(°▽°)ノ✿，后面也许会搞点内核 pwn，到时候再做记录，收工收工</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">in1t</a></span></div><div class="post-cover__authorid"><span class="post-copyright-meta">封面画师: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://www.pixiv.net/users/27517">27517</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://in1nit1t.github.io/2020/06/06/Linux%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-fs/">http://in1nit1t.github.io/2020/06/06/Linux内核源码阅读-fs/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://in1nit1t.github.io" target="_blank">in1t's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><a class="post-meta__tags" href="/tags/Linux0-11/">Linux0.11</a></div><div class="post_share"><div class="social-share" data-image="/img/cover/linux_fs.jpg" data-sites="wechat,qq,weibo,facebook,twitter"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/10/05/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95apk/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/cover/debug_apk_java.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">动态调试apk(Java 层)</div></div></a></div><div class="next-post pull-right"><a href="/2020/06/04/Linux%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%9D%97%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/"><img class="next-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/cover/blkdevicesys.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Linux内核源码阅读-块设备驱动</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2020/04/11/Linux内核源码阅读-kernel（三）/" title="Linux内核源码阅读-kernel（三）"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/cover/kernel3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-04-11</div><div class="title">Linux内核源码阅读-kernel（三）</div></div></a></div><div><a href="/2020/04/27/Linux内核源码阅读-mm/" title="Linux内核源码阅读-mm"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/cover/mmmodule.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-04-27</div><div class="title">Linux内核源码阅读-mm</div></div></a></div><div><a href="/2020/04/13/Linux内核源码阅读-kernel（四）/" title="Linux内核源码阅读-kernel（四）"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/cover/kernel4.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-04-13</div><div class="title">Linux内核源码阅读-kernel（四）</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E9%80%9F%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">1.</span> <span class="toc-text">高速缓冲区的管理方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E7%9A%84%E5%AE%8C%E6%95%B4%E8%BF%87%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">读取文件的完整过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#open"><span class="toc-number">2.1.</span> <span class="toc-text">open</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#read"><span class="toc-number">2.2.</span> <span class="toc-text">read</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#close"><span class="toc-number">2.3.</span> <span class="toc-text">close</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('/img/cover/linux_fs.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By in1t</div><div class="footer_custom_text"><p><a style="margin-inline:5px" target="_blank" href="https://hexo.io/"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a><a style="margin-inline:5px" target="_blank" href="https://butterfly.js.org/"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-orange?style=flat&logo=bitdefender" title="主题采用butterfly"></a><a style="margin-inline:5px" target="_blank" href="https://github.com/"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://img.shields.io/badge/Source-Github-brightgreen?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a><a style="margin-inline:5px" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script async="async">var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())
setTimeout(function(){preloader.endLoading();}, 5000);</script><div class="js-pjax"></div><script defer src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script defer src="/js/modify.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="false" data-text="💐,🌸,💮,🏵,🌹,🥀,🌺,🌻,🌼,🌷,🌱,🌲,🌳,🌴,🌵,🌾,🌿,☘,🍀,🍁,🍂,🍃,🍇,🍈,🍉,🍊,🍋,🍌,🍍,🍎,🍏,🍐,🍑,🍒,🍓,🥝,🍅,🥥,🥑,🍆,🥔,🥕,🌽,🌶,🥒,🥬,🥦,🧄,🧅,🍄,🥜,🌰,🍞,🥐,🥖,🥨,🥯,🥞,🧇,🧀,🍖,🍗,🥩,🥓,🍔,🍟,🍕,🌭,🥪,🌮,🌯,🥙,🧆,🥚,🍳,🥘,🍲,🥣,🥗,🍿,🧈,🧂,🥫,🍱,🍘,🍙,🍚,🍛,🍜,🍠,🍢,🍣,🍤,🍥,🥮,🍡,🥟,🥠,🥡,🦪,🍨,🍩,🍪,🎂,🍰,🧁,🥧,🍫,🍬,🍭,🍮,🍯,🍼,🥛,☕,🍵,🍶,🍾,🍷,🍹,🍻,🥂,🥃,🥤,🧃,🧉,🧊,🥢,🍽,🥄" data-fontsize="20px" data-random="false" async="async"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300,"hOffset":20,"vOffset":-65},"mobile":{"show":false},"react":{"opacity":0.7},"log":false});</script></body></html>